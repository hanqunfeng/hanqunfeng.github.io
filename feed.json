{"version":"https://jsonfeed.org/version/1","name":"飘逸峰的博客","home_page_url":"https://blog.hanqunfeng.com","feed_url":"https://blog.hanqunfeng.com/feed.json","author":{"name":"飘逸峰"},"items":[{"id":"https://blog.hanqunfeng.com/2025/12/22/redis7-datatype-12-CF/","url":"https://blog.hanqunfeng.com/2025/12/22/redis7-datatype-12-CF/","title":"Redis 命令及数据类型 -- CF(Cuckoo Filter)","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis 扩展模型 RedisBloom 中的 Cuckoo Filter 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n<li class=\"lvl-2\">RedisBloom 的安装参见 <a href=\"/2025/12/21/redis7-module-RedisBloom/\" title=\"Redis 扩展模块 -- RedisBloom\">Redis 扩展模块 -- RedisBloom</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Cuckoo-Filter（布谷鸟过滤器）\">Cuckoo Filter（布谷鸟过滤器）</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Bloom Filter 的增强版，支持 删除元素</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://en.wikipedia.org/wiki/Cuckoo_filter\">维基百科对 Cuckoo Filter 的描述</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>在高 QPS 查询场景下，Cuckoo Filter 通常优于 Bloom Filter。</p>\n</li>\n<li class=\"lvl-2\">\n<p>低误判率 + 高负载率场景，Cuckoo Filter 更省内存。</p>\n</li>\n<li class=\"lvl-2\">\n<p>对应Redis命令： <code>CF.xxx</code></p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能说明</th>\n<th>是否创建 Filter</th>\n<th>关键参数含义</th>\n<th>返回值</th>\n<th>示例</th>\n<th>使用要点 / 备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>CF.RESERVE</strong></td>\n<td>显式创建 Cuckoo Filter</td>\n<td>是</td>\n<td><code>capacity</code>：容量(必填)<br><code>BUCKETSIZE</code>：每个桶里最多能放多少个 fingerprint（指纹），默认 2(大多数情况下的最优解)<br><code>MAXITERATIONS</code>：重排次数，越大成功率越高<br><code>EXPANSION</code>：扩容倍数，默认 1（不扩容）</td>\n<td>OK</td>\n<td><code>CF.RESERVE user:cf 100000</code></td>\n<td>✅ <strong>生产推荐</strong><br>支持删除与计数</td>\n</tr>\n<tr>\n<td><strong>CF.ADD</strong></td>\n<td>添加一个元素，不去重</td>\n<td>是 （不存在则创建）</td>\n<td><code>item</code>：元素</td>\n<td>OK</td>\n<td><code>CF.ADD user:cf user_1</code></td>\n<td>若满可能失败</td>\n</tr>\n<tr>\n<td><strong>CF.ADDNX</strong></td>\n<td>元素不存在时才添加，去重</td>\n<td>是 （不存在则创建）</td>\n<td><code>item</code></td>\n<td><code>1</code> 新增<br><code>0</code> 已存在</td>\n<td><code>CF.ADDNX user:cf user_1</code></td>\n<td>幂等写入首选</td>\n</tr>\n<tr>\n<td><strong>CF.INSERT</strong></td>\n<td>批量插入</td>\n<td>是（不存在则创建）</td>\n<td><code>ITEMS</code>：元素列表</td>\n<td>OK</td>\n<td><code>CF.INSERT user:cf ITEMS u1 u2</code></td>\n<td>默认配置</td>\n</tr>\n<tr>\n<td><strong>CF.INSERTNX</strong></td>\n<td>批量插入（不存在才加）</td>\n<td>是</td>\n<td><code>ITEMS</code></td>\n<td><code>0/1</code> 列表</td>\n<td><code>CF.INSERTNX user:cf ITEMS u1 u2</code></td>\n<td>幂等 + 批量</td>\n</tr>\n<tr>\n<td><strong>CF.EXISTS</strong></td>\n<td>判断单个元素是否存在</td>\n<td>否</td>\n<td><code>item</code></td>\n<td><code>1</code> 可能存在<br><code>0</code> 不存在</td>\n<td><code>CF.EXISTS user:cf user_1</code></td>\n<td>仍有误判</td>\n</tr>\n<tr>\n<td><strong>CF.MEXISTS</strong></td>\n<td>批量判断是否存在</td>\n<td>否</td>\n<td><code>item...</code></td>\n<td><code>0/1</code> 列表</td>\n<td><code>CF.MEXISTS user:cf u1 u9</code></td>\n<td>高并发推荐</td>\n</tr>\n<tr>\n<td><strong>CF.COUNT</strong></td>\n<td>返回元素出现次数</td>\n<td>否</td>\n<td><code>item</code></td>\n<td>整数</td>\n<td><code>CF.COUNT user:cf user_1</code></td>\n<td>⭐ Bloom 没有的能力</td>\n</tr>\n<tr>\n<td><strong>CF.DEL</strong></td>\n<td>删除一个元素</td>\n<td>否</td>\n<td><code>item</code></td>\n<td><code>1</code> 删除成功<br><code>0</code> 不存在</td>\n<td><code>CF.DEL user:cf user_1</code></td>\n<td>⭐ Bloom 不支持</td>\n</tr>\n<tr>\n<td><strong><a href=\"http://CF.INFO\">CF.INFO</a></strong></td>\n<td>查看 Filter 元信息</td>\n<td>否</td>\n<td>无</td>\n<td>KV 列表</td>\n<td><code>CF.INFO user:cf</code></td>\n<td>运维分析</td>\n</tr>\n<tr>\n<td><strong>CF.SCANDUMP</strong></td>\n<td>分块导出 Filter</td>\n<td>否</td>\n<td><code>iterator</code></td>\n<td><code>iterator + data</code></td>\n<td><code>CF.SCANDUMP user:cf 0</code></td>\n<td>迁移 / 备份</td>\n</tr>\n<tr>\n<td><strong>CF.LOADCHUNK</strong></td>\n<td>从 dump 恢复 Filter</td>\n<td>是</td>\n<td><code>iterator + data</code></td>\n<td>OK</td>\n<td><code>CF.LOADCHUNK user:cf 1 &quot;xxx&quot;</code></td>\n<td>与 SCANDUMP 配合</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Bloom vs Cuckoo</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>Bloom Filter</th>\n<th>Cuckoo Filter</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>查询复杂度</td>\n<td>O(k)（k 个哈希函数）</td>\n<td>O(1)（2–4 次 bucket 访问）</td>\n</tr>\n<tr>\n<td>插入复杂度</td>\n<td>O(k)</td>\n<td>平均 O(1)，最坏可能触发重排</td>\n</tr>\n<tr>\n<td>删除支持</td>\n<td>❌ 原生不支持</td>\n<td>✅ 原生支持</td>\n</tr>\n<tr>\n<td>误判率（False Positive）</td>\n<td>可配置，稳定</td>\n<td>可配置，通常更低</td>\n</tr>\n<tr>\n<td>漏判（False Negative）</td>\n<td>❌ 理论上不会</td>\n<td>❌ 理论上不会</td>\n</tr>\n<tr>\n<td>空间利用率</td>\n<td>高（但受 k 影响）</td>\n<td>通常更高（特别是低误判率）</td>\n</tr>\n<tr>\n<td>扩容成本</td>\n<td>高（需重建）</td>\n<td>中等（支持扩展策略）</td>\n</tr>\n<tr>\n<td>实现复杂度</td>\n<td>低</td>\n<td>较高</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>RedisBloom Cuckoo Filter 不支持设置 <code>误判率</code>，通常 容量 越大，误判率越低。</p>\n</blockquote>\n<h2 id=\"CF-命令示例\">CF 命令示例</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建 Cuckoo Filter</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.RESERVE user:cf 1000 BUCKETSIZE 2 MAXITERATIONS 500 EXPANSION 2</span><br><span class=\"line\">OK</span><br><span class=\"line\"><span class=\"comment\"># 添加元素</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.ADD user:cf user_1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; CF.ADD user:cf user_2</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"><span class=\"comment\"># 可以重复添加元素</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.ADD user:cf user_1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"><span class=\"comment\"># 返回元素出现次数</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.COUNT user:cf user_1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 2</span><br><span class=\"line\"><span class=\"comment\"># 判断元素是否存在</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.EXISTS user:cf user_1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"><span class=\"comment\"># 批量判断元素是否存在</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.MEXISTS user:cf user_1 user_2 user_100</span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">3) (<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\"><span class=\"comment\"># 删除元素，一次只删除一个</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.DEL user:cf user_1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"><span class=\"comment\"># 因为user_1有两个，所以才是还是能查询出 user_1</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.COUNT user:cf user_1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"><span class=\"comment\"># 再次删除</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.DEL user:cf user_1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"><span class=\"comment\"># 同名元素已全部删除，查询不到</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.COUNT user:cf user_1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 元素不存在时才添加，幂等</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.ADDNX user:cf user_2</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; CF.ADDNX user:cf user_3</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看 Filter 元信息</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.INFO user:cf</span><br><span class=\"line\"> 1) Size                      <span class=\"comment\"># 当前 Cuckoo Filter 实际占用的内存大小（字节）</span></span><br><span class=\"line\"> 2) (<span class=\"built_in\">integer</span>) 1080</span><br><span class=\"line\"> 3) Number of buckets         <span class=\"comment\"># 当前过滤器中 bucket（桶）的总数量，Size = Number of buckets * Bucket size(默认为2)</span></span><br><span class=\"line\"> 4) (<span class=\"built_in\">integer</span>) 512</span><br><span class=\"line\"> 5) Number of filters         <span class=\"comment\"># 内部 子 Cuckoo Filter 的数量</span></span><br><span class=\"line\"> 6) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"> 7) Number of items inserted  <span class=\"comment\"># 成功插入的元素总数（近似）</span></span><br><span class=\"line\"> 8) (<span class=\"built_in\">integer</span>) 2</span><br><span class=\"line\"> 9) Number of items deleted   <span class=\"comment\"># 已删除元素的累计次数</span></span><br><span class=\"line\">10) (<span class=\"built_in\">integer</span>) 2</span><br><span class=\"line\">11) Bucket size               <span class=\"comment\"># 每个 bucket 可容纳的 fingerprint 数，默认为 2</span></span><br><span class=\"line\">12) (<span class=\"built_in\">integer</span>) 2</span><br><span class=\"line\">13) Expansion rate            <span class=\"comment\"># 过滤器自动扩容倍率，默认为1，0 或 1 表示不扩容（满则失败）</span></span><br><span class=\"line\">14) (<span class=\"built_in\">integer</span>) 2</span><br><span class=\"line\">15) Max iterations            <span class=\"comment\"># Cuckoo Kick-out 的最大重排次数，值越大，插入成功率越高，但写入延迟可能上升</span></span><br><span class=\"line\">16) (<span class=\"built_in\">integer</span>) 500</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 批量添加，key不存在则创建</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.INSERT order:cf CAPACITY 100 ITEMS order1 order2</span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"><span class=\"comment\"># 幂等，元素不存在时才添加</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CF.INSERTNX order:cf CAPACITY 100 ITEMS order1 order2 order100</span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\">3) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看类型</span></span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">type</span> order:cf</span><br><span class=\"line\">MBbloomCF</span><br></pre></td></tr></table></figure>\n<h2 id=\"SpringBoot-集成\">SpringBoot 集成</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot 的 RedisTemplate 中没有提供对<code>RedisBloom</code>的封装，需要自己封装，我这里封装了一个简易的<code>RedisCuckooFilterTool</code></p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.redisbloom;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 基于 RedisBloom 插件的 CuckooFilter 实现</span></span><br><span class=\"line\"><span class=\"comment\"> * https://github.com/RedisBloom/RedisBloom/releases</span></span><br><span class=\"line\"><span class=\"comment\"> * Created by hanqf on 2025/12/22 17:09.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.connection.ReturnType;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.core.RedisCallback;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Collections;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.LinkedHashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisCuckooFilterTool</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> StringRedisTemplate redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">RedisCuckooFilterTool</span><span class=\"params\">(StringRedisTemplate redisTemplate)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.redisTemplate = redisTemplate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 初始化 Cuckoo Filter</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 不能重复执行</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key      Filter 名称</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> capacity 预计容量</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">reserve</span><span class=\"params\">(String key, <span class=\"type\">long</span> capacity)</span> &#123;</span><br><span class=\"line\">        redisTemplate.execute((RedisCallback&lt;String&gt;) connection -&gt;</span><br><span class=\"line\">                connection.scriptingCommands().eval(</span><br><span class=\"line\">                        (<span class=\"string\">&quot;return redis.call(&#x27;CF.RESERVE&#x27;, KEYS[1], &quot;</span> + capacity + <span class=\"string\">&quot;)&quot;</span>).getBytes(),</span><br><span class=\"line\">                        ReturnType.STATUS,</span><br><span class=\"line\">                        <span class=\"number\">1</span>,</span><br><span class=\"line\">                        key.getBytes()</span><br><span class=\"line\">                )</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 初始化 Cuckoo Filter（高级参数）</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key           Filter 名称</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> capacity      预计容量</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> bucketSize    每个桶里最多能放多少个 fingerprint（指纹），默认 2(大多数情况下的最优解)</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> maxIterations 重排次数，越大成功率越高</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> expansion     扩容倍数，默认 1（不扩容）</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">reserve</span><span class=\"params\">(String key, <span class=\"type\">long</span> capacity, <span class=\"type\">int</span> bucketSize, <span class=\"type\">int</span> maxIterations, <span class=\"type\">int</span> expansion)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> String.format(</span><br><span class=\"line\">                <span class=\"string\">&quot;return redis.call(&#x27;CF.RESERVE&#x27;, KEYS[1], %d, &quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;&#x27;BUCKETSIZE&#x27;, %d, &#x27;MAXITERATIONS&#x27;, %d, &#x27;EXPANSION&#x27;, %d)&quot;</span>,</span><br><span class=\"line\">                capacity, bucketSize, maxIterations, expansion</span><br><span class=\"line\">        );</span><br><span class=\"line\"></span><br><span class=\"line\">        redisTemplate.execute((RedisCallback&lt;String&gt;) connection -&gt;</span><br><span class=\"line\">                connection.scriptingCommands().eval(</span><br><span class=\"line\">                        script.getBytes(),</span><br><span class=\"line\">                        ReturnType.STATUS,</span><br><span class=\"line\">                        <span class=\"number\">1</span>,</span><br><span class=\"line\">                        key.getBytes()</span><br><span class=\"line\">                )</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 添加元素（不去重）</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">add</span><span class=\"params\">(String key, String value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Boolean.TRUE.equals(redisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt;</span><br><span class=\"line\">                connection.scriptingCommands().eval(</span><br><span class=\"line\">                        (<span class=\"string\">&quot;return redis.call(&#x27;CF.ADD&#x27;, KEYS[1], ARGV[1])&quot;</span>).getBytes(),</span><br><span class=\"line\">                        ReturnType.BOOLEAN,</span><br><span class=\"line\">                        <span class=\"number\">1</span>,</span><br><span class=\"line\">                        key.getBytes(),</span><br><span class=\"line\">                        value.getBytes()</span><br><span class=\"line\">                )</span><br><span class=\"line\">        ));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 添加元素（仅当不存在时）</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true 表示成功插入，false 表示已存在</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">addNx</span><span class=\"params\">(String key, String value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Boolean.TRUE.equals(redisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt;</span><br><span class=\"line\">                connection.scriptingCommands().eval(</span><br><span class=\"line\">                        (<span class=\"string\">&quot;return redis.call(&#x27;CF.ADDNX&#x27;, KEYS[1], ARGV[1])&quot;</span>).getBytes(),</span><br><span class=\"line\">                        ReturnType.BOOLEAN,</span><br><span class=\"line\">                        <span class=\"number\">1</span>,</span><br><span class=\"line\">                        key.getBytes(),</span><br><span class=\"line\">                        value.getBytes()</span><br><span class=\"line\">                )</span><br><span class=\"line\">        ));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 判断元素是否存在</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">exists</span><span class=\"params\">(String key, String value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Boolean.TRUE.equals(redisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt;</span><br><span class=\"line\">                connection.scriptingCommands().eval(</span><br><span class=\"line\">                        (<span class=\"string\">&quot;return redis.call(&#x27;CF.EXISTS&#x27;, KEYS[1], ARGV[1])&quot;</span>).getBytes(),</span><br><span class=\"line\">                        ReturnType.BOOLEAN,</span><br><span class=\"line\">                        <span class=\"number\">1</span>,</span><br><span class=\"line\">                        key.getBytes(),</span><br><span class=\"line\">                        value.getBytes()</span><br><span class=\"line\">                )</span><br><span class=\"line\">        ));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 批量判断是否存在</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Boolean&gt; <span class=\"title function_\">mexists</span><span class=\"params\">(String key, String... items)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (items == <span class=\"literal\">null</span> || items.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Collections.emptyList();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">byte</span>[][] keysAndArgs = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">1</span> + items.length][];</span><br><span class=\"line\">        keysAndArgs[<span class=\"number\">0</span>] = key.getBytes();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; items.length; i++) &#123;</span><br><span class=\"line\">            keysAndArgs[i + <span class=\"number\">1</span>] = items[i].getBytes();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.execute((RedisCallback&lt;List&lt;Boolean&gt;&gt;) connection -&gt;</span><br><span class=\"line\">                connection.scriptingCommands().eval(</span><br><span class=\"line\">                        (<span class=\"string\">&quot;return redis.call(&#x27;CF.MEXISTS&#x27;, KEYS[1], unpack(ARGV))&quot;</span>).getBytes(),</span><br><span class=\"line\">                        ReturnType.MULTI,</span><br><span class=\"line\">                        <span class=\"number\">1</span>,</span><br><span class=\"line\">                        keysAndArgs</span><br><span class=\"line\">                )</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回元素出现次数（近似）</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Long <span class=\"title function_\">count</span><span class=\"params\">(String key, String value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt;</span><br><span class=\"line\">                connection.scriptingCommands().eval(</span><br><span class=\"line\">                        (<span class=\"string\">&quot;return redis.call(&#x27;CF.COUNT&#x27;, KEYS[1], ARGV[1])&quot;</span>).getBytes(),</span><br><span class=\"line\">                        ReturnType.INTEGER,</span><br><span class=\"line\">                        <span class=\"number\">1</span>,</span><br><span class=\"line\">                        key.getBytes(),</span><br><span class=\"line\">                        value.getBytes()</span><br><span class=\"line\">                )</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 删除元素</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true 删除成功，false 表示不存在</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">delete</span><span class=\"params\">(String key, String value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Boolean.TRUE.equals(redisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt;</span><br><span class=\"line\">                connection.scriptingCommands().eval(</span><br><span class=\"line\">                        (<span class=\"string\">&quot;return redis.call(&#x27;CF.DEL&#x27;, KEYS[1], ARGV[1])&quot;</span>).getBytes(),</span><br><span class=\"line\">                        ReturnType.BOOLEAN,</span><br><span class=\"line\">                        <span class=\"number\">1</span>,</span><br><span class=\"line\">                        key.getBytes(),</span><br><span class=\"line\">                        value.getBytes()</span><br><span class=\"line\">                )</span><br><span class=\"line\">        ));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 批量插入，不去重</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Boolean&gt; <span class=\"title function_\">insert</span><span class=\"params\">(String key, String... items)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (items == <span class=\"literal\">null</span> || items.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Collections.emptyList();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">byte</span>[][] keysAndArgs = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">1</span> + items.length][];</span><br><span class=\"line\">        keysAndArgs[<span class=\"number\">0</span>] = key.getBytes();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; items.length; i++) &#123;</span><br><span class=\"line\">            keysAndArgs[i + <span class=\"number\">1</span>] = items[i].getBytes();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.execute((RedisCallback&lt;List&lt;Boolean&gt;&gt;) connection -&gt;</span><br><span class=\"line\">                connection.scriptingCommands().eval(</span><br><span class=\"line\">                        (<span class=\"string\">&quot;return redis.call(&#x27;CF.INSERT&#x27;, KEYS[1], &#x27;ITEMS&#x27;, unpack(ARGV))&quot;</span>).getBytes(),</span><br><span class=\"line\">                        ReturnType.MULTI,</span><br><span class=\"line\">                        <span class=\"number\">1</span>,</span><br><span class=\"line\">                        keysAndArgs</span><br><span class=\"line\">                )</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 批量插入，去重</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Boolean&gt; <span class=\"title function_\">insertNx</span><span class=\"params\">(String key, String... items)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (items == <span class=\"literal\">null</span> || items.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Collections.emptyList();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">byte</span>[][] keysAndArgs = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">1</span> + items.length][];</span><br><span class=\"line\">        keysAndArgs[<span class=\"number\">0</span>] = key.getBytes();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; items.length; i++) &#123;</span><br><span class=\"line\">            keysAndArgs[i + <span class=\"number\">1</span>] = items[i].getBytes();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.execute((RedisCallback&lt;List&lt;Boolean&gt;&gt;) connection -&gt;</span><br><span class=\"line\">                connection.scriptingCommands().eval(</span><br><span class=\"line\">                        (<span class=\"string\">&quot;return redis.call(&#x27;CF.INSERTNX&#x27;, KEYS[1], &#x27;ITEMS&#x27;, unpack(ARGV))&quot;</span>).getBytes(),</span><br><span class=\"line\">                        ReturnType.MULTI,</span><br><span class=\"line\">                        <span class=\"number\">1</span>,</span><br><span class=\"line\">                        keysAndArgs</span><br><span class=\"line\">                )</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取 Cuckoo Filter 元信息</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Map&lt;String, Object&gt; <span class=\"title function_\">info</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        List&lt;Object&gt; result = redisTemplate.execute(</span><br><span class=\"line\">                (RedisCallback&lt;List&lt;Object&gt;&gt;) connection -&gt;</span><br><span class=\"line\">                        connection.scriptingCommands().eval(</span><br><span class=\"line\">                                <span class=\"string\">&quot;return redis.call(&#x27;CF.INFO&#x27;, KEYS[1])&quot;</span>.getBytes(),</span><br><span class=\"line\">                                ReturnType.MULTI,</span><br><span class=\"line\">                                <span class=\"number\">1</span>,</span><br><span class=\"line\">                                key.getBytes()</span><br><span class=\"line\">                        )</span><br><span class=\"line\">        );</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result == <span class=\"literal\">null</span> || result.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Collections.emptyMap();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Map&lt;String, Object&gt; infoMap = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedHashMap</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; result.size(); i += <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">field</span> <span class=\"operator\">=</span> toString(result.get(i));</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> result.get(i + <span class=\"number\">1</span>);</span><br><span class=\"line\">            infoMap.put(field, value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> infoMap;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 字节数组转字符串</span></span><br><span class=\"line\"><span class=\"comment\">     * info 返回的 List</span></span><br><span class=\"line\"><span class=\"comment\">     * [</span></span><br><span class=\"line\"><span class=\"comment\">     *   byte[](&quot;Size&quot;),                  Long(1080),</span></span><br><span class=\"line\"><span class=\"comment\">     *   byte[](&quot;Number of buckets&quot;),     Long(512),</span></span><br><span class=\"line\"><span class=\"comment\">     *   byte[](&quot;Number of filters&quot;),     Long(1),</span></span><br><span class=\"line\"><span class=\"comment\">     *   ...</span></span><br><span class=\"line\"><span class=\"comment\">     * ]</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String <span class=\"title function_\">toString</span><span class=\"params\">(Object obj)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (obj <span class=\"keyword\">instanceof</span> <span class=\"type\">byte</span>[]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>((<span class=\"type\">byte</span>[]) obj);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> String.valueOf(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍 Redis 扩展模型 RedisBloom 中的 Cuckoo Filter 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RedisBloom 的安装参见 Redis 扩展模块 -- RedisBloom Cuckoo Filter（布谷鸟过滤器） Bloom Filter 的增强版，支持 删除元素 维基百科对 Cuckoo Filter 的描述 在高 QPS 查询场景下，Cuckoo Filter 通常优于 Bloom Filter。 低误判率 + 高负载率场景，Cuckoo Filter 更省内存。 对应Redis命令： CF.xxx 命令 功能说明 是否创建 Filter 关键参数含义 返回值 示例 使用要点 / 备注 CF.RESERVE 显式创建 Cuckoo Filter 是 capacity：容量(必填)BUCKETSIZE：每个桶里最多能放多少个 fingerprint（指纹），默认 2(大多数情况下的最优解)MAXITERATIONS：重排次数，越大成功率越高EXPANSION：扩容倍数，默认 1（不扩容） OK CF.RESERVE user:cf 100000 ✅ 生产推荐支持删除与计数 CF.ADD 添加一个元素，不去重 是 （不存在则创建） item：元素 OK CF.ADD user:cf user_1 若满可能失败 CF.ADDNX 元素不存在时才添加，去重 是 （不存在则创建） item 1 新增0 已存在 CF.ADDNX user:cf user_1 幂等写入首选 CF.INSERT 批量插入 是（不存在则创建） ITEMS：元素列表 OK CF.INSERT user:cf ITEMS u1 u2 默认配置 CF.INSERTNX 批量插入（不存在才加） 是 ITEMS 0/1 列表 CF.INSERTNX user:cf ITEMS u1 u2 幂等 + 批量 CF.EXISTS 判断单个元素是否存在 否 item 1 可能存在0 不存在 CF.EXISTS user:cf user_1 仍有误判 CF.MEXISTS 批量判断是否存在 否 item... 0/1 列表 CF.MEXISTS user:cf u1 u9 高并发推荐 CF.COUNT 返回元素出现次数 否 item 整数 CF.COUNT user:cf user_1 ⭐ Bloom 没有的能力 CF.DEL 删除一个元素 否 item 1 删除成功0 不存在 CF.DEL user:cf user_1 ⭐ Bloom 不支持 CF.INFO 查看 Filter 元信息 否 无 KV 列表 CF.INFO user:cf 运维分析 CF.SCANDUMP 分块导出 Filter 否 iterator iterator + data CF.SCANDUMP user:cf 0 迁移 / 备份 CF.LOADCHUNK 从 dump 恢复 Filter 是 iterator + data OK CF.LOADCHUNK user:cf 1 &quot;xxx&quot; 与 SCANDUMP 配合 Bloom vs Cuckoo 维度 Bloom Filter Cuckoo Filter 查询复杂度 O(k)（k 个哈希函数） O(1)（2–4 次 bucket 访问） 插入复杂度 O(k) 平均 O(1)，最坏可能触发重排 删除支持 ❌ 原生不支持 ✅ 原生支持 误判率（False Positive） 可配置，稳定 可配置，通常更低 漏判（False Negative） ❌ 理论上不会 ❌ 理论上不会 空间利用率 高（但受 k 影响） 通常更高（特别是低误判率） 扩容成本 高（需重建） 中等（支持扩展策略） 实现复杂度 低 较高 RedisBloom Cuckoo Filter 不支持设置 误判率，通常 容量 越大，误判率越低。 CF 命令示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# 创建 Cuckoo Filter127.0.0.1:6379&gt; CF.RESERVE user:cf 1000 BUCKETSIZE 2 MAXITERATIONS 500 EXPANSION 2OK# 添加元素127.0.0.1:6379&gt; CF.ADD user:cf user_1(integer) 1127.0.0.1:6379&gt; CF.ADD user:cf user_2(integer) 1# 可以重复添加元素127.0.0.1:6379&gt; CF.ADD user:cf user_1(integer) 1# 返回元素出现次数127.0.0.1:6379&gt; CF.COUNT user:cf user_1(integer) 2# 判断元素是否存在127.0.0.1:6379&gt; CF.EXISTS user:cf user_1(integer) 1# 批量判断元素是否存在127.0.0.1:6379&gt; CF.MEXISTS user:cf user_1 user_2 user_1001) (integer) 12) (integer) 13) (integer) 0# 删除元素，一次只删除一个127.0.0.1:6379&gt; CF.DEL user:cf user_1(integer) 1# 因为user_1有两个，所以才是还是能查询出 user_1127.0.0.1:6379&gt; CF.COUNT user:cf user_1(integer) 1# 再次删除127.0.0.1:6379&gt; CF.DEL user:cf user_1(integer) 1# 同名元素已全部删除，查询不到127.0.0.1:6379&gt; CF.COUNT user:cf user_1(integer) 0# 元素不存在时才添加，幂等127.0.0.1:6379&gt; CF.ADDNX user:cf user_2(integer) 0127.0.0.1:6379&gt; CF.ADDNX user:cf user_3(integer) 1# 查看 Filter 元信息127.0.0.1:6379&gt; CF.INFO user:cf 1) Size # 当前 Cuckoo Filter 实际占用的内存大小（字节） 2) (integer) 1080 3) Number of buckets # 当前过滤器中 bucket（桶）的总数量，Size = Number of buckets * Bucket size(默认为2) 4) (integer) 512 5) Number of filters # 内部 子 Cuckoo Filter 的数量 6) (integer) 1 7) Number of items inserted # 成功插入的元素总数（近似） 8) (integer) 2 9) Number of items deleted # 已删除元素的累计次数10) (integer) 211) Bucket size # 每个 bucket 可容纳的 fingerprint 数，默认为 212) (integer) 213) Expansion rate # 过滤器自动扩容倍率，默认为1，0 或 1 表示不扩容（满则失败）14) (integer) 215) Max iterations # Cuckoo Kick-out 的最大重排次数，值越大，插入成功率越高，但写入延迟可能上升16) (integer) 500# 批量添加，key不存在则创建127.0.0.1:6379&gt; CF.INSERT order:cf CAPACITY 100 ITEMS order1 order21) (integer) 12) (integer) 1# 幂等，元素不存在时才添加127.0.0.1:6379&gt; CF.INSERTNX order:cf CAPACITY 100 ITEMS order1 order2 order1001) (integer) 02) (integer) 03) (integer) 1# 查看类型127.0.0.1:6379&gt; type order:cfMBbloomCF SpringBoot 集成 SpringBoot 的 RedisTemplate 中没有提供对RedisBloom的封装，需要自己封装，我这里封装了一个简易的RedisCuckooFilterTool 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269package com.example.redisbloom;/** * 基于 RedisBloom 插件的 CuckooFilter 实现 * https://github.com/RedisBloom/RedisBloom/releases * Created by hanqf on 2025/12/22 17:09. */import org.springframework.data.redis.connection.ReturnType;import org.springframework.data.redis.core.RedisCallback;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.stereotype.Component;import java.util.Collections;import java.util.LinkedHashMap;import java.util.List;import java.util.Map;@Componentpublic class RedisCuckooFilterTool &#123; private final StringRedisTemplate redisTemplate; public RedisCuckooFilterTool(StringRedisTemplate redisTemplate) &#123; this.redisTemplate = redisTemplate; &#125; /** * 初始化 Cuckoo Filter * &lt;p&gt; * 不能重复执行 * * @param key Filter 名称 * @param capacity 预计容量 */ public void reserve(String key, long capacity) &#123; redisTemplate.execute((RedisCallback&lt;String&gt;) connection -&gt; connection.scriptingCommands().eval( (&quot;return redis.call(&#x27;CF.RESERVE&#x27;, KEYS[1], &quot; + capacity + &quot;)&quot;).getBytes(), ReturnType.STATUS, 1, key.getBytes() ) ); &#125; /** * 初始化 Cuckoo Filter（高级参数） * * @param key Filter 名称 * @param capacity 预计容量 * @param bucketSize 每个桶里最多能放多少个 fingerprint（指纹），默认 2(大多数情况下的最优解) * @param maxIterations 重排次数，越大成功率越高 * @param expansion 扩容倍数，默认 1（不扩容） */ public void reserve(String key, long capacity, int bucketSize, int maxIterations, int expansion) &#123; String script = String.format( &quot;return redis.call(&#x27;CF.RESERVE&#x27;, KEYS[1], %d, &quot; + &quot;&#x27;BUCKETSIZE&#x27;, %d, &#x27;MAXITERATIONS&#x27;, %d, &#x27;EXPANSION&#x27;, %d)&quot;, capacity, bucketSize, maxIterations, expansion ); redisTemplate.execute((RedisCallback&lt;String&gt;) connection -&gt; connection.scriptingCommands().eval( script.getBytes(), ReturnType.STATUS, 1, key.getBytes() ) ); &#125; /** * 添加元素（不去重） */ public boolean add(String key, String value) &#123; return Boolean.TRUE.equals(redisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt; connection.scriptingCommands().eval( (&quot;return redis.call(&#x27;CF.ADD&#x27;, KEYS[1], ARGV[1])&quot;).getBytes(), ReturnType.BOOLEAN, 1, key.getBytes(), value.getBytes() ) )); &#125; /** * 添加元素（仅当不存在时） * * @return true 表示成功插入，false 表示已存在 */ public boolean addNx(String key, String value) &#123; return Boolean.TRUE.equals(redisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt; connection.scriptingCommands().eval( (&quot;return redis.call(&#x27;CF.ADDNX&#x27;, KEYS[1], ARGV[1])&quot;).getBytes(), ReturnType.BOOLEAN, 1, key.getBytes(), value.getBytes() ) )); &#125; /** * 判断元素是否存在 */ public boolean exists(String key, String value) &#123; return Boolean.TRUE.equals(redisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt; connection.scriptingCommands().eval( (&quot;return redis.call(&#x27;CF.EXISTS&#x27;, KEYS[1], ARGV[1])&quot;).getBytes(), ReturnType.BOOLEAN, 1, key.getBytes(), value.getBytes() ) )); &#125; /** * 批量判断是否存在 */ public List&lt;Boolean&gt; mexists(String key, String... items) &#123; if (items == null || items.length == 0) &#123; return Collections.emptyList(); &#125; byte[][] keysAndArgs = new byte[1 + items.length][]; keysAndArgs[0] = key.getBytes(); for (int i = 0; i &lt; items.length; i++) &#123; keysAndArgs[i + 1] = items[i].getBytes(); &#125; return redisTemplate.execute((RedisCallback&lt;List&lt;Boolean&gt;&gt;) connection -&gt; connection.scriptingCommands().eval( (&quot;return redis.call(&#x27;CF.MEXISTS&#x27;, KEYS[1], unpack(ARGV))&quot;).getBytes(), ReturnType.MULTI, 1, keysAndArgs ) ); &#125; /** * 返回元素出现次数（近似） */ public Long count(String key, String value) &#123; return redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt; connection.scriptingCommands().eval( (&quot;return redis.call(&#x27;CF.COUNT&#x27;, KEYS[1], ARGV[1])&quot;).getBytes(), ReturnType.INTEGER, 1, key.getBytes(), value.getBytes() ) ); &#125; /** * 删除元素 * * @return true 删除成功，false 表示不存在 */ public boolean delete(String key, String value) &#123; return Boolean.TRUE.equals(redisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt; connection.scriptingCommands().eval( (&quot;return redis.call(&#x27;CF.DEL&#x27;, KEYS[1], ARGV[1])&quot;).getBytes(), ReturnType.BOOLEAN, 1, key.getBytes(), value.getBytes() ) )); &#125; /** * 批量插入，不去重 */ public List&lt;Boolean&gt; insert(String key, String... items) &#123; if (items == null || items.length == 0) &#123; return Collections.emptyList(); &#125; byte[][] keysAndArgs = new byte[1 + items.length][]; keysAndArgs[0] = key.getBytes(); for (int i = 0; i &lt; items.length; i++) &#123; keysAndArgs[i + 1] = items[i].getBytes(); &#125; return redisTemplate.execute((RedisCallback&lt;List&lt;Boolean&gt;&gt;) connection -&gt; connection.scriptingCommands().eval( (&quot;return redis.call(&#x27;CF.INSERT&#x27;, KEYS[1], &#x27;ITEMS&#x27;, unpack(ARGV))&quot;).getBytes(), ReturnType.MULTI, 1, keysAndArgs ) ); &#125; /** * 批量插入，去重 */ public List&lt;Boolean&gt; insertNx(String key, String... items) &#123; if (items == null || items.length == 0) &#123; return Collections.emptyList(); &#125; byte[][] keysAndArgs = new byte[1 + items.length][]; keysAndArgs[0] = key.getBytes(); for (int i = 0; i &lt; items.length; i++) &#123; keysAndArgs[i + 1] = items[i].getBytes(); &#125; return redisTemplate.execute((RedisCallback&lt;List&lt;Boolean&gt;&gt;) connection -&gt; connection.scriptingCommands().eval( (&quot;return redis.call(&#x27;CF.INSERTNX&#x27;, KEYS[1], &#x27;ITEMS&#x27;, unpack(ARGV))&quot;).getBytes(), ReturnType.MULTI, 1, keysAndArgs ) ); &#125; /** * 获取 Cuckoo Filter 元信息 */ public Map&lt;String, Object&gt; info(String key) &#123; List&lt;Object&gt; result = redisTemplate.execute( (RedisCallback&lt;List&lt;Object&gt;&gt;) connection -&gt; connection.scriptingCommands().eval( &quot;return redis.call(&#x27;CF.INFO&#x27;, KEYS[1])&quot;.getBytes(), ReturnType.MULTI, 1, key.getBytes() ) ); if (result == null || result.isEmpty()) &#123; return Collections.emptyMap(); &#125; Map&lt;String, Object&gt; infoMap = new LinkedHashMap&lt;&gt;(); for (int i = 0; i &lt; result.size(); i += 2) &#123; String field = toString(result.get(i)); Object value = result.get(i + 1); infoMap.put(field, value); &#125; return infoMap; &#125; /** * 字节数组转字符串 * info 返回的 List * [ * byte[](&quot;Size&quot;), Long(1080), * byte[](&quot;Number of buckets&quot;), Long(512), * byte[](&quot;Number of filters&quot;), Long(1), * ... * ] */ private String toString(Object obj) &#123; if (obj instanceof byte[]) &#123; return new String((byte[]) obj); &#125; return String.valueOf(obj); &#125;&#125;","summary":"摘要 本文介绍 Redis 扩展模型 RedisBloom 中的 Cuckoo Filter 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RedisBloom 的安装参见 Redis 扩展模块 -- RedisBloom","date_published":"2025-12-22T06:40:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/22/redis7-datatype-11-BF/","url":"https://blog.hanqunfeng.com/2025/12/22/redis7-datatype-11-BF/","title":"Redis 命令及数据类型 -- BF(Bloom Filter)","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis 扩展模型 RedisBloom 中的 Bloom Filter 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n<li class=\"lvl-2\">RedisBloom 的安装参见 <a href=\"/2025/12/21/redis7-module-RedisBloom/\" title=\"Redis 扩展模块 -- RedisBloom\">Redis 扩展模块 -- RedisBloom</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"BF-Bloom-Filter\">BF(Bloom Filter)</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>判断某个元素“可能存在 / 一定不存在”，但不存储元素本身，也不支持删除</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://en.wikipedia.org/wiki/Bloom_filter\">维基百科对 Bloom Filter 的描述</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>生产环境推荐使用 <a href=\"https://redisson.pro/docs/data-and-services/objects/#bloom-filter\">Redisson的布隆过滤器</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>对应Redis命令： <code>BF.xxx</code></p>\n</li>\n</ul>\n<h2 id=\"BF-命令说明\">BF 命令说明</h2>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能说明</th>\n<th>是否创建 Filter</th>\n<th>关键参数含义</th>\n<th>返回值</th>\n<th>示例</th>\n<th>使用要点 / 备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>BF.RESERVE</strong></td>\n<td>显式创建 Bloom Filter</td>\n<td>是（已存在则报错）</td>\n<td><code>error_rate</code>：误判率<br><code>capacity</code>：预计元素数<br><code>EXPANSION</code>：扩容倍率</td>\n<td>OK</td>\n<td><code>BF.RESERVE user:bf 0.001 1000000</code></td>\n<td>✅ <strong>生产推荐</strong><br>显式规划容量与误判率，避免隐式创建</td>\n</tr>\n<tr>\n<td><strong>BF.ADD</strong></td>\n<td>添加单个元素</td>\n<td>是（不存在则创建）</td>\n<td>无</td>\n<td><code>1</code> 新增<br><code>0</code> 可能已存在</td>\n<td><code>BF.ADD user:bf user_1</code></td>\n<td>Key 必须已存在，否则报错</td>\n</tr>\n<tr>\n<td><strong>BF.MADD</strong></td>\n<td>批量添加元素</td>\n<td>是（不存在则创建）</td>\n<td><code>item...</code>：多个元素</td>\n<td><code>0/1</code> 列表</td>\n<td><code>BF.MADD user:bf u1 u2 u3</code></td>\n<td>⚠ 使用默认配置，不建议生产</td>\n</tr>\n<tr>\n<td><strong>BF.INSERT</strong></td>\n<td>批量插入（可控参数）</td>\n<td>是</td>\n<td><code>CAPACITY</code>：容量<br><code>ERROR</code>：误判率<br><code>NOCREATE</code>:不自动创建过滤器<br><code>NONSCALING</code>: 不扩容，达到capacity时，过滤器返回错误<br><code>EXPANSION expansion</code>:扩容时，新建子过滤器的容量增长倍率，默认2 <br><code>ITEMS</code>：元素列表</td>\n<td><code>0/1</code> 列表</td>\n<td><code>BF.INSERT user:bf CAPACITY 10000 ERROR 0.001 ITEMS u1 u2</code></td>\n<td>✅ <strong>最推荐的写入方式</strong><br>支持初始化 + 插入</td>\n</tr>\n<tr>\n<td><strong>BF.EXISTS</strong></td>\n<td>判断单个元素是否存在</td>\n<td>否</td>\n<td><code>item</code>：待判断元素</td>\n<td><code>1</code> 可能存在<br><code>0</code> 一定不存在</td>\n<td><code>BF.EXISTS user:bf user_1</code></td>\n<td>不存在结果 <strong>绝对可靠</strong></td>\n</tr>\n<tr>\n<td><strong>BF.MEXISTS</strong></td>\n<td>批量判断是否存在</td>\n<td>否</td>\n<td><code>item...</code>：多个元素</td>\n<td><code>0/1</code> 列表</td>\n<td><code>BF.MEXISTS user:bf u1 u9</code></td>\n<td>高并发批量查询首选</td>\n</tr>\n<tr>\n<td><strong>BF.CARD</strong></td>\n<td>返回插入元素数量（近似）</td>\n<td>否</td>\n<td>无</td>\n<td>整数</td>\n<td><code>BF.CARD user:bf</code></td>\n<td>用于容量监控，非精确</td>\n</tr>\n<tr>\n<td><strong><a href=\"http://BF.INFO\">BF.INFO</a></strong></td>\n<td>返回 Bloom Filter 元信息</td>\n<td>否</td>\n<td>无</td>\n<td>KV 列表</td>\n<td><code>BF.INFO user:bf</code></td>\n<td>运维、容量与内存分析必备</td>\n</tr>\n<tr>\n<td><strong>BF.SCANDUMP</strong></td>\n<td>分块导出 Bloom Filter</td>\n<td>否</td>\n<td><code>iterator</code>：游标</td>\n<td><code>iterator + data</code></td>\n<td><code>BF.SCANDUMP user:bf 0</code></td>\n<td>用于迁移、备份</td>\n</tr>\n<tr>\n<td><strong>BF.LOADCHUNK</strong></td>\n<td>从 dump 数据恢复 Filter</td>\n<td>是</td>\n<td><code>iterator</code><br><code>data</code></td>\n<td>OK</td>\n<td><code>BF.LOADCHUNK user:bf 1 &quot;xxx&quot;</code></td>\n<td>必须与 SCANDUMP 配合使用</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"BF-命令示例\">BF 命令示例</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 初始化一个BloomFilter，错误率0.01，元素数量1000</span></span><br><span class=\"line\">127.0.0.1:6379&gt; BF.RESERVE <span class=\"built_in\">test</span> 0.01 1000</span><br><span class=\"line\">OK</span><br><span class=\"line\"><span class=\"comment\"># 查看类型</span></span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">type</span> <span class=\"built_in\">test</span></span><br><span class=\"line\">MBbloom--</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加元素</span></span><br><span class=\"line\">127.0.0.1:6379&gt; BF.ADD <span class=\"built_in\">test</span> user1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; BF.ADD <span class=\"built_in\">test</span> user2</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"><span class=\"comment\"># 批量添加元素</span></span><br><span class=\"line\">127.0.0.1:6379&gt; BF.MADD <span class=\"built_in\">test</span> user3 user4 user5</span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">3) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"><span class=\"comment\"># 返回Bloom过滤器的基数，即添加的元素数量(存在误差)</span></span><br><span class=\"line\">127.0.0.1:6379&gt; BF.CARD <span class=\"built_in\">test</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 5</span><br><span class=\"line\"><span class=\"comment\"># 查询元素是否存在</span></span><br><span class=\"line\">127.0.0.1:6379&gt; BF.EXISTS <span class=\"built_in\">test</span> user2</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; BF.EXISTS <span class=\"built_in\">test</span> user6</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\"><span class=\"comment\"># 批量查询元素是否存在</span></span><br><span class=\"line\">127.0.0.1:6379&gt; BF.MEXISTS <span class=\"built_in\">test</span> user1 user2 user6</span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">3) (<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取信息</span></span><br><span class=\"line\">127.0.0.1:6379&gt; BF.INFO <span class=\"built_in\">test</span></span><br><span class=\"line\"> 1) Capacity       <span class=\"comment\"># 初始化时的容量，超过该值后，会触发 扩容（新建一个子 Bloom Filter）</span></span><br><span class=\"line\"> 2) (<span class=\"built_in\">integer</span>) 1000</span><br><span class=\"line\"> 3) Size           <span class=\"comment\"># 当前 Bloom Filter 实际使用的 bit array 大小（字节)，由 capacity + error_rate 计算得出，值一旦创建 不会随元素减少</span></span><br><span class=\"line\"> 4) (<span class=\"built_in\">integer</span>) 1480</span><br><span class=\"line\"> 5) Number of filters <span class=\"comment\"># 当前 key 内部包含的 Bloom Filter 数量</span></span><br><span class=\"line\"> 6) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"> 7) Number of items inserted  <span class=\"comment\"># 已调用 BF.ADD / BF.MADD 插入的元素总数</span></span><br><span class=\"line\"> 8) (<span class=\"built_in\">integer</span>) 5</span><br><span class=\"line\"> 9) Expansion rate     <span class=\"comment\"># Bloom Filter 扩容时，新建子过滤器的容量增长倍率</span></span><br><span class=\"line\">10) (<span class=\"built_in\">integer</span>) 2</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"SpringBoot-集成\">SpringBoot 集成</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot 的 RedisTemplate 中没有提供对<code>RedisBloom</code>的封装，需要自己封装，我这里封装了一个简易的<code>RedisBloomFilterTool</code></p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.redisbloom;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 基于 RedisBloom 插件的 BloomFilter 工具类</span></span><br><span class=\"line\"><span class=\"comment\"> * https://github.com/RedisBloom/RedisBloom/releases</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 不想安装插件也可以使用 Redission 的 BloomFilter</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.connection.ReturnType;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.core.RedisCallback;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Collections;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisBloomFilterTool</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> StringRedisTemplate redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">RedisBloomFilterTool</span><span class=\"params\">(StringRedisTemplate redisTemplate)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.redisTemplate = redisTemplate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 初始化 BloomFilter</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 不能重复执行</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key       BloomFilter 名称</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> errorRate 错误率，比如为0.01，即 1%</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> capacity  容量，比如为1000</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">reserve</span><span class=\"params\">(String key, <span class=\"type\">double</span> errorRate, <span class=\"type\">long</span> capacity)</span> &#123;</span><br><span class=\"line\">        redisTemplate.execute((RedisCallback&lt;String&gt;) connection -&gt;</span><br><span class=\"line\">                connection.scriptingCommands().eval(</span><br><span class=\"line\">                        (<span class=\"string\">&quot;return redis.call(&#x27;BF.RESERVE&#x27;, KEYS[1], &quot;</span> + errorRate + <span class=\"string\">&quot;, &quot;</span> + capacity + <span class=\"string\">&quot;)&quot;</span>).getBytes(),</span><br><span class=\"line\">                        ReturnType.STATUS,</span><br><span class=\"line\">                        <span class=\"number\">1</span>,</span><br><span class=\"line\">                        key.getBytes()</span><br><span class=\"line\">                )</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 添加元素到 BloomFilter，BloomFilter 不存在会自动创建</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">add</span><span class=\"params\">(String key, String value)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 使用 RedisModule 提供的 BF.ADD 命令</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Boolean.TRUE.equals(redisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt;</span><br><span class=\"line\">                connection.scriptingCommands().eval(</span><br><span class=\"line\">                        (<span class=\"string\">&quot;return redis.call(&#x27;BF.ADD&#x27;, KEYS[1], ARGV[1])&quot;</span>).getBytes(),</span><br><span class=\"line\">                        ReturnType.BOOLEAN,</span><br><span class=\"line\">                        <span class=\"number\">1</span>,</span><br><span class=\"line\">                        key.getBytes(),</span><br><span class=\"line\">                        value.getBytes()</span><br><span class=\"line\">                )</span><br><span class=\"line\">        ));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 判断元素是否存在</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">exists</span><span class=\"params\">(String key, String value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Boolean.TRUE.equals(redisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt;</span><br><span class=\"line\">                connection.scriptingCommands().eval(</span><br><span class=\"line\">                        (<span class=\"string\">&quot;return redis.call(&#x27;BF.EXISTS&#x27;, KEYS[1], ARGV[1])&quot;</span>).getBytes(),</span><br><span class=\"line\">                        ReturnType.BOOLEAN,</span><br><span class=\"line\">                        <span class=\"number\">1</span>,</span><br><span class=\"line\">                        key.getBytes(),</span><br><span class=\"line\">                        value.getBytes()</span><br><span class=\"line\">                )</span><br><span class=\"line\">        ));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 批量添加</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Boolean&gt; <span class=\"title function_\">addBatch</span><span class=\"params\">(String key, String... items)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (items == <span class=\"literal\">null</span> || items.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Collections.emptyList();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 构建 keys + args 数组</span></span><br><span class=\"line\">        <span class=\"type\">byte</span>[][] keysAndArgs = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">1</span> + items.length][];</span><br><span class=\"line\">        keysAndArgs[<span class=\"number\">0</span>] = key.getBytes();  <span class=\"comment\">// KEYS[1]</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; items.length; i++) &#123;</span><br><span class=\"line\">            keysAndArgs[i + <span class=\"number\">1</span>] = items[i].getBytes(); <span class=\"comment\">// ARGV[1..n]</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 调用 BF.MADD 命令</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.execute((RedisCallback&lt;List&lt;Boolean&gt;&gt;) connection -&gt;</span><br><span class=\"line\">                connection.scriptingCommands().eval(</span><br><span class=\"line\">                        (<span class=\"string\">&quot;return redis.call(&#x27;BF.MADD&#x27;, KEYS[1], unpack(ARGV))&quot;</span>).getBytes(),</span><br><span class=\"line\">                        ReturnType.MULTI,</span><br><span class=\"line\">                        <span class=\"number\">1</span>,                <span class=\"comment\">// numKeys</span></span><br><span class=\"line\">                        keysAndArgs       <span class=\"comment\">// KEYS + ARGV</span></span><br><span class=\"line\">                )</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 批量添加，如果BloomFilter不存在，则根据参数创建 BloomFilter，若已存在，则忽略 capacity 和 errorRate</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key       BloomFilter 名称</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> capacity  容量</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> errorRate 错误率</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> items     要添加的元素</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 添加结果列表，成功 true，失败 false</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Boolean&gt; <span class=\"title function_\">insert</span><span class=\"params\">(String key, <span class=\"type\">long</span> capacity, <span class=\"type\">double</span> errorRate, String... items)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (items == <span class=\"literal\">null</span> || items.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Collections.emptyList();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 构建 keys + args 数组</span></span><br><span class=\"line\">        <span class=\"type\">byte</span>[][] keysAndArgs = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">6</span> + items.length][];</span><br><span class=\"line\">        keysAndArgs[<span class=\"number\">0</span>] = key.getBytes();  <span class=\"comment\">// KEYS[1]</span></span><br><span class=\"line\">        keysAndArgs[<span class=\"number\">1</span>] = <span class=\"string\">&quot;CAPACITY&quot;</span>.getBytes();</span><br><span class=\"line\">        keysAndArgs[<span class=\"number\">2</span>] = String.valueOf(capacity).getBytes();</span><br><span class=\"line\">        keysAndArgs[<span class=\"number\">3</span>] = <span class=\"string\">&quot;ERROR&quot;</span>.getBytes();</span><br><span class=\"line\">        keysAndArgs[<span class=\"number\">4</span>] = String.valueOf(errorRate).getBytes();</span><br><span class=\"line\">        keysAndArgs[<span class=\"number\">5</span>] = <span class=\"string\">&quot;ITEMS&quot;</span>.getBytes();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; items.length; i++) &#123;</span><br><span class=\"line\">            keysAndArgs[i + <span class=\"number\">6</span>] = items[i].getBytes(); <span class=\"comment\">// ARGV[1..n]</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 调用 BF.INSERT 命令</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.execute((RedisCallback&lt;List&lt;Boolean&gt;&gt;) connection -&gt;</span><br><span class=\"line\">                connection.scriptingCommands().eval(</span><br><span class=\"line\">                        (<span class=\"string\">&quot;return redis.call(&#x27;BF.INSERT&#x27;, KEYS[1], unpack(ARGV))&quot;</span>).getBytes(),</span><br><span class=\"line\">                        ReturnType.MULTI,</span><br><span class=\"line\">                        <span class=\"number\">1</span>,                <span class=\"comment\">// numKeys</span></span><br><span class=\"line\">                        keysAndArgs       <span class=\"comment\">// KEYS + ARGV</span></span><br><span class=\"line\">                )</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 批量判断元素是否存在</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Boolean&gt; <span class=\"title function_\">mexists</span><span class=\"params\">(String key, String... items)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (items == <span class=\"literal\">null</span> || items.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Collections.emptyList();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 构建 keys + args 数组</span></span><br><span class=\"line\">        <span class=\"type\">byte</span>[][] keysAndArgs = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">1</span> + items.length][];</span><br><span class=\"line\">        keysAndArgs[<span class=\"number\">0</span>] = key.getBytes();  <span class=\"comment\">// KEYS[1]</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; items.length; i++) &#123;</span><br><span class=\"line\">            keysAndArgs[i + <span class=\"number\">1</span>] = items[i].getBytes(); <span class=\"comment\">// ARGV[1..n]</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 调用 BF.MADD 命令</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.execute((RedisCallback&lt;List&lt;Boolean&gt;&gt;) connection -&gt;</span><br><span class=\"line\">                connection.scriptingCommands().eval(</span><br><span class=\"line\">                        (<span class=\"string\">&quot;return redis.call(&#x27;BF.MEXISTS&#x27;, KEYS[1], unpack(ARGV))&quot;</span>).getBytes(),</span><br><span class=\"line\">                        ReturnType.MULTI,</span><br><span class=\"line\">                        <span class=\"number\">1</span>,                <span class=\"comment\">// numKeys</span></span><br><span class=\"line\">                        keysAndArgs       <span class=\"comment\">// KEYS + ARGV</span></span><br><span class=\"line\">                )</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取元素数量</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Long <span class=\"title function_\">card</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt;</span><br><span class=\"line\">                connection.scriptingCommands().eval(</span><br><span class=\"line\">                        (<span class=\"string\">&quot;return redis.call(&#x27;BF.CARD&#x27;, KEYS[1])&quot;</span>).getBytes(),</span><br><span class=\"line\">                        ReturnType.INTEGER,</span><br><span class=\"line\">                        <span class=\"number\">1</span>,</span><br><span class=\"line\">                        key.getBytes()</span><br><span class=\"line\">                )</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取 Bloom Filter 元信息</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Map&lt;String, Object&gt; <span class=\"title function_\">info</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        List&lt;Object&gt; result = redisTemplate.execute(</span><br><span class=\"line\">                (RedisCallback&lt;List&lt;Object&gt;&gt;) connection -&gt;</span><br><span class=\"line\">                        connection.scriptingCommands().eval(</span><br><span class=\"line\">                                <span class=\"string\">&quot;return redis.call(&#x27;BF.INFO&#x27;, KEYS[1])&quot;</span>.getBytes(),</span><br><span class=\"line\">                                ReturnType.MULTI,</span><br><span class=\"line\">                                <span class=\"number\">1</span>,</span><br><span class=\"line\">                                key.getBytes()</span><br><span class=\"line\">                        )</span><br><span class=\"line\">        );</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result == <span class=\"literal\">null</span> || result.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Collections.emptyMap();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Map&lt;String, Object&gt; infoMap = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedHashMap</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; result.size(); i += <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">field</span> <span class=\"operator\">=</span> toString(result.get(i));</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> result.get(i + <span class=\"number\">1</span>);</span><br><span class=\"line\">            infoMap.put(field, value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> infoMap;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String <span class=\"title function_\">toString</span><span class=\"params\">(Object obj)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (obj <span class=\"keyword\">instanceof</span> <span class=\"type\">byte</span>[]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>((<span class=\"type\">byte</span>[]) obj);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> String.valueOf(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","content_text":"摘要 本文介绍 Redis 扩展模型 RedisBloom 中的 Bloom Filter 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RedisBloom 的安装参见 Redis 扩展模块 -- RedisBloom BF(Bloom Filter) 判断某个元素“可能存在 / 一定不存在”，但不存储元素本身，也不支持删除 维基百科对 Bloom Filter 的描述 生产环境推荐使用 Redisson的布隆过滤器 对应Redis命令： BF.xxx BF 命令说明 命令 功能说明 是否创建 Filter 关键参数含义 返回值 示例 使用要点 / 备注 BF.RESERVE 显式创建 Bloom Filter 是（已存在则报错） error_rate：误判率capacity：预计元素数EXPANSION：扩容倍率 OK BF.RESERVE user:bf 0.001 1000000 ✅ 生产推荐显式规划容量与误判率，避免隐式创建 BF.ADD 添加单个元素 是（不存在则创建） 无 1 新增0 可能已存在 BF.ADD user:bf user_1 Key 必须已存在，否则报错 BF.MADD 批量添加元素 是（不存在则创建） item...：多个元素 0/1 列表 BF.MADD user:bf u1 u2 u3 ⚠ 使用默认配置，不建议生产 BF.INSERT 批量插入（可控参数） 是 CAPACITY：容量ERROR：误判率NOCREATE:不自动创建过滤器NONSCALING: 不扩容，达到capacity时，过滤器返回错误EXPANSION expansion:扩容时，新建子过滤器的容量增长倍率，默认2 ITEMS：元素列表 0/1 列表 BF.INSERT user:bf CAPACITY 10000 ERROR 0.001 ITEMS u1 u2 ✅ 最推荐的写入方式支持初始化 + 插入 BF.EXISTS 判断单个元素是否存在 否 item：待判断元素 1 可能存在0 一定不存在 BF.EXISTS user:bf user_1 不存在结果 绝对可靠 BF.MEXISTS 批量判断是否存在 否 item...：多个元素 0/1 列表 BF.MEXISTS user:bf u1 u9 高并发批量查询首选 BF.CARD 返回插入元素数量（近似） 否 无 整数 BF.CARD user:bf 用于容量监控，非精确 BF.INFO 返回 Bloom Filter 元信息 否 无 KV 列表 BF.INFO user:bf 运维、容量与内存分析必备 BF.SCANDUMP 分块导出 Bloom Filter 否 iterator：游标 iterator + data BF.SCANDUMP user:bf 0 用于迁移、备份 BF.LOADCHUNK 从 dump 数据恢复 Filter 是 iteratordata OK BF.LOADCHUNK user:bf 1 &quot;xxx&quot; 必须与 SCANDUMP 配合使用 BF 命令示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344# 初始化一个BloomFilter，错误率0.01，元素数量1000127.0.0.1:6379&gt; BF.RESERVE test 0.01 1000OK# 查看类型127.0.0.1:6379&gt; type testMBbloom--# 添加元素127.0.0.1:6379&gt; BF.ADD test user1(integer) 1127.0.0.1:6379&gt; BF.ADD test user2(integer) 1# 批量添加元素127.0.0.1:6379&gt; BF.MADD test user3 user4 user51) (integer) 12) (integer) 13) (integer) 1# 返回Bloom过滤器的基数，即添加的元素数量(存在误差)127.0.0.1:6379&gt; BF.CARD test(integer) 5# 查询元素是否存在127.0.0.1:6379&gt; BF.EXISTS test user2(integer) 1127.0.0.1:6379&gt; BF.EXISTS test user6(integer) 0# 批量查询元素是否存在127.0.0.1:6379&gt; BF.MEXISTS test user1 user2 user61) (integer) 12) (integer) 13) (integer) 0# 获取信息127.0.0.1:6379&gt; BF.INFO test 1) Capacity # 初始化时的容量，超过该值后，会触发 扩容（新建一个子 Bloom Filter） 2) (integer) 1000 3) Size # 当前 Bloom Filter 实际使用的 bit array 大小（字节)，由 capacity + error_rate 计算得出，值一旦创建 不会随元素减少 4) (integer) 1480 5) Number of filters # 当前 key 内部包含的 Bloom Filter 数量 6) (integer) 1 7) Number of items inserted # 已调用 BF.ADD / BF.MADD 插入的元素总数 8) (integer) 5 9) Expansion rate # Bloom Filter 扩容时，新建子过滤器的容量增长倍率10) (integer) 2 SpringBoot 集成 SpringBoot 的 RedisTemplate 中没有提供对RedisBloom的封装，需要自己封装，我这里封装了一个简易的RedisBloomFilterTool 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219package com.example.redisbloom;/** * 基于 RedisBloom 插件的 BloomFilter 工具类 * https://github.com/RedisBloom/RedisBloom/releases * &lt;p&gt; * 不想安装插件也可以使用 Redission 的 BloomFilter */import org.springframework.data.redis.connection.ReturnType;import org.springframework.data.redis.core.RedisCallback;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.stereotype.Component;import java.util.Collections;import java.util.List;@Componentpublic class RedisBloomFilterTool &#123; private final StringRedisTemplate redisTemplate; public RedisBloomFilterTool(StringRedisTemplate redisTemplate) &#123; this.redisTemplate = redisTemplate; &#125; /** * 初始化 BloomFilter * &lt;p&gt; * 不能重复执行 * * @param key BloomFilter 名称 * @param errorRate 错误率，比如为0.01，即 1% * @param capacity 容量，比如为1000 */ public void reserve(String key, double errorRate, long capacity) &#123; redisTemplate.execute((RedisCallback&lt;String&gt;) connection -&gt; connection.scriptingCommands().eval( (&quot;return redis.call(&#x27;BF.RESERVE&#x27;, KEYS[1], &quot; + errorRate + &quot;, &quot; + capacity + &quot;)&quot;).getBytes(), ReturnType.STATUS, 1, key.getBytes() ) ); &#125; /** * 添加元素到 BloomFilter，BloomFilter 不存在会自动创建 */ public boolean add(String key, String value) &#123; // 使用 RedisModule 提供的 BF.ADD 命令 return Boolean.TRUE.equals(redisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt; connection.scriptingCommands().eval( (&quot;return redis.call(&#x27;BF.ADD&#x27;, KEYS[1], ARGV[1])&quot;).getBytes(), ReturnType.BOOLEAN, 1, key.getBytes(), value.getBytes() ) )); &#125; /** * 判断元素是否存在 */ public boolean exists(String key, String value) &#123; return Boolean.TRUE.equals(redisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt; connection.scriptingCommands().eval( (&quot;return redis.call(&#x27;BF.EXISTS&#x27;, KEYS[1], ARGV[1])&quot;).getBytes(), ReturnType.BOOLEAN, 1, key.getBytes(), value.getBytes() ) )); &#125; /** * 批量添加 */ public List&lt;Boolean&gt; addBatch(String key, String... items) &#123; if (items == null || items.length == 0) &#123; return Collections.emptyList(); &#125; // 构建 keys + args 数组 byte[][] keysAndArgs = new byte[1 + items.length][]; keysAndArgs[0] = key.getBytes(); // KEYS[1] for (int i = 0; i &lt; items.length; i++) &#123; keysAndArgs[i + 1] = items[i].getBytes(); // ARGV[1..n] &#125; // 调用 BF.MADD 命令 return redisTemplate.execute((RedisCallback&lt;List&lt;Boolean&gt;&gt;) connection -&gt; connection.scriptingCommands().eval( (&quot;return redis.call(&#x27;BF.MADD&#x27;, KEYS[1], unpack(ARGV))&quot;).getBytes(), ReturnType.MULTI, 1, // numKeys keysAndArgs // KEYS + ARGV ) ); &#125; /** * 批量添加，如果BloomFilter不存在，则根据参数创建 BloomFilter，若已存在，则忽略 capacity 和 errorRate * * @param key BloomFilter 名称 * @param capacity 容量 * @param errorRate 错误率 * @param items 要添加的元素 * @return 添加结果列表，成功 true，失败 false */ public List&lt;Boolean&gt; insert(String key, long capacity, double errorRate, String... items) &#123; if (items == null || items.length == 0) &#123; return Collections.emptyList(); &#125; // 构建 keys + args 数组 byte[][] keysAndArgs = new byte[6 + items.length][]; keysAndArgs[0] = key.getBytes(); // KEYS[1] keysAndArgs[1] = &quot;CAPACITY&quot;.getBytes(); keysAndArgs[2] = String.valueOf(capacity).getBytes(); keysAndArgs[3] = &quot;ERROR&quot;.getBytes(); keysAndArgs[4] = String.valueOf(errorRate).getBytes(); keysAndArgs[5] = &quot;ITEMS&quot;.getBytes(); for (int i = 0; i &lt; items.length; i++) &#123; keysAndArgs[i + 6] = items[i].getBytes(); // ARGV[1..n] &#125; // 调用 BF.INSERT 命令 return redisTemplate.execute((RedisCallback&lt;List&lt;Boolean&gt;&gt;) connection -&gt; connection.scriptingCommands().eval( (&quot;return redis.call(&#x27;BF.INSERT&#x27;, KEYS[1], unpack(ARGV))&quot;).getBytes(), ReturnType.MULTI, 1, // numKeys keysAndArgs // KEYS + ARGV ) ); &#125; /** * 批量判断元素是否存在 */ public List&lt;Boolean&gt; mexists(String key, String... items) &#123; if (items == null || items.length == 0) &#123; return Collections.emptyList(); &#125; // 构建 keys + args 数组 byte[][] keysAndArgs = new byte[1 + items.length][]; keysAndArgs[0] = key.getBytes(); // KEYS[1] for (int i = 0; i &lt; items.length; i++) &#123; keysAndArgs[i + 1] = items[i].getBytes(); // ARGV[1..n] &#125; // 调用 BF.MADD 命令 return redisTemplate.execute((RedisCallback&lt;List&lt;Boolean&gt;&gt;) connection -&gt; connection.scriptingCommands().eval( (&quot;return redis.call(&#x27;BF.MEXISTS&#x27;, KEYS[1], unpack(ARGV))&quot;).getBytes(), ReturnType.MULTI, 1, // numKeys keysAndArgs // KEYS + ARGV ) ); &#125; /** * 获取元素数量 */ public Long card(String key) &#123; return redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt; connection.scriptingCommands().eval( (&quot;return redis.call(&#x27;BF.CARD&#x27;, KEYS[1])&quot;).getBytes(), ReturnType.INTEGER, 1, key.getBytes() ) ); &#125; /** * 获取 Bloom Filter 元信息 */ public Map&lt;String, Object&gt; info(String key) &#123; List&lt;Object&gt; result = redisTemplate.execute( (RedisCallback&lt;List&lt;Object&gt;&gt;) connection -&gt; connection.scriptingCommands().eval( &quot;return redis.call(&#x27;BF.INFO&#x27;, KEYS[1])&quot;.getBytes(), ReturnType.MULTI, 1, key.getBytes() ) ); if (result == null || result.isEmpty()) &#123; return Collections.emptyMap(); &#125; Map&lt;String, Object&gt; infoMap = new LinkedHashMap&lt;&gt;(); for (int i = 0; i &lt; result.size(); i += 2) &#123; String field = toString(result.get(i)); Object value = result.get(i + 1); infoMap.put(field, value); &#125; return infoMap; &#125; private String toString(Object obj) &#123; if (obj instanceof byte[]) &#123; return new String((byte[]) obj); &#125; return String.valueOf(obj); &#125;&#125;","summary":"摘要 本文介绍 Redis 扩展模型 RedisBloom 中的 Bloom Filter 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RedisBloom 的安装参见 Redis 扩展模块 -- RedisBloom","date_published":"2025-12-22T05:40:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/21/redis7-module-RedisBloom/","url":"https://blog.hanqunfeng.com/2025/12/21/redis7-module-RedisBloom/","title":"Redis 扩展模块 -- RedisBloom","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis 扩展模块 – RedisBloom 的使用方法</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"RedisBloom-简介\">RedisBloom 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/RedisBloom/RedisBloom\">RedisBloom</a> 是 Redis 官方维护的一个扩展模块，隶属于 <code>Redis Stack</code>，专门用于提供概率型数据结构（Probabilistic Data Structures）的高性能实现。</p>\n</li>\n<li class=\"lvl-2\">\n<p>它通过牺牲一定的精确性，换取极低的内存占用和极高的吞吐能力，非常适合海量数据场景下的“存在性判断”和“近似统计”。</p>\n</li>\n<li class=\"lvl-2\">\n<p>该模块以 <code>Redis Module</code> 方式加载，可无缝集成到现有 Redis 实例中。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Redis8+，RedisBloom 已经内置在 Redis 中，不需要单独安装。</p>\n</li>\n</ul>\n<h3 id=\"RedisBloom-提供的核心数据结构\">RedisBloom 提供的核心数据结构</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1️⃣ Bloom Filter（布隆过滤器）</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">判断某个元素“可能存在 / 一定不存在”，但不存储元素本身，也不支持删除</li>\n<li class=\"lvl-6\"><a href=\"https://en.wikipedia.org/wiki/Bloom_filter\">维基百科对 Bloom Filter 的描述</a></li>\n<li class=\"lvl-6\">生产环境推荐使用 <a href=\"https://redisson.pro/docs/data-and-services/objects/#bloom-filter\">Redisson的布隆过滤器</a></li>\n<li class=\"lvl-6\">对应Redis命令： <code>BF.xxx</code>，详细的使用方法参见 <a href=\"/2025/12/22/redis7-datatype-11-BF/\" title=\"Redis 命令及数据类型 -- BF(Bloom Filter)\">Redis 命令及数据类型 -- BF(Bloom Filter)</a></li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>2️⃣ Cuckoo Filter（布谷鸟过滤器）</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">Bloom Filter 的增强版，支持 删除元素</li>\n<li class=\"lvl-6\"><a href=\"https://en.wikipedia.org/wiki/Cuckoo_filter\">维基百科对 Cuckoo Filter 的描述</a></li>\n<li class=\"lvl-6\">在高 QPS 查询场景下，Cuckoo Filter 通常优于 Bloom Filter。</li>\n<li class=\"lvl-6\">低误判率 + 高负载率场景，Cuckoo Filter 更省内存。</li>\n<li class=\"lvl-6\">对应Redis命令： <code>CF.xxx</code>，详细的使用方法参见 <a href=\"/2025/12/22/redis7-datatype-12-CF/\" title=\"Redis 命令及数据类型 -- CF(Cuckoo Filter)\">Redis 命令及数据类型 -- CF(Cuckoo Filter)</a></li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>3️⃣ Count-Min Sketch（CMS）</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">近似统计元素出现频率</li>\n<li class=\"lvl-6\">对应Redis命令： <code>CMS.xxx</code></li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>4️⃣ Top-K</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">统计访问频率最高的 K 个元素</li>\n<li class=\"lvl-6\">对应Redis命令： <code>TOPK.xxx</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"安装-RedisBloom\">安装 RedisBloom</h2>\n<blockquote>\n<p>安装时需要科学上网，主要是安装依赖时需要从海外网下载，如果要部署在国内服务器，可能会连接失败。<br>\n可以在海外的<code>相同配置</code>的服务器上进行编译，之后将编译好的<code>redisbloom.so</code>上传到国内服务器即可。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> -p /usr/local/soft/modules/</span><br><span class=\"line\"><span class=\"built_in\">cd</span> /usr/local/soft/modules</span><br><span class=\"line\"><span class=\"comment\"># clone 代码，这里 --recursive 是为了拉取子模块</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> --recursive https://github.com/RedisBloom/RedisBloom.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> RedisBloom</span><br><span class=\"line\"><span class=\"comment\"># 推荐切换到稳定的release版本</span></span><br><span class=\"line\">git checkout v2.8.17</span><br><span class=\"line\"><span class=\"comment\"># 更新子模块，非必须，如果上面 clone 时没有加上 --recursive ，这个步骤就不能省略</span></span><br><span class=\"line\">git submodule update --init --recursive</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查并安装需要的依赖</span></span><br><span class=\"line\">./sbin/setup</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\"><span class=\"comment\"># readies version: 7fc8e62</span></span><br><span class=\"line\">dnf install -q -y ca-certificates</span><br><span class=\"line\">dnf install -q -y wget unzip</span><br><span class=\"line\">/usr/local/soft/modules/RedisBloom/deps/readies/bin/enable-utf8</span><br><span class=\"line\">dnf install -q -y git jq</span><br><span class=\"line\">dnf install -q -y <span class=\"built_in\">which</span></span><br><span class=\"line\">/usr/local/soft/modules/RedisBloom/deps/readies/bin/getepel</span><br><span class=\"line\">/usr/local/soft/modules/RedisBloom/deps/readies/bin/getgcc --modern</span><br><span class=\"line\">dnf install -q -y valgrind</span><br><span class=\"line\">/usr/local/soft/modules/RedisBloom/sbin/get-fbinfer</span><br><span class=\"line\">dnf install -q -y lcov</span><br><span class=\"line\">/usr/bin/python3 /usr/local/soft/modules/RedisBloom/deps/readies/bin/getrmpytools --reinstall --modern</span><br><span class=\"line\">/usr/bin/python3 /usr/local/soft/modules/RedisBloom/deps/readies/bin/getcmake --usr</span><br><span class=\"line\">/usr/bin/python3 -m pip install --disable-pip-version-check --user  -r tests/flow/requirements.txt</span><br><span class=\"line\">/usr/local/soft/modules/RedisBloom/deps/readies/bin/getaws</span><br><span class=\"line\">/usr/bin/python3 -m pip install --disable-pip-version-check --user  pudb</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 编译</span></span><br><span class=\"line\">make</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">Building /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/t-digest-c/src/libtdigest_static.a ...</span><br><span class=\"line\"></span><br><span class=\"line\">Generating /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/t-digest-c/Makefile ...</span><br><span class=\"line\">-- The C compiler identification is GNU 11.5.0</span><br><span class=\"line\">-- The CXX compiler identification is GNU 11.5.0</span><br><span class=\"line\">-- Detecting C compiler ABI info</span><br><span class=\"line\">-- Detecting C compiler ABI info - <span class=\"keyword\">done</span></span><br><span class=\"line\">-- Check <span class=\"keyword\">for</span> working C compiler: /usr/bin/gcc - skipped</span><br><span class=\"line\">-- Detecting C compile features</span><br><span class=\"line\">-- Detecting C compile features - <span class=\"keyword\">done</span></span><br><span class=\"line\">-- Detecting CXX compiler ABI info</span><br><span class=\"line\">-- Detecting CXX compiler ABI info - <span class=\"keyword\">done</span></span><br><span class=\"line\">-- Check <span class=\"keyword\">for</span> working CXX compiler: /usr/bin/g++ - skipped</span><br><span class=\"line\">-- Detecting CXX compile features</span><br><span class=\"line\">-- Detecting CXX compile features - <span class=\"keyword\">done</span></span><br><span class=\"line\">-- Setting build <span class=\"built_in\">type</span> to <span class=\"string\">&#x27;Release&#x27;</span> as none was specified.</span><br><span class=\"line\">-- Configuring <span class=\"keyword\">done</span></span><br><span class=\"line\">-- Generating <span class=\"keyword\">done</span></span><br><span class=\"line\">-- Build files have been written to: /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/t-digest-c</span><br><span class=\"line\"></span><br><span class=\"line\">Building /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/t-digest-c/libtdigest_static.a ...</span><br><span class=\"line\">[ 50%] Building C object src/CMakeFiles/tdigest_static.dir/tdigest.c.o</span><br><span class=\"line\">[100%] Linking C static library libtdigest_static.a</span><br><span class=\"line\">[100%] Built target tdigest_static</span><br><span class=\"line\">Compiling deps/bloom/bloom.c...</span><br><span class=\"line\">Compiling deps/murmur2/MurmurHash2.c...</span><br><span class=\"line\">Compiling deps/rmutil/util.c...</span><br><span class=\"line\">Compiling src/rebloom.c...</span><br><span class=\"line\">Compiling src/sb.c...</span><br><span class=\"line\">Compiling src/cf.c...</span><br><span class=\"line\">Compiling src/rm_topk.c...</span><br><span class=\"line\">Compiling src/rm_tdigest.c...</span><br><span class=\"line\">Compiling src/topk.c...</span><br><span class=\"line\">Compiling src/rm_cms.c...</span><br><span class=\"line\">Compiling src/cms.c...</span><br><span class=\"line\">Linking /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/redisbloom.so...</span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong><code>./sbin/setup</code> 报错</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">本人使用的是 Amazon Linux 2023(内核 6.1)，即 <code>EL9</code>，相当于CentOS 9，所以第一次运行会报错，大致报错信息如下：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./sbin/setup</span><br><span class=\"line\"><span class=\"comment\">## 错误信息</span></span><br><span class=\"line\">[FAILED] raven-release.el9.noarch.rpm: Status code: 403 <span class=\"keyword\">for</span> https://dyn.su/el9/base/x86_64/raven-release.el9.noarch.rpm (IP: 104.21.57.14)</span><br><span class=\"line\">Status code: 403 <span class=\"keyword\">for</span> https://dyn.su/el9/base/x86_64/raven-release.el9.noarch.rpm (IP: 104.21.57.14)</span><br><span class=\"line\"></span><br><span class=\"line\">In /usr/local/soft/modules/RedisBloom/deps/readies/bin/getepel:</span><br><span class=\"line\">346      \t\t<span class=\"comment\"># xinstall --allowerasing https://dl.fedoraproject.org/pub/epel/epel-release-latest-$&#123;EPEL&#125;.noarch.rpm</span></span><br><span class=\"line\">347      \t<span class=\"keyword\">fi</span></span><br><span class=\"line\">348</span><br><span class=\"line\">349  &gt;&gt;&gt; \tinstall_raven</span><br><span class=\"line\">350      \tinstall_remi</span><br><span class=\"line\">351      \t<span class=\"comment\"># install_centos_stream_repos</span></span><br><span class=\"line\">352</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">command</span> failed: /usr/local/soft/modules/RedisBloom/deps/readies/bin/getepel</span><br><span class=\"line\"></span><br><span class=\"line\">In /usr/local/soft/modules/RedisBloom/sbin/setup:</span><br><span class=\"line\">16       \tpython3 -m pip list</span><br><span class=\"line\">17       <span class=\"keyword\">fi</span></span><br><span class=\"line\">18</span><br><span class=\"line\">19   &gt;&gt;&gt; <span class=\"variable\">$ROOT</span>/sbin/system-setup.py</span><br><span class=\"line\">20       <span class=\"keyword\">if</span> [[ <span class=\"variable\">$VERBOSE</span> == 1 ]]; <span class=\"keyword\">then</span></span><br><span class=\"line\">21       \tpython3 -m pip list</span><br><span class=\"line\">22       <span class=\"keyword\">fi</span> 编译安装时报错</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 错误分析与解决方法</span></span><br><span class=\"line\">问题原因：</span><br><span class=\"line\">    你这个错误不是 RedisBloom 本身的编译问题，而是 依赖环境初始化（readies / getepel）阶段失败，失败点非常明确。</span><br><span class=\"line\">readies/bin/getepel 脚本在 RHEL 9 / Rocky 9 / AlmaLinux 9 系统上尝试安装 Raven Repo，但该仓库地址 https://dyn.su/el9/... 已被 403 Forbidden 拒绝，导致脚本直接失败并中断 setup。</span><br><span class=\"line\">    这不是你机器的问题，而是 RedisBloom 依赖工具链对 EL9 的兼容性滞后。</span><br><span class=\"line\">    RedisBloom 的 ./sbin/setup 会调用 deps/readies/bin/getepel</span><br><span class=\"line\">    这个脚本用于：</span><br><span class=\"line\">        安装 EPEL</span><br><span class=\"line\">        安装 Raven Repo（EL9 特有）</span><br><span class=\"line\">        安装 Remi Repo</span><br><span class=\"line\">    但 Raven Repo 目前已不稳定 / 不再公开提供 rpm 下载，而 readies 代码仍然在强制安装。</span><br><span class=\"line\">    你的系统是 EL9 系列，日志中明确：raven-release.el9.noarch.rpm</span><br><span class=\"line\">    说明你使用的可能是如下系统中的一个：</span><br><span class=\"line\">        RHEL 9</span><br><span class=\"line\">        Rocky Linux 9</span><br><span class=\"line\">        AlmaLinux 9</span><br><span class=\"line\">        CentOS Stream 9</span><br><span class=\"line\"></span><br><span class=\"line\">推荐解决方案:</span><br><span class=\"line\">   直接修改 getepel 脚本，禁用 install_raven</span><br><span class=\"line\">   vi deps/readies/bin/getepel，找到所有 install_raven，并将其注释掉即可</span><br></pre></td></tr></table></figure>\n</div>\n<h2 id=\"Redis-启用模块\">Redis 启用模块</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>将生成的 <a href=\"http://redisbloom.so\">redisbloom.so</a> 拷贝到 redis 的 modules 目录下（非必须）</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cp</span> /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/redisbloom.so /usr/local/soft/redis-7.4.7/modules/redisbloom.so</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis 启用模块有三种方法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.将 redisbloom.so 添加到 redis.conf 中，需要重启 redis</span></span><br><span class=\"line\">loadmodule /usr/local/soft/redis-7.4.7/modules/redisbloom.so</span><br><span class=\"line\"><span class=\"comment\"># 2.也可以通过如下方式加载模块</span></span><br><span class=\"line\">redis-server --loadmodule /usr/local/soft/redis-7.4.7/modules/redisbloom.so</span><br><span class=\"line\"><span class=\"comment\"># 3.不需要重启redis</span></span><br><span class=\"line\">redis-cli MODULE LOAD /usr/local/soft/redis-7.4.7/modules/redisbloom.so</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>加载方式</th>\n<th>是否持久</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>MODULE LOAD</code>（redis-cli）</td>\n<td>❌ 仅当前进程</td>\n</tr>\n<tr>\n<td>命令行 <code>redis-server --loadmodule</code></td>\n<td>❌ 仅本次启动</td>\n</tr>\n<tr>\n<td><code>redis.conf</code> 中 <code>loadmodule</code></td>\n<td>✅ <strong>永久生效</strong> （推荐/生产）</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文采用 <code>loadmodule</code> 加载模块</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将 redisbloom.so 添加到 redis.conf 中，需要重启 redis</span></span><br><span class=\"line\">loadmodule /usr/local/soft/redis-7.4.7/modules/redisbloom.so</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动redis</span></span><br><span class=\"line\">redis-server redis.conf</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 登录测试</span></span><br><span class=\"line\">redis-cli --user admin --pass 123456</span><br><span class=\"line\"><span class=\"comment\"># 查看模块</span></span><br><span class=\"line\">127.0.0.1:6379&gt; info Modules</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\"><span class=\"comment\"># Modules</span></span><br><span class=\"line\">module:name=bf,ver=20817,api=1,filters=0,usedby=[],using=[],options=[handle-io-errors]</span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:6379&gt; MODULE LIST</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;bf&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;ver&quot;</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 20817</span><br><span class=\"line\">   5) <span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;/usr/local/soft/redis-7.4.7/modules/redisbloom.so&quot;</span></span><br><span class=\"line\">   7) <span class=\"string\">&quot;args&quot;</span></span><br><span class=\"line\">   8) (empty array)</span><br></pre></td></tr></table></figure>\n","content_text":"摘要 本文介绍 Redis 扩展模块 – RedisBloom 的使用方法 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ RedisBloom 简介 RedisBloom 是 Redis 官方维护的一个扩展模块，隶属于 Redis Stack，专门用于提供概率型数据结构（Probabilistic Data Structures）的高性能实现。 它通过牺牲一定的精确性，换取极低的内存占用和极高的吞吐能力，非常适合海量数据场景下的“存在性判断”和“近似统计”。 该模块以 Redis Module 方式加载，可无缝集成到现有 Redis 实例中。 Redis8+，RedisBloom 已经内置在 Redis 中，不需要单独安装。 RedisBloom 提供的核心数据结构 1️⃣ Bloom Filter（布隆过滤器） 判断某个元素“可能存在 / 一定不存在”，但不存储元素本身，也不支持删除 维基百科对 Bloom Filter 的描述 生产环境推荐使用 Redisson的布隆过滤器 对应Redis命令： BF.xxx，详细的使用方法参见 Redis 命令及数据类型 -- BF(Bloom Filter) 2️⃣ Cuckoo Filter（布谷鸟过滤器） Bloom Filter 的增强版，支持 删除元素 维基百科对 Cuckoo Filter 的描述 在高 QPS 查询场景下，Cuckoo Filter 通常优于 Bloom Filter。 低误判率 + 高负载率场景，Cuckoo Filter 更省内存。 对应Redis命令： CF.xxx，详细的使用方法参见 Redis 命令及数据类型 -- CF(Cuckoo Filter) 3️⃣ Count-Min Sketch（CMS） 近似统计元素出现频率 对应Redis命令： CMS.xxx 4️⃣ Top-K 统计访问频率最高的 K 个元素 对应Redis命令： TOPK.xxx 安装 RedisBloom 安装时需要科学上网，主要是安装依赖时需要从海外网下载，如果要部署在国内服务器，可能会连接失败。 可以在海外的相同配置的服务器上进行编译，之后将编译好的redisbloom.so上传到国内服务器即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869mkdir -p /usr/local/soft/modules/cd /usr/local/soft/modules# clone 代码，这里 --recursive 是为了拉取子模块git clone --recursive https://github.com/RedisBloom/RedisBloom.gitcd RedisBloom# 推荐切换到稳定的release版本git checkout v2.8.17# 更新子模块，非必须，如果上面 clone 时没有加上 --recursive ，这个步骤就不能省略git submodule update --init --recursive# 检查并安装需要的依赖./sbin/setup## 输出# readies version: 7fc8e62dnf install -q -y ca-certificatesdnf install -q -y wget unzip/usr/local/soft/modules/RedisBloom/deps/readies/bin/enable-utf8dnf install -q -y git jqdnf install -q -y which/usr/local/soft/modules/RedisBloom/deps/readies/bin/getepel/usr/local/soft/modules/RedisBloom/deps/readies/bin/getgcc --moderndnf install -q -y valgrind/usr/local/soft/modules/RedisBloom/sbin/get-fbinferdnf install -q -y lcov/usr/bin/python3 /usr/local/soft/modules/RedisBloom/deps/readies/bin/getrmpytools --reinstall --modern/usr/bin/python3 /usr/local/soft/modules/RedisBloom/deps/readies/bin/getcmake --usr/usr/bin/python3 -m pip install --disable-pip-version-check --user -r tests/flow/requirements.txt/usr/local/soft/modules/RedisBloom/deps/readies/bin/getaws/usr/bin/python3 -m pip install --disable-pip-version-check --user pudb# 编译make# 输出Building /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/t-digest-c/src/libtdigest_static.a ...Generating /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/t-digest-c/Makefile ...-- The C compiler identification is GNU 11.5.0-- The CXX compiler identification is GNU 11.5.0-- Detecting C compiler ABI info-- Detecting C compiler ABI info - done-- Check for working C compiler: /usr/bin/gcc - skipped-- Detecting C compile features-- Detecting C compile features - done-- Detecting CXX compiler ABI info-- Detecting CXX compiler ABI info - done-- Check for working CXX compiler: /usr/bin/g++ - skipped-- Detecting CXX compile features-- Detecting CXX compile features - done-- Setting build type to &#x27;Release&#x27; as none was specified.-- Configuring done-- Generating done-- Build files have been written to: /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/t-digest-cBuilding /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/t-digest-c/libtdigest_static.a ...[ 50%] Building C object src/CMakeFiles/tdigest_static.dir/tdigest.c.o[100%] Linking C static library libtdigest_static.a[100%] Built target tdigest_staticCompiling deps/bloom/bloom.c...Compiling deps/murmur2/MurmurHash2.c...Compiling deps/rmutil/util.c...Compiling src/rebloom.c...Compiling src/sb.c...Compiling src/cf.c...Compiling src/rm_topk.c...Compiling src/rm_tdigest.c...Compiling src/topk.c...Compiling src/rm_cms.c...Compiling src/cms.c...Linking /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/redisbloom.so... ./sbin/setup 报错 本人使用的是 Amazon Linux 2023(内核 6.1)，即 EL9，相当于CentOS 9，所以第一次运行会报错，大致报错信息如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546./sbin/setup## 错误信息[FAILED] raven-release.el9.noarch.rpm: Status code: 403 for https://dyn.su/el9/base/x86_64/raven-release.el9.noarch.rpm (IP: 104.21.57.14)Status code: 403 for https://dyn.su/el9/base/x86_64/raven-release.el9.noarch.rpm (IP: 104.21.57.14)In /usr/local/soft/modules/RedisBloom/deps/readies/bin/getepel:346 # xinstall --allowerasing https://dl.fedoraproject.org/pub/epel/epel-release-latest-$&#123;EPEL&#125;.noarch.rpm347 fi348349 &gt;&gt;&gt; install_raven350 install_remi351 # install_centos_stream_repos352command failed: /usr/local/soft/modules/RedisBloom/deps/readies/bin/getepelIn /usr/local/soft/modules/RedisBloom/sbin/setup:16 python3 -m pip list17 fi1819 &gt;&gt;&gt; $ROOT/sbin/system-setup.py20 if [[ $VERBOSE == 1 ]]; then21 python3 -m pip list22 fi 编译安装时报错## 错误分析与解决方法问题原因： 你这个错误不是 RedisBloom 本身的编译问题，而是 依赖环境初始化（readies / getepel）阶段失败，失败点非常明确。readies/bin/getepel 脚本在 RHEL 9 / Rocky 9 / AlmaLinux 9 系统上尝试安装 Raven Repo，但该仓库地址 https://dyn.su/el9/... 已被 403 Forbidden 拒绝，导致脚本直接失败并中断 setup。 这不是你机器的问题，而是 RedisBloom 依赖工具链对 EL9 的兼容性滞后。 RedisBloom 的 ./sbin/setup 会调用 deps/readies/bin/getepel 这个脚本用于： 安装 EPEL 安装 Raven Repo（EL9 特有） 安装 Remi Repo 但 Raven Repo 目前已不稳定 / 不再公开提供 rpm 下载，而 readies 代码仍然在强制安装。 你的系统是 EL9 系列，日志中明确：raven-release.el9.noarch.rpm 说明你使用的可能是如下系统中的一个： RHEL 9 Rocky Linux 9 AlmaLinux 9 CentOS Stream 9推荐解决方案: 直接修改 getepel 脚本，禁用 install_raven vi deps/readies/bin/getepel，找到所有 install_raven，并将其注释掉即可 Redis 启用模块 将生成的 redisbloom.so 拷贝到 redis 的 modules 目录下（非必须） 1cp /usr/local/soft/modules/RedisBloom/bin/linux-x64-release/redisbloom.so /usr/local/soft/redis-7.4.7/modules/redisbloom.so Redis 启用模块有三种方法 123456# 1.将 redisbloom.so 添加到 redis.conf 中，需要重启 redisloadmodule /usr/local/soft/redis-7.4.7/modules/redisbloom.so# 2.也可以通过如下方式加载模块redis-server --loadmodule /usr/local/soft/redis-7.4.7/modules/redisbloom.so# 3.不需要重启redisredis-cli MODULE LOAD /usr/local/soft/redis-7.4.7/modules/redisbloom.so 加载方式 是否持久 MODULE LOAD（redis-cli） ❌ 仅当前进程 命令行 redis-server --loadmodule ❌ 仅本次启动 redis.conf 中 loadmodule ✅ 永久生效 （推荐/生产） 本文采用 loadmodule 加载模块 123456789101112131415161718192021222324# 将 redisbloom.so 添加到 redis.conf 中，需要重启 redisloadmodule /usr/local/soft/redis-7.4.7/modules/redisbloom.so# 启动redisredis-server redis.conf# 登录测试redis-cli --user admin --pass 123456# 查看模块127.0.0.1:6379&gt; info Modules## 输出# Modulesmodule:name=bf,ver=20817,api=1,filters=0,usedby=[],using=[],options=[handle-io-errors]127.0.0.1:6379&gt; MODULE LIST# 输出1) 1) &quot;name&quot; 2) &quot;bf&quot; 3) &quot;ver&quot; 4) (integer) 20817 5) &quot;path&quot; 6) &quot;/usr/local/soft/redis-7.4.7/modules/redisbloom.so&quot; 7) &quot;args&quot; 8) (empty array)","summary":"摘要 本文介绍 Redis 扩展模块 – RedisBloom 的使用方法 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2025-12-21T13:30:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/20/redis7-datatype-10-stream/","url":"https://blog.hanqunfeng.com/2025/12/20/redis7-datatype-10-stream/","title":"Redis 命令及数据类型 -- Stream","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis Stream 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Stream-核心详解\">Stream 核心详解</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis Stream 是 Redis 5.0 新增的有序、可持久化、支持多播的<code>消息队列</code>，底层用<code>基数树+链表</code>实现，兼顾了高效查询与有序写入，完美解决了 List 队列（无法多播、无持久化保障）、Pub/Sub（无持久化、丢消息）的痛点，是生产环境首选的 Redis 消息队列方案。</p>\n</li>\n<li class=\"lvl-2\">\n<p>建议生产环境还是使用传统的 MQ 方案，如果仅是内部系统使用的轻量MQ，已经有了redis，但是不想引入其它中间件，也可以尝试。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Stream 与传统的MQ 的对比</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>对比维度</th>\n<th>Redis Stream</th>\n<th>RabbitMQ</th>\n<th>Kafka</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>数据模型</strong></td>\n<td>类似日志的有序 KV 消息流（ID → field/value）</td>\n<td>队列（FIFO）</td>\n<td>日志分区（Partitioned Append-Only Log）</td>\n</tr>\n<tr>\n<td><strong>消息持久化</strong></td>\n<td>可选持久化（AOF / RDB），默认内存优先</td>\n<td>可持久化到磁盘</td>\n<td>持久化到磁盘，顺序写入，效率高</td>\n</tr>\n<tr>\n<td><strong>消息确认</strong></td>\n<td>XACK 对单条消息确认，支持 Pending 消息管理</td>\n<td>ACK / NACK</td>\n<td>Offset 控制，Consumer 自行提交</td>\n</tr>\n<tr>\n<td><strong>消费模式</strong></td>\n<td>支持 Consumer Group，多消费者共享 Pending 消息</td>\n<td>Queue 绑定 Consumer，多消费者抢占</td>\n<td>Consumer Group，多消费者平行消费</td>\n</tr>\n<tr>\n<td><strong>重复消费</strong></td>\n<td>默认可能重复，需要应用端幂等</td>\n<td>可通过 ACK/NACK 控制</td>\n<td>默认可能重复，Consumer 需幂等处理</td>\n</tr>\n<tr>\n<td><strong>消息顺序</strong></td>\n<td>按 Stream ID 顺序，可保证分组内顺序</td>\n<td>队列顺序保证</td>\n<td>Partition 内顺序保证</td>\n</tr>\n<tr>\n<td><strong>消息保留策略</strong></td>\n<td>可配置 maxlen / minid，按时间或长度裁剪</td>\n<td>队列长度 / TTL 控制</td>\n<td>基于时间或大小保留（Retention Policy）</td>\n</tr>\n<tr>\n<td><strong>延时/定时消费</strong></td>\n<td>原生不支持延时队列，需要应用端处理</td>\n<td>支持插件或 TTL</td>\n<td>原生不支持，需要应用端处理或 Kafka Streams</td>\n</tr>\n<tr>\n<td><strong>事务与原子操作</strong></td>\n<td>事务可用 MULTI/EXEC，XADD 支持 NOMKSTREAM 等选项</td>\n<td>原生事务支持（事务 / confirm 模式）</td>\n<td>不支持事务，依赖幂等生产者</td>\n</tr>\n<tr>\n<td><strong>性能</strong></td>\n<td>内存级高吞吐，持久化会有开销</td>\n<td>中等，受磁盘和网络限制</td>\n<td>高吞吐，顺序写入磁盘效率极高</td>\n</tr>\n<tr>\n<td><strong>典型使用场景</strong></td>\n<td>事件日志、轻量 MQ、内部异步流水线</td>\n<td>企业级消息、任务调度、RPC</td>\n<td>大数据管道、日志收集、流处理</td>\n</tr>\n<tr>\n<td><strong>多语言支持</strong></td>\n<td>客户端支持多种语言（Java、Python、Go 等）</td>\n<td>客户端丰富</td>\n<td>客户端丰富</td>\n</tr>\n<tr>\n<td><strong>易运维性</strong></td>\n<td>单节点即可使用，但持久化需关注内存</td>\n<td>集群较复杂，需要 RabbitMQ 集群</td>\n<td>集群复杂度高，需要 ZooKeeper 或 KRaft</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"底层核心实现\">底层核心实现</h3>\n<ol>\n<li class=\"lvl-3\">\n<p>存储结构：核心是基数树（Radix Tree）+ 双向链表，基数树存「消息ID→消息内容」的映射，双向链表按消息ID有序串联所有消息，保证写入和按ID查询的高效性（O(logN)）。</p>\n</li>\n<li class=\"lvl-3\">\n<p>消息ID：默认自动生成，格式为时间戳-序列号（如1734567890000-0），时间戳是毫秒级，序列号解决同一毫秒多消息的有序问题；也支持手动指定，需满足严格递增，否则写入失败。</p>\n</li>\n<li class=\"lvl-3\">\n<p>持久化：和 Redis 其他数据结构一致，依赖 RDB/AOF 持久化，消息写入后会落盘，重启后不丢失，这是 Pub/Sub 不具备的核心优势。</p>\n</li>\n<li class=\"lvl-3\">\n<p>核心元数据：每个 Stream 会维护last-id（最新消息ID）、groups（消费组列表）、entries（消息实体）三类元数据，消费组的元数据独立存储，互不干扰。</p>\n</li>\n</ol>\n<h2 id=\"Stream-核心基础操作（必用）\">Stream 核心基础操作（必用）</h2>\n<h3 id=\"1-生产消息（XADD）：写入队列\">1. 生产消息（XADD）：写入队列</h3>\n<p>• 核心命令：<code>XADD key ID 字段1 值1 字段2 值2 ...</code>，ID 写*表示自动生成（生产首选）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XADD key</span><br><span class=\"line\">     [NOMKSTREAM]</span><br><span class=\"line\">     [MAXLEN | MINID [= | ~] threshold [LIMIT count]]</span><br><span class=\"line\">     * | <span class=\"built_in\">id</span></span><br><span class=\"line\">     field value [field value ...]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 参数解释</span></span><br><span class=\"line\"><span class=\"comment\"># key: Stream 名称</span></span><br><span class=\"line\"><span class=\"comment\"># NOMKSTREAM: 不自动创建 Stream，若 key 不存在 → 命令直接失败</span></span><br><span class=\"line\"><span class=\"comment\"># MAXLEN threshold —— 按长度裁剪</span></span><br><span class=\"line\"><span class=\"comment\">#   MAXLEN 1000: Stream 最多保留 1000 条消息，超出部分会被删除（从最旧开始）</span></span><br><span class=\"line\"><span class=\"comment\">#   MAXLEN = 1000: 精确裁剪，严格保证长度 ≤ 1000，每次写入都会检查并裁剪，性能开销较大</span></span><br><span class=\"line\"><span class=\"comment\">#   MAXLEN ~ 1000（推荐）: 近似裁剪，允许 Stream 长度 略微超过阈值，Redis 在内部批量裁剪，写入性能更高</span></span><br><span class=\"line\"><span class=\"comment\"># LIMIT count —— 每次最多裁剪多少条</span></span><br><span class=\"line\"><span class=\"comment\">#   MAXLEN ~ 1000 LIMIT 100: 单次写入 最多删除 100 条旧消息，防止一次裁剪阻塞 Redis 主线程</span></span><br><span class=\"line\"><span class=\"comment\"># MINID threshold —— 按 ID 裁剪（Redis ≥ 6.2）</span></span><br><span class=\"line\"><span class=\"comment\">#   MINID ~ 1670000000000-0: 删除 ID 小于 threshold 的消息，更适合 时间窗口型保留策略</span></span><br><span class=\"line\"><span class=\"comment\"># * | id —— 消息 ID</span></span><br><span class=\"line\"><span class=\"comment\">#   *: 自动生成 ID（99% 场景），格式：&lt;毫秒时间戳&gt;-&lt;序号&gt;，单调递增，全局有序，消费者组依赖它进行 offset 管理</span></span><br><span class=\"line\"><span class=\"comment\">#   id: 指定ID（不常用），ID 必须严格大于 Stream 中最大 ID，否则写入失败</span></span><br><span class=\"line\"><span class=\"comment\"># field value —— 消息体（Payload）</span></span><br><span class=\"line\"><span class=\"comment\">#   至少一对 field-value，field / value 都是 Binary Safe，本质类似 Hash，但不可修改</span></span><br></pre></td></tr></table></figure>\n<p>• 示例</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 向订单队列写入1条消息，自动生成消息ID</span></span><br><span class=\"line\">XADD order_stream * uid 1001 order_no ORD20251220 price 299</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\"><span class=\"string\">&quot;1766215406540-0&quot;</span> <span class=\"comment\"># 消息ID</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 保留某个时间点之后的日志</span></span><br><span class=\"line\">XADD <span class=\"built_in\">log</span> MINID ~ 1689900000000-0 * level INFO msg <span class=\"string\">&quot;startup&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-消费消息（2种核心模式）\">2. 消费消息（2种核心模式）</h3>\n<h4 id=\"（1）-独立消费（无消费组）：一对一消费，适合简单场景\">（1） 独立消费（无消费组）：一对一消费，适合简单场景</h4>\n<p>• XREAD：主动拉取消息，支持阻塞/非阻塞</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XREAD</span><br><span class=\"line\">  [COUNT count]</span><br><span class=\"line\">  [BLOCK milliseconds]</span><br><span class=\"line\">  STREAMS key [key ...]</span><br><span class=\"line\">          <span class=\"built_in\">id</span>  [<span class=\"built_in\">id</span>  ...]</span><br><span class=\"line\"><span class=\"comment\"># 参数解释</span></span><br><span class=\"line\"><span class=\"comment\"># COUNT count —— 单次最多读取多少条，是“上限”，不是保证值</span></span><br><span class=\"line\"><span class=\"comment\"># BLOCK milliseconds —— 阻塞等待新消息，阻塞期间 不会占用 CPU，超时返回 nil</span></span><br><span class=\"line\"><span class=\"comment\">#   BLOCK 0: 无限阻塞，直到有新消息</span></span><br><span class=\"line\"><span class=\"comment\"># STREAMS key [key ...] —— 指定读取的 Stream，key 与 id 一一对应</span></span><br><span class=\"line\"><span class=\"comment\"># id [id ...] —— 从哪个位置开始读，读取 ID 大于该值的消息，不包含 该 ID 本身</span></span><br><span class=\"line\"><span class=\"comment\">#   普通 ID（游标语义）: XREAD STREAMS mystream 1689999999999-0</span></span><br><span class=\"line\"><span class=\"comment\">#   $: 只关心“将来”的消息，从 当前 Stream 的末尾之后 开始读，历史消息全部忽略: XREAD BLOCK 0 STREAMS mystream $</span></span><br></pre></td></tr></table></figure>\n<p>• 示例1（非阻塞）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 从开头拉5条消息</span></span><br><span class=\"line\">XREAD COUNT 5 STREAMS order_stream 0-0</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;order_stream&quot;</span>          <span class=\"comment\"># Stream名称</span></span><br><span class=\"line\">   2) 1) 1) <span class=\"string\">&quot;1766215406540-0&quot;</span> <span class=\"comment\"># 消息ID</span></span><br><span class=\"line\">         2) 1) <span class=\"string\">&quot;uid&quot;</span>          <span class=\"comment\"># 消息体 键值对</span></span><br><span class=\"line\">            2) <span class=\"string\">&quot;1001&quot;</span></span><br><span class=\"line\">            3) <span class=\"string\">&quot;order_no&quot;</span></span><br><span class=\"line\">            4) <span class=\"string\">&quot;ORD20251220&quot;</span></span><br><span class=\"line\">            5) <span class=\"string\">&quot;price&quot;</span></span><br><span class=\"line\">            6) <span class=\"string\">&quot;299&quot;</span></span><br></pre></td></tr></table></figure>\n<p>• 示例2（阻塞）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># $表示从最新消息开始拉，阻塞3秒，有新消息立即返回，无则3秒后超时，是生产常用写法。</span></span><br><span class=\"line\">XREAD COUNT 5 BLOCK 3000 STREAMS order_stream $</span><br></pre></td></tr></table></figure>\n<h4 id=\"（2）-消费组消费（XGROUP）：一对多消费，核心生产模式\">（2） 消费组消费（XGROUP）：一对多消费，核心生产模式</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Stream 最核心的价值就是消费组，支持多消费者协同消费、消息确认、未消费消息追溯，解决了分布式场景下的消息分片与负载均衡问题。</p>\n</li>\n<li class=\"lvl-2\">\n<ol>\n<li class=\"lvl-5\">先创建消费组<code>XGROUP CREATE</code></li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XGROUP CREATE key group <span class=\"built_in\">id</span>|$</span><br><span class=\"line\">       [MKSTREAM]</span><br><span class=\"line\">       [ENTRIESREAD entries-read]</span><br><span class=\"line\"><span class=\"comment\"># 参数解释</span></span><br><span class=\"line\"><span class=\"comment\"># key：Stream 名称，为指定的Stream创建消费组</span></span><br><span class=\"line\"><span class=\"comment\"># group: 消费组名称，消费者组的唯一标识，一个 Stream 可以有 多个 consumer group</span></span><br><span class=\"line\"><span class=\"comment\"># id | $ —— 关键参数：消费起始位点（offset），$表示从当前最新消息开始消费，用0-0表示从队列开头消费。</span></span><br><span class=\"line\"><span class=\"comment\"># [MKSTREAM] —— 自动创建 Stream，如果指定的key不存在则自动创建，推荐在自动化部署中使用</span></span><br><span class=\"line\"><span class=\"comment\"># [ENTRIESREAD entries-read] —— 设置“已读取条数”（高级参数），一般业务不需要使用，主要用于手动恢复group、数据迁移等场景</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例：创建group1消费组，从最新订单消息开始消费</span></span><br><span class=\"line\">XGROUP CREATE order_stream group1 $ MKSTREAM</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>消费者拉取消息<code>XREADGROUP</code></p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XREADGROUP GROUP group consumer</span><br><span class=\"line\">           [COUNT count]</span><br><span class=\"line\">           [BLOCK milliseconds]</span><br><span class=\"line\">           [NOACK]</span><br><span class=\"line\">           STREAMS key [key ...]</span><br><span class=\"line\">                   <span class=\"built_in\">id</span>  [<span class=\"built_in\">id</span>  ...]</span><br><span class=\"line\"><span class=\"comment\"># 参数解释</span></span><br><span class=\"line\"><span class=\"comment\"># GROUP group consumer: 指定消费者组名：group，消费者名：consumer</span></span><br><span class=\"line\"><span class=\"comment\">#    同一个 group 下，不同 consumer 不会收到重复消息</span></span><br><span class=\"line\"><span class=\"comment\"># [COUNT count] —— 单次最多返回条数，是软限制，不是严格保证</span></span><br><span class=\"line\"><span class=\"comment\"># [BLOCK milliseconds] —— 阻塞等待新消息，最多阻塞 milliseconds 毫秒</span></span><br><span class=\"line\"><span class=\"comment\">#    BLOCK 0 → 永久阻塞</span></span><br><span class=\"line\"><span class=\"comment\"># [NOACK] —— 不进入 Pending（⚠️ 谨慎）</span></span><br><span class=\"line\"><span class=\"comment\">#    消息 不会进入 Pending，不需要 XACK，消费后即认为完成</span></span><br><span class=\"line\"><span class=\"comment\">#    风险：消费者崩溃 → 消息直接丢失，不可重投递</span></span><br><span class=\"line\"><span class=\"comment\"># STREAMS key [key ...]: 指定要读取的 Stream（支持多个），key 顺序需与后续 id 顺序一致</span></span><br><span class=\"line\"><span class=\"comment\"># id [id ...] —— 决定“读什么”的关键</span></span><br><span class=\"line\"><span class=\"comment\">#    使用 &gt; —— 读取“新消息”（✅ 生产环境 99% 使用这种方式），从未投递给任何 consumer 的新消息</span></span><br><span class=\"line\"><span class=\"comment\">#    使用 0/具体ID —— 重读 Pending（补偿），读取 已投递但未 ACK 的消息</span></span><br><span class=\"line\"><span class=\"comment\">#    多 Stream 场景: STREAMS stream1 stream2 &gt; &gt;，每个 stream 必须有一个对应 id</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例：consumerA 从group1拉3条未被消费的消息，阻塞5秒。</span></span><br><span class=\"line\">XREADGROUP GROUP group1 consumerA COUNT 3 BLOCK 5000 STREAMS order_stream &gt;</span><br><span class=\"line\"><span class=\"comment\">## 此时在5秒内创建新的消息，就会有类似如下输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;order_stream&quot;</span></span><br><span class=\"line\">   2) 1) 1) <span class=\"string\">&quot;1766215642763-0&quot;</span></span><br><span class=\"line\">         2) 1) <span class=\"string\">&quot;uid&quot;</span></span><br><span class=\"line\">            2) <span class=\"string\">&quot;1001&quot;</span></span><br><span class=\"line\">            3) <span class=\"string\">&quot;order_no&quot;</span></span><br><span class=\"line\">            4) <span class=\"string\">&quot;ORD20251220&quot;</span></span><br><span class=\"line\">            5) <span class=\"string\">&quot;price&quot;</span></span><br><span class=\"line\">            6) <span class=\"string\">&quot;299&quot;</span></span><br><span class=\"line\">(1.50s)</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-消息确认（XACK）\">3. 消息确认（XACK）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>消费完成后必须确认，否则会被标记为「未确认消息」</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># XACK key 消费组名 消息ID1 消息ID2 ...。</span></span><br><span class=\"line\">XACK key group <span class=\"built_in\">id</span> [<span class=\"built_in\">id</span> ...]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例: 确认2条消息消费完成，Stream 会删除该消息的未确认标记</span></span><br><span class=\"line\">XACK order_stream group1 1734567890000-0 1734567890001-0</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-消息重试\">4. 消息重试</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>未确认的消息，会被存入消费组的<code>「PEL（Pending Entries List）」</code>，可通过<code>XPENDING key 消费组名</code>查看，支持<code>XCLAIM</code>将<code>PEL</code>中的消息转移给其他消费者处理，避免单点故障导致消息堆积。</p>\n</li>\n<li class=\"lvl-2\">\n<p>XPENDING：查看未被确认的消息情况</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XPENDING key group</span><br><span class=\"line\">        [[IDLE min-idle-time]</span><br><span class=\"line\">         start end count</span><br><span class=\"line\">         [consumer]]</span><br><span class=\"line\"><span class=\"comment\"># 参数解释</span></span><br><span class=\"line\"><span class=\"comment\"># key: Stream 名称，必须存在</span></span><br><span class=\"line\"><span class=\"comment\"># group: 消费者组名称，必须存在</span></span><br><span class=\"line\"><span class=\"comment\"># [IDLE min-idle-time]（Redis ≥ 6.2）: 仅返回 空闲时间 ≥ min-idle-time（毫秒） 的 Pending 消息</span></span><br><span class=\"line\"><span class=\"comment\">#    min-idle-time(空闲时间) = 从上次投递 / claim到现在</span></span><br><span class=\"line\"><span class=\"comment\"># start end —— ID 范围</span></span><br><span class=\"line\"><span class=\"comment\">#    -: 最小ID</span></span><br><span class=\"line\"><span class=\"comment\">#    +: 最大ID</span></span><br><span class=\"line\"><span class=\"comment\"># count —— 返回条数上限</span></span><br><span class=\"line\"><span class=\"comment\"># [consumer]（可选）: 只查看某一个 consumer 的 Pending，不指定则查看 group 内全部</span></span><br><span class=\"line\"><span class=\"comment\"># 只返回 元数据，不返回消息内容</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例1: 查看是否有消息积压</span></span><br><span class=\"line\">XPENDING order_stream group1</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 1      <span class=\"comment\"># 积压消息数，未确认消息数量</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;1766215642763-0&quot;</span> <span class=\"comment\"># Pending 中最小 ID</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;1766215642763-0&quot;</span> <span class=\"comment\"># Pending 中最大 ID</span></span><br><span class=\"line\">4) 1) 1) <span class=\"string\">&quot;consumerA&quot;</span> <span class=\"comment\"># 按 consumer 统计的 Pending 数量</span></span><br><span class=\"line\">      2) <span class=\"string\">&quot;1&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例2: 查找 idle 超过 1 分钟的消息，最多返回10条</span></span><br><span class=\"line\">XPENDING order_stream group1 IDLE 60000 - + 10</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;1766215642763-0&quot;</span> <span class=\"comment\"># 消息 ID</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;consumerA&quot;</span>       <span class=\"comment\"># 当前持有该消息的 consumer</span></span><br><span class=\"line\">   3) (<span class=\"built_in\">integer</span>) 255581  <span class=\"comment\"># idle 时间（毫秒）</span></span><br><span class=\"line\">   4) (<span class=\"built_in\">integer</span>) 2       <span class=\"comment\"># delivery count（投递次数）,该消息至少被投递过 2 次</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例3: 只查看 consumerA 的 Pending，最多返回20条</span></span><br><span class=\"line\">XPENDING order_stream group1 - + 20 consumerA</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>XCLAIM: 转移投递</p>\n</li>\n</ul>\n<blockquote>\n<p>将已经投递但未 ACK、且 idle 超过阈值的 Pending 消息，从原 consumer 手中“抢占”给新的 consumer，并重新投递。<br>\n一旦抢占成功，原 consumer 就不在拥有该消息的 Pending 记录</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XCLAIM key group consumer min-idle-time <span class=\"built_in\">id</span> [<span class=\"built_in\">id</span> ...]</span><br><span class=\"line\">       [IDLE ms]</span><br><span class=\"line\">       [TIME unix-time-milliseconds]</span><br><span class=\"line\">       [RETRYCOUNT count]</span><br><span class=\"line\">       [FORCE]</span><br><span class=\"line\">       [JUSTID]</span><br><span class=\"line\">       [LASTID lastid]</span><br><span class=\"line\"><span class=\"comment\"># 参数解释</span></span><br><span class=\"line\"><span class=\"comment\"># key: Stream Key，必须存在</span></span><br><span class=\"line\"><span class=\"comment\"># group: 消费者组名称，必须存在</span></span><br><span class=\"line\"><span class=\"comment\"># consumer: 新的消费者，抢占后的 Pending 消息将归属该 consumer</span></span><br><span class=\"line\"><span class=\"comment\"># min-idle-time: 空闲时间，只有 idle ≥ min-idle-time 的 Pending 消息才允许被 claim</span></span><br><span class=\"line\"><span class=\"comment\"># id [id ...]: 指定要 claim 的消息 ID，ID必须存在</span></span><br><span class=\"line\"><span class=\"comment\"># [IDLE ms]: 人为设置 idle 时间，覆盖 Redis 内部计算的 idle，比如强制制造“已超时”状态</span></span><br><span class=\"line\"><span class=\"comment\"># [TIME unix-time-milliseconds]: 手动指定“最后投递时间”，与 IDLE 二选一使用，极少见于业务代码</span></span><br><span class=\"line\"><span class=\"comment\"># [RETRYCOUNT count]: 手动设置 delivery count，实现“最多重试 N 次，超过进死信队列”</span></span><br><span class=\"line\"><span class=\"comment\"># [FORCE]: 强制 claim 不存在于 Pending 的消息，⚠️ 高风险</span></span><br><span class=\"line\"><span class=\"comment\"># [JUSTID]: 只返回 消息 ID，不返回消息体（field/value），减少网络开销</span></span><br><span class=\"line\"><span class=\"comment\"># [LASTID lastid]（Redis ≥ 7.0）: 更新 consumer group 的 last-delivered-id，影响后续 XREADGROUP &gt; 的行为</span></span><br><span class=\"line\"><span class=\"comment\">#    ⚠️ 高级特性，一般不建议业务代码使用</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例：</span></span><br><span class=\"line\"><span class=\"comment\"># 1️⃣ 抢占 idle 超过 60s 的消息</span></span><br><span class=\"line\">XCLAIM order_stream group1 consumerB 60000 1766215642763-0</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;1766215642763-0&quot;</span></span><br><span class=\"line\">   2) 1) <span class=\"string\">&quot;uid&quot;</span></span><br><span class=\"line\">      2) <span class=\"string\">&quot;1001&quot;</span></span><br><span class=\"line\">      3) <span class=\"string\">&quot;order_no&quot;</span></span><br><span class=\"line\">      4) <span class=\"string\">&quot;ORD20251220&quot;</span></span><br><span class=\"line\">      5) <span class=\"string\">&quot;price&quot;</span></span><br><span class=\"line\">      6) <span class=\"string\">&quot;299&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2️⃣ 抢占并标记为第 3 次重试</span></span><br><span class=\"line\">XCLAIM orders order-group consumerB 60000 1766215642763-0 RETRYCOUNT 3</span><br><span class=\"line\"><span class=\"comment\"># 3️⃣ 只返回 ID（配合批处理）</span></span><br><span class=\"line\">XCLAIM orders order-group consumerB 60000 1766215642763-0 JUSTID</span><br></pre></td></tr></table></figure>\n<h2 id=\"高级特性（生产必备）\">高级特性（生产必备）</h2>\n<ol>\n<li class=\"lvl-3\">\n<p>消息回溯与遍历</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># XRANGE key 起始ID 结束ID [COUNT 条数]（正向遍历）</span></span><br><span class=\"line\">XRANGE key start end [COUNT count]</span><br><span class=\"line\"><span class=\"comment\"># XREVRANGE key 结束ID 起始ID [COUNT 条数]（反向遍历）</span></span><br><span class=\"line\">XREVRANGE key end start [COUNT count]</span><br><span class=\"line\"><span class=\"comment\"># 示例: 0-0:最小的消息ID，等同于 -，+:表示最新消息，适合数据对账、历史消息查询。</span></span><br><span class=\"line\">XRANGE order_stream 0-0 + COUNT 10</span><br><span class=\"line\">XRANGE order_stream - + COUNT 10</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>队列信息查询</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查消息总数</span></span><br><span class=\"line\">XLEN key</span><br><span class=\"line\"><span class=\"comment\"># 查Stream完整元数据（最新ID、消费组数量、消息总数等）</span></span><br><span class=\"line\"></span><br><span class=\"line\">XINFO STREAM key [FULL [COUNT count]]</span><br><span class=\"line\"><span class=\"comment\">## FULL: 完整模式</span></span><br><span class=\"line\">    <span class=\"comment\"># 👉 返回：</span></span><br><span class=\"line\">    <span class=\"comment\">#     Stream 元信息</span></span><br><span class=\"line\">    <span class=\"comment\">#     所有 Consumer Group</span></span><br><span class=\"line\">    <span class=\"comment\">#     每个 Group 的 Consumer</span></span><br><span class=\"line\">    <span class=\"comment\">#     Pending Entries List（PEL）</span></span><br><span class=\"line\">    <span class=\"comment\">#     部分历史 entries</span></span><br><span class=\"line\">    <span class=\"comment\"># ⚠️ 开销很大，慎用于生产环境。</span></span><br><span class=\"line\"><span class=\"comment\">## COUNT count（FULL 模式的限制参数）</span></span><br><span class=\"line\">    <span class=\"comment\">#   XINFO STREAM key FULL COUNT 10: 限制返回的entries 数量以及每个 group / consumer 的 PEL 记录数量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查所有消费组信息</span></span><br><span class=\"line\">XINFO GROUPS key</span><br><span class=\"line\"><span class=\"comment\"># 查该组下所有消费者</span></span><br><span class=\"line\">XINFO CONSUMERS key 消费组名</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li class=\"lvl-3\">\n<p>消费组管理</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除消费组</span></span><br><span class=\"line\">XGROUP DESTROY key 消费组名</span><br><span class=\"line\"><span class=\"comment\"># 删除消费者</span></span><br><span class=\"line\">XGROUP DELCONSUMER key 消费组名 消费者名</span><br><span class=\"line\"><span class=\"comment\"># 重置消费组起始ID</span></span><br><span class=\"line\">XGROUP SETID key 消费组名 新ID</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li class=\"lvl-3\">\n<p>惰性删除：Stream 不会主动删除已确认的消息，仅靠MAXLEN淘汰，若需主动清理历史消息，直接用XADD的MAXLEN参数即可，无需额外命令。</p>\n</li>\n</ol>\n<h2 id=\"生产环境核心痛点与解决方案\">生产环境核心痛点与解决方案</h2>\n<ol>\n<li class=\"lvl-3\">\n<p>消息丢失：3重保障</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">开启 Redis AOF 持久化（设为everysec，兼顾性能与可靠性）</li>\n<li class=\"lvl-6\">生产者写入后确认返回值（确保写入成功）</li>\n<li class=\"lvl-6\">消费者消费后必须<code>XACK</code>确认。</li>\n</ul>\n</li>\n<li class=\"lvl-3\">\n<p>消息堆积：2种处理</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">① 写入时用<code>MAXLEN</code>设置上限，淘汰旧消息；</li>\n<li class=\"lvl-6\">② 消费端扩容消费者实例，消费组会自动将未消费消息分片给多个消费者，实现并行消费。</li>\n</ul>\n</li>\n<li class=\"lvl-3\">\n<p>重复消费</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">根源: 网络抖动（消费者确认消息前断开连接，消息重回PEL）</li>\n<li class=\"lvl-6\">解决方案: 消息幂等性（生产者给消息加唯一标识，消费者根据唯一标识去重）。</li>\n</ul>\n</li>\n<li class=\"lvl-3\">\n<p>阻塞超时：消费端用BLOCK阻塞拉取，超时时间建议设为3-5秒，避免频繁空轮询占用CPU，同时保证新消息的响应速度。</p>\n</li>\n</ol>\n<h2 id=\"典型应用场景\">典型应用场景</h2>\n<h3 id=\"分布式业务解耦（订单-库存-支付-物流解耦）\">分布式业务解耦（订单-库存-支付-物流解耦）</h3>\n<blockquote>\n<p>核心思路：单 Stream 对应核心业务（订单），库存、支付、物流各创建独立消费组，各自消费互不干扰，实现业务解耦。</p>\n</blockquote>\n<ol>\n<li class=\"lvl-3\">\n<p>生产者（订单服务）：写入订单完成消息</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 自动生成消息ID，写入订单核心信息，设置队列最大1万条消息（近似淘汰）</span></span><br><span class=\"line\">XADD order_core_stream * MAXLEN ~ 10000 order_no ORD20251220001 uid 1001 amount 299 status created create_time 1734567890</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>创建3个独立消费组（库存/支付/物流）</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 库存消费组：从最新消息开始消费，队列不存在则自动创建</span></span><br><span class=\"line\">XGROUP CREATE order_core_stream group_stock $ MKSTREAM</span><br><span class=\"line\"><span class=\"comment\"># 支付消费组</span></span><br><span class=\"line\">XGROUP CREATE order_core_stream group_pay $ MKSTREAM</span><br><span class=\"line\"><span class=\"comment\"># 物流消费组</span></span><br><span class=\"line\">XGROUP CREATE order_core_stream group_logistics $ MKSTREAM</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li class=\"lvl-3\">\n<p>各消费组消费者拉取+确认消息</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 库存服务消费者（consumer_stock1）拉取3条未消费消息，阻塞5秒</span></span><br><span class=\"line\">XREADGROUP GROUP group_stock consumer_stock1 COUNT 3 BLOCK 5000 STREAMS order_core_stream &gt;</span><br><span class=\"line\"><span class=\"comment\"># 库存处理完成后确认消息（替换为实际拉取到的消息ID）</span></span><br><span class=\"line\">XACK order_core_stream group_stock 1734567890000-0 1734567890001-0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 支付服务消费者（consumer_pay1）同理</span></span><br><span class=\"line\">XREADGROUP GROUP group_pay consumer_pay1 COUNT 3 BLOCK 5000 STREAMS order_core_stream &gt;</span><br><span class=\"line\">XACK order_core_stream group_pay 1734567890000-0 1734567890001-0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 物流服务消费者（consumer_log1）同理</span></span><br><span class=\"line\">XREADGROUP GROUP group_logistics consumer_log1 COUNT 3 BLOCK 5000 STREAMS order_core_stream &gt;</span><br><span class=\"line\">XACK order_core_stream group_logistics 1734567890000-0 1734567890001-0</span><br></pre></td></tr></table></figure>\n<h3 id=\"异步任务处理（用户注册-邮件-短信-积分异步执行）\">异步任务处理（用户注册-邮件/短信/积分异步执行）</h3>\n<blockquote>\n<p>核心思路：注册接口只负责写入 Stream 消息，无需等待后续任务完成，单消费组多消费者提升异步任务处理效率，核心是快速响应前端。</p>\n</blockquote>\n<ol>\n<li class=\"lvl-3\">\n<p>生产者（注册服务）：用户注册成功后写入消息</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 写入用户注册信息，MAXLEN限制5000条，避免积压过多无效注册消息</span></span><br><span class=\"line\">XADD user_register_stream * MAXLEN ~ 5000 uid 1001 username zhangsan phone 13800138000 email zs@xxx.com reg_time 1734567900</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>创建单个消费组（统一处理注册后续任务）</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XGROUP CREATE user_register_stream group_reg_task $ MKSTREAM</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li class=\"lvl-3\">\n<p>多消费者并行拉取（邮件/短信/积分各1个消费者，或多实例扩容）</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 短信发送消费者（consumer_sms）</span></span><br><span class=\"line\">XREADGROUP GROUP group_reg_task consumer_sms COUNT 5 BLOCK 3000 STREAMS user_register_stream &gt;</span><br><span class=\"line\">XACK user_register_stream group_reg_task 消息ID1 消息ID2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 邮件发送消费者（consumer_email）</span></span><br><span class=\"line\">XREADGROUP GROUP group_reg_task consumer_email COUNT 5 BLOCK 3000 STREAMS user_register_stream &gt;</span><br><span class=\"line\">XACK user_register_stream group_reg_task 消息ID1 消息ID2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 积分发放消费者（consumer_score）</span></span><br><span class=\"line\">XREADGROUP GROUP group_reg_task consumer_score COUNT 5 BLOCK 3000 STREAMS user_register_stream &gt;</span><br><span class=\"line\">XACK user_register_stream group_reg_task 消息ID1 消息ID2</span><br></pre></td></tr></table></figure>\n<h3 id=\"日志收集（系统实时日志-分析-告警）\">日志收集（系统实时日志-分析/告警）</h3>\n<blockquote>\n<p>核心思路：各业务系统实时写入日志到 Stream，多消费组分别做日志分析、实时告警，兼顾实时性与数据留存，支持历史日志回溯。</p>\n</blockquote>\n<ol>\n<li class=\"lvl-3\">\n<p>生产者（各业务系统）：实时写入系统日志（按级别/业务分类，这里统一写入总日志流）</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 写入日志：包含业务模块、日志级别、内容、时间，无消息数量上限（按实际服务器内存调整MAXLEN）</span></span><br><span class=\"line\">XADD sys_log_stream * module order_service level ERROR content <span class=\"string\">&quot;库存扣减失败，订单号ORD20251220001&quot;</span> log_time 1734567910</span><br><span class=\"line\">XADD sys_log_stream * module pay_service level INFO content <span class=\"string\">&quot;支付成功，uid1001，金额299&quot;</span> log_time 1734567912</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>创建2个消费组（日志分析+实时告警）</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 日志分析消费组（用于离线统计、数据归档），从队列开头消费（0-0），兜底所有历史日志</span></span><br><span class=\"line\">XGROUP CREATE sys_log_stream group_log_analysis 0-0 MKSTREAM</span><br><span class=\"line\"><span class=\"comment\"># 实时告警消费组（用于实时捕获ERROR日志告警），从最新消息消费</span></span><br><span class=\"line\">XGROUP CREATE sys_log_stream group_log_alert $ MKSTREAM</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li class=\"lvl-3\">\n<p>对应消费者拉取处理</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 日志分析消费者（批量拉取，非阻塞，适合离线处理）</span></span><br><span class=\"line\">XREADGROUP GROUP group_log_analysis consumer_analysis COUNT 100 STREAMS sys_log_stream &gt;</span><br><span class=\"line\">XACK sys_log_stream group_log_analysis 批量消息ID...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 告警消费者（阻塞拉取，快速响应，只处理ERROR级别日志）</span></span><br><span class=\"line\">XREADGROUP GROUP group_log_alert consumer_alert BLOCK 0 STREAMS sys_log_stream &gt;  <span class=\"comment\"># BLOCK 0 永久阻塞，有消息立即返回</span></span><br><span class=\"line\">XACK sys_log_stream group_log_alert 告警消息ID</span><br></pre></td></tr></table></figure>\n<h3 id=\"限流削峰（秒杀场景-请求削峰填谷）\">限流削峰（秒杀场景-请求削峰填谷）</h3>\n<blockquote>\n<p>核心思路：秒杀请求高峰时，先写入 Stream 做缓冲，消费端匀速拉取（控制每秒处理量），避免下游数据库/业务服务被压垮，核心是“慢消费、稳处理”。</p>\n</blockquote>\n<ol>\n<li class=\"lvl-3\">\n<p>生产者（秒杀入口服务）：接收秒杀请求，直接写入 Stream，快速返回“排队中”</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 写入秒杀请求，设置MAXLEN 10000（限制最大排队数，超过则拒绝，避免OOM）</span></span><br><span class=\"line\">XADD seckill_stream * MAXLEN ~ 10000 seckill_id 101 uid 1001 request_time 1734568000</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>创建消费组（单消费组+多消费者，控制总处理速率）</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XGROUP CREATE seckill_stream group_seckill $ MKSTREAM</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li class=\"lvl-3\">\n<p>消费端（匀速拉取，核心是控制COUNT和消费频率，比如每秒处理100条）</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 消费者（多实例部署，总处理量=单实例COUNT×实例数，这里单实例每次拉10条，每秒拉10次，单实例每秒处理100条）</span></span><br><span class=\"line\">XREADGROUP GROUP group_seckill consumer_seckill1 COUNT 10 BLOCK 100 STREAMS seckill_stream &gt;</span><br><span class=\"line\"><span class=\"comment\"># 业务处理：扣库存、生成订单（核心是处理逻辑同步执行，控制速率）</span></span><br><span class=\"line\">XACK seckill_stream group_seckill 秒杀请求消息ID...</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>关键优化：消费端通过定时任务+固定COUNT拉取，而非无限拉取，精准控制处理速率，实现削峰填谷。</p>\n</blockquote>\n<h2 id=\"与其他-Redis-队列方案对比（核心优势）\">与其他 Redis 队列方案对比（核心优势）</h2>\n<p>• 对比 List<br>\n- List 是简单的先进先出，不支持多播（多个消费者会抢消息）、无消费组、无消息确认，仅适合简单一对一队列；<br>\n- Stream 支持多播+消费组+确认机制，适合复杂分布式场景。</p>\n<table>\n<thead>\n<tr>\n<th>对比项</th>\n<th>Stream</th>\n<th>List</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>消费者组</td>\n<td>✅</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>ACK</td>\n<td>✅</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>重试</td>\n<td>✅</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>阻塞</td>\n<td>✅</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>顺序性</td>\n<td>强</td>\n<td>强</td>\n</tr>\n</tbody>\n</table>\n<p>• 对比 Pub/Sub<br>\n- Pub/Sub 无持久化，Redis 重启或消费者离线会丢消息；<br>\n- Pub/Sub 无消费组，消息发完即丢，仅适合实时广播（如聊天室），不适合重要业务。</p>\n<h2 id=\"Stream-命令\">Stream 命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot 的 <code>StringRedisTemplate.opsForStream()</code> 中 Stream 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p>\n</li>\n</ul>\n<blockquote>\n<p>注意这里不一定要用 <code>StringRedisTemplate</code> 来操作 Stream，但是用 <code>StringRedisTemplate</code> 可以保证可读性。</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>核心能力划分：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">消息写入（XADD）</span><br><span class=\"line\">消息确认（XACK）</span><br><span class=\"line\">消息读取（XRANGE / XREAD / XREADGROUP）</span><br><span class=\"line\">Pending 消息管理（XPENDING / XCLAIM）</span><br><span class=\"line\">消费者组管理（XGROUP）</span><br><span class=\"line\">Stream 元信息（XINFO）</span><br><span class=\"line\">Stream 裁剪与删除（XTRIM / XDEL）</span><br><span class=\"line\">对象映射（MapRecord / ObjectRecord）</span><br></pre></td></tr></table></figure>\n<h3 id=\"消息写入（XADD）\">消息写入（XADD）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1️⃣ 基础写入</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法 <code>opsForStream().xxx()</code></th>\n<th>Redis 原始命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>写入 Map</td>\n<td><code>add(K key, Map&lt;HK,HV&gt;)</code></td>\n<td><code>XADD key * field value</code></td>\n<td>自动生成 ID</td>\n</tr>\n<tr>\n<td>写入 Record</td>\n<td><code>add(Record&lt;K, ?&gt; record)</code></td>\n<td><code>XADD</code></td>\n<td>支持 ObjectRecord</td>\n</tr>\n<tr>\n<td>写入 MapRecord</td>\n<td><code>add(MapRecord&lt;K,HK,HV&gt;)</code></td>\n<td><code>XADD</code></td>\n<td>Map 形式</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2️⃣ 带参数写入（推荐）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>写入 + 选项</td>\n<td><code>add(record, XAddOptions)</code></td>\n<td><code>XADD ...</code></td>\n<td>支持 MAXLEN / NOMKSTREAM</td>\n</tr>\n<tr>\n<td>Map + 选项</td>\n<td><code>add(key, map, XAddOptions)</code></td>\n<td><code>XADD</code></td>\n<td>Redis ≥ 6</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"消息确认（XACK）\">消息确认（XACK）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>确认消息</td>\n<td><code>acknowledge(key, group, recordIds…)</code></td>\n<td><code>XACK</code></td>\n<td>标记已消费</td>\n</tr>\n<tr>\n<td>Record 确认</td>\n<td><code>acknowledge(group, record)</code></td>\n<td><code>XACK</code></td>\n<td>常用</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>⚠️ 只对 Consumer Group 生效</p>\n</blockquote>\n<h3 id=\"消息读取（无消费者组）\">消息读取（无消费者组）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1️⃣ 按 Range 读取（历史数据）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>正序读取</td>\n<td><code>range(key, range)</code></td>\n<td><code>XRANGE</code></td>\n</tr>\n<tr>\n<td>限制条数</td>\n<td><code>range(key, range, limit)</code></td>\n<td><code>XRANGE</code></td>\n</tr>\n<tr>\n<td>反序读取</td>\n<td><code>reverseRange(key, range)</code></td>\n<td><code>XREVRANGE</code></td>\n</tr>\n<tr>\n<td>反序 + limit</td>\n<td><code>reverseRange(key, range, limit)</code></td>\n<td><code>XREVRANGE</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2️⃣ 实时读取（XREAD）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>读取</td>\n<td><code>read(StreamOffset…)</code></td>\n<td><code>XREAD</code></td>\n<td>不支持 ACK</td>\n</tr>\n<tr>\n<td>带参数</td>\n<td><code>read(options, offsets…)</code></td>\n<td><code>XREAD</code></td>\n<td>BLOCK / COUNT</td>\n</tr>\n<tr>\n<td>映射对象</td>\n<td><code>read(Class&lt;T&gt;, …)</code></td>\n<td><code>XREAD</code></td>\n<td>自动反序列化</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"消费者组读取（XREADGROUP）\">消费者组读取（XREADGROUP）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>组内读取</td>\n<td><code>read(Consumer, offsets…)</code></td>\n<td><code>XREADGROUP</code></td>\n<td>MQ 核心</td>\n</tr>\n<tr>\n<td>带参数</td>\n<td><code>read(Consumer, options, offsets…)</code></td>\n<td><code>XREADGROUP</code></td>\n<td>BLOCK</td>\n</tr>\n<tr>\n<td>映射对象</td>\n<td><code>read(Class&lt;T&gt;, Consumer, …)</code></td>\n<td><code>XREADGROUP</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Pending-消息管理（XPENDING-XCLAIM）\">Pending 消息管理（XPENDING / XCLAIM）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1️⃣ Pending 查询</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Pending 汇总</td>\n<td><code>pending(key, group)</code></td>\n<td><code>XPENDING</code></td>\n</tr>\n<tr>\n<td>指定消费者</td>\n<td><code>pending(key, consumer)</code></td>\n<td><code>XPENDING</code></td>\n</tr>\n<tr>\n<td>范围查询</td>\n<td><code>pending(key, group, range, count)</code></td>\n<td><code>XPENDING</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2️⃣ 消息重新分配（XCLAIM）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>重新分配</td>\n<td><code>claim(key, group, newOwner, minIdle, ids…)</code></td>\n<td><code>XCLAIM</code></td>\n<td>超时接管</td>\n</tr>\n<tr>\n<td>高级配置</td>\n<td><code>claim(key, group, newOwner, XClaimOptions)</code></td>\n<td><code>XCLAIM</code></td>\n<td>force / retry</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"消费者组管理（XGROUP）\">消费者组管理（XGROUP）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>创建组</td>\n<td><code>createGroup(key, group)</code></td>\n<td><code>XGROUP CREATE</code></td>\n<td>从 <code>$</code> 开始</td>\n</tr>\n<tr>\n<td>指定 offset</td>\n<td><code>createGroup(key, offset, group)</code></td>\n<td><code>XGROUP CREATE</code></td>\n<td>常用 <code>0-0</code></td>\n</tr>\n<tr>\n<td>删除消费者</td>\n<td><code>deleteConsumer(key, consumer)</code></td>\n<td><code>XGROUP DELCONSUMER</code></td>\n<td></td>\n</tr>\n<tr>\n<td>销毁组</td>\n<td><code>destroyGroup(key, group)</code></td>\n<td><code>XGROUP DESTROY</code></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Stream-元信息（XINFO）\">Stream 元信息（XINFO）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Stream 信息</td>\n<td><code>info(key)</code></td>\n<td><code>XINFO STREAM</code></td>\n</tr>\n<tr>\n<td>组信息</td>\n<td><code>groups(key)</code></td>\n<td><code>XINFO GROUPS</code></td>\n</tr>\n<tr>\n<td>消费者信息</td>\n<td><code>consumers(key, group)</code></td>\n<td><code>XINFO CONSUMERS</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Stream-删除-裁剪\">Stream 删除 / 裁剪</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1️⃣ 删除消息</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>删除消息</td>\n<td><code>delete(key, recordIds…)</code></td>\n<td><code>XDEL</code></td>\n</tr>\n<tr>\n<td>删除 Record</td>\n<td><code>delete(record)</code></td>\n<td><code>XDEL</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2️⃣ 裁剪 Stream（XTRIM）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>精确裁剪</td>\n<td><code>trim(key, count)</code></td>\n<td><code>XTRIM</code></td>\n<td></td>\n</tr>\n<tr>\n<td>近似裁剪</td>\n<td><code>trim(key, count, true)</code></td>\n<td><code>XTRIM ~</code></td>\n<td>性能更好</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"对象映射能力（非常重要）\">对象映射能力（非常重要）</h3>\n<table>\n<thead>\n<tr>\n<th>能力</th>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Map → Object</td>\n<td><code>map(MapRecord, Class&lt;T&gt;)</code></td>\n<td>自动反序列化</td>\n</tr>\n<tr>\n<td>List 映射</td>\n<td><code>map(List&lt;MapRecord&gt;, Class&lt;T&gt;)</code></td>\n<td></td>\n</tr>\n<tr>\n<td>HashMapper</td>\n<td><code>getHashMapper(Class&lt;T&gt;)</code></td>\n<td>自定义映射</td>\n</tr>\n<tr>\n<td>反序列化</td>\n<td><code>deserializeRecord(ByteRecord)</code></td>\n<td>底层能力</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 Redis Stream 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ Stream 核心详解 Redis Stream 是 Redis 5.0 新增的有序、可持久化、支持多播的消息队列，底层用基数树+链表实现，兼顾了高效查询与有序写入，完美解决了 List 队列（无法多播、无持久化保障）、Pub/Sub（无持久化、丢消息）的痛点，是生产环境首选的 Redis 消息队列方案。 建议生产环境还是使用传统的 MQ 方案，如果仅是内部系统使用的轻量MQ，已经有了redis，但是不想引入其它中间件，也可以尝试。 Stream 与传统的MQ 的对比 对比维度 Redis Stream RabbitMQ Kafka 数据模型 类似日志的有序 KV 消息流（ID → field/value） 队列（FIFO） 日志分区（Partitioned Append-Only Log） 消息持久化 可选持久化（AOF / RDB），默认内存优先 可持久化到磁盘 持久化到磁盘，顺序写入，效率高 消息确认 XACK 对单条消息确认，支持 Pending 消息管理 ACK / NACK Offset 控制，Consumer 自行提交 消费模式 支持 Consumer Group，多消费者共享 Pending 消息 Queue 绑定 Consumer，多消费者抢占 Consumer Group，多消费者平行消费 重复消费 默认可能重复，需要应用端幂等 可通过 ACK/NACK 控制 默认可能重复，Consumer 需幂等处理 消息顺序 按 Stream ID 顺序，可保证分组内顺序 队列顺序保证 Partition 内顺序保证 消息保留策略 可配置 maxlen / minid，按时间或长度裁剪 队列长度 / TTL 控制 基于时间或大小保留（Retention Policy） 延时/定时消费 原生不支持延时队列，需要应用端处理 支持插件或 TTL 原生不支持，需要应用端处理或 Kafka Streams 事务与原子操作 事务可用 MULTI/EXEC，XADD 支持 NOMKSTREAM 等选项 原生事务支持（事务 / confirm 模式） 不支持事务，依赖幂等生产者 性能 内存级高吞吐，持久化会有开销 中等，受磁盘和网络限制 高吞吐，顺序写入磁盘效率极高 典型使用场景 事件日志、轻量 MQ、内部异步流水线 企业级消息、任务调度、RPC 大数据管道、日志收集、流处理 多语言支持 客户端支持多种语言（Java、Python、Go 等） 客户端丰富 客户端丰富 易运维性 单节点即可使用，但持久化需关注内存 集群较复杂，需要 RabbitMQ 集群 集群复杂度高，需要 ZooKeeper 或 KRaft 底层核心实现 存储结构：核心是基数树（Radix Tree）+ 双向链表，基数树存「消息ID→消息内容」的映射，双向链表按消息ID有序串联所有消息，保证写入和按ID查询的高效性（O(logN)）。 消息ID：默认自动生成，格式为时间戳-序列号（如1734567890000-0），时间戳是毫秒级，序列号解决同一毫秒多消息的有序问题；也支持手动指定，需满足严格递增，否则写入失败。 持久化：和 Redis 其他数据结构一致，依赖 RDB/AOF 持久化，消息写入后会落盘，重启后不丢失，这是 Pub/Sub 不具备的核心优势。 核心元数据：每个 Stream 会维护last-id（最新消息ID）、groups（消费组列表）、entries（消息实体）三类元数据，消费组的元数据独立存储，互不干扰。 Stream 核心基础操作（必用） 1. 生产消息（XADD）：写入队列 • 核心命令：XADD key ID 字段1 值1 字段2 值2 ...，ID 写*表示自动生成（生产首选） 12345678910111213141516171819202122XADD key [NOMKSTREAM] [MAXLEN | MINID [= | ~] threshold [LIMIT count]] * | id field value [field value ...]# 参数解释# key: Stream 名称# NOMKSTREAM: 不自动创建 Stream，若 key 不存在 → 命令直接失败# MAXLEN threshold —— 按长度裁剪# MAXLEN 1000: Stream 最多保留 1000 条消息，超出部分会被删除（从最旧开始）# MAXLEN = 1000: 精确裁剪，严格保证长度 ≤ 1000，每次写入都会检查并裁剪，性能开销较大# MAXLEN ~ 1000（推荐）: 近似裁剪，允许 Stream 长度 略微超过阈值，Redis 在内部批量裁剪，写入性能更高# LIMIT count —— 每次最多裁剪多少条# MAXLEN ~ 1000 LIMIT 100: 单次写入 最多删除 100 条旧消息，防止一次裁剪阻塞 Redis 主线程# MINID threshold —— 按 ID 裁剪（Redis ≥ 6.2）# MINID ~ 1670000000000-0: 删除 ID 小于 threshold 的消息，更适合 时间窗口型保留策略# * | id —— 消息 ID# *: 自动生成 ID（99% 场景），格式：&lt;毫秒时间戳&gt;-&lt;序号&gt;，单调递增，全局有序，消费者组依赖它进行 offset 管理# id: 指定ID（不常用），ID 必须严格大于 Stream 中最大 ID，否则写入失败# field value —— 消息体（Payload）# 至少一对 field-value，field / value 都是 Binary Safe，本质类似 Hash，但不可修改 • 示例 1234567# 向订单队列写入1条消息，自动生成消息IDXADD order_stream * uid 1001 order_no ORD20251220 price 299## 输出&quot;1766215406540-0&quot; # 消息ID# 保留某个时间点之后的日志XADD log MINID ~ 1689900000000-0 * level INFO msg &quot;startup&quot; 2. 消费消息（2种核心模式） （1） 独立消费（无消费组）：一对一消费，适合简单场景 • XREAD：主动拉取消息，支持阻塞/非阻塞 12345678910111213XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] id [id ...]# 参数解释# COUNT count —— 单次最多读取多少条，是“上限”，不是保证值# BLOCK milliseconds —— 阻塞等待新消息，阻塞期间 不会占用 CPU，超时返回 nil# BLOCK 0: 无限阻塞，直到有新消息# STREAMS key [key ...] —— 指定读取的 Stream，key 与 id 一一对应# id [id ...] —— 从哪个位置开始读，读取 ID 大于该值的消息，不包含 该 ID 本身# 普通 ID（游标语义）: XREAD STREAMS mystream 1689999999999-0# $: 只关心“将来”的消息，从 当前 Stream 的末尾之后 开始读，历史消息全部忽略: XREAD BLOCK 0 STREAMS mystream $ • 示例1（非阻塞） 1234567891011# 从开头拉5条消息XREAD COUNT 5 STREAMS order_stream 0-0# 输出1) 1) &quot;order_stream&quot; # Stream名称 2) 1) 1) &quot;1766215406540-0&quot; # 消息ID 2) 1) &quot;uid&quot; # 消息体 键值对 2) &quot;1001&quot; 3) &quot;order_no&quot; 4) &quot;ORD20251220&quot; 5) &quot;price&quot; 6) &quot;299&quot; • 示例2（阻塞） 12# $表示从最新消息开始拉，阻塞3秒，有新消息立即返回，无则3秒后超时，是生产常用写法。XREAD COUNT 5 BLOCK 3000 STREAMS order_stream $ （2） 消费组消费（XGROUP）：一对多消费，核心生产模式 Stream 最核心的价值就是消费组，支持多消费者协同消费、消息确认、未消费消息追溯，解决了分布式场景下的消息分片与负载均衡问题。 先创建消费组XGROUP CREATE 1234567891011121314XGROUP CREATE key group id|$ [MKSTREAM] [ENTRIESREAD entries-read]# 参数解释# key：Stream 名称，为指定的Stream创建消费组# group: 消费组名称，消费者组的唯一标识，一个 Stream 可以有 多个 consumer group# id | $ —— 关键参数：消费起始位点（offset），$表示从当前最新消息开始消费，用0-0表示从队列开头消费。# [MKSTREAM] —— 自动创建 Stream，如果指定的key不存在则自动创建，推荐在自动化部署中使用# [ENTRIESREAD entries-read] —— 设置“已读取条数”（高级参数），一般业务不需要使用，主要用于手动恢复group、数据迁移等场景# 示例：创建group1消费组，从最新订单消息开始消费XGROUP CREATE order_stream group1 $ MKSTREAM# 输出OK 消费者拉取消息XREADGROUP 123456789101112131415161718192021222324252627282930313233XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] id [id ...]# 参数解释# GROUP group consumer: 指定消费者组名：group，消费者名：consumer# 同一个 group 下，不同 consumer 不会收到重复消息# [COUNT count] —— 单次最多返回条数，是软限制，不是严格保证# [BLOCK milliseconds] —— 阻塞等待新消息，最多阻塞 milliseconds 毫秒# BLOCK 0 → 永久阻塞# [NOACK] —— 不进入 Pending（⚠️ 谨慎）# 消息 不会进入 Pending，不需要 XACK，消费后即认为完成# 风险：消费者崩溃 → 消息直接丢失，不可重投递# STREAMS key [key ...]: 指定要读取的 Stream（支持多个），key 顺序需与后续 id 顺序一致# id [id ...] —— 决定“读什么”的关键# 使用 &gt; —— 读取“新消息”（✅ 生产环境 99% 使用这种方式），从未投递给任何 consumer 的新消息# 使用 0/具体ID —— 重读 Pending（补偿），读取 已投递但未 ACK 的消息# 多 Stream 场景: STREAMS stream1 stream2 &gt; &gt;，每个 stream 必须有一个对应 id# 示例：consumerA 从group1拉3条未被消费的消息，阻塞5秒。XREADGROUP GROUP group1 consumerA COUNT 3 BLOCK 5000 STREAMS order_stream &gt;## 此时在5秒内创建新的消息，就会有类似如下输出1) 1) &quot;order_stream&quot; 2) 1) 1) &quot;1766215642763-0&quot; 2) 1) &quot;uid&quot; 2) &quot;1001&quot; 3) &quot;order_no&quot; 4) &quot;ORD20251220&quot; 5) &quot;price&quot; 6) &quot;299&quot;(1.50s) 3. 消息确认（XACK） 消费完成后必须确认，否则会被标记为「未确认消息」 12345# XACK key 消费组名 消息ID1 消息ID2 ...。XACK key group id [id ...]# 示例: 确认2条消息消费完成，Stream 会删除该消息的未确认标记XACK order_stream group1 1734567890000-0 1734567890001-0 4. 消息重试 未确认的消息，会被存入消费组的「PEL（Pending Entries List）」，可通过XPENDING key 消费组名查看，支持XCLAIM将PEL中的消息转移给其他消费者处理，避免单点故障导致消息堆积。 XPENDING：查看未被确认的消息情况 123456789101112131415161718192021222324252627282930313233343536XPENDING key group [[IDLE min-idle-time] start end count [consumer]]# 参数解释# key: Stream 名称，必须存在# group: 消费者组名称，必须存在# [IDLE min-idle-time]（Redis ≥ 6.2）: 仅返回 空闲时间 ≥ min-idle-time（毫秒） 的 Pending 消息# min-idle-time(空闲时间) = 从上次投递 / claim到现在# start end —— ID 范围# -: 最小ID# +: 最大ID# count —— 返回条数上限# [consumer]（可选）: 只查看某一个 consumer 的 Pending，不指定则查看 group 内全部# 只返回 元数据，不返回消息内容# 示例1: 查看是否有消息积压XPENDING order_stream group1## 输出1) (integer) 1 # 积压消息数，未确认消息数量2) &quot;1766215642763-0&quot; # Pending 中最小 ID3) &quot;1766215642763-0&quot; # Pending 中最大 ID4) 1) 1) &quot;consumerA&quot; # 按 consumer 统计的 Pending 数量 2) &quot;1&quot;# 示例2: 查找 idle 超过 1 分钟的消息，最多返回10条XPENDING order_stream group1 IDLE 60000 - + 10## 输出1) 1) &quot;1766215642763-0&quot; # 消息 ID 2) &quot;consumerA&quot; # 当前持有该消息的 consumer 3) (integer) 255581 # idle 时间（毫秒） 4) (integer) 2 # delivery count（投递次数）,该消息至少被投递过 2 次# 示例3: 只查看 consumerA 的 Pending，最多返回20条XPENDING order_stream group1 - + 20 consumerA XCLAIM: 转移投递 将已经投递但未 ACK、且 idle 超过阈值的 Pending 消息，从原 consumer 手中“抢占”给新的 consumer，并重新投递。 一旦抢占成功，原 consumer 就不在拥有该消息的 Pending 记录 12345678910111213141516171819202122232425262728293031323334353637XCLAIM key group consumer min-idle-time id [id ...] [IDLE ms] [TIME unix-time-milliseconds] [RETRYCOUNT count] [FORCE] [JUSTID] [LASTID lastid]# 参数解释# key: Stream Key，必须存在# group: 消费者组名称，必须存在# consumer: 新的消费者，抢占后的 Pending 消息将归属该 consumer# min-idle-time: 空闲时间，只有 idle ≥ min-idle-time 的 Pending 消息才允许被 claim# id [id ...]: 指定要 claim 的消息 ID，ID必须存在# [IDLE ms]: 人为设置 idle 时间，覆盖 Redis 内部计算的 idle，比如强制制造“已超时”状态# [TIME unix-time-milliseconds]: 手动指定“最后投递时间”，与 IDLE 二选一使用，极少见于业务代码# [RETRYCOUNT count]: 手动设置 delivery count，实现“最多重试 N 次，超过进死信队列”# [FORCE]: 强制 claim 不存在于 Pending 的消息，⚠️ 高风险# [JUSTID]: 只返回 消息 ID，不返回消息体（field/value），减少网络开销# [LASTID lastid]（Redis ≥ 7.0）: 更新 consumer group 的 last-delivered-id，影响后续 XREADGROUP &gt; 的行为# ⚠️ 高级特性，一般不建议业务代码使用# 示例：# 1️⃣ 抢占 idle 超过 60s 的消息XCLAIM order_stream group1 consumerB 60000 1766215642763-0# 输出1) 1) &quot;1766215642763-0&quot; 2) 1) &quot;uid&quot; 2) &quot;1001&quot; 3) &quot;order_no&quot; 4) &quot;ORD20251220&quot; 5) &quot;price&quot; 6) &quot;299&quot;# 2️⃣ 抢占并标记为第 3 次重试XCLAIM orders order-group consumerB 60000 1766215642763-0 RETRYCOUNT 3# 3️⃣ 只返回 ID（配合批处理）XCLAIM orders order-group consumerB 60000 1766215642763-0 JUSTID 高级特性（生产必备） 消息回溯与遍历 1234567# XRANGE key 起始ID 结束ID [COUNT 条数]（正向遍历）XRANGE key start end [COUNT count]# XREVRANGE key 结束ID 起始ID [COUNT 条数]（反向遍历）XREVRANGE key end start [COUNT count]# 示例: 0-0:最小的消息ID，等同于 -，+:表示最新消息，适合数据对账、历史消息查询。XRANGE order_stream 0-0 + COUNT 10XRANGE order_stream - + COUNT 10 队列信息查询 1234567891011121314151617181920# 查消息总数XLEN key# 查Stream完整元数据（最新ID、消费组数量、消息总数等）XINFO STREAM key [FULL [COUNT count]]## FULL: 完整模式 # 👉 返回： # Stream 元信息 # 所有 Consumer Group # 每个 Group 的 Consumer # Pending Entries List（PEL） # 部分历史 entries # ⚠️ 开销很大，慎用于生产环境。## COUNT count（FULL 模式的限制参数） # XINFO STREAM key FULL COUNT 10: 限制返回的entries 数量以及每个 group / consumer 的 PEL 记录数量# 查所有消费组信息XINFO GROUPS key# 查该组下所有消费者XINFO CONSUMERS key 消费组名 消费组管理 123456# 删除消费组XGROUP DESTROY key 消费组名# 删除消费者XGROUP DELCONSUMER key 消费组名 消费者名# 重置消费组起始IDXGROUP SETID key 消费组名 新ID 惰性删除：Stream 不会主动删除已确认的消息，仅靠MAXLEN淘汰，若需主动清理历史消息，直接用XADD的MAXLEN参数即可，无需额外命令。 生产环境核心痛点与解决方案 消息丢失：3重保障 开启 Redis AOF 持久化（设为everysec，兼顾性能与可靠性） 生产者写入后确认返回值（确保写入成功） 消费者消费后必须XACK确认。 消息堆积：2种处理 ① 写入时用MAXLEN设置上限，淘汰旧消息； ② 消费端扩容消费者实例，消费组会自动将未消费消息分片给多个消费者，实现并行消费。 重复消费 根源: 网络抖动（消费者确认消息前断开连接，消息重回PEL） 解决方案: 消息幂等性（生产者给消息加唯一标识，消费者根据唯一标识去重）。 阻塞超时：消费端用BLOCK阻塞拉取，超时时间建议设为3-5秒，避免频繁空轮询占用CPU，同时保证新消息的响应速度。 典型应用场景 分布式业务解耦（订单-库存-支付-物流解耦） 核心思路：单 Stream 对应核心业务（订单），库存、支付、物流各创建独立消费组，各自消费互不干扰，实现业务解耦。 生产者（订单服务）：写入订单完成消息 12# 自动生成消息ID，写入订单核心信息，设置队列最大1万条消息（近似淘汰）XADD order_core_stream * MAXLEN ~ 10000 order_no ORD20251220001 uid 1001 amount 299 status created create_time 1734567890 创建3个独立消费组（库存/支付/物流） 123456# 库存消费组：从最新消息开始消费，队列不存在则自动创建XGROUP CREATE order_core_stream group_stock $ MKSTREAM# 支付消费组XGROUP CREATE order_core_stream group_pay $ MKSTREAM# 物流消费组XGROUP CREATE order_core_stream group_logistics $ MKSTREAM 各消费组消费者拉取+确认消息 123456789101112# 库存服务消费者（consumer_stock1）拉取3条未消费消息，阻塞5秒XREADGROUP GROUP group_stock consumer_stock1 COUNT 3 BLOCK 5000 STREAMS order_core_stream &gt;# 库存处理完成后确认消息（替换为实际拉取到的消息ID）XACK order_core_stream group_stock 1734567890000-0 1734567890001-0# 支付服务消费者（consumer_pay1）同理XREADGROUP GROUP group_pay consumer_pay1 COUNT 3 BLOCK 5000 STREAMS order_core_stream &gt;XACK order_core_stream group_pay 1734567890000-0 1734567890001-0# 物流服务消费者（consumer_log1）同理XREADGROUP GROUP group_logistics consumer_log1 COUNT 3 BLOCK 5000 STREAMS order_core_stream &gt;XACK order_core_stream group_logistics 1734567890000-0 1734567890001-0 异步任务处理（用户注册-邮件/短信/积分异步执行） 核心思路：注册接口只负责写入 Stream 消息，无需等待后续任务完成，单消费组多消费者提升异步任务处理效率，核心是快速响应前端。 生产者（注册服务）：用户注册成功后写入消息 12# 写入用户注册信息，MAXLEN限制5000条，避免积压过多无效注册消息XADD user_register_stream * MAXLEN ~ 5000 uid 1001 username zhangsan phone 13800138000 email zs@xxx.com reg_time 1734567900 创建单个消费组（统一处理注册后续任务） 1XGROUP CREATE user_register_stream group_reg_task $ MKSTREAM 多消费者并行拉取（邮件/短信/积分各1个消费者，或多实例扩容） 1234567891011# 短信发送消费者（consumer_sms）XREADGROUP GROUP group_reg_task consumer_sms COUNT 5 BLOCK 3000 STREAMS user_register_stream &gt;XACK user_register_stream group_reg_task 消息ID1 消息ID2# 邮件发送消费者（consumer_email）XREADGROUP GROUP group_reg_task consumer_email COUNT 5 BLOCK 3000 STREAMS user_register_stream &gt;XACK user_register_stream group_reg_task 消息ID1 消息ID2# 积分发放消费者（consumer_score）XREADGROUP GROUP group_reg_task consumer_score COUNT 5 BLOCK 3000 STREAMS user_register_stream &gt;XACK user_register_stream group_reg_task 消息ID1 消息ID2 日志收集（系统实时日志-分析/告警） 核心思路：各业务系统实时写入日志到 Stream，多消费组分别做日志分析、实时告警，兼顾实时性与数据留存，支持历史日志回溯。 生产者（各业务系统）：实时写入系统日志（按级别/业务分类，这里统一写入总日志流） 123# 写入日志：包含业务模块、日志级别、内容、时间，无消息数量上限（按实际服务器内存调整MAXLEN）XADD sys_log_stream * module order_service level ERROR content &quot;库存扣减失败，订单号ORD20251220001&quot; log_time 1734567910XADD sys_log_stream * module pay_service level INFO content &quot;支付成功，uid1001，金额299&quot; log_time 1734567912 创建2个消费组（日志分析+实时告警） 1234# 日志分析消费组（用于离线统计、数据归档），从队列开头消费（0-0），兜底所有历史日志XGROUP CREATE sys_log_stream group_log_analysis 0-0 MKSTREAM# 实时告警消费组（用于实时捕获ERROR日志告警），从最新消息消费XGROUP CREATE sys_log_stream group_log_alert $ MKSTREAM 对应消费者拉取处理 1234567# 日志分析消费者（批量拉取，非阻塞，适合离线处理）XREADGROUP GROUP group_log_analysis consumer_analysis COUNT 100 STREAMS sys_log_stream &gt;XACK sys_log_stream group_log_analysis 批量消息ID...# 告警消费者（阻塞拉取，快速响应，只处理ERROR级别日志）XREADGROUP GROUP group_log_alert consumer_alert BLOCK 0 STREAMS sys_log_stream &gt; # BLOCK 0 永久阻塞，有消息立即返回XACK sys_log_stream group_log_alert 告警消息ID 限流削峰（秒杀场景-请求削峰填谷） 核心思路：秒杀请求高峰时，先写入 Stream 做缓冲，消费端匀速拉取（控制每秒处理量），避免下游数据库/业务服务被压垮，核心是“慢消费、稳处理”。 生产者（秒杀入口服务）：接收秒杀请求，直接写入 Stream，快速返回“排队中” 12# 写入秒杀请求，设置MAXLEN 10000（限制最大排队数，超过则拒绝，避免OOM）XADD seckill_stream * MAXLEN ~ 10000 seckill_id 101 uid 1001 request_time 1734568000 创建消费组（单消费组+多消费者，控制总处理速率） 1XGROUP CREATE seckill_stream group_seckill $ MKSTREAM 消费端（匀速拉取，核心是控制COUNT和消费频率，比如每秒处理100条） 1234# 消费者（多实例部署，总处理量=单实例COUNT×实例数，这里单实例每次拉10条，每秒拉10次，单实例每秒处理100条）XREADGROUP GROUP group_seckill consumer_seckill1 COUNT 10 BLOCK 100 STREAMS seckill_stream &gt;# 业务处理：扣库存、生成订单（核心是处理逻辑同步执行，控制速率）XACK seckill_stream group_seckill 秒杀请求消息ID... 关键优化：消费端通过定时任务+固定COUNT拉取，而非无限拉取，精准控制处理速率，实现削峰填谷。 与其他 Redis 队列方案对比（核心优势） • 对比 List - List 是简单的先进先出，不支持多播（多个消费者会抢消息）、无消费组、无消息确认，仅适合简单一对一队列； - Stream 支持多播+消费组+确认机制，适合复杂分布式场景。 对比项 Stream List 消费者组 ✅ ❌ ACK ✅ ❌ 重试 ✅ ❌ 阻塞 ✅ ✅ 顺序性 强 强 • 对比 Pub/Sub - Pub/Sub 无持久化，Redis 重启或消费者离线会丢消息； - Pub/Sub 无消费组，消息发完即丢，仅适合实时广播（如聊天室），不适合重要业务。 Stream 命令 SpringBoot 的 StringRedisTemplate.opsForStream() 中 Stream 数据类型 的操作方法与 Redis 原生命令的对应关系如下： 注意这里不一定要用 StringRedisTemplate 来操作 Stream，但是用 StringRedisTemplate 可以保证可读性。 核心能力划分： 12345678消息写入（XADD）消息确认（XACK）消息读取（XRANGE / XREAD / XREADGROUP）Pending 消息管理（XPENDING / XCLAIM）消费者组管理（XGROUP）Stream 元信息（XINFO）Stream 裁剪与删除（XTRIM / XDEL）对象映射（MapRecord / ObjectRecord） 消息写入（XADD） 1️⃣ 基础写入 方法功能 方法 opsForStream().xxx() Redis 原始命令 说明 写入 Map add(K key, Map&lt;HK,HV&gt;) XADD key * field value 自动生成 ID 写入 Record add(Record&lt;K, ?&gt; record) XADD 支持 ObjectRecord 写入 MapRecord add(MapRecord&lt;K,HK,HV&gt;) XADD Map 形式 2️⃣ 带参数写入（推荐） 方法功能 方法 Redis 原始命令 备注 写入 + 选项 add(record, XAddOptions) XADD ... 支持 MAXLEN / NOMKSTREAM Map + 选项 add(key, map, XAddOptions) XADD Redis ≥ 6 消息确认（XACK） 方法功能 方法 Redis 原始命令 说明 确认消息 acknowledge(key, group, recordIds…) XACK 标记已消费 Record 确认 acknowledge(group, record) XACK 常用 ⚠️ 只对 Consumer Group 生效 消息读取（无消费者组） 1️⃣ 按 Range 读取（历史数据） 方法功能 方法 Redis 原始命令 正序读取 range(key, range) XRANGE 限制条数 range(key, range, limit) XRANGE 反序读取 reverseRange(key, range) XREVRANGE 反序 + limit reverseRange(key, range, limit) XREVRANGE 2️⃣ 实时读取（XREAD） 方法功能 方法 Redis 原始命令 说明 读取 read(StreamOffset…) XREAD 不支持 ACK 带参数 read(options, offsets…) XREAD BLOCK / COUNT 映射对象 read(Class&lt;T&gt;, …) XREAD 自动反序列化 消费者组读取（XREADGROUP） 方法功能 方法 Redis 原始命令 说明 组内读取 read(Consumer, offsets…) XREADGROUP MQ 核心 带参数 read(Consumer, options, offsets…) XREADGROUP BLOCK 映射对象 read(Class&lt;T&gt;, Consumer, …) XREADGROUP — Pending 消息管理（XPENDING / XCLAIM） 1️⃣ Pending 查询 方法功能 方法 Redis 原始命令 Pending 汇总 pending(key, group) XPENDING 指定消费者 pending(key, consumer) XPENDING 范围查询 pending(key, group, range, count) XPENDING 2️⃣ 消息重新分配（XCLAIM） 方法功能 方法 Redis 原始命令 说明 重新分配 claim(key, group, newOwner, minIdle, ids…) XCLAIM 超时接管 高级配置 claim(key, group, newOwner, XClaimOptions) XCLAIM force / retry 消费者组管理（XGROUP） 方法功能 方法 Redis 原始命令 说明 创建组 createGroup(key, group) XGROUP CREATE 从 $ 开始 指定 offset createGroup(key, offset, group) XGROUP CREATE 常用 0-0 删除消费者 deleteConsumer(key, consumer) XGROUP DELCONSUMER 销毁组 destroyGroup(key, group) XGROUP DESTROY Stream 元信息（XINFO） 方法功能 方法 Redis 原始命令 Stream 信息 info(key) XINFO STREAM 组信息 groups(key) XINFO GROUPS 消费者信息 consumers(key, group) XINFO CONSUMERS Stream 删除 / 裁剪 1️⃣ 删除消息 方法功能 方法 Redis 原始命令 删除消息 delete(key, recordIds…) XDEL 删除 Record delete(record) XDEL 2️⃣ 裁剪 Stream（XTRIM） 方法功能 方法 Redis 原始命令 说明 精确裁剪 trim(key, count) XTRIM 近似裁剪 trim(key, count, true) XTRIM ~ 性能更好 对象映射能力（非常重要） 能力 方法 说明 Map → Object map(MapRecord, Class&lt;T&gt;) 自动反序列化 List 映射 map(List&lt;MapRecord&gt;, Class&lt;T&gt;) HashMapper getHashMapper(Class&lt;T&gt;) 自定义映射 反序列化 deserializeRecord(ByteRecord) 底层能力","summary":"摘要 本文介绍 Redis Stream 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2025-12-20T05:40:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/19/redis7-datatype-09-geo/","url":"https://blog.hanqunfeng.com/2025/12/19/redis7-datatype-09-geo/","title":"Redis 命令及数据类型 -- Geo","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis Geo 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Geo-核心详解\">Geo 核心详解</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis Geo 是基于有序集合（<code>zset</code>） 实现的地理空间操作功能，底层用<code>geohash编码</code>存储<code>经纬度</code>，核心支持 6 个基础操作 + 2 个扩展操作，兼顾<code>精准存储</code>、<code>距离计算</code>、<code>范围筛选</code>等核心需求，直接对接实际场景（如附近门店、同城好友）。</p>\n</li>\n<li class=\"lvl-2\">\n<p>有效经度(longitude)为 <code>-180 ~ 180</code>，有效纬度(latitude)为 <code>-85.05112878 ~ 85.05112878</code>。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Redis 内部实现中：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GEO 数据 ≈ ZSET</span><br><span class=\"line\">score = GeoHash（52 位bit ≈ 11 个字符）</span><br><span class=\"line\">member = 实际成员名</span><br></pre></td></tr></table></figure>\n<h2 id=\"Geohash-是什么\">Geohash 是什么?</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Geohash 是一种将二维地理坐标（经度、纬度）编码为一维字符串或整数的空间索引算法，核心目标是：</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">将「位置」映射为「可排序的值」</span><br><span class=\"line\">相近的地理位置 → 前缀相同或接近</span><br><span class=\"line\">便于 范围查询、邻近查询、索引存储</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>核心思想</p>\n</li>\n</ul>\n<blockquote>\n<p>不断对经纬度区间进行二分，并交叉编码<br>\n编码顺序：经度 → 纬度 → 经度 → 纬度 → …</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">每一步：</span><br><span class=\"line\">    1.取当前区间的中点</span><br><span class=\"line\">    2.大于中点记为 1</span><br><span class=\"line\">    3.小于中点记为 0</span><br><span class=\"line\">    4.缩小区间，继续下一位</span><br><span class=\"line\">最终得到一个 bit 序列。</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis 内部的 Geohash 字符 = <code>52bit</code>，即 经度 <code>26 bit</code>，纬度 <code>26 bit</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">每个字符 = 5 bit</span><br><span class=\"line\">内部 52 bit → 按 5 bit 分组 → 52 ÷ 5 = 10 余 2 bit</span><br><span class=\"line\"></span><br><span class=\"line\">Redis 默认在输出字符串时：</span><br><span class=\"line\">    会把 剩余的 2 bit 填充成完整字符，即末尾补三个 0</span><br><span class=\"line\">    因此最终得到 11 个 Base32 字符</span><br></pre></td></tr></table></figure>\n<h3 id=\"Geohash-计算过程示例\">Geohash 计算过程示例</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">longitude = 116.397128</span><br><span class=\"line\">latitude  = 39.916527</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>为了简化计算过程，我们这里固定一个常用精度：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">精度选择：5 个 Geohash 字符 = 25 个 bit ⇒ 经度 13 bit，纬度 12 bit（奇数位经度）</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>逐位计算（关键过程）<br>\n1️⃣ 经度 bit（13 位）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>位次</th>\n<th>区间</th>\n<th>mid</th>\n<th>判断</th>\n<th>bit</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>[-180,180]</td>\n<td>0</td>\n<td>116 ≥ 0</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2</td>\n<td>[0,180]</td>\n<td>90</td>\n<td>116 ≥ 90</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3</td>\n<td>[90,180]</td>\n<td>135</td>\n<td>116 &lt; 135</td>\n<td>0</td>\n</tr>\n<tr>\n<td>4</td>\n<td>[90,135]</td>\n<td>112.5</td>\n<td>116 ≥ 112.5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>5</td>\n<td>[112.5,135]</td>\n<td>123.75</td>\n<td>116 &lt; 123.75</td>\n<td>0</td>\n</tr>\n<tr>\n<td>6</td>\n<td>[112.5,123.75]</td>\n<td>118.125</td>\n<td>116 &lt; 118.125</td>\n<td>0</td>\n</tr>\n<tr>\n<td>7</td>\n<td>[112.5,118.125]</td>\n<td>115.3125</td>\n<td>116 ≥ 115.3125</td>\n<td>1</td>\n</tr>\n<tr>\n<td>8</td>\n<td>[115.3125,118.125]</td>\n<td>116.71875</td>\n<td>116 &lt; 116.71875</td>\n<td>0</td>\n</tr>\n<tr>\n<td>9</td>\n<td>[115.3125,116.71875]</td>\n<td>116.015625</td>\n<td>116 ≥ 116.015625</td>\n<td>1</td>\n</tr>\n<tr>\n<td>10</td>\n<td>[116.015625,116.71875]</td>\n<td>116.3671875</td>\n<td>116 ≥ 116.3671875</td>\n<td>1</td>\n</tr>\n<tr>\n<td>11</td>\n<td>[116.3671875,116.71875]</td>\n<td>116.54296875</td>\n<td>116 &lt; 116.54296875</td>\n<td>0</td>\n</tr>\n<tr>\n<td>12</td>\n<td>[116.3671875,116.54296875]</td>\n<td>116.455078125</td>\n<td>116 &lt; 116.455078125</td>\n<td>0</td>\n</tr>\n<tr>\n<td>13</td>\n<td>[116.3671875,116.455078125]</td>\n<td>116.4111328125</td>\n<td>116 &lt; 116.4111328125</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>经度 bit（13 位）：<code>1101001011000</code></p>\n</blockquote>\n<p>2️⃣ 纬度 bit（12 位）</p>\n<table>\n<thead>\n<tr>\n<th>位次</th>\n<th>区间</th>\n<th>mid</th>\n<th>判断</th>\n<th>bit</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>[-90,90]</td>\n<td>0</td>\n<td>39 ≥ 0</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2</td>\n<td>[0,90]</td>\n<td>45</td>\n<td>39 &lt; 45</td>\n<td>0</td>\n</tr>\n<tr>\n<td>3</td>\n<td>[0,45]</td>\n<td>22.5</td>\n<td>39 ≥ 22.5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>4</td>\n<td>[22.5,45]</td>\n<td>33.75</td>\n<td>39 ≥ 33.75</td>\n<td>1</td>\n</tr>\n<tr>\n<td>5</td>\n<td>[33.75,45]</td>\n<td>39.375</td>\n<td>39 &lt; 39.375</td>\n<td>0</td>\n</tr>\n<tr>\n<td>6</td>\n<td>[33.75,39.375]</td>\n<td>36.5625</td>\n<td>39 ≥ 36.5625</td>\n<td>1</td>\n</tr>\n<tr>\n<td>7</td>\n<td>[36.5625,39.375]</td>\n<td>37.96875</td>\n<td>39 ≥ 37.96875</td>\n<td>1</td>\n</tr>\n<tr>\n<td>8</td>\n<td>[37.96875,39.375]</td>\n<td>38.671875</td>\n<td>39 ≥ 38.671875</td>\n<td>1</td>\n</tr>\n<tr>\n<td>9</td>\n<td>[38.671875,39.375]</td>\n<td>39.0234375</td>\n<td>39 &lt; 39.0234375</td>\n<td>0</td>\n</tr>\n<tr>\n<td>10</td>\n<td>[38.671875,39.0234375]</td>\n<td>38.84765625</td>\n<td>39 ≥ 38.84765625</td>\n<td>1</td>\n</tr>\n<tr>\n<td>11</td>\n<td>[38.84765625,39.0234375]</td>\n<td>38.935546875</td>\n<td>39 ≥ 38.935546875</td>\n<td>1</td>\n</tr>\n<tr>\n<td>12</td>\n<td>[38.935546875,39.0234375]</td>\n<td>38.9794921875</td>\n<td>39 ≥ 38.9794921875</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>纬度 bit（12 位）：<code>101101110111</code></p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>交叉合并（最终 bit 序列）</p>\n</li>\n</ul>\n<blockquote>\n<p>按规则：经度 → 纬度 → 经度 → 纬度 …</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">经度: 1 1 0 1 0 0 1 0 1 1 0 0 0</span><br><span class=\"line\">纬度: 1 0 1 1 0 1 1 1 0 1 1 1</span><br><span class=\"line\"></span><br><span class=\"line\">交叉后得到 25 bit：11 10 01 11 00 01 11 01 10 11 01 01 01</span><br><span class=\"line\">合并为一行：1110011100011101101010101</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>每 5 bit → 1 个 Base32 字符</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 从左到右，每 5 位一组：</span></span><br><span class=\"line\">11100 | 11100 | 01110 | 11010 | 10101</span><br><span class=\"line\"><span class=\"comment\"># 转10进制</span></span><br><span class=\"line\">28    | 28    | 14    | 26    | 21</span><br><span class=\"line\"><span class=\"comment\"># 转 Base32</span></span><br><span class=\"line\">w     | w    | f    | u    | p</span><br><span class=\"line\"><span class=\"comment\"># 最终结果：</span></span><br><span class=\"line\">wwfup</span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>Geohash 使用的 Base32 字符集（固定，不是 RFC Base32）：</strong></em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Index:  0 1 2 3 4 5 6 7 8 9</span><br><span class=\"line\">Char :  0 1 2 3 4 5 6 7 8 9</span><br><span class=\"line\"></span><br><span class=\"line\">Index: 10 11 12 13 14 15 16 17 18 19</span><br><span class=\"line\">Char :  b  c  d  e  f  g  h  j  k  m</span><br><span class=\"line\"></span><br><span class=\"line\">Index: 20 21 22 23 24 25 26 27 28 29</span><br><span class=\"line\">Char :  n  p  q  r  s  t  u  v  w  x</span><br><span class=\"line\"></span><br><span class=\"line\">Index: 30 31</span><br><span class=\"line\">Char :  y  z</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">Geohash Base32 字符集 为什么缺少 <code>a, i, l, o</code>\n<ul class=\"lvl-3\">\n<li class=\"lvl-6\">为了避免在视觉上引起数字混淆</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a 容易和 4 混淆</span><br><span class=\"line\">i 容易和 1 混淆</span><br><span class=\"line\">l 容易和 1 混淆</span><br><span class=\"line\">o 容易和 0 混淆</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-3\">\n<li class=\"lvl-6\">去掉 <code>a, i, l, o</code> 后刚好是 32 个字符，因为 Geohash 需要 2⁵ = 32 个字符 对应 5 bit 精度</li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id=\"Geo-核心基础操作（必用）\">Geo 核心基础操作（必用）</h2>\n<h3 id=\"1-GEOADD：添加地理位置坐标（核心写入操作）\">1. GEOADD：添加地理位置坐标（核心写入操作）</h3>\n<p>◦ 语法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GEOADD key [NX | XX] [CH] longitude latitude member [longitude latitude member ...]</span><br><span class=\"line\"><span class=\"comment\"># 参数说明：</span></span><br><span class=\"line\"><span class=\"comment\"># key: key名称</span></span><br><span class=\"line\"><span class=\"comment\"># NX：如果已存在，则不执行写入操作</span></span><br><span class=\"line\"><span class=\"comment\"># XX: 如果不存在，则执行写入操作，与 NX 互斥</span></span><br><span class=\"line\"><span class=\"comment\"># CH: （CH是更改的缩写）返回新增和修改的成员数量，修改经纬度也算修改，如果不加CH，则只计算新增成员数量</span></span><br><span class=\"line\"><span class=\"comment\"># longitude: 经度 (-180 ~ 180)</span></span><br><span class=\"line\"><span class=\"comment\"># latitude: 纬度 (-85.05112878 ~ 85.05112878)</span></span><br><span class=\"line\"><span class=\"comment\"># member: 成员名称，位置唯一标识（字符串）</span></span><br><span class=\"line\"><span class=\"comment\"># 返回值：(不带CH)成功新增的 member 数量（已存在不会重复计算），(带CH)返回新增和修改的成员数量</span></span><br></pre></td></tr></table></figure>\n<p>◦ 示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 给shop集合加王府井、西单2个门店的经纬度</span></span><br><span class=\"line\">GEOADD shop 116.403963 39.915112 wangfujing 116.391248 39.906217 xidan</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 2</span><br></pre></td></tr></table></figure>\n<p>◦ 关键：经纬度顺序不能反，存储后会自动给每个成员生成geohash编码。</p>\n<h3 id=\"2-GEOPOS：获取指定成员的经纬度（精准查询坐标）\">2. GEOPOS：获取指定成员的经纬度（精准查询坐标）</h3>\n<p>◦ 语法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GEOPOS key [member [member ...]]</span><br></pre></td></tr></table></figure>\n<p>◦ 示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 返回王府井的经纬度数组 [经度, 纬度]</span></span><br><span class=\"line\">GEOPOS shop wangfujing</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;116.40396326780319214&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;39.91511209922290249&quot;</span></span><br></pre></td></tr></table></figure>\n<p>◦ 关键：返回结果与查询成员顺序一致，不存在的成员返回nil，可批量查询提升效率。</p>\n<h3 id=\"3-GEODIST：计算两个成员之间的距离（核心计算操作）\">3. GEODIST：计算两个成员之间的距离（核心计算操作）</h3>\n<p>◦ 语法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GEODIST key member1 member2 [M|KM|FT|MI]</span><br><span class=\"line\"><span class=\"comment\"># [M|KM|FT|MI] : 距离单位</span></span><br><span class=\"line\"><span class=\"comment\"># M : 米，默认</span></span><br><span class=\"line\"><span class=\"comment\"># KM : 千米</span></span><br><span class=\"line\"><span class=\"comment\"># FT : 英尺</span></span><br><span class=\"line\"><span class=\"comment\"># MI : 英里</span></span><br></pre></td></tr></table></figure>\n<p>◦ 示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 返回王府井和西单之间的距离，单位为米</span></span><br><span class=\"line\">GEODIST shop wangfujing xidan</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\"><span class=\"string\">&quot;1468.0611&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 计算王府井到西单的距离，单位千米</span></span><br><span class=\"line\">GEODIST shop wangfujing xidan km</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\"><span class=\"string\">&quot;1.4681&quot;</span></span><br></pre></td></tr></table></figure>\n<p>◦ 关键：返回浮点型结果，成员不存在返回nil，支持跨区域距离计算（如不同城市门店）。</p>\n<h3 id=\"4-GEOHASH：获取指定成员的geohash编码（底层编码查询）\">4. GEOHASH：获取指定成员的geohash编码（底层编码查询）</h3>\n<p>◦ 语法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GEOHASH key [member [member ...]]</span><br></pre></td></tr></table></figure>\n<p>◦ 示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 返回王府井的geohash字符串，共11位</span></span><br><span class=\"line\">GEOHASH shop wangfujing</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) <span class=\"string\">&quot;wx4g0f6f2u0&quot;</span></span><br></pre></td></tr></table></figure>\n<p>◦ 关键：geohash编码越长精度越高，Redis默认精度足够日常使用；编码相同的成员，地理位置极近，可用于快速判近。</p>\n<h3 id=\"5-GEORADIUS：按指定经纬度为中心，筛选指定范围的成员（范围查询1，按中心点坐标）\">5. GEORADIUS：按指定经纬度为中心，筛选指定范围的成员（范围查询1，按中心点坐标）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>即将弃用，请使用 <code>GEOSEARCH</code> / <code>GEOSEARCHSTORE</code> 替代<br>\n◦ 语法：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GEORADIUS key longitude latitude radius M|KM|FT|MI [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count [ANY]] [ASC|DESC] [STORE key|STOREDIST key]</span><br><span class=\"line\"><span class=\"comment\"># 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># key: key名称</span></span><br><span class=\"line\"><span class=\"comment\"># longitude: 经度</span></span><br><span class=\"line\"><span class=\"comment\"># latitude: 纬度</span></span><br><span class=\"line\"><span class=\"comment\"># radius: 半径</span></span><br><span class=\"line\"><span class=\"comment\"># M|KM|FT|MI: 单位</span></span><br><span class=\"line\"><span class=\"comment\">## 可选参数</span></span><br><span class=\"line\"><span class=\"comment\"># WITHCOORD: 返回经纬度</span></span><br><span class=\"line\"><span class=\"comment\"># WITHDIST: 带距离</span></span><br><span class=\"line\"><span class=\"comment\"># WITHHASH: 带geohash</span></span><br><span class=\"line\"><span class=\"comment\"># COUNT count: 限制返回数量</span></span><br><span class=\"line\"><span class=\"comment\"># ANY: 随机返回数量</span></span><br><span class=\"line\"><span class=\"comment\"># ASC/DESC: 按距离正/倒序</span></span><br><span class=\"line\"><span class=\"comment\"># STORE key: 存储结果到指定key</span></span><br><span class=\"line\"><span class=\"comment\"># STOREDIST key: 存储结果到指定key，结果为距离</span></span><br></pre></td></tr></table></figure>\n<p>◦ 核心可选参数：WITHDIST（返回距离）、WITHCOORD（返回经纬度）、WITHHASH（返回geohash）、COUNT n（限制返回数量）、ASC/DESC（按距离正/倒序）</p>\n<p>◦ 示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 以天安门附近为中心，查5km内10个门店，按距离从近到远返回并带距离</span></span><br><span class=\"line\">GEORADIUS shop 116.397 39.91 5 km WITHDIST COUNT 10 ASC</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;xidan&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;0.6463&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;wangfujing&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;0.8223&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"6-GEORADIUSBYMEMBER：按已有成员为中心，筛选指定范围的成员（范围查询2，按已有节点，更常用）\">6. GEORADIUSBYMEMBER：按已有成员为中心，筛选指定范围的成员（范围查询2，按已有节点，更常用）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>即将弃用，请使用 <code>GEOSEARCH</code> / <code>GEOSEARCHSTORE</code> 替代<br>\n◦ 语法：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GEORADIUSBYMEMBER key member radius M|KM|FT|MI [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count [ANY]] [ASC|DESC] [STORE key|STOREDIST key]</span><br><span class=\"line\"><span class=\"comment\"># 语法说明：</span></span><br><span class=\"line\"><span class=\"comment\"># key: key名称</span></span><br><span class=\"line\"><span class=\"comment\"># member: 已有成员名称</span></span><br><span class=\"line\"><span class=\"comment\"># radius: 半径</span></span><br><span class=\"line\"><span class=\"comment\"># M|KM|FT|MI: 单位</span></span><br><span class=\"line\"><span class=\"comment\">## 可选参数说明同 GEORADIUS</span></span><br></pre></td></tr></table></figure>\n<p>◦ 可选参数与GEORADIUS一致，场景更贴合实际（如查“我附近”的门店，先存自己的坐标为成员，再用此命令）<br>\n◦ 示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查王府井3km内的门店，按距离排序</span></span><br><span class=\"line\">GEORADIUSBYMEMBER shop wangfujing 3 km WITHDIST ASC</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;wangfujing&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;0.0000&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;xidan&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;1.4681&quot;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Geo-扩展操作（实战常用）\">Geo 扩展操作（实战常用）</h2>\n<h3 id=\"1-GEOSEARCH（Redis-6-2-新增，替代-GEORADIUS-GEORADIUSBYMEMBER）\">1. GEOSEARCH（Redis 6.2+ 新增，替代 GEORADIUS/GEORADIUSBYMEMBER）</h3>\n<p>◦ 优势：功能更全、语法更统一，支持两种查询模式，是未来主流用法</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GEOSEARCH key &lt;FROMMEMBER member | FROMLONLAT longitude latitude&gt;</span><br><span class=\"line\">  &lt;BYRADIUS radius &lt;M | KM | FT | MI&gt; | BYBOX width height &lt;M | KM | FT | MI&gt;&gt;</span><br><span class=\"line\">  [ASC | DESC] [COUNT count [ANY]] [WITHCOORD] [WITHDIST] [WITHHASH]</span><br></pre></td></tr></table></figure>\n<p>◦ 语法1（按坐标中心）：<code>GEOSEARCH key FROMLONLAT 经度 纬度 BYRADIUS 距离 单位 [可选参数]</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查天安门3km内的门店，按距离排序</span></span><br><span class=\"line\">GEOSEARCH shop FROMLONLAT 116.397 39.91 BYRADIUS 3 km WITHDIST WITHCOORD WITHHASH ASC COUNT 10</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;xidan&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;0.6463&quot;</span></span><br><span class=\"line\">   3) (<span class=\"built_in\">integer</span>) 4069885362016563</span><br><span class=\"line\">   4) 1) <span class=\"string\">&quot;116.39124959707260132&quot;</span></span><br><span class=\"line\">      2) <span class=\"string\">&quot;39.90621776267477827&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;wangfujing&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;0.8223&quot;</span></span><br><span class=\"line\">   3) (<span class=\"built_in\">integer</span>) 4069885555089518</span><br><span class=\"line\">   4) 1) <span class=\"string\">&quot;116.40396326780319214&quot;</span></span><br><span class=\"line\">      2) <span class=\"string\">&quot;39.91511209922290249&quot;</span></span><br></pre></td></tr></table></figure>\n<p>◦ 语法2（按成员中心）：<code>GEOSEARCH key FROMMEMBER 中心成员 BYRADIUS 距离 单位 [可选参数]</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查王府井3km内的门店，按距离排序</span></span><br><span class=\"line\">GEOSEARCH shop FROMMEMBER wangfujing BYRADIUS 3 km WITHDIST WITHCOORD WITHHASH ASC COUNT 10</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;wangfujing&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;0.0000&quot;</span></span><br><span class=\"line\">   3) (<span class=\"built_in\">integer</span>) 4069885555089518</span><br><span class=\"line\">   4) 1) <span class=\"string\">&quot;116.40396326780319214&quot;</span></span><br><span class=\"line\">      2) <span class=\"string\">&quot;39.91511209922290249&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;xidan&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;1.4681&quot;</span></span><br><span class=\"line\">   3) (<span class=\"built_in\">integer</span>) 4069885362016563</span><br><span class=\"line\">   4) 1) <span class=\"string\">&quot;116.39124959707260132&quot;</span></span><br><span class=\"line\">      2) <span class=\"string\">&quot;39.90621776267477827&quot;</span></span><br></pre></td></tr></table></figure>\n<p>◦ 新增特性：支持 <code>BYBOX（按矩形范围查询）</code>，适配更多场景（如查询某片区内的门店）。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查王府井2.0*2.0km内的门店，按距离排序，这里以 王府井 为矩形的中心，查询2.0*2.0km内的门店</span></span><br><span class=\"line\"><span class=\"comment\"># 西单距离王府井 1.4681 km，所以不在结果中</span></span><br><span class=\"line\">GEOSEARCH shop FROMMEMBER wangfujing BYBOX 2.0 2.0 km WITHDIST WITHCOORD WITHHASH ASC COUNT 10</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) 1) <span class=\"string\">&quot;wangfujing&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;0.0000&quot;</span></span><br><span class=\"line\">   3) (<span class=\"built_in\">integer</span>) 4069885555089518</span><br><span class=\"line\">   4) 1) <span class=\"string\">&quot;116.40396326780319214&quot;</span></span><br><span class=\"line\">      2) <span class=\"string\">&quot;39.91511209922290249&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-GEOSEARCHSTORE（Redis-6-2-新增）\">2. GEOSEARCHSTORE（Redis 6.2+ 新增）</h3>\n<p>◦ 作用：将 GEOSEARCH 的查询结果，直接存储到指定zset中，方便后续二次处理（如分页、排序）<br>\n◦ 语法：GEOSEARCHSTORE 目标key 源key 查询条件（同GEOSEARCH）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GEOSEARCHSTORE destination <span class=\"built_in\">source</span></span><br><span class=\"line\">  &lt;FROMMEMBER member | FROMLONLAT longitude latitude&gt;</span><br><span class=\"line\">  &lt;BYRADIUS radius &lt;M | KM | FT | MI&gt; | BYBOX width height &lt;M | KM | FT | MI&gt;&gt;</span><br><span class=\"line\">  [ASC | DESC] [COUNT count [ANY]] [STOREDIST]</span><br></pre></td></tr></table></figure>\n<p>◦ 示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 把王府井3km内的门店，存到near_shop集合</span></span><br><span class=\"line\">GEOSEARCHSTORE near_shop shop FROMMEMBER wangfujing BYRADIUS 3 km</span><br></pre></td></tr></table></figure>\n<h2 id=\"底层核心与实战注意事项\">底层核心与实战注意事项</h2>\n<ol>\n<li class=\"lvl-3\">\n<p>底层本质：所有Geo操作的key，本质都是zset，因此zset的命令（如ZREM、ZSCORE）可直接用于Geo key，例如 ZREM shop xidan 可删除西单的地理位置（Geo无单独删除命令，依赖ZREM）。</p>\n</li>\n<li class=\"lvl-3\">\n<p>精度限制：经纬度支持小数点后多位，但Redis内部会做精度取舍，日常场景（如打车、门店）完全够用，无需额外处理。</p>\n</li>\n<li class=\"lvl-3\">\n<p>性能优化：大范围查询（如100km以上）建议加COUNT限制返回数量；高频查询可将结果缓存到普通key，减少Geo计算开销。</p>\n</li>\n<li class=\"lvl-3\">\n<p>适用场景：附近门店、同城社交、物流定位，不适用高精度场景（如军事、测绘），此类场景需用专业GIS系统。</p>\n</li>\n</ol>\n<h2 id=\"典型实战场景示例\">典型实战场景示例</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>需求：搭建“附近餐饮”查询功能，支持添加餐饮坐标、查询当前位置3km内餐饮并按距离排序。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. 批量添加餐饮坐标</span></span><br><span class=\"line\">GEOADD restaurant 116.405 39.916 aaa 116.402 39.913 bbb 116.408 39.918 ccc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. 查当前位置（116.404,39.915）3km内餐饮（带距离、正序）</span></span><br><span class=\"line\">GEOSEARCH restaurant FROMLONLAT 116.404 39.915 BYRADIUS 3 km WITHDIST ASC</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. 删除某餐饮</span></span><br><span class=\"line\">ZREM restaurant aaa</span><br></pre></td></tr></table></figure>\n<h2 id=\"Geo-命令\">Geo 命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot 的 <code>StringRedisTemplate.opsForGeo()</code> 中 Geo 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p>\n</li>\n</ul>\n<blockquote>\n<p>注意这里一定要用 <code>StringRedisTemplate</code> 来操作 Geo</p>\n</blockquote>\n<h3 id=\"写入-删除类操作\">写入 / 删除类操作</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>添加单个坐标</td>\n<td><code>add(K key, Point point, M member)</code></td>\n<td><code>GEOADD key longitude latitude member</code></td>\n<td>返回 <strong>新增成员数量</strong>（已存在则返回 0）</td>\n</tr>\n<tr>\n<td>添加单个位置</td>\n<td><code>add(K key, GeoLocation&lt;M&gt; location)</code></td>\n<td><code>GEOADD key longitude latitude member</code></td>\n<td><code>GeoLocation</code> 内部封装了 <code>Point + member</code></td>\n</tr>\n<tr>\n<td>批量添加</td>\n<td><code>add(K key, Map&lt;M, Point&gt; map)</code></td>\n<td><code>GEOADD key lon1 lat1 member1 [lon2 lat2 member2 ...]</code></td>\n<td><strong>推荐</strong>，一次网络 IO</td>\n</tr>\n<tr>\n<td>批量添加</td>\n<td><code>add(K key, Iterable&lt;GeoLocation&lt;M&gt;&gt; locations)</code></td>\n<td><code>GEOADD key lon1 lat1 member1 [lon2 lat2 member2 ...]</code></td>\n<td>与 Map 方式等价</td>\n</tr>\n<tr>\n<td>删除成员</td>\n<td><code>remove(K key, M... members)</code></td>\n<td><code>ZREM key member [member ...]</code></td>\n<td>GEO 本质是 <strong>Sorted Set</strong></td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Point</span> <span class=\"variable\">point</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Point</span>(longitude, latitude);</span><br><span class=\"line\">redisTemplate.opsForGeo().add(key, point, member);</span><br><span class=\"line\"></span><br><span class=\"line\">RedisGeoCommands.GeoLocation&lt;String&gt; geoLocation= <span class=\"keyword\">new</span> <span class=\"title class_\">RedisGeoCommands</span>.GeoLocation&lt;&gt;(member, point);</span><br><span class=\"line\">redisTemplate.opsForGeo().add(key, geoLocation);</span><br></pre></td></tr></table></figure>\n<h3 id=\"距离-坐标-哈希查询\">距离 / 坐标 / 哈希查询</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>两点距离</td>\n<td><code>distance(K key, m1, m2)</code></td>\n<td><code>GEODIST key m1 m2</code></td>\n<td>默认单位米</td>\n</tr>\n<tr>\n<td>指定单位距离</td>\n<td><code>distance(K key, m1, m2, metric)</code></td>\n<td><code>GEODIST key m1 m2 unit</code></td>\n<td>m / km / mi / ft</td>\n</tr>\n<tr>\n<td>获取 GeoHash</td>\n<td><code>hash(K key, M... members)</code></td>\n<td><code>GEOHASH key member</code></td>\n<td>用于调试</td>\n</tr>\n<tr>\n<td>获取坐标</td>\n<td><code>position(K key, M... members)</code></td>\n<td><code>GEOPOS key member</code></td>\n<td>lon / lat</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"半径查询（旧接口，已不推荐）\">半径查询（旧接口，已不推荐）</h3>\n<blockquote>\n<p>Redis 6.2 起，官方不推荐继续使用 GEORADIUS / GEORADIUSBYMEMBER，但 Spring 仍保留接口以兼容。</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1️⃣ 基于坐标点</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>半径查询</td>\n<td><code>radius(K key, Circle within)</code></td>\n<td><code>GEORADIUS key lon lat radius</code></td>\n</tr>\n<tr>\n<td>半径 + 参数</td>\n<td><code>radius(K key, Circle within, args)</code></td>\n<td><code>GEORADIUS</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2️⃣ 基于成员</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>半径查询</td>\n<td><code>radius(K key, member, radius)</code></td>\n<td><code>GEORADIUSBYMEMBER</code></td>\n</tr>\n<tr>\n<td>指定单位</td>\n<td><code>radius(K key, member, Distance)</code></td>\n<td><code>GEORADIUSBYMEMBER</code></td>\n</tr>\n<tr>\n<td>带参数</td>\n<td><code>radius(K key, member, Distance, args)</code></td>\n<td><code>GEORADIUSBYMEMBER</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"搜索查询（推荐使用-GEOSEARCH）\">搜索查询（推荐使用 GEOSEARCH）</h3>\n<blockquote>\n<p>替代 GEORADIUS / GEORADIUSBYMEMBER</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1️⃣ 按圆形范围搜索</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>圆形搜索</td>\n<td><code>search(K key, Circle within)</code></td>\n<td><code>GEOSEARCH</code></td>\n<td>新推荐接口</td>\n</tr>\n<tr>\n<td>指定参考点</td>\n<td><code>search(K key, GeoReference, Distance)</code></td>\n<td><code>GEOSEARCH</code></td>\n<td>FROMMEMBER / FROMLONLAT</td>\n</tr>\n<tr>\n<td>带参数</td>\n<td><code>search(K key, reference, radius, args)</code></td>\n<td><code>GEOSEARCH</code></td>\n<td>支持排序、limit</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2️⃣ 按矩形范围搜索</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>矩形搜索</td>\n<td><code>search(K key, reference, BoundingBox)</code></td>\n<td><code>GEOSEARCH</code></td>\n</tr>\n<tr>\n<td>带参数</td>\n<td><code>search(K key, reference, BoundingBox, args)</code></td>\n<td><code>GEOSEARCH</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>通用搜索（底层能力）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>任意 GeoShape</td>\n<td><code>search(K key, reference, GeoShape, args)</code></td>\n<td><code>GEOSEARCH</code></td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 基于给定的坐标搜索</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">search</span><span class=\"params\">(String key, <span class=\"type\">double</span> longitude, <span class=\"type\">double</span> latitude, <span class=\"type\">double</span> radius)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 中心点</span></span><br><span class=\"line\">    <span class=\"type\">Point</span> <span class=\"variable\">point</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Point</span>(longitude, latitude);</span><br><span class=\"line\">    <span class=\"comment\">// 半径</span></span><br><span class=\"line\">    <span class=\"type\">Distance</span> <span class=\"variable\">distance</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Distance</span>(radius, RedisGeoCommands.DistanceUnit.METERS);</span><br><span class=\"line\">    <span class=\"comment\">// 创建圆形</span></span><br><span class=\"line\">    <span class=\"type\">Circle</span> <span class=\"variable\">circle</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Circle</span>(point, distance);</span><br><span class=\"line\">    <span class=\"comment\">// 创建地理参考</span></span><br><span class=\"line\">    GeoReference&lt;String&gt; objectGeoReference = GeoReference.fromCircle(circle);</span><br><span class=\"line\">    <span class=\"comment\">// 创建地理形状</span></span><br><span class=\"line\">    <span class=\"type\">GeoShape</span> <span class=\"variable\">geoShape</span> <span class=\"operator\">=</span> GeoShape.byRadius(distance);</span><br><span class=\"line\">    <span class=\"comment\">// 创建参数</span></span><br><span class=\"line\">    RedisGeoCommands.<span class=\"type\">GeoRadiusCommandArgs</span> <span class=\"variable\">args</span> <span class=\"operator\">=</span> RedisGeoCommands.GeoRadiusCommandArgs.newGeoRadiusArgs()</span><br><span class=\"line\">            .includeCoordinates() <span class=\"comment\">// 返回坐标</span></span><br><span class=\"line\">            .includeDistance() <span class=\"comment\">// 返回距离</span></span><br><span class=\"line\">            .sortAscending() <span class=\"comment\">// 排序</span></span><br><span class=\"line\">            .limit(<span class=\"number\">10</span>); <span class=\"comment\">// 限制返回数量</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 查询</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = redisTemplate.opsForGeo().search(key, objectGeoReference, geoShape, args);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (results != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        results.forEach(result -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取成员名称</span></span><br><span class=\"line\">            System.out.println(result.getContent().getName());</span><br><span class=\"line\">            <span class=\"comment\">// 获取坐标</span></span><br><span class=\"line\">            System.out.println(result.getContent().getPoint());</span><br><span class=\"line\">            <span class=\"comment\">// 获取距离</span></span><br><span class=\"line\">            System.out.println(result.getDistance());</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 基于成员的坐标搜索</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">search</span><span class=\"params\">(String key, String member, <span class=\"type\">double</span> radius)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 半径</span></span><br><span class=\"line\">    <span class=\"type\">Distance</span> <span class=\"variable\">distance</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Distance</span>(radius, RedisGeoCommands.DistanceUnit.METERS);</span><br><span class=\"line\">    <span class=\"comment\">// 创建地理参考</span></span><br><span class=\"line\">    GeoReference&lt;String&gt; objectGeoReference = GeoReference.fromMember(member);</span><br><span class=\"line\">    <span class=\"comment\">// 创建地理形状</span></span><br><span class=\"line\">    <span class=\"type\">GeoShape</span> <span class=\"variable\">geoShape</span> <span class=\"operator\">=</span> GeoShape.byRadius(distance);</span><br><span class=\"line\">    <span class=\"comment\">// 创建参数</span></span><br><span class=\"line\">    RedisGeoCommands.<span class=\"type\">GeoRadiusCommandArgs</span> <span class=\"variable\">args</span> <span class=\"operator\">=</span> RedisGeoCommands.GeoRadiusCommandArgs.newGeoRadiusArgs()</span><br><span class=\"line\">            .includeCoordinates() <span class=\"comment\">// 返回坐标</span></span><br><span class=\"line\">            .includeDistance() <span class=\"comment\">// 返回距离</span></span><br><span class=\"line\">            .sortAscending() <span class=\"comment\">// 排序</span></span><br><span class=\"line\">            .limit(<span class=\"number\">10</span>); <span class=\"comment\">// 限制返回数量</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 查询</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = redisTemplate.opsForGeo().search(key, objectGeoReference, geoShape, args);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (results != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        results.forEach(result -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取成员名称</span></span><br><span class=\"line\">            System.out.println(result.getContent().getName());</span><br><span class=\"line\">            <span class=\"comment\">// 获取坐标</span></span><br><span class=\"line\">            System.out.println(result.getContent().getPoint());</span><br><span class=\"line\">            <span class=\"comment\">// 获取距离</span></span><br><span class=\"line\">            System.out.println(result.getDistance());</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"搜索并存储（GEOSEARCHSTORE）\">搜索并存储（GEOSEARCHSTORE）</h3>\n<blockquote>\n<p>这是 搜索 + 写入 的组合操作，结果会写入新的 ZSet</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1️⃣ 圆形范围存储</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>搜索并存储</td>\n<td><code>searchAndStore(K key, destKey, Circle)</code></td>\n<td><code>GEOSEARCHSTORE</code></td>\n</tr>\n<tr>\n<td>指定参考点</td>\n<td><code>searchAndStore(K key, destKey, reference, radius)</code></td>\n<td><code>GEOSEARCHSTORE</code></td>\n</tr>\n<tr>\n<td>带参数</td>\n<td><code>searchAndStore(K key, destKey, reference, radius, args)</code></td>\n<td><code>GEOSEARCHSTORE</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2️⃣ 矩形范围存储</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>矩形存储</td>\n<td><code>searchAndStore(K key, destKey, reference, BoundingBox)</code></td>\n<td><code>GEOSEARCHSTORE</code></td>\n</tr>\n<tr>\n<td>带参数</td>\n<td><code>searchAndStore(K key, destKey, reference, BoundingBox, args)</code></td>\n<td><code>GEOSEARCHSTORE</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>3️⃣ 通用 GeoShape 存储</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>通用存储</td>\n<td><code>searchAndStore(K key, destKey, reference, GeoShape, args)</code></td>\n<td><code>GEOSEARCHSTORE</code></td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 Redis Geo 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ Geo 核心详解 Redis Geo 是基于有序集合（zset） 实现的地理空间操作功能，底层用geohash编码存储经纬度，核心支持 6 个基础操作 + 2 个扩展操作，兼顾精准存储、距离计算、范围筛选等核心需求，直接对接实际场景（如附近门店、同城好友）。 有效经度(longitude)为 -180 ~ 180，有效纬度(latitude)为 -85.05112878 ~ 85.05112878。 Redis 内部实现中： 123GEO 数据 ≈ ZSETscore = GeoHash（52 位bit ≈ 11 个字符）member = 实际成员名 Geohash 是什么? Geohash 是一种将二维地理坐标（经度、纬度）编码为一维字符串或整数的空间索引算法，核心目标是： 123将「位置」映射为「可排序的值」相近的地理位置 → 前缀相同或接近便于 范围查询、邻近查询、索引存储 核心思想 不断对经纬度区间进行二分，并交叉编码 编码顺序：经度 → 纬度 → 经度 → 纬度 → … 123456每一步： 1.取当前区间的中点 2.大于中点记为 1 3.小于中点记为 0 4.缩小区间，继续下一位最终得到一个 bit 序列。 Redis 内部的 Geohash 字符 = 52bit，即 经度 26 bit，纬度 26 bit 123456每个字符 = 5 bit内部 52 bit → 按 5 bit 分组 → 52 ÷ 5 = 10 余 2 bitRedis 默认在输出字符串时： 会把 剩余的 2 bit 填充成完整字符，即末尾补三个 0 因此最终得到 11 个 Base32 字符 Geohash 计算过程示例 12longitude = 116.397128latitude = 39.916527 为了简化计算过程，我们这里固定一个常用精度： 精度选择：5 个 Geohash 字符 = 25 个 bit ⇒ 经度 13 bit，纬度 12 bit（奇数位经度） 逐位计算（关键过程） 1️⃣ 经度 bit（13 位） 位次 区间 mid 判断 bit 1 [-180,180] 0 116 ≥ 0 1 2 [0,180] 90 116 ≥ 90 1 3 [90,180] 135 116 &lt; 135 0 4 [90,135] 112.5 116 ≥ 112.5 1 5 [112.5,135] 123.75 116 &lt; 123.75 0 6 [112.5,123.75] 118.125 116 &lt; 118.125 0 7 [112.5,118.125] 115.3125 116 ≥ 115.3125 1 8 [115.3125,118.125] 116.71875 116 &lt; 116.71875 0 9 [115.3125,116.71875] 116.015625 116 ≥ 116.015625 1 10 [116.015625,116.71875] 116.3671875 116 ≥ 116.3671875 1 11 [116.3671875,116.71875] 116.54296875 116 &lt; 116.54296875 0 12 [116.3671875,116.54296875] 116.455078125 116 &lt; 116.455078125 0 13 [116.3671875,116.455078125] 116.4111328125 116 &lt; 116.4111328125 0 经度 bit（13 位）：1101001011000 2️⃣ 纬度 bit（12 位） 位次 区间 mid 判断 bit 1 [-90,90] 0 39 ≥ 0 1 2 [0,90] 45 39 &lt; 45 0 3 [0,45] 22.5 39 ≥ 22.5 1 4 [22.5,45] 33.75 39 ≥ 33.75 1 5 [33.75,45] 39.375 39 &lt; 39.375 0 6 [33.75,39.375] 36.5625 39 ≥ 36.5625 1 7 [36.5625,39.375] 37.96875 39 ≥ 37.96875 1 8 [37.96875,39.375] 38.671875 39 ≥ 38.671875 1 9 [38.671875,39.375] 39.0234375 39 &lt; 39.0234375 0 10 [38.671875,39.0234375] 38.84765625 39 ≥ 38.84765625 1 11 [38.84765625,39.0234375] 38.935546875 39 ≥ 38.935546875 1 12 [38.935546875,39.0234375] 38.9794921875 39 ≥ 38.9794921875 1 纬度 bit（12 位）：101101110111 交叉合并（最终 bit 序列） 按规则：经度 → 纬度 → 经度 → 纬度 … 12345经度: 1 1 0 1 0 0 1 0 1 1 0 0 0纬度: 1 0 1 1 0 1 1 1 0 1 1 1交叉后得到 25 bit：11 10 01 11 00 01 11 01 10 11 01 01 01合并为一行：1110011100011101101010101 每 5 bit → 1 个 Base32 字符 12345678# 从左到右，每 5 位一组：11100 | 11100 | 01110 | 11010 | 10101# 转10进制28 | 28 | 14 | 26 | 21# 转 Base32w | w | f | u | p# 最终结果：wwfup Geohash 使用的 Base32 字符集（固定，不是 RFC Base32）： 1234567891011Index: 0 1 2 3 4 5 6 7 8 9Char : 0 1 2 3 4 5 6 7 8 9Index: 10 11 12 13 14 15 16 17 18 19Char : b c d e f g h j k mIndex: 20 21 22 23 24 25 26 27 28 29Char : n p q r s t u v w xIndex: 30 31Char : y z Geohash Base32 字符集 为什么缺少 a, i, l, o 为了避免在视觉上引起数字混淆 1234a 容易和 4 混淆i 容易和 1 混淆l 容易和 1 混淆o 容易和 0 混淆 去掉 a, i, l, o 后刚好是 32 个字符，因为 Geohash 需要 2⁵ = 32 个字符 对应 5 bit 精度 Geo 核心基础操作（必用） 1. GEOADD：添加地理位置坐标（核心写入操作） ◦ 语法： 12345678910GEOADD key [NX | XX] [CH] longitude latitude member [longitude latitude member ...]# 参数说明：# key: key名称# NX：如果已存在，则不执行写入操作# XX: 如果不存在，则执行写入操作，与 NX 互斥# CH: （CH是更改的缩写）返回新增和修改的成员数量，修改经纬度也算修改，如果不加CH，则只计算新增成员数量# longitude: 经度 (-180 ~ 180)# latitude: 纬度 (-85.05112878 ~ 85.05112878)# member: 成员名称，位置唯一标识（字符串）# 返回值：(不带CH)成功新增的 member 数量（已存在不会重复计算），(带CH)返回新增和修改的成员数量 ◦ 示例： 1234# 给shop集合加王府井、西单2个门店的经纬度GEOADD shop 116.403963 39.915112 wangfujing 116.391248 39.906217 xidan# 输出(integer) 2 ◦ 关键：经纬度顺序不能反，存储后会自动给每个成员生成geohash编码。 2. GEOPOS：获取指定成员的经纬度（精准查询坐标） ◦ 语法： 1GEOPOS key [member [member ...]] ◦ 示例： 12345# 返回王府井的经纬度数组 [经度, 纬度]GEOPOS shop wangfujing# 输出1) 1) &quot;116.40396326780319214&quot; 2) &quot;39.91511209922290249&quot; ◦ 关键：返回结果与查询成员顺序一致，不存在的成员返回nil，可批量查询提升效率。 3. GEODIST：计算两个成员之间的距离（核心计算操作） ◦ 语法： 123456GEODIST key member1 member2 [M|KM|FT|MI]# [M|KM|FT|MI] : 距离单位# M : 米，默认# KM : 千米# FT : 英尺# MI : 英里 ◦ 示例： 123456789# 返回王府井和西单之间的距离，单位为米GEODIST shop wangfujing xidan# 输出&quot;1468.0611&quot;# 计算王府井到西单的距离，单位千米GEODIST shop wangfujing xidan km# 输出&quot;1.4681&quot; ◦ 关键：返回浮点型结果，成员不存在返回nil，支持跨区域距离计算（如不同城市门店）。 4. GEOHASH：获取指定成员的geohash编码（底层编码查询） ◦ 语法： 1GEOHASH key [member [member ...]] ◦ 示例： 1234# 返回王府井的geohash字符串，共11位GEOHASH shop wangfujing# 输出1) &quot;wx4g0f6f2u0&quot; ◦ 关键：geohash编码越长精度越高，Redis默认精度足够日常使用；编码相同的成员，地理位置极近，可用于快速判近。 5. GEORADIUS：按指定经纬度为中心，筛选指定范围的成员（范围查询1，按中心点坐标） 即将弃用，请使用 GEOSEARCH / GEOSEARCHSTORE 替代 ◦ 语法： 12345678910111213141516GEORADIUS key longitude latitude radius M|KM|FT|MI [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count [ANY]] [ASC|DESC] [STORE key|STOREDIST key]# 参数说明# key: key名称# longitude: 经度# latitude: 纬度# radius: 半径# M|KM|FT|MI: 单位## 可选参数# WITHCOORD: 返回经纬度# WITHDIST: 带距离# WITHHASH: 带geohash# COUNT count: 限制返回数量# ANY: 随机返回数量# ASC/DESC: 按距离正/倒序# STORE key: 存储结果到指定key# STOREDIST key: 存储结果到指定key，结果为距离 ◦ 核心可选参数：WITHDIST（返回距离）、WITHCOORD（返回经纬度）、WITHHASH（返回geohash）、COUNT n（限制返回数量）、ASC/DESC（按距离正/倒序） ◦ 示例： 1234567# 以天安门附近为中心，查5km内10个门店，按距离从近到远返回并带距离GEORADIUS shop 116.397 39.91 5 km WITHDIST COUNT 10 ASC# 输出1) 1) &quot;xidan&quot; 2) &quot;0.6463&quot;2) 1) &quot;wangfujing&quot; 2) &quot;0.8223&quot; 6. GEORADIUSBYMEMBER：按已有成员为中心，筛选指定范围的成员（范围查询2，按已有节点，更常用） 即将弃用，请使用 GEOSEARCH / GEOSEARCHSTORE 替代 ◦ 语法： 1234567GEORADIUSBYMEMBER key member radius M|KM|FT|MI [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count [ANY]] [ASC|DESC] [STORE key|STOREDIST key]# 语法说明：# key: key名称# member: 已有成员名称# radius: 半径# M|KM|FT|MI: 单位## 可选参数说明同 GEORADIUS ◦ 可选参数与GEORADIUS一致，场景更贴合实际（如查“我附近”的门店，先存自己的坐标为成员，再用此命令） ◦ 示例： 1234567# 查王府井3km内的门店，按距离排序GEORADIUSBYMEMBER shop wangfujing 3 km WITHDIST ASC# 输出1) 1) &quot;wangfujing&quot; 2) &quot;0.0000&quot;2) 1) &quot;xidan&quot; 2) &quot;1.4681&quot; Geo 扩展操作（实战常用） 1. GEOSEARCH（Redis 6.2+ 新增，替代 GEORADIUS/GEORADIUSBYMEMBER） ◦ 优势：功能更全、语法更统一，支持两种查询模式，是未来主流用法 123GEOSEARCH key &lt;FROMMEMBER member | FROMLONLAT longitude latitude&gt; &lt;BYRADIUS radius &lt;M | KM | FT | MI&gt; | BYBOX width height &lt;M | KM | FT | MI&gt;&gt; [ASC | DESC] [COUNT count [ANY]] [WITHCOORD] [WITHDIST] [WITHHASH] ◦ 语法1（按坐标中心）：GEOSEARCH key FROMLONLAT 经度 纬度 BYRADIUS 距离 单位 [可选参数] 12345678910111213# 查天安门3km内的门店，按距离排序GEOSEARCH shop FROMLONLAT 116.397 39.91 BYRADIUS 3 km WITHDIST WITHCOORD WITHHASH ASC COUNT 10# 输出1) 1) &quot;xidan&quot; 2) &quot;0.6463&quot; 3) (integer) 4069885362016563 4) 1) &quot;116.39124959707260132&quot; 2) &quot;39.90621776267477827&quot;2) 1) &quot;wangfujing&quot; 2) &quot;0.8223&quot; 3) (integer) 4069885555089518 4) 1) &quot;116.40396326780319214&quot; 2) &quot;39.91511209922290249&quot; ◦ 语法2（按成员中心）：GEOSEARCH key FROMMEMBER 中心成员 BYRADIUS 距离 单位 [可选参数] 12345678910111213# 查王府井3km内的门店，按距离排序GEOSEARCH shop FROMMEMBER wangfujing BYRADIUS 3 km WITHDIST WITHCOORD WITHHASH ASC COUNT 10# 输出1) 1) &quot;wangfujing&quot; 2) &quot;0.0000&quot; 3) (integer) 4069885555089518 4) 1) &quot;116.40396326780319214&quot; 2) &quot;39.91511209922290249&quot;2) 1) &quot;xidan&quot; 2) &quot;1.4681&quot; 3) (integer) 4069885362016563 4) 1) &quot;116.39124959707260132&quot; 2) &quot;39.90621776267477827&quot; ◦ 新增特性：支持 BYBOX（按矩形范围查询），适配更多场景（如查询某片区内的门店）。 123456789# 查王府井2.0*2.0km内的门店，按距离排序，这里以 王府井 为矩形的中心，查询2.0*2.0km内的门店# 西单距离王府井 1.4681 km，所以不在结果中GEOSEARCH shop FROMMEMBER wangfujing BYBOX 2.0 2.0 km WITHDIST WITHCOORD WITHHASH ASC COUNT 10# 输出1) 1) &quot;wangfujing&quot; 2) &quot;0.0000&quot; 3) (integer) 4069885555089518 4) 1) &quot;116.40396326780319214&quot; 2) &quot;39.91511209922290249&quot; 2. GEOSEARCHSTORE（Redis 6.2+ 新增） ◦ 作用：将 GEOSEARCH 的查询结果，直接存储到指定zset中，方便后续二次处理（如分页、排序） ◦ 语法：GEOSEARCHSTORE 目标key 源key 查询条件（同GEOSEARCH） 1234GEOSEARCHSTORE destination source &lt;FROMMEMBER member | FROMLONLAT longitude latitude&gt; &lt;BYRADIUS radius &lt;M | KM | FT | MI&gt; | BYBOX width height &lt;M | KM | FT | MI&gt;&gt; [ASC | DESC] [COUNT count [ANY]] [STOREDIST] ◦ 示例： 12# 把王府井3km内的门店，存到near_shop集合GEOSEARCHSTORE near_shop shop FROMMEMBER wangfujing BYRADIUS 3 km 底层核心与实战注意事项 底层本质：所有Geo操作的key，本质都是zset，因此zset的命令（如ZREM、ZSCORE）可直接用于Geo key，例如 ZREM shop xidan 可删除西单的地理位置（Geo无单独删除命令，依赖ZREM）。 精度限制：经纬度支持小数点后多位，但Redis内部会做精度取舍，日常场景（如打车、门店）完全够用，无需额外处理。 性能优化：大范围查询（如100km以上）建议加COUNT限制返回数量；高频查询可将结果缓存到普通key，减少Geo计算开销。 适用场景：附近门店、同城社交、物流定位，不适用高精度场景（如军事、测绘），此类场景需用专业GIS系统。 典型实战场景示例 需求：搭建“附近餐饮”查询功能，支持添加餐饮坐标、查询当前位置3km内餐饮并按距离排序。 12345678# 1. 批量添加餐饮坐标GEOADD restaurant 116.405 39.916 aaa 116.402 39.913 bbb 116.408 39.918 ccc# 2. 查当前位置（116.404,39.915）3km内餐饮（带距离、正序）GEOSEARCH restaurant FROMLONLAT 116.404 39.915 BYRADIUS 3 km WITHDIST ASC# 3. 删除某餐饮ZREM restaurant aaa Geo 命令 SpringBoot 的 StringRedisTemplate.opsForGeo() 中 Geo 数据类型 的操作方法与 Redis 原生命令的对应关系如下： 注意这里一定要用 StringRedisTemplate 来操作 Geo 写入 / 删除类操作 方法功能 方法 Redis 原始命令 备注 添加单个坐标 add(K key, Point point, M member) GEOADD key longitude latitude member 返回 新增成员数量（已存在则返回 0） 添加单个位置 add(K key, GeoLocation&lt;M&gt; location) GEOADD key longitude latitude member GeoLocation 内部封装了 Point + member 批量添加 add(K key, Map&lt;M, Point&gt; map) GEOADD key lon1 lat1 member1 [lon2 lat2 member2 ...] 推荐，一次网络 IO 批量添加 add(K key, Iterable&lt;GeoLocation&lt;M&gt;&gt; locations) GEOADD key lon1 lat1 member1 [lon2 lat2 member2 ...] 与 Map 方式等价 删除成员 remove(K key, M... members) ZREM key member [member ...] GEO 本质是 Sorted Set 12345Point point = new Point(longitude, latitude);redisTemplate.opsForGeo().add(key, point, member);RedisGeoCommands.GeoLocation&lt;String&gt; geoLocation= new RedisGeoCommands.GeoLocation&lt;&gt;(member, point);redisTemplate.opsForGeo().add(key, geoLocation); 距离 / 坐标 / 哈希查询 方法功能 方法 Redis 原始命令 说明 两点距离 distance(K key, m1, m2) GEODIST key m1 m2 默认单位米 指定单位距离 distance(K key, m1, m2, metric) GEODIST key m1 m2 unit m / km / mi / ft 获取 GeoHash hash(K key, M... members) GEOHASH key member 用于调试 获取坐标 position(K key, M... members) GEOPOS key member lon / lat 半径查询（旧接口，已不推荐） Redis 6.2 起，官方不推荐继续使用 GEORADIUS / GEORADIUSBYMEMBER，但 Spring 仍保留接口以兼容。 1️⃣ 基于坐标点 方法功能 方法 Redis 原始命令 半径查询 radius(K key, Circle within) GEORADIUS key lon lat radius 半径 + 参数 radius(K key, Circle within, args) GEORADIUS 2️⃣ 基于成员 方法功能 方法 Redis 原始命令 半径查询 radius(K key, member, radius) GEORADIUSBYMEMBER 指定单位 radius(K key, member, Distance) GEORADIUSBYMEMBER 带参数 radius(K key, member, Distance, args) GEORADIUSBYMEMBER 搜索查询（推荐使用 GEOSEARCH） 替代 GEORADIUS / GEORADIUSBYMEMBER 1️⃣ 按圆形范围搜索 方法功能 方法 Redis 原始命令 说明 圆形搜索 search(K key, Circle within) GEOSEARCH 新推荐接口 指定参考点 search(K key, GeoReference, Distance) GEOSEARCH FROMMEMBER / FROMLONLAT 带参数 search(K key, reference, radius, args) GEOSEARCH 支持排序、limit 2️⃣ 按矩形范围搜索 方法功能 方法 Redis 原始命令 矩形搜索 search(K key, reference, BoundingBox) GEOSEARCH 带参数 search(K key, reference, BoundingBox, args) GEOSEARCH 通用搜索（底层能力） 方法功能 方法 Redis 原始命令 任意 GeoShape search(K key, reference, GeoShape, args) GEOSEARCH 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 基于给定的坐标搜索public void search(String key, double longitude, double latitude, double radius) &#123; // 中心点 Point point = new Point(longitude, latitude); // 半径 Distance distance = new Distance(radius, RedisGeoCommands.DistanceUnit.METERS); // 创建圆形 Circle circle = new Circle(point, distance); // 创建地理参考 GeoReference&lt;String&gt; objectGeoReference = GeoReference.fromCircle(circle); // 创建地理形状 GeoShape geoShape = GeoShape.byRadius(distance); // 创建参数 RedisGeoCommands.GeoRadiusCommandArgs args = RedisGeoCommands.GeoRadiusCommandArgs.newGeoRadiusArgs() .includeCoordinates() // 返回坐标 .includeDistance() // 返回距离 .sortAscending() // 排序 .limit(10); // 限制返回数量 // 查询 final GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = redisTemplate.opsForGeo().search(key, objectGeoReference, geoShape, args); if (results != null) &#123; results.forEach(result -&gt; &#123; // 获取成员名称 System.out.println(result.getContent().getName()); // 获取坐标 System.out.println(result.getContent().getPoint()); // 获取距离 System.out.println(result.getDistance()); &#125;); &#125;&#125;// 基于成员的坐标搜索public void search(String key, String member, double radius) &#123; // 半径 Distance distance = new Distance(radius, RedisGeoCommands.DistanceUnit.METERS); // 创建地理参考 GeoReference&lt;String&gt; objectGeoReference = GeoReference.fromMember(member); // 创建地理形状 GeoShape geoShape = GeoShape.byRadius(distance); // 创建参数 RedisGeoCommands.GeoRadiusCommandArgs args = RedisGeoCommands.GeoRadiusCommandArgs.newGeoRadiusArgs() .includeCoordinates() // 返回坐标 .includeDistance() // 返回距离 .sortAscending() // 排序 .limit(10); // 限制返回数量 // 查询 final GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = redisTemplate.opsForGeo().search(key, objectGeoReference, geoShape, args); if (results != null) &#123; results.forEach(result -&gt; &#123; // 获取成员名称 System.out.println(result.getContent().getName()); // 获取坐标 System.out.println(result.getContent().getPoint()); // 获取距离 System.out.println(result.getDistance()); &#125;); &#125;&#125; 搜索并存储（GEOSEARCHSTORE） 这是 搜索 + 写入 的组合操作，结果会写入新的 ZSet 1️⃣ 圆形范围存储 方法功能 方法 Redis 原始命令 搜索并存储 searchAndStore(K key, destKey, Circle) GEOSEARCHSTORE 指定参考点 searchAndStore(K key, destKey, reference, radius) GEOSEARCHSTORE 带参数 searchAndStore(K key, destKey, reference, radius, args) GEOSEARCHSTORE 2️⃣ 矩形范围存储 方法功能 方法 Redis 原始命令 矩形存储 searchAndStore(K key, destKey, reference, BoundingBox) GEOSEARCHSTORE 带参数 searchAndStore(K key, destKey, reference, BoundingBox, args) GEOSEARCHSTORE 3️⃣ 通用 GeoShape 存储 方法功能 方法 Redis 原始命令 通用存储 searchAndStore(K key, destKey, reference, GeoShape, args) GEOSEARCHSTORE","summary":"摘要 本文介绍 Redis Geo 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2025-12-19T13:40:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/19/redis7-datatype-08-hyperloglog/","url":"https://blog.hanqunfeng.com/2025/12/19/redis7-datatype-08-hyperloglog/","title":"Redis 命令及数据类型 -- Hyperloglog","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis Hyperloglog 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Hyperloglog-核心详解\">Hyperloglog 核心详解</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis HyperLogLog 是专门用于做基数统计的高级数据类型，核心优势是用极小的内存（固定约 <code>12KB</code>）就能统计海量数据的基数，误差率仅 <code>0.81%</code>，无需存储全部数据本身。</p>\n</li>\n</ul>\n<blockquote>\n<p>基数：指集合中不重复元素的数量（比如统计 UV，就是不重复访客的数量）。</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis Hyperloglog 并非独立数据类型，而是基于 String 类型的位操作扩展</p>\n</li>\n</ul>\n<h2 id=\"核心使用方式（3个核心命令）\">核心使用方式（3个核心命令）</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>HyperLogLog 命令极简，只有 3 个核心操作</p>\n</li>\n</ul>\n<h3 id=\"PFADD\">PFADD</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>向 HyperLogLog 中添加1个或多个元素，成功添加（元素未存在）返回1，否则返回0。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PFADD key [element [element ...]]</span><br></pre></td></tr></table></figure>\n<h3 id=\"PFCOUNT\">PFCOUNT</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>统计单个/多个 HyperLogLog 的基数（去重总数），多 key 传入时会计算所有 key 的并集基数。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PFCOUNT key [key ...]</span><br></pre></td></tr></table></figure>\n<h3 id=\"PFMERGE\">PFMERGE</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>将多个源 HyperLogLog 合并为1个目标 HyperLogLog，适用于跨维度汇总统计（比如合并今日、昨日的 UV 得到两日总 UV）。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PFMERGE destkey [sourcekey [sourcekey ...]]</span><br></pre></td></tr></table></figure>\n<h2 id=\"实操示例\">实操示例</h2>\n<h3 id=\"示例1：单-key-基础统计（统计网站-UV）\">示例1：单 key 基础统计（统计网站 UV）</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. 模拟3个访客访问，其中用户A重复访问</span></span><br><span class=\"line\">127.0.0.1:6379&gt; PFADD uv:20251218 userA userB userC</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; PFADD uv:20251218 userA</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. 统计当日UV（去重后是3，忽略重复的userA）</span></span><br><span class=\"line\">127.0.0.1:6379&gt; PFCOUNT uv:20251218</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br></pre></td></tr></table></figure>\n<h3 id=\"示例2：-多-key-合并与汇总统计\">示例2： 多 key 合并与汇总统计</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. 分别统计12.17和12.18的UV</span></span><br><span class=\"line\">127.0.0.1:6379&gt; PFADD uv:20251217 userA userD</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; PFADD uv:20251218 userA userB userC</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. 合并两日UV到 uv:20251217_18</span></span><br><span class=\"line\">127.0.0.1:6379&gt; PFMERGE uv:20251217_18 uv:20251217 uv:20251218</span><br><span class=\"line\">OK</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. 统计两日总UV（并集去重，结果为4：userA、B、C、D）</span></span><br><span class=\"line\">127.0.0.1:6379&gt; PFCOUNT uv:20251217_18</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 4</span><br></pre></td></tr></table></figure>\n<h2 id=\"核心应用场景（精准落地场景）\">核心应用场景（精准落地场景）</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>HyperLogLog 只关注 <strong>“去重数量”</strong>，不关注“具体元素是谁”，适合以下高频场景，也是企业级常用方案：</p>\n</li>\n</ul>\n<ol>\n<li class=\"lvl-3\">\n<p>网站/APP UV 统计：替代传统的 Set 存储（Set 存海量 UV 内存占用极高），单 key 仅 12KB，轻松统计百万/千万级 UV。</p>\n</li>\n<li class=\"lvl-3\">\n<p>业务场景去重计数：比如统计单日/单月的独立支付用户数、独立下单用户数、独立点击商品的用户数。</p>\n</li>\n<li class=\"lvl-3\">\n<p>海量数据去重统计：比如统计某接口的独立调用 IP 数、某直播间的独立观看人数、某广告的独立曝光数。</p>\n</li>\n<li class=\"lvl-3\">\n<p>跨维度汇总统计：比如合并不同渠道（APP、小程序、H5）的独立访客数，得到全渠道总访客数。</p>\n</li>\n</ol>\n<h2 id=\"关键注意事项（避坑重点）\">关键注意事项（避坑重点）</h2>\n<ol>\n<li class=\"lvl-3\">\n<p>不存储具体元素，仅存统计结果：无法像 Set 那样获取集合中的具体元素（比如无法通过 HyperLogLog 查到具体是哪些用户访问了网站），只关心“有多少个”，不关心“是谁”。</p>\n</li>\n<li class=\"lvl-3\">\n<p>误差不可避免，可控不影响大部分场景：固定误差率 <code>0.81%</code>，数据量越大误差越稳定，UV、独立用户数等场景对精度要求不高，完全够用；若需 100% 精准（比如统计核心交易用户数），需用 Set 或 Hash 实现。</p>\n</li>\n<li class=\"lvl-3\">\n<p>内存占用固定，与数据量无关：无论统计 10 个还是 1 亿个元素，单个 HyperLogLog 占用内存约 <code>12KB</code>，这是其核心优势，也是区别于 Set 的关键。</p>\n</li>\n<li class=\"lvl-3\">\n<p>元素支持字符串类型：PFADD 传入的元素必须是字符串/字节类型，不支持其他数据类型（如数字、列表等，需手动转为字符串）。</p>\n</li>\n<li class=\"lvl-3\">\n<p>过期时间支持：HyperLogLog 本身不自带过期机制，但可通过 <code>EXPIRE key seconds</code> 给其设置过期时间（比如 UV 统计按日过期，避免内存堆积）。</p>\n</li>\n<li class=\"lvl-3\">\n<p>PFADD 幂等性：重复添加同一元素，不会改变基数结果，也不会额外占用内存，可放心重复调用。</p>\n</li>\n</ol>\n<h2 id=\"与-Set-统计基数的对比（选型参考）\">与 Set 统计基数的对比（选型参考）</h2>\n<table>\n<thead>\n<tr>\n<th>对比维度</th>\n<th>HyperLogLog</th>\n<th>Set</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数据结构类型</td>\n<td>基数统计结构</td>\n<td>无序集合</td>\n</tr>\n<tr>\n<td>内存占用</td>\n<td>固定约 <strong>12KB</strong>，与数据量无关</td>\n<td>随元素数量线性增长，海量数据内存占用极高</td>\n</tr>\n<tr>\n<td>统计结果精度</td>\n<td><strong>非精准</strong>，标准误差约 <strong>0.81%</strong></td>\n<td><strong>100% 精准</strong></td>\n</tr>\n<tr>\n<td>是否支持获取具体元素</td>\n<td>不支持</td>\n<td>支持（如 <code>SMEMBERS</code>）</td>\n</tr>\n<tr>\n<td>是否支持去重</td>\n<td>支持（基数去重）</td>\n<td>支持（元素级去重）</td>\n</tr>\n<tr>\n<td>统计性能</td>\n<td>极快（固定计算逻辑，O(1)）</td>\n<td>数据量越大，统计与遍历成本越高</td>\n</tr>\n<tr>\n<td>适合数据规模</td>\n<td>超大规模（百万 / 千万 / 亿级）</td>\n<td>中小规模集合</td>\n</tr>\n<tr>\n<td>常见使用场景</td>\n<td>UV / DAU 统计、独立 IP 数、访问用户数</td>\n<td>好友列表、标签集合、关注列表</td>\n</tr>\n<tr>\n<td>是否可做集合运算</td>\n<td>不支持</td>\n<td>支持（<code>SUNION</code> / <code>SINTER</code> / <code>SDIFF</code>）</td>\n</tr>\n<tr>\n<td>是否可序列化/持久化</td>\n<td>可（Redis 内部结构）</td>\n<td>可</td>\n</tr>\n<tr>\n<td>选型结论</td>\n<td><strong>低成本 + 海量数据 + 可接受误差的基数统计</strong></td>\n<td><strong>精准统计 + 需要元素明细的场景</strong></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"HyperLogLog-命令\">HyperLogLog 命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot 的 <code>StringRedisTemplate.opsForHyperLogLog()</code> 中 HyperLogLog 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p>\n</li>\n</ul>\n<blockquote>\n<p>注意这里一定要用 <code>StringRedisTemplate</code> 来操作 HyperLogLog</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注 / 使用建议</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>添加元素</td>\n<td><code>Long add(K key, V... values)</code></td>\n<td><code>PFADD key element [element ...]</code></td>\n<td>返回 1 表示 HLL 结构发生变化</td>\n</tr>\n<tr>\n<td>获取基数（去重数）</td>\n<td><code>Long size(K... keys)</code></td>\n<td><code>PFCOUNT key [key ...]</code></td>\n<td>支持多 key 合并统计</td>\n</tr>\n<tr>\n<td>合并 HLL</td>\n<td><code>Long union(K destination, K... sourceKeys)</code></td>\n<td><code>PFMERGE destkey sourcekey [sourcekey ...]</code></td>\n<td>合并后写入 destkey</td>\n</tr>\n<tr>\n<td>删除 HLL</td>\n<td><code>void delete(K key)</code></td>\n<td><code>DEL key</code></td>\n<td>直接删除整个 HLL</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 Redis Hyperloglog 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ Hyperloglog 核心详解 Redis HyperLogLog 是专门用于做基数统计的高级数据类型，核心优势是用极小的内存（固定约 12KB）就能统计海量数据的基数，误差率仅 0.81%，无需存储全部数据本身。 基数：指集合中不重复元素的数量（比如统计 UV，就是不重复访客的数量）。 Redis Hyperloglog 并非独立数据类型，而是基于 String 类型的位操作扩展 核心使用方式（3个核心命令） HyperLogLog 命令极简，只有 3 个核心操作 PFADD 向 HyperLogLog 中添加1个或多个元素，成功添加（元素未存在）返回1，否则返回0。 1PFADD key [element [element ...]] PFCOUNT 统计单个/多个 HyperLogLog 的基数（去重总数），多 key 传入时会计算所有 key 的并集基数。 1PFCOUNT key [key ...] PFMERGE 将多个源 HyperLogLog 合并为1个目标 HyperLogLog，适用于跨维度汇总统计（比如合并今日、昨日的 UV 得到两日总 UV）。 1PFMERGE destkey [sourcekey [sourcekey ...]] 实操示例 示例1：单 key 基础统计（统计网站 UV） 123456789# 1. 模拟3个访客访问，其中用户A重复访问127.0.0.1:6379&gt; PFADD uv:20251218 userA userB userC(integer) 1127.0.0.1:6379&gt; PFADD uv:20251218 userA(integer) 0# 2. 统计当日UV（去重后是3，忽略重复的userA）127.0.0.1:6379&gt; PFCOUNT uv:20251218(integer) 3 示例2： 多 key 合并与汇总统计 12345678910111213# 1. 分别统计12.17和12.18的UV127.0.0.1:6379&gt; PFADD uv:20251217 userA userD(integer) 1127.0.0.1:6379&gt; PFADD uv:20251218 userA userB userC(integer) 1# 2. 合并两日UV到 uv:20251217_18127.0.0.1:6379&gt; PFMERGE uv:20251217_18 uv:20251217 uv:20251218OK# 3. 统计两日总UV（并集去重，结果为4：userA、B、C、D）127.0.0.1:6379&gt; PFCOUNT uv:20251217_18(integer) 4 核心应用场景（精准落地场景） HyperLogLog 只关注 “去重数量”，不关注“具体元素是谁”，适合以下高频场景，也是企业级常用方案： 网站/APP UV 统计：替代传统的 Set 存储（Set 存海量 UV 内存占用极高），单 key 仅 12KB，轻松统计百万/千万级 UV。 业务场景去重计数：比如统计单日/单月的独立支付用户数、独立下单用户数、独立点击商品的用户数。 海量数据去重统计：比如统计某接口的独立调用 IP 数、某直播间的独立观看人数、某广告的独立曝光数。 跨维度汇总统计：比如合并不同渠道（APP、小程序、H5）的独立访客数，得到全渠道总访客数。 关键注意事项（避坑重点） 不存储具体元素，仅存统计结果：无法像 Set 那样获取集合中的具体元素（比如无法通过 HyperLogLog 查到具体是哪些用户访问了网站），只关心“有多少个”，不关心“是谁”。 误差不可避免，可控不影响大部分场景：固定误差率 0.81%，数据量越大误差越稳定，UV、独立用户数等场景对精度要求不高，完全够用；若需 100% 精准（比如统计核心交易用户数），需用 Set 或 Hash 实现。 内存占用固定，与数据量无关：无论统计 10 个还是 1 亿个元素，单个 HyperLogLog 占用内存约 12KB，这是其核心优势，也是区别于 Set 的关键。 元素支持字符串类型：PFADD 传入的元素必须是字符串/字节类型，不支持其他数据类型（如数字、列表等，需手动转为字符串）。 过期时间支持：HyperLogLog 本身不自带过期机制，但可通过 EXPIRE key seconds 给其设置过期时间（比如 UV 统计按日过期，避免内存堆积）。 PFADD 幂等性：重复添加同一元素，不会改变基数结果，也不会额外占用内存，可放心重复调用。 与 Set 统计基数的对比（选型参考） 对比维度 HyperLogLog Set 数据结构类型 基数统计结构 无序集合 内存占用 固定约 12KB，与数据量无关 随元素数量线性增长，海量数据内存占用极高 统计结果精度 非精准，标准误差约 0.81% 100% 精准 是否支持获取具体元素 不支持 支持（如 SMEMBERS） 是否支持去重 支持（基数去重） 支持（元素级去重） 统计性能 极快（固定计算逻辑，O(1)） 数据量越大，统计与遍历成本越高 适合数据规模 超大规模（百万 / 千万 / 亿级） 中小规模集合 常见使用场景 UV / DAU 统计、独立 IP 数、访问用户数 好友列表、标签集合、关注列表 是否可做集合运算 不支持 支持（SUNION / SINTER / SDIFF） 是否可序列化/持久化 可（Redis 内部结构） 可 选型结论 低成本 + 海量数据 + 可接受误差的基数统计 精准统计 + 需要元素明细的场景 HyperLogLog 命令 SpringBoot 的 StringRedisTemplate.opsForHyperLogLog() 中 HyperLogLog 数据类型 的操作方法与 Redis 原生命令的对应关系如下： 注意这里一定要用 StringRedisTemplate 来操作 HyperLogLog 方法功能 方法 Redis 原始命令 备注 / 使用建议 添加元素 Long add(K key, V... values) PFADD key element [element ...] 返回 1 表示 HLL 结构发生变化 获取基数（去重数） Long size(K... keys) PFCOUNT key [key ...] 支持多 key 合并统计 合并 HLL Long union(K destination, K... sourceKeys) PFMERGE destkey sourcekey [sourcekey ...] 合并后写入 destkey 删除 HLL void delete(K key) DEL key 直接删除整个 HLL","summary":"摘要 本文介绍 Redis Hyperloglog 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2025-12-19T13:30:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/18/redis7-datatype-07-bitmap/","url":"https://blog.hanqunfeng.com/2025/12/18/redis7-datatype-07-bitmap/","title":"Redis 命令及数据类型 -- Bitmap","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis Bitmap 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Bitmap-核心详解\">Bitmap 核心详解</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis Bitmap 并非独立数据类型，而是基于 String 类型的位操作扩展</p>\n</li>\n<li class=\"lvl-2\">\n<p>String 底层是字节数组，Bitmap 就是对数组中单个 bit 做读写（bit 只有 0/1 两个值）</p>\n</li>\n</ul>\n<h2 id=\"Bitmap-命令使用方式\">Bitmap 命令使用方式</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>核心围绕「位设置、位查询、位统计、位运算」四类命令，是日常使用的基础</p>\n</li>\n</ul>\n<h3 id=\"1-位设置：SETBIT-key-offset-value\">1. 位设置：<code>SETBIT key offset value</code></h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>给指定 key 的第 offset 位设 0/1（offset 从 0 开始，支持超大偏移量，Redis 会自动扩容）</p>\n</li>\n<li class=\"lvl-2\">\n<p>offset 从左往右递增，从左到右为 0、1、2…，至少申请 8bit 空间，不足 8bit 时，会自动扩展到 8bit 即 1byte</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SETBIT bitkey 1 1 <span class=\"comment\"># 实际的bit为 01000000</span></span><br><span class=\"line\">SETBIT bitkey 10 1 <span class=\"comment\"># 实际的bit为 0100000000100000</span></span><br><span class=\"line\"><span class=\"comment\"># 操作 String</span></span><br><span class=\"line\">SET k1 v1 <span class=\"comment\"># 实际的bit为 0111011000110001</span></span><br><span class=\"line\">SETBIT k1 1 0 <span class=\"comment\"># 实际bit为 0011011000110001</span></span><br><span class=\"line\">GET k1 <span class=\"comment\"># 输出 61</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># bitmap 实际上是 string</span></span><br><span class=\"line\">TYPE bitkey <span class=\"comment\"># 输出 string</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-位查询：GETBIT-key-offset\">2. 位查询：<code>GETBIT key offset</code></h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查询指定偏移量的位值，不存在的 offset 默认返回 0</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GETBIT bitkey 1</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-位统计：BITCOUNT-key-start-end\">3. 位统计：<code>BITCOUNT key [start end]</code></h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>统计 key 中值为 1 的 bit 总数，可选按字节范围（start/end 是字节索引）筛选</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BITCOUNT bitkey</span><br><span class=\"line\"><span class=\"comment\"># 等价于</span></span><br><span class=\"line\">BITCOUNT bitkey 0 -1</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-位运算：BITOP-op-destkey-key1-key2\">4. 位运算：<code>BITOP op destkey key1 key2...</code></h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>对多个 Bitmap 做 与（AND）、或（OR）、异或（XOR）、非（NOT）运算，结果存入 destkey</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将key1 与 key2 做按位与运算，结果存入 destkey</span></span><br><span class=\"line\">BITOP AND destkey key1 key2</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-位查找：BITPOS-key-value-start-end\">5. 位查找：<code>BITPOS key value [start end]</code></h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查找第一个值为 0/1 的 bit 偏移量，快速定位目标位</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BITPOS bitkey 1</span><br><span class=\"line\"><span class=\"comment\"># 等价于</span></span><br><span class=\"line\">BITPOS bitkey 1 0 -1</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-BITFIELD-批量位操作\">6. <code>BITFIELD</code> 批量位操作</h3>\n<p>• BITFIELD 是 Redis 用于把一个 字符串值视为一个由二进制“位数组”组成的存储区，并对其中任意指定位置的整数域进行读取、写入、自增等操作的命令。<br>\n• 这些整数域可以是任意位宽（例如 1 位、4 位、8 位、31 位、63 位等），可指定为有符号（signed）或无符号（unsigned）。<br>\n• BITFIELD 命令支持在一次调用中执行多个操作，并将结果按操作顺序返回。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BITFIELD key [GET encoding offset | [OVERFLOW &lt;WRAP | SAT | FAIL&gt;]</span><br><span class=\"line\">  &lt;SET encoding offset value | INCRBY encoding offset increment&gt;</span><br><span class=\"line\">  [GET encoding offset | [OVERFLOW &lt;WRAP | SAT | FAIL&gt;]</span><br><span class=\"line\">  &lt;SET encoding offset value | INCRBY encoding offset increment&gt;</span><br><span class=\"line\">  ...]]</span><br></pre></td></tr></table></figure>\n<p>• 参数说明（核心部分）</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>key</strong></td>\n<td>操作的 Redis 字符串键</td>\n</tr>\n<tr>\n<td><strong>GET encoding offset</strong></td>\n<td>从指定位偏移量读取一个整数</td>\n</tr>\n<tr>\n<td><strong>SET encoding offset value</strong></td>\n<td>在指定位置写入整数</td>\n</tr>\n<tr>\n<td><strong>INCRBY encoding offset increment</strong></td>\n<td>在指定位置对整数做增量操作</td>\n</tr>\n<tr>\n<td><strong>OVERFLOW WRAP/SAT/FAIL</strong></td>\n<td>配置随后的算数操作溢出行为</td>\n</tr>\n</tbody>\n</table>\n<p>• 数据类型（encoding）:用于指定整数的位宽和符号类型</p>\n<table>\n<thead>\n<tr>\n<th>前缀</th>\n<th>含义</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>u&lt;number&gt;</code></td>\n<td>无符号整数（unsigned），占位 bits = number</td>\n<td>u5 — 5 位无符号整数</td>\n</tr>\n<tr>\n<td><code>i&lt;number&gt;</code></td>\n<td>有符号整数（signed），占位 bits = number</td>\n<td>i10 — 10 位有符号整数</td>\n</tr>\n</tbody>\n</table>\n<p>• 溢出（OVERFLOW）:默认算数操作中可能发生溢出，OVERFLOW 允许你控制处理策略。注意，这部分必须在后续的 SET/INCRBY 操作之前指定。</p>\n<table>\n<thead>\n<tr>\n<th>策略</th>\n<th>行为</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>WRAP</strong></td>\n<td>环绕（默认）溢出按环形计数处理</td>\n</tr>\n<tr>\n<td><strong>SAT</strong></td>\n<td>饱和，在边界值保持最大/最小</td>\n</tr>\n<tr>\n<td><strong>FAIL</strong></td>\n<td>溢出时操作失败并返回错误</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 4 位无符号整数加 1 时，如果超过 15，则保持 15（饱和）。</span></span><br><span class=\"line\">BITFIELD key OVERFLOW SAT INCRBY u4 0 1</span><br></pre></td></tr></table></figure>\n<p>• 返回值: BITFIELD 会为每个子命令返回一个整数数组，数组各元素按操作顺序对应执行结果</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BITFIELD mykey INCRBY i5 100 1 GET u4 0</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 0</span><br></pre></td></tr></table></figure>\n<h3 id=\"7-BITFIELD-RO-批量只读\">7. <code>BITFIELD_RO</code> 批量只读</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis 6.0 新增的只读版本，用于批量只读</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BITFIELD_RO key [GET encoding offset [GET encoding offset ...]]</span><br></pre></td></tr></table></figure>\n<h3 id=\"综合示例\">综合示例</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例 1. 设置并读取简单整数</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; SET mykey <span class=\"string\">&quot;&quot;</span> <span class=\"comment\"># 此时mykey 的值是空字符串，长度为 0</span></span><br><span class=\"line\"><span class=\"comment\"># SET u4 0 7：在 key mykey 偏移 0 位置设置 4 位无符号整数值为 7，即前4位变成 0111，因为至少8bit，所以实际值是 01110000</span></span><br><span class=\"line\"><span class=\"comment\"># GET u4 0：读取 key mykey 偏移 0 位的 4 位无符号整数，此时 mykey 虽然是 01110000，但这里指定只读前4位，即 0111，所以转换为二进制就是 7</span></span><br><span class=\"line\">&gt; BITFIELD mykey SET u4 0 7 GET u4 0</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 0 <span class=\"comment\"># set命令的返回值，这里返回set前的值</span></span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 7 <span class=\"comment\"># get命令的返回值</span></span><br><span class=\"line\"><span class=\"comment\"># 设置有符号整数</span></span><br><span class=\"line\">&gt; BITFIELD mykey SET i4 0 -2 GET i4 0</span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 7 <span class=\"comment\"># 返回set前的值，之前是7，即 0111，set后变为 -2，即 1110</span></span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) -2 <span class=\"comment\"># get命令的返回值</span></span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>负数的二进制表示</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">以 -2 为例，先写出 +2 的二进制，以8位为例，就是 <code>00000010</code>，4位就是 <code>0010</code></li>\n<li class=\"lvl-2\">按位取反（得到反码），例如 <code>00000010</code>，按位取反就是 <code>11111101</code></li>\n<li class=\"lvl-2\">加 1（得到补码），<code>11111101</code> + 1，得到 <code>11111110</code>，这就是 -2 的二进制表示</li>\n<li class=\"lvl-2\">如果是4位，则 -2 就是 <code>1110</code></li>\n</ul>\n</div>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例 2. 自增计数器</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果 counter 之前为空，则视为 0</span></span><br><span class=\"line\"><span class=\"comment\"># INCRBY u8 8 5：在 key counter 的第 8 位（下一个字节开头处）上按 8 位 unsigned 类型自增 5</span></span><br><span class=\"line\"><span class=\"comment\"># GET u8 8：读取 key counter 的第 8 位（下一个字节开头处）的 8 位无符号整数，返回这个整数的新值</span></span><br><span class=\"line\">BITFIELD counter INCRBY u8 8 5 GET u8 8</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 5 <span class=\"comment\"># INCRBY 的返回值，这里返回的是增加的值，而不是计算后的值</span></span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 5</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例 3. 带溢出控制的操作</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># OVERFLOW SAT: 设置溢出策略为 SAT（饱和）</span></span><br><span class=\"line\"><span class=\"comment\"># INCRBY u4 0 20: 对 4 位无符号整数（最大 15）加 20，此时肯定会溢出，由于过 15 上限，结果返回 15（饱和）</span></span><br><span class=\"line\"><span class=\"comment\"># GET u4 0：读取 4 位无符号整数，即15</span></span><br><span class=\"line\">BITFIELD limits OVERFLOW SAT INCRBY u4 0 20 GET u4 0</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 15</span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 15</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例 4. 批量多个操作</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># GET u4 0 GET u4 4: 依次读取多个不同 bit 偏移量上的小整数</span></span><br><span class=\"line\"><span class=\"comment\"># SET u4 8 3 INCRBY i5 16 1: 写入、增量操作可以混合处理</span></span><br><span class=\"line\"><span class=\"comment\"># 返回结果数组对应每个子命令顺序返回结果</span></span><br><span class=\"line\">BITFIELD events GET u4 0 GET u4 4 SET u4 8 3 INCRBY i5 16 1</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 0 <span class=\"comment\"># events原先为空，所以这里返回0</span></span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 0 <span class=\"comment\"># events原先为空，所以这里返回0</span></span><br><span class=\"line\">3) (<span class=\"built_in\">integer</span>) 0 <span class=\"comment\"># events原先为空，这里返回原先的值，所以还是0，但此时实际的值是 0000000000110000</span></span><br><span class=\"line\">4) (<span class=\"built_in\">integer</span>) 1 <span class=\"comment\"># 返回增加的值，即 1，但此时实际的值是 000000000011000000001000，即占用了3个字节</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"核心使用场景-实操举例（贴合开发实战）\">核心使用场景 + 实操举例（贴合开发实战）</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Bitmap 的核心优势是极致省内存+高效统计（1 个字节=8 个 bit，存储 1000 万条状态仅需约 1.2MB），以下是高频场景</p>\n</li>\n</ul>\n<h3 id=\"场景1：-用户签到-打卡（最经典场景）\">场景1： 用户签到/打卡（最经典场景）</h3>\n<p>• 需求：记录用户每日签到状态，查询某用户某天是否签到、统计某用户月度签到次数<br>\n• 设计：key 格式 <code>user:sign:uid:202512</code>（用户2025年12月签到），offset 为日期（1号=0、2号=1…31号=30），签到设 1、未签到默认 0<br>\n• 实操命令：</p>\n<ol>\n<li class=\"lvl-3\">\n<p>12月1号签到：<code>SETBIT user:sign:uid:202512 0 1</code></p>\n</li>\n<li class=\"lvl-3\">\n<p>查询12月1号是否签到：<code>GETBIT user:sign:uid:202512 0</code>（返回1=签到）</p>\n</li>\n<li class=\"lvl-3\">\n<p>统计12月总签到次数：<code>BITCOUNT user:sign:uid:202512</code></p>\n</li>\n</ol>\n<p>• 优势：1个用户1个月签到仅占 4 字节（31 bit），百万用户月度签到仅占约 3.9MB，远超数据库存储的性价比。</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>劣势：若想查询该用户本月内都哪天签到了，即要查看bitmap哪些位为1，则bitmap不支持这个命令，可以在业务端实现。如需要精确查询和聚合统计则需要同步数据到关系型数据库。</p>\n</li>\n</ul>\n<h3 id=\"场景2：-日活-周活-月活（DAU-WAU-MAU）统计（高并发场景首选）\">场景2： 日活/周活/月活（DAU/WAU/MAU）统计（高并发场景首选）</h3>\n<p>• 需求：统计每日访问平台的用户数，快速计算周活（7天内至少访问1次）、月活，去重统计<br>\n• 设计：按日期建 Bitmap，key 格式 <code>active:user:20251217</code>（当日活跃），offset 设为用户唯一ID（需确保ID是连续或可映射为数字，避免超大偏移量），用户访问则设 1<br>\n• 实操命令：</p>\n<ol>\n<li class=\"lvl-3\">\n<p>用户ID 10086 12月17日访问：<code>SETBIT active:user:20251217 10086 1</code></p>\n</li>\n<li class=\"lvl-3\">\n<p>统计12月17日日活：<code>BITCOUNT active:user:20251217</code></p>\n</li>\n<li class=\"lvl-3\">\n<p>统计12月15-17日3天内活跃的用户数：<code>BITOP OR active:user:20251215_17 active:user:20251215 active:user:20251216 active:user:20251217</code> → 再执行 <code>BITCOUNT active:user:20251215_17</code></p>\n</li>\n<li class=\"lvl-3\">\n<p>统计12月15-17日每天都登录的用户数：<code>BITOP AND active:user:20251215_17 active:user:20251215 active:user:20251216 active:user:20251217</code> → 再执行 <code>BITCOUNT active:user:20251215_17</code></p>\n</li>\n</ol>\n<p>• 优势：百万级用户日活统计，单 Bitmap 仅占约 125KB，位运算合并统计速度毫秒级，远快于数据库 group by 去重。</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>劣势：若想查看本月内哪些用户登录过，则需要遍历 Bitmap 的所有 offset 位，效率较低。如需要精确查询和聚合统计则需要同步数据到关系型数据库。</p>\n</li>\n</ul>\n<h3 id=\"场景3：-功能开关-状态标记（多维度轻量标记）\">场景3： 功能开关/状态标记（多维度轻量标记）</h3>\n<p>• 需求：给用户标记多类轻量状态（如是否开通会员、是否绑定手机、是否参与活动），无需单独存多个key<br>\n• 设计：1个key对应1个用户，key 格式 <code>user:status:10086</code>，不同 offset 对应不同状态（offset0=是否绑定手机、offset1=是否会员、offset2=是否参与活动），1=是、0=否<br>\n• 实操命令：</p>\n<ol>\n<li class=\"lvl-3\">\n<p>给用户10086绑定手机：<code>SETBIT user:status:10086 0 1</code></p>\n</li>\n<li class=\"lvl-3\">\n<p>开通会员：<code>SETBIT user:status:10086 1 1</code></p>\n</li>\n<li class=\"lvl-3\">\n<p>查询是否是会员：<code>GETBIT user:status:10086 1</code></p>\n</li>\n</ol>\n<p>• 优势：1个key承载用户N个状态，无需维护多个 String/Hash，查询和修改均为O(1)，极简高效。</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>劣势：若想查看用户所有状态，则需要遍历所有 offset 的位，效率较低，另外统计哪些用户开启了某个状态也比较麻烦。如需要精确查询和聚合统计则需要同步数据到关系型数据库。</p>\n</li>\n</ul>\n<h3 id=\"场景4：-布隆过滤器底层实现（核心依赖Bitmap）\">场景4： 布隆过滤器底层实现（核心依赖Bitmap）</h3>\n<p>• 需求：实现海量数据的快速去重判断（如缓存穿透防护、海量URL去重），允许极小误判率，不允许漏判<br>\n• 设计：用1个大 Bitmap 作为底层存储，配合多个哈希函数 —— 数据存入时，通过多个哈希函数算出多个 offset，将对应 bit 设为1；查询时，若所有哈希对应的 offset 都是1，则大概率存在，否则一定不存在<br>\n• 实操：Redis 7 可直接用 Bitmap 手动实现，也可结合 RedisBloom 扩展（更易用），核心原理是 Bitmap 的位设置与查询。<br>\n• 优势：存储1亿条数据，误判率5%的布隆过滤器，仅需约 12MB 内存，查询速度极致快。</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>劣势：布隆过滤器虽然有极小误判率，但不允许删除。</p>\n</li>\n</ul>\n<h2 id=\"注意事项（避坑关键）\">注意事项（避坑关键）</h2>\n<ol>\n<li class=\"lvl-3\">\n<p>offset 不要无限制过大：虽 Redis 支持超大 offset，但过大（如超过10亿）会导致 Bitmap 占用内存骤增，需合理规划 offset 范围（如用户ID做哈希映射压缩）</p>\n</li>\n<li class=\"lvl-3\">\n<p>避免单 key 过大：单个 Bitmap 建议控制在1GB内（对应约85亿 bit），过大易导致Redis持久化/迁移耗时过长</p>\n</li>\n<li class=\"lvl-3\">\n<p>注意编码兼容：Bitmap 基于 String，Redis 会自动用 RAW 编码存储，无需手动设置</p>\n</li>\n</ol>\n<h2 id=\"Bitmap-命令\">Bitmap 命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot 的 <code>StringRedisTemplate.opsForValue()</code> 中 Bitmap 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p>\n</li>\n</ul>\n<blockquote>\n<p>注意这里一定要用 <code>StringRedisTemplate</code> 来操作 Bitmap</p>\n</blockquote>\n<h3 id=\"写操作（位修改）\">写操作（位修改）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>设置指定偏移量的位</td>\n<td><code>setBit(K key, long offset, boolean value)</code></td>\n<td><code>SETBIT key offset value</code></td>\n<td>返回旧值（0 / 1），offset 从 0 开始</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>offset 表示 第几位（bit），不是字节</p>\n</blockquote>\n<h3 id=\"读操作（位查询）\">读操作（位查询）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>获取指定偏移量的位</td>\n<td><code>getBit(K key, long offset)</code></td>\n<td><code>GETBIT key offset</code></td>\n<td>返回 0 / 1，不会修改数据</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"批量位操作（位字段-BitField）\">批量位操作（位字段 BitField）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>位字段读/写/自增</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>位字段操作（读/写/自增）</td>\n<td><code>bitField(K key, BitFieldSubCommands subCommands)</code></td>\n<td><code>BITFIELD key ...</code></td>\n<td>原子执行多个子命令</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BITFIELD limits</span><br><span class=\"line\">    OVERFLOW SAT</span><br><span class=\"line\">    SET u4 0 3</span><br><span class=\"line\">    INCRBY u4 0 20</span><br><span class=\"line\">    GET u4 0</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// SET u4 0 3</span></span><br><span class=\"line\">BitFieldSubCommands.<span class=\"type\">BitFieldSet</span> <span class=\"variable\">bitFieldSet</span> <span class=\"operator\">=</span> BitFieldSubCommands.BitFieldSet.create(BitFieldSubCommands.BitFieldType.unsigned(<span class=\"number\">4</span>), BitFieldSubCommands.Offset.offset(<span class=\"number\">0</span>), <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"comment\">// OVERFLOW SAT INCRBY u4 0 20</span></span><br><span class=\"line\">BitFieldSubCommands.<span class=\"type\">BitFieldIncrBy</span> <span class=\"variable\">bitFieldIncrBy</span> <span class=\"operator\">=</span> BitFieldSubCommands.BitFieldIncrBy.create(BitFieldSubCommands.BitFieldType.unsigned(<span class=\"number\">4</span>), BitFieldSubCommands.Offset.offset(<span class=\"number\">0</span>), <span class=\"number\">20</span>, BitFieldSubCommands.BitFieldIncrBy.Overflow.SAT);</span><br><span class=\"line\"><span class=\"comment\">// GET u4 0</span></span><br><span class=\"line\">BitFieldSubCommands.<span class=\"type\">BitFieldGet</span> <span class=\"variable\">bitFieldGet</span> <span class=\"operator\">=</span> BitFieldSubCommands.BitFieldGet.create(BitFieldSubCommands.BitFieldType.unsigned(<span class=\"number\">4</span>), BitFieldSubCommands.Offset.offset(<span class=\"number\">0</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取结果，每个子操作返回一个结果</span></span><br><span class=\"line\">List&lt;Long&gt; limits = redisTemplate.opsForValue().bitField(<span class=\"string\">&quot;limits&quot;</span>, BitFieldSubCommands.create(bitFieldSet, bitFieldIncrBy, bitFieldGet));</span><br></pre></td></tr></table></figure>\n<h3 id=\"Bitmap-常用但-Spring-未直接封装的命令\">Bitmap 常用但 Spring 未直接封装的命令</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Spring Data Redis 中通常通过 RedisCallback 或 execute 调用这些命令。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Redis 命令</th>\n<th>功能</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>BITCOUNT key [start end]</code></td>\n<td>统计 bit=1 的数量</td>\n<td>常用于活跃用户统计</td>\n</tr>\n<tr>\n<td><code>BITPOS key bit [start end]</code></td>\n<td>查找第一个 0/1 的位置</td>\n<td>常用于分配位</td>\n</tr>\n<tr>\n<td><code>BITOP AND/OR/XOR/NOT</code></td>\n<td>位运算</td>\n<td>多 bitmap 计算</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.demo.bitmap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.demo.CommonUtil;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.domain.Range;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.connection.RedisStringCommands;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.core.RedisCallback;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.charset.StandardCharsets;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BitmapUtil</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> StringRedisTemplate redisTemplate;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * BITCOUNT key [start end]</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 统计 bit=1 的数量</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Long <span class=\"title function_\">bitCount</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt;</span><br><span class=\"line\">                connection.stringCommands().bitCount(key.getBytes(StandardCharsets.UTF_8))</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Long <span class=\"title function_\">bitCount</span><span class=\"params\">(String key, <span class=\"type\">long</span> start, <span class=\"type\">long</span> end)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt;</span><br><span class=\"line\">                connection.stringCommands().bitCount(key.getBytes(), start, end)</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * BITPOS key bit [start] [end]</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * bit = false → 查找第一个 0</span></span><br><span class=\"line\"><span class=\"comment\">     * bit = true → 查找第一个 1</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回值是 bit 索引（不是 byte）</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Long <span class=\"title function_\">bitPos</span><span class=\"params\">(String key, <span class=\"type\">boolean</span> bit)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt;</span><br><span class=\"line\">                connection.stringCommands().bitPos(key.getBytes(), bit)</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Long <span class=\"title function_\">bitPos</span><span class=\"params\">(String key, <span class=\"type\">boolean</span> bit, <span class=\"type\">long</span> start, <span class=\"type\">long</span> end)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt;</span><br><span class=\"line\">                connection.stringCommands().bitPos(key.getBytes(), bit, Range.open(start, end))</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * BITOP operation destKey key [key ...]</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * operation: AND\\OR\\XOR\\NOT</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 运算结果保存在 destKey 中</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Long <span class=\"title function_\">bitOp</span><span class=\"params\">(String destKey, RedisStringCommands.BitOperation operation, String... sourceKeys)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt; &#123;</span><br><span class=\"line\">            <span class=\"type\">byte</span>[][] keys = Arrays.stream(sourceKeys)</span><br><span class=\"line\">                    .map(String::getBytes)</span><br><span class=\"line\">                    .toArray(<span class=\"type\">byte</span>[][]::<span class=\"keyword\">new</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> connection.stringCommands().bitOp(</span><br><span class=\"line\">                    operation,</span><br><span class=\"line\">                    destKey.getBytes(),</span><br><span class=\"line\">                    keys</span><br><span class=\"line\">            );</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍 Redis Bitmap 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ Bitmap 核心详解 Redis Bitmap 并非独立数据类型，而是基于 String 类型的位操作扩展 String 底层是字节数组，Bitmap 就是对数组中单个 bit 做读写（bit 只有 0/1 两个值） Bitmap 命令使用方式 核心围绕「位设置、位查询、位统计、位运算」四类命令，是日常使用的基础 1. 位设置：SETBIT key offset value 给指定 key 的第 offset 位设 0/1（offset 从 0 开始，支持超大偏移量，Redis 会自动扩容） offset 从左往右递增，从左到右为 0、1、2…，至少申请 8bit 空间，不足 8bit 时，会自动扩展到 8bit 即 1byte 123456789SETBIT bitkey 1 1 # 实际的bit为 01000000SETBIT bitkey 10 1 # 实际的bit为 0100000000100000# 操作 StringSET k1 v1 # 实际的bit为 0111011000110001SETBIT k1 1 0 # 实际bit为 0011011000110001GET k1 # 输出 61# bitmap 实际上是 stringTYPE bitkey # 输出 string 2. 位查询：GETBIT key offset 查询指定偏移量的位值，不存在的 offset 默认返回 0 123GETBIT bitkey 1# 输出(integer) 1 3. 位统计：BITCOUNT key [start end] 统计 key 中值为 1 的 bit 总数，可选按字节范围（start/end 是字节索引）筛选 123BITCOUNT bitkey# 等价于BITCOUNT bitkey 0 -1 4. 位运算：BITOP op destkey key1 key2... 对多个 Bitmap 做 与（AND）、或（OR）、异或（XOR）、非（NOT）运算，结果存入 destkey 12# 将key1 与 key2 做按位与运算，结果存入 destkeyBITOP AND destkey key1 key2 5. 位查找：BITPOS key value [start end] 查找第一个值为 0/1 的 bit 偏移量，快速定位目标位 123BITPOS bitkey 1# 等价于BITPOS bitkey 1 0 -1 6. BITFIELD 批量位操作 • BITFIELD 是 Redis 用于把一个 字符串值视为一个由二进制“位数组”组成的存储区，并对其中任意指定位置的整数域进行读取、写入、自增等操作的命令。 • 这些整数域可以是任意位宽（例如 1 位、4 位、8 位、31 位、63 位等），可指定为有符号（signed）或无符号（unsigned）。 • BITFIELD 命令支持在一次调用中执行多个操作，并将结果按操作顺序返回。 12345BITFIELD key [GET encoding offset | [OVERFLOW &lt;WRAP | SAT | FAIL&gt;] &lt;SET encoding offset value | INCRBY encoding offset increment&gt; [GET encoding offset | [OVERFLOW &lt;WRAP | SAT | FAIL&gt;] &lt;SET encoding offset value | INCRBY encoding offset increment&gt; ...]] • 参数说明（核心部分） 参数 含义 key 操作的 Redis 字符串键 GET encoding offset 从指定位偏移量读取一个整数 SET encoding offset value 在指定位置写入整数 INCRBY encoding offset increment 在指定位置对整数做增量操作 OVERFLOW WRAP/SAT/FAIL 配置随后的算数操作溢出行为 • 数据类型（encoding）:用于指定整数的位宽和符号类型 前缀 含义 示例 u&lt;number&gt; 无符号整数（unsigned），占位 bits = number u5 — 5 位无符号整数 i&lt;number&gt; 有符号整数（signed），占位 bits = number i10 — 10 位有符号整数 • 溢出（OVERFLOW）:默认算数操作中可能发生溢出，OVERFLOW 允许你控制处理策略。注意，这部分必须在后续的 SET/INCRBY 操作之前指定。 策略 行为 WRAP 环绕（默认）溢出按环形计数处理 SAT 饱和，在边界值保持最大/最小 FAIL 溢出时操作失败并返回错误 12# 4 位无符号整数加 1 时，如果超过 15，则保持 15（饱和）。BITFIELD key OVERFLOW SAT INCRBY u4 0 1 • 返回值: BITFIELD 会为每个子命令返回一个整数数组，数组各元素按操作顺序对应执行结果 1234BITFIELD mykey INCRBY i5 100 1 GET u4 0# 输出1) (integer) 12) (integer) 0 7. BITFIELD_RO 批量只读 Redis 6.0 新增的只读版本，用于批量只读 1BITFIELD_RO key [GET encoding offset [GET encoding offset ...]] 综合示例 示例 1. 设置并读取简单整数 1234567891011&gt; SET mykey &quot;&quot; # 此时mykey 的值是空字符串，长度为 0# SET u4 0 7：在 key mykey 偏移 0 位置设置 4 位无符号整数值为 7，即前4位变成 0111，因为至少8bit，所以实际值是 01110000# GET u4 0：读取 key mykey 偏移 0 位的 4 位无符号整数，此时 mykey 虽然是 01110000，但这里指定只读前4位，即 0111，所以转换为二进制就是 7&gt; BITFIELD mykey SET u4 0 7 GET u4 0# 输出1) (integer) 0 # set命令的返回值，这里返回set前的值2) (integer) 7 # get命令的返回值# 设置有符号整数&gt; BITFIELD mykey SET i4 0 -2 GET i4 01) (integer) 7 # 返回set前的值，之前是7，即 0111，set后变为 -2，即 11102) (integer) -2 # get命令的返回值 负数的二进制表示 以 -2 为例，先写出 +2 的二进制，以8位为例，就是 00000010，4位就是 0010 按位取反（得到反码），例如 00000010，按位取反就是 11111101 加 1（得到补码），11111101 + 1，得到 11111110，这就是 -2 的二进制表示 如果是4位，则 -2 就是 1110 示例 2. 自增计数器 1234567# 如果 counter 之前为空，则视为 0# INCRBY u8 8 5：在 key counter 的第 8 位（下一个字节开头处）上按 8 位 unsigned 类型自增 5# GET u8 8：读取 key counter 的第 8 位（下一个字节开头处）的 8 位无符号整数，返回这个整数的新值BITFIELD counter INCRBY u8 8 5 GET u8 8# 输出1) (integer) 5 # INCRBY 的返回值，这里返回的是增加的值，而不是计算后的值2) (integer) 5 示例 3. 带溢出控制的操作 1234567# OVERFLOW SAT: 设置溢出策略为 SAT（饱和）# INCRBY u4 0 20: 对 4 位无符号整数（最大 15）加 20，此时肯定会溢出，由于过 15 上限，结果返回 15（饱和）# GET u4 0：读取 4 位无符号整数，即15BITFIELD limits OVERFLOW SAT INCRBY u4 0 20 GET u4 0# 输出1) (integer) 152) (integer) 15 示例 4. 批量多个操作 123456789# GET u4 0 GET u4 4: 依次读取多个不同 bit 偏移量上的小整数# SET u4 8 3 INCRBY i5 16 1: 写入、增量操作可以混合处理# 返回结果数组对应每个子命令顺序返回结果BITFIELD events GET u4 0 GET u4 4 SET u4 8 3 INCRBY i5 16 1# 输出1) (integer) 0 # events原先为空，所以这里返回02) (integer) 0 # events原先为空，所以这里返回03) (integer) 0 # events原先为空，这里返回原先的值，所以还是0，但此时实际的值是 00000000001100004) (integer) 1 # 返回增加的值，即 1，但此时实际的值是 000000000011000000001000，即占用了3个字节 核心使用场景 + 实操举例（贴合开发实战） Bitmap 的核心优势是极致省内存+高效统计（1 个字节=8 个 bit，存储 1000 万条状态仅需约 1.2MB），以下是高频场景 场景1： 用户签到/打卡（最经典场景） • 需求：记录用户每日签到状态，查询某用户某天是否签到、统计某用户月度签到次数 • 设计：key 格式 user:sign:uid:202512（用户2025年12月签到），offset 为日期（1号=0、2号=1…31号=30），签到设 1、未签到默认 0 • 实操命令： 12月1号签到：SETBIT user:sign:uid:202512 0 1 查询12月1号是否签到：GETBIT user:sign:uid:202512 0（返回1=签到） 统计12月总签到次数：BITCOUNT user:sign:uid:202512 • 优势：1个用户1个月签到仅占 4 字节（31 bit），百万用户月度签到仅占约 3.9MB，远超数据库存储的性价比。 劣势：若想查询该用户本月内都哪天签到了，即要查看bitmap哪些位为1，则bitmap不支持这个命令，可以在业务端实现。如需要精确查询和聚合统计则需要同步数据到关系型数据库。 场景2： 日活/周活/月活（DAU/WAU/MAU）统计（高并发场景首选） • 需求：统计每日访问平台的用户数，快速计算周活（7天内至少访问1次）、月活，去重统计 • 设计：按日期建 Bitmap，key 格式 active:user:20251217（当日活跃），offset 设为用户唯一ID（需确保ID是连续或可映射为数字，避免超大偏移量），用户访问则设 1 • 实操命令： 用户ID 10086 12月17日访问：SETBIT active:user:20251217 10086 1 统计12月17日日活：BITCOUNT active:user:20251217 统计12月15-17日3天内活跃的用户数：BITOP OR active:user:20251215_17 active:user:20251215 active:user:20251216 active:user:20251217 → 再执行 BITCOUNT active:user:20251215_17 统计12月15-17日每天都登录的用户数：BITOP AND active:user:20251215_17 active:user:20251215 active:user:20251216 active:user:20251217 → 再执行 BITCOUNT active:user:20251215_17 • 优势：百万级用户日活统计，单 Bitmap 仅占约 125KB，位运算合并统计速度毫秒级，远快于数据库 group by 去重。 劣势：若想查看本月内哪些用户登录过，则需要遍历 Bitmap 的所有 offset 位，效率较低。如需要精确查询和聚合统计则需要同步数据到关系型数据库。 场景3： 功能开关/状态标记（多维度轻量标记） • 需求：给用户标记多类轻量状态（如是否开通会员、是否绑定手机、是否参与活动），无需单独存多个key • 设计：1个key对应1个用户，key 格式 user:status:10086，不同 offset 对应不同状态（offset0=是否绑定手机、offset1=是否会员、offset2=是否参与活动），1=是、0=否 • 实操命令： 给用户10086绑定手机：SETBIT user:status:10086 0 1 开通会员：SETBIT user:status:10086 1 1 查询是否是会员：GETBIT user:status:10086 1 • 优势：1个key承载用户N个状态，无需维护多个 String/Hash，查询和修改均为O(1)，极简高效。 劣势：若想查看用户所有状态，则需要遍历所有 offset 的位，效率较低，另外统计哪些用户开启了某个状态也比较麻烦。如需要精确查询和聚合统计则需要同步数据到关系型数据库。 场景4： 布隆过滤器底层实现（核心依赖Bitmap） • 需求：实现海量数据的快速去重判断（如缓存穿透防护、海量URL去重），允许极小误判率，不允许漏判 • 设计：用1个大 Bitmap 作为底层存储，配合多个哈希函数 —— 数据存入时，通过多个哈希函数算出多个 offset，将对应 bit 设为1；查询时，若所有哈希对应的 offset 都是1，则大概率存在，否则一定不存在 • 实操：Redis 7 可直接用 Bitmap 手动实现，也可结合 RedisBloom 扩展（更易用），核心原理是 Bitmap 的位设置与查询。 • 优势：存储1亿条数据，误判率5%的布隆过滤器，仅需约 12MB 内存，查询速度极致快。 劣势：布隆过滤器虽然有极小误判率，但不允许删除。 注意事项（避坑关键） offset 不要无限制过大：虽 Redis 支持超大 offset，但过大（如超过10亿）会导致 Bitmap 占用内存骤增，需合理规划 offset 范围（如用户ID做哈希映射压缩） 避免单 key 过大：单个 Bitmap 建议控制在1GB内（对应约85亿 bit），过大易导致Redis持久化/迁移耗时过长 注意编码兼容：Bitmap 基于 String，Redis 会自动用 RAW 编码存储，无需手动设置 Bitmap 命令 SpringBoot 的 StringRedisTemplate.opsForValue() 中 Bitmap 数据类型 的操作方法与 Redis 原生命令的对应关系如下： 注意这里一定要用 StringRedisTemplate 来操作 Bitmap 写操作（位修改） 方法功能 方法 Redis 原始命令 备注 设置指定偏移量的位 setBit(K key, long offset, boolean value) SETBIT key offset value 返回旧值（0 / 1），offset 从 0 开始 offset 表示 第几位（bit），不是字节 读操作（位查询） 方法功能 方法 Redis 原始命令 备注 获取指定偏移量的位 getBit(K key, long offset) GETBIT key offset 返回 0 / 1，不会修改数据 批量位操作（位字段 BitField） 位字段读/写/自增 方法功能 方法 Redis 原始命令 备注 位字段操作（读/写/自增） bitField(K key, BitFieldSubCommands subCommands) BITFIELD key ... 原子执行多个子命令 示例 12345BITFIELD limits OVERFLOW SAT SET u4 0 3 INCRBY u4 0 20 GET u4 0 123456789// SET u4 0 3BitFieldSubCommands.BitFieldSet bitFieldSet = BitFieldSubCommands.BitFieldSet.create(BitFieldSubCommands.BitFieldType.unsigned(4), BitFieldSubCommands.Offset.offset(0), 3);// OVERFLOW SAT INCRBY u4 0 20BitFieldSubCommands.BitFieldIncrBy bitFieldIncrBy = BitFieldSubCommands.BitFieldIncrBy.create(BitFieldSubCommands.BitFieldType.unsigned(4), BitFieldSubCommands.Offset.offset(0), 20, BitFieldSubCommands.BitFieldIncrBy.Overflow.SAT);// GET u4 0BitFieldSubCommands.BitFieldGet bitFieldGet = BitFieldSubCommands.BitFieldGet.create(BitFieldSubCommands.BitFieldType.unsigned(4), BitFieldSubCommands.Offset.offset(0));// 获取结果，每个子操作返回一个结果List&lt;Long&gt; limits = redisTemplate.opsForValue().bitField(&quot;limits&quot;, BitFieldSubCommands.create(bitFieldSet, bitFieldIncrBy, bitFieldGet)); Bitmap 常用但 Spring 未直接封装的命令 Spring Data Redis 中通常通过 RedisCallback 或 execute 调用这些命令。 Redis 命令 功能 说明 BITCOUNT key [start end] 统计 bit=1 的数量 常用于活跃用户统计 BITPOS key bit [start end] 查找第一个 0/1 的位置 常用于分配位 BITOP AND/OR/XOR/NOT 位运算 多 bitmap 计算 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.example.demo.bitmap;import com.example.demo.CommonUtil;import org.springframework.data.domain.Range;import org.springframework.data.redis.connection.RedisStringCommands;import org.springframework.data.redis.core.RedisCallback;import org.springframework.stereotype.Component;import java.nio.charset.StandardCharsets;import java.util.Arrays;@Componentpublic class BitmapUtil &#123; @Autowired protected StringRedisTemplate redisTemplate; /** * BITCOUNT key [start end] * &lt;p&gt; * 统计 bit=1 的数量 */ public Long bitCount(String key) &#123; return redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt; connection.stringCommands().bitCount(key.getBytes(StandardCharsets.UTF_8)) ); &#125; public Long bitCount(String key, long start, long end) &#123; return redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt; connection.stringCommands().bitCount(key.getBytes(), start, end) ); &#125; /** * BITPOS key bit [start] [end] * &lt;p&gt; * bit = false → 查找第一个 0 * bit = true → 查找第一个 1 * &lt;p&gt; * 返回值是 bit 索引（不是 byte） */ public Long bitPos(String key, boolean bit) &#123; return redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt; connection.stringCommands().bitPos(key.getBytes(), bit) ); &#125; public Long bitPos(String key, boolean bit, long start, long end) &#123; return redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt; connection.stringCommands().bitPos(key.getBytes(), bit, Range.open(start, end)) ); &#125; /** * BITOP operation destKey key [key ...] * &lt;p&gt; * operation: AND\\OR\\XOR\\NOT * &lt;p&gt; * 运算结果保存在 destKey 中 */ public Long bitOp(String destKey, RedisStringCommands.BitOperation operation, String... sourceKeys) &#123; return redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt; &#123; byte[][] keys = Arrays.stream(sourceKeys) .map(String::getBytes) .toArray(byte[][]::new); return connection.stringCommands().bitOp( operation, destKey.getBytes(), keys ); &#125;); &#125;&#125;","summary":"摘要 本文介绍 Redis Bitmap 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2025-12-18T13:30:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/17/redis7-ReentrantLock/","url":"https://blog.hanqunfeng.com/2025/12/17/redis7-ReentrantLock/","title":"一个基于 Redis 的可重入分布式锁的实现","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 一个基于 Redis 的可重入分布式锁的实现方案</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n<li class=\"lvl-2\">本文仅为学习原理，生产环境推荐使用 <a href=\"https://redisson.pro/docs/data-and-services/locks-and-synchronizers/\">Redisson 分布式锁</a> 吧。</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"设计目标与关键约束\">设计目标与关键约束</h2>\n<h3 id=\"设计目标\">设计目标</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>互斥性：同一时间只有一个持有者</p>\n</li>\n<li class=\"lvl-2\">\n<p>可重入：同一线程 / 请求可多次加锁</p>\n</li>\n<li class=\"lvl-2\">\n<p>安全释放：只能释放自己持有的锁</p>\n</li>\n<li class=\"lvl-2\">\n<p>自动过期：防止死锁</p>\n</li>\n<li class=\"lvl-2\">\n<p>续期能力（Watch Dog）：业务时间不确定时依然安全</p>\n</li>\n<li class=\"lvl-2\">\n<p>高性能：单 Redis Key，Lua 保证原子性</p>\n</li>\n</ul>\n<h3 id=\"技术选型\">技术选型</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Spring Boot</p>\n</li>\n<li class=\"lvl-2\">\n<p>Spring Data Redis（Lettuce）</p>\n</li>\n<li class=\"lvl-2\">\n<p>Redis Lua Script</p>\n</li>\n</ul>\n<blockquote>\n<p>Redis 是唯一依赖组件：Redis<br>\nSpring Boot 作为运行框架：Spring Boot</p>\n</blockquote>\n<h3 id=\"锁的核心数据结构设计（关键）\">锁的核心数据结构设计（关键）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis Key 结构(String)</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># lock:前缀</span></span><br><span class=\"line\">lock:order:123</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Value 结构（Hash）</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;uuid:threadId&quot;</span> : 重入次数</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>同一线程重入 → count +1，不同线程 → 拒绝</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>使用<code>StringRedisTemplate</code>，因其序列化器是<code>StringRedisSerializer</code>，可以保证 Lua 脚本能够正常执行。</p>\n</li>\n</ul>\n<blockquote>\n<p>基于 Redis + Lua + HINCRBY 的可重入分布式锁，HashValue 序列化器 必须是 StringRedisSerializer</p>\n</blockquote>\n<h3 id=\"Lua-脚本（原子性保障）\">Lua 脚本（原子性保障）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>加锁脚本（支持可重入）</p>\n</li>\n</ul>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- KEYS[1] 锁key</span></span><br><span class=\"line\"><span class=\"comment\">-- ARGV[1] ownerId (uuid:threadId)</span></span><br><span class=\"line\"><span class=\"comment\">-- ARGV[2] expireMillis</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (redis.call(<span class=\"string\">&#x27;exists&#x27;</span>, KEYS[<span class=\"number\">1</span>]) == <span class=\"number\">0</span>) <span class=\"keyword\">then</span></span><br><span class=\"line\">    redis.call(<span class=\"string\">&#x27;hset&#x27;</span>, KEYS[<span class=\"number\">1</span>], ARGV[<span class=\"number\">1</span>], <span class=\"number\">1</span>)</span><br><span class=\"line\">    redis.call(<span class=\"string\">&#x27;pexpire&#x27;</span>, KEYS[<span class=\"number\">1</span>], ARGV[<span class=\"number\">2</span>])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (redis.call(<span class=\"string\">&#x27;hexists&#x27;</span>, KEYS[<span class=\"number\">1</span>], ARGV[<span class=\"number\">1</span>]) == <span class=\"number\">1</span>) <span class=\"keyword\">then</span></span><br><span class=\"line\">    redis.call(<span class=\"string\">&#x27;hincrby&#x27;</span>, KEYS[<span class=\"number\">1</span>], ARGV[<span class=\"number\">1</span>], <span class=\"number\">1</span>)</span><br><span class=\"line\">    redis.call(<span class=\"string\">&#x27;pexpire&#x27;</span>, KEYS[<span class=\"number\">1</span>], ARGV[<span class=\"number\">2</span>])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>解锁脚本（防误删）</p>\n</li>\n</ul>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- KEYS[1] 锁key</span></span><br><span class=\"line\"><span class=\"comment\">-- ARGV[1] ownerId</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (redis.call(<span class=\"string\">&#x27;hexists&#x27;</span>, KEYS[<span class=\"number\">1</span>], ARGV[<span class=\"number\">1</span>]) == <span class=\"number\">0</span>) <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">local</span> count = redis.call(<span class=\"string\">&#x27;hincrby&#x27;</span>, KEYS[<span class=\"number\">1</span>], ARGV[<span class=\"number\">1</span>], <span class=\"number\">-1</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> (count &gt; <span class=\"number\">0</span>) <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    redis.call(<span class=\"string\">&#x27;hdel&#x27;</span>, KEYS[<span class=\"number\">1</span>], ARGV[<span class=\"number\">1</span>])</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (redis.call(<span class=\"string\">&#x27;hlen&#x27;</span>, KEYS[<span class=\"number\">1</span>]) == <span class=\"number\">0</span>) <span class=\"keyword\">then</span></span><br><span class=\"line\">        redis.call(<span class=\"string\">&#x27;del&#x27;</span>, KEYS[<span class=\"number\">1</span>])</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Java-实现（核心代码）\">Java 实现（核心代码）</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>WatchDog，实现锁自动续期</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.lock;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.core.script.DefaultRedisScript;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Collections;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisLockWatchDog</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * WatchDog的Lua脚本</span></span><br><span class=\"line\"><span class=\"comment\">     * KEYS[1] 锁key</span></span><br><span class=\"line\"><span class=\"comment\">     * ARGV[1] ownerId (uuid:threadId)</span></span><br><span class=\"line\"><span class=\"comment\">     * ARGV[2] expireMillis 过期时间</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 说明：</span></span><br><span class=\"line\"><span class=\"comment\">     * 拥有者是当前线程就续期</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">WATCHDOG_SCRIPT</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">            if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1) then</span></span><br><span class=\"line\"><span class=\"string\">                redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2])</span></span><br><span class=\"line\"><span class=\"string\">                return 1</span></span><br><span class=\"line\"><span class=\"string\">            end</span></span><br><span class=\"line\"><span class=\"string\">            return 0</span></span><br><span class=\"line\"><span class=\"string\">            &quot;&quot;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> StringRedisTemplate redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 单线程足够（Redisson 也是）</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">ScheduledExecutorService</span> <span class=\"variable\">scheduler</span> <span class=\"operator\">=</span></span><br><span class=\"line\">            Executors.newSingleThreadScheduledExecutor(r -&gt; &#123;</span><br><span class=\"line\">                <span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(r);</span><br><span class=\"line\">                t.setName(<span class=\"string\">&quot;redis-lock-watch-dog&quot;</span>);</span><br><span class=\"line\">                t.setDaemon(<span class=\"literal\">true</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 每个 lockKey 对应一个续期任务</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, ScheduledFuture&lt;?&gt;&gt; renewTasks = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">RedisLockWatchDog</span><span class=\"params\">(StringRedisTemplate redisTemplate)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.redisTemplate = redisTemplate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 启动续期</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> lockKey     Redis 锁 key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> ownerId     uuid:threadId</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> leaseMillis 锁过期时间</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">startRenew</span><span class=\"params\">(String lockKey, String ownerId, <span class=\"type\">long</span> leaseMillis)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 防止重复启动</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (renewTasks.containsKey(lockKey)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 间隔多久续期一次</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">period</span> <span class=\"operator\">=</span> leaseMillis / <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        ScheduledFuture&lt;?&gt; future = scheduler.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                renew(lockKey, ownerId, leaseMillis);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 生产环境建议接日志</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, period, period, TimeUnit.MILLISECONDS);</span><br><span class=\"line\"></span><br><span class=\"line\">        renewTasks.put(lockKey, future);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 取消续期</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">stopRenew</span><span class=\"params\">(String lockKey)</span> &#123;</span><br><span class=\"line\">        ScheduledFuture&lt;?&gt; future = renewTasks.remove(lockKey);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (future != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            future.cancel(<span class=\"literal\">false</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 实际续期逻辑</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">renew</span><span class=\"params\">(String lockKey, String ownerId, <span class=\"type\">long</span> leaseMillis)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Boolean</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(WATCHDOG_SCRIPT, Boolean.class),</span><br><span class=\"line\">                Collections.singletonList(lockKey),</span><br><span class=\"line\">                ownerId,</span><br><span class=\"line\">                String.valueOf(leaseMillis)</span><br><span class=\"line\">        );</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!result) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 锁已不属于当前线程，停止 Watch Dog</span></span><br><span class=\"line\">            stopRenew(lockKey);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 应用关闭时释放资源（可选）</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">shutdown</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        scheduler.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>锁接口</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.lock;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">DistributedLock</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 尝试获取锁</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key       锁的key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> waitTime  尝试获取锁的最大等待时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> leaseTime 锁的过期时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> unit      时间单位</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true表示获取锁成功，false表示获取锁失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">tryLock</span><span class=\"params\">(String key, <span class=\"type\">long</span> waitTime, <span class=\"type\">long</span> leaseTime, TimeUnit unit)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 尝试获取锁</span></span><br><span class=\"line\"><span class=\"comment\">     * 不等待立即返回</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key       锁的key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> leaseTime 锁的过期时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> unit      时间单位</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true表示获取锁成功，false表示获取锁失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">tryLock</span><span class=\"params\">(String key, <span class=\"type\">long</span> leaseTime, TimeUnit unit)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取锁</span></span><br><span class=\"line\"><span class=\"comment\">     * 只要获取到锁就返回，否则一直自旋获取锁</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 锁的key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> leaseTime 锁的过期时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> unit 时间单位</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true表示获取锁成功，false表示获取锁失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">lock</span><span class=\"params\">(String key, <span class=\"type\">long</span> leaseTime, TimeUnit unit)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 释放锁</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 锁的key</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">unlock</span><span class=\"params\">(String key)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>锁实现类</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.lock;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.core.script.DefaultRedisScript;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Collections;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.UUID;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisReentrantLock</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">DistributedLock</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 锁的key前缀</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">LOCK_PREFIX</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;lock:&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 锁的Lua脚本</span></span><br><span class=\"line\"><span class=\"comment\">     * KEYS[1] 锁key</span></span><br><span class=\"line\"><span class=\"comment\">     * ARGV[1] ownerId (uuid:threadId)</span></span><br><span class=\"line\"><span class=\"comment\">     * ARGV[2] expireMillis 过期时间</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 说明：</span></span><br><span class=\"line\"><span class=\"comment\">     * 1.key 不存在时创建锁</span></span><br><span class=\"line\"><span class=\"comment\">     * 2.key 存在时判断锁的拥有者是否为当前线程</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">LOCK_SCRIPT</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">            if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then</span></span><br><span class=\"line\"><span class=\"string\">                redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[1], 1)</span></span><br><span class=\"line\"><span class=\"string\">                redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2])</span></span><br><span class=\"line\"><span class=\"string\">                return 1</span></span><br><span class=\"line\"><span class=\"string\">            end</span></span><br><span class=\"line\"><span class=\"string\">            if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1) then</span></span><br><span class=\"line\"><span class=\"string\">                redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], 1)</span></span><br><span class=\"line\"><span class=\"string\">                redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2])</span></span><br><span class=\"line\"><span class=\"string\">                return 1</span></span><br><span class=\"line\"><span class=\"string\">            end</span></span><br><span class=\"line\"><span class=\"string\">            return 0</span></span><br><span class=\"line\"><span class=\"string\">            &quot;&quot;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 释放锁的Lua脚本</span></span><br><span class=\"line\"><span class=\"comment\">     * KEYS[1] 锁key</span></span><br><span class=\"line\"><span class=\"comment\">     * ARGV[1] ownerId (uuid:threadId)</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">UNLOCK_SCRIPT</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">            if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 0) then</span></span><br><span class=\"line\"><span class=\"string\">                return 0</span></span><br><span class=\"line\"><span class=\"string\">            end</span></span><br><span class=\"line\"><span class=\"string\">            local count = redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], -1)</span></span><br><span class=\"line\"><span class=\"string\">            if (count &gt; 0) then</span></span><br><span class=\"line\"><span class=\"string\">                return 1</span></span><br><span class=\"line\"><span class=\"string\">            else</span></span><br><span class=\"line\"><span class=\"string\">                redis.call(&#x27;hdel&#x27;, KEYS[1], ARGV[1])</span></span><br><span class=\"line\"><span class=\"string\">                if (redis.call(&#x27;hlen&#x27;, KEYS[1]) == 0) then</span></span><br><span class=\"line\"><span class=\"string\">                    redis.call(&#x27;del&#x27;, KEYS[1])</span></span><br><span class=\"line\"><span class=\"string\">                end</span></span><br><span class=\"line\"><span class=\"string\">                return 1</span></span><br><span class=\"line\"><span class=\"string\">            end</span></span><br><span class=\"line\"><span class=\"string\">            &quot;&quot;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> StringRedisTemplate redisTemplate;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> RedisLockWatchDog watchDog;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">uuid</span> <span class=\"operator\">=</span> UUID.randomUUID().toString();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">RedisReentrantLock</span><span class=\"params\">(StringRedisTemplate redisTemplate)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.redisTemplate = redisTemplate;</span><br><span class=\"line\">        watchDog = <span class=\"keyword\">new</span> <span class=\"title class_\">RedisLockWatchDog</span>(redisTemplate);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取当前线程的 ownerId</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String <span class=\"title function_\">ownerId</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> uuid + <span class=\"string\">&quot;:&quot;</span> + Thread.currentThread().getId();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryLock</span><span class=\"params\">(String key, <span class=\"type\">long</span> leaseTime, TimeUnit unit)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">lockKey</span> <span class=\"operator\">=</span> LOCK_PREFIX + key;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">expireMillis</span> <span class=\"operator\">=</span> unit.toMillis(leaseTime);</span><br><span class=\"line\">        <span class=\"type\">Boolean</span> <span class=\"variable\">success</span> <span class=\"operator\">=</span> redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(LOCK_SCRIPT, Boolean.class),</span><br><span class=\"line\">                Collections.singletonList(lockKey),</span><br><span class=\"line\">                ownerId(),</span><br><span class=\"line\">                String.valueOf(expireMillis)</span><br><span class=\"line\">        );</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Boolean.TRUE.equals(success)) &#123;<span class=\"comment\">//防止NullPointerException</span></span><br><span class=\"line\">            <span class=\"comment\">// 启动 Watch Dog（只有在 leaseTime 不确定时）</span></span><br><span class=\"line\">            watchDog.startRenew(</span><br><span class=\"line\">                    lockKey,</span><br><span class=\"line\">                    ownerId(),</span><br><span class=\"line\">                    expireMillis</span><br><span class=\"line\">            );</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryLock</span><span class=\"params\">(String key, <span class=\"type\">long</span> waitTime, <span class=\"type\">long</span> leaseTime, TimeUnit unit)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">deadline</span> <span class=\"operator\">=</span> System.currentTimeMillis() + unit.toMillis(waitTime);</span><br><span class=\"line\">        <span class=\"comment\">// 使用带条件的循环，避免重复赋值</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (System.currentTimeMillis() &lt; deadline) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tryLock(key, leaseTime, unit)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 让当前线程挂起（阻塞），最长不超过指定的纳秒数</span></span><br><span class=\"line\">                <span class=\"comment\">// 在竞争失败后，让出 CPU 一小段时间，避免忙等，同时控制对 Redis 的重试频率。</span></span><br><span class=\"line\">                <span class=\"comment\">// 这里50毫秒是经验值，可以根据实际需求调整</span></span><br><span class=\"line\">                LockSupport.parkNanos(TimeUnit.MILLISECONDS.toNanos(<span class=\"number\">50</span>));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">lock</span><span class=\"params\">(String key, <span class=\"type\">long</span> leaseTime, TimeUnit unit)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 使用无限循环，语义更清晰</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tryLock(key, leaseTime, unit)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 让当前线程挂起（阻塞），最长不超过指定的纳秒数</span></span><br><span class=\"line\">                <span class=\"comment\">// 在竞争失败后，让出 CPU 一小段时间，避免忙等，同时控制对 Redis 的重试频率。</span></span><br><span class=\"line\">                <span class=\"comment\">// 这里50毫秒是经验值，可以根据实际需求调整</span></span><br><span class=\"line\">                LockSupport.parkNanos(TimeUnit.MILLISECONDS.toNanos(<span class=\"number\">50</span>));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">unlock</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">lockKey</span> <span class=\"operator\">=</span> LOCK_PREFIX + key;</span><br><span class=\"line\">        <span class=\"comment\">// 先停续期</span></span><br><span class=\"line\">        watchDog.stopRenew(lockKey);</span><br><span class=\"line\">        <span class=\"comment\">// 释放锁</span></span><br><span class=\"line\">        redisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(UNLOCK_SCRIPT, Long.class),</span><br><span class=\"line\">                Collections.singletonList(lockKey),</span><br><span class=\"line\">                ownerId()</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>测试类</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.lock.RedisReentrantLock;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.jupiter.api.Test;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.CountDownLatch;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SpringBootTest</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LockTests</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    RedisReentrantLock redisReentrantLock;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">lockKey</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;order:123&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 测试获取锁</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">demo</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (redisReentrantLock.tryLock(lockKey, <span class=\"number\">5</span>, <span class=\"number\">30</span>, TimeUnit.SECONDS)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 业务逻辑</span></span><br><span class=\"line\">                doBusiness();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                redisReentrantLock.unlock(lockKey);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 测试可重入锁</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doBusiness</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (redisReentrantLock.lock(lockKey, <span class=\"number\">30</span>, TimeUnit.SECONDS)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;开始执行业务逻辑&quot;</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 模拟业务逻辑执行时间，这里设置200秒，就是为了测试锁的自动续期功能</span></span><br><span class=\"line\">                    TimeUnit.SECONDS.sleep(<span class=\"number\">200</span>);</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;结束执行业务逻辑&quot;</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    redisReentrantLock.unlock(lockKey);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 测试多线程同时获取锁</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">demoMultiThread</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">threadCount</span> <span class=\"operator\">=</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">        <span class=\"type\">CountDownLatch</span> <span class=\"variable\">latch</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CountDownLatch</span>(threadCount);</span><br><span class=\"line\">        <span class=\"type\">AtomicInteger</span> <span class=\"variable\">successCount</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">threadId</span> <span class=\"operator\">=</span> i;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 每个线程都尝试获取同一个锁</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (redisReentrantLock.tryLock(lockKey, <span class=\"number\">10</span>, <span class=\"number\">30</span>, TimeUnit.SECONDS)) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            successCount.incrementAndGet();</span><br><span class=\"line\">                            System.out.println(<span class=\"string\">&quot;线程 &quot;</span> + threadId + <span class=\"string\">&quot; 获取锁成功，开始执行业务&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                            <span class=\"comment\">// 模拟业务执行时间</span></span><br><span class=\"line\">                            TimeUnit.SECONDS.sleep(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                            System.out.println(<span class=\"string\">&quot;线程 &quot;</span> + threadId + <span class=\"string\">&quot; 业务执行完成&quot;</span>);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                            redisReentrantLock.unlock(lockKey);</span><br><span class=\"line\">                            System.out.println(<span class=\"string\">&quot;线程 &quot;</span> + threadId + <span class=\"string\">&quot; 释放锁&quot;</span>);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">&quot;线程 &quot;</span> + threadId + <span class=\"string\">&quot; 获取锁失败&quot;</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    latch.countDown();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 等待所有线程执行完成</span></span><br><span class=\"line\">        latch.await();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;成功获取锁的线程数: &quot;</span> + successCount.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍 一个基于 Redis 的可重入分布式锁的实现方案 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ 本文仅为学习原理，生产环境推荐使用 Redisson 分布式锁 吧。 设计目标与关键约束 设计目标 互斥性：同一时间只有一个持有者 可重入：同一线程 / 请求可多次加锁 安全释放：只能释放自己持有的锁 自动过期：防止死锁 续期能力（Watch Dog）：业务时间不确定时依然安全 高性能：单 Redis Key，Lua 保证原子性 技术选型 Spring Boot Spring Data Redis（Lettuce） Redis Lua Script Redis 是唯一依赖组件：Redis Spring Boot 作为运行框架：Spring Boot 锁的核心数据结构设计（关键） Redis Key 结构(String) 12# lock:前缀lock:order:123 Value 结构（Hash） 123&#123; &quot;uuid:threadId&quot; : 重入次数&#125; 同一线程重入 → count +1，不同线程 → 拒绝 使用StringRedisTemplate，因其序列化器是StringRedisSerializer，可以保证 Lua 脚本能够正常执行。 基于 Redis + Lua + HINCRBY 的可重入分布式锁，HashValue 序列化器 必须是 StringRedisSerializer Lua 脚本（原子性保障） 加锁脚本（支持可重入） 1234567891011121314151617-- KEYS[1] 锁key-- ARGV[1] ownerId (uuid:threadId)-- ARGV[2] expireMillisif (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[1], 1) redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]) return 1endif (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1) then redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], 1) redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]) return 1endreturn 0 解锁脚本（防误删） 1234567891011121314151617-- KEYS[1] 锁key-- ARGV[1] ownerIdif (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 0) then return 0endlocal count = redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], -1)if (count &gt; 0) then return 1else redis.call(&#x27;hdel&#x27;, KEYS[1], ARGV[1]) if (redis.call(&#x27;hlen&#x27;, KEYS[1]) == 0) then redis.call(&#x27;del&#x27;, KEYS[1]) end return 1end Java 实现（核心代码） WatchDog，实现锁自动续期 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package com.example.lock;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.core.script.DefaultRedisScript;import java.util.Collections;import java.util.Map;import java.util.concurrent.*;public class RedisLockWatchDog &#123; /** * WatchDog的Lua脚本 * KEYS[1] 锁key * ARGV[1] ownerId (uuid:threadId) * ARGV[2] expireMillis 过期时间 * &lt;p&gt; * 说明： * 拥有者是当前线程就续期 */ private static final String WATCHDOG_SCRIPT = &quot;&quot;&quot; if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1) then redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]) return 1 end return 0 &quot;&quot;&quot;; private final StringRedisTemplate redisTemplate; /** * 单线程足够（Redisson 也是） */ private final ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor(r -&gt; &#123; Thread t = new Thread(r); t.setName(&quot;redis-lock-watch-dog&quot;); t.setDaemon(true); return t; &#125;); /** * 每个 lockKey 对应一个续期任务 */ private final Map&lt;String, ScheduledFuture&lt;?&gt;&gt; renewTasks = new ConcurrentHashMap&lt;&gt;(); public RedisLockWatchDog(StringRedisTemplate redisTemplate) &#123; this.redisTemplate = redisTemplate; &#125; /** * 启动续期 * * @param lockKey Redis 锁 key * @param ownerId uuid:threadId * @param leaseMillis 锁过期时间 */ public void startRenew(String lockKey, String ownerId, long leaseMillis) &#123; // 防止重复启动 if (renewTasks.containsKey(lockKey)) &#123; return; &#125; // 间隔多久续期一次 long period = leaseMillis / 3; ScheduledFuture&lt;?&gt; future = scheduler.scheduleAtFixedRate(() -&gt; &#123; try &#123; renew(lockKey, ownerId, leaseMillis); &#125; catch (Exception e) &#123; // 生产环境建议接日志 &#125; &#125;, period, period, TimeUnit.MILLISECONDS); renewTasks.put(lockKey, future); &#125; /** * 取消续期 */ public void stopRenew(String lockKey) &#123; ScheduledFuture&lt;?&gt; future = renewTasks.remove(lockKey); if (future != null) &#123; future.cancel(false); &#125; &#125; /** * 实际续期逻辑 */ private void renew(String lockKey, String ownerId, long leaseMillis) &#123; Boolean result = redisTemplate.execute( new DefaultRedisScript&lt;&gt;(WATCHDOG_SCRIPT, Boolean.class), Collections.singletonList(lockKey), ownerId, String.valueOf(leaseMillis) ); if (!result) &#123; // 锁已不属于当前线程，停止 Watch Dog stopRenew(lockKey); &#125; &#125; /** * 应用关闭时释放资源（可选） */ public void shutdown() &#123; scheduler.shutdown(); &#125;&#125; 锁接口 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.example.lock;import java.util.concurrent.TimeUnit;public interface DistributedLock &#123; /** * 尝试获取锁 * * @param key 锁的key * @param waitTime 尝试获取锁的最大等待时间 * @param leaseTime 锁的过期时间 * @param unit 时间单位 * @return true表示获取锁成功，false表示获取锁失败 */ boolean tryLock(String key, long waitTime, long leaseTime, TimeUnit unit); /** * 尝试获取锁 * 不等待立即返回 * @param key 锁的key * @param leaseTime 锁的过期时间 * @param unit 时间单位 * @return true表示获取锁成功，false表示获取锁失败 */ boolean tryLock(String key, long leaseTime, TimeUnit unit); /** * 获取锁 * 只要获取到锁就返回，否则一直自旋获取锁 * @param key 锁的key * @param leaseTime 锁的过期时间 * @param unit 时间单位 * @return true表示获取锁成功，false表示获取锁失败 */ boolean lock(String key, long leaseTime, TimeUnit unit); /** * 释放锁 * * @param key 锁的key */ void unlock(String key);&#125; 锁实现类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151package com.example.lock;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.core.script.DefaultRedisScript;import org.springframework.stereotype.Component;import java.util.Collections;import java.util.UUID;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.LockSupport;@Componentpublic class RedisReentrantLock implements DistributedLock &#123; /** * 锁的key前缀 */ private static final String LOCK_PREFIX = &quot;lock:&quot;; /** * 锁的Lua脚本 * KEYS[1] 锁key * ARGV[1] ownerId (uuid:threadId) * ARGV[2] expireMillis 过期时间 * &lt;p&gt; * 说明： * 1.key 不存在时创建锁 * 2.key 存在时判断锁的拥有者是否为当前线程 */ private static final String LOCK_SCRIPT = &quot;&quot;&quot; if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[1], 1) redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]) return 1 end if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1) then redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], 1) redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]) return 1 end return 0 &quot;&quot;&quot;; /** * 释放锁的Lua脚本 * KEYS[1] 锁key * ARGV[1] ownerId (uuid:threadId) */ private static final String UNLOCK_SCRIPT = &quot;&quot;&quot; if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 0) then return 0 end local count = redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], -1) if (count &gt; 0) then return 1 else redis.call(&#x27;hdel&#x27;, KEYS[1], ARGV[1]) if (redis.call(&#x27;hlen&#x27;, KEYS[1]) == 0) then redis.call(&#x27;del&#x27;, KEYS[1]) end return 1 end &quot;&quot;&quot;; private final StringRedisTemplate redisTemplate; private final RedisLockWatchDog watchDog; private final String uuid = UUID.randomUUID().toString(); public RedisReentrantLock(StringRedisTemplate redisTemplate) &#123; this.redisTemplate = redisTemplate; watchDog = new RedisLockWatchDog(redisTemplate); &#125; /** * 获取当前线程的 ownerId * * @return */ private String ownerId() &#123; return uuid + &quot;:&quot; + Thread.currentThread().getId(); &#125; @Override public boolean tryLock(String key, long leaseTime, TimeUnit unit) &#123; String lockKey = LOCK_PREFIX + key; long expireMillis = unit.toMillis(leaseTime); Boolean success = redisTemplate.execute( new DefaultRedisScript&lt;&gt;(LOCK_SCRIPT, Boolean.class), Collections.singletonList(lockKey), ownerId(), String.valueOf(expireMillis) ); if (Boolean.TRUE.equals(success)) &#123;//防止NullPointerException // 启动 Watch Dog（只有在 leaseTime 不确定时） watchDog.startRenew( lockKey, ownerId(), expireMillis ); return true; &#125; return false; &#125; @Override public boolean tryLock(String key, long waitTime, long leaseTime, TimeUnit unit) &#123; long deadline = System.currentTimeMillis() + unit.toMillis(waitTime); // 使用带条件的循环，避免重复赋值 while (System.currentTimeMillis() &lt; deadline) &#123; if (tryLock(key, leaseTime, unit)) &#123; return true; &#125; else &#123; // 让当前线程挂起（阻塞），最长不超过指定的纳秒数 // 在竞争失败后，让出 CPU 一小段时间，避免忙等，同时控制对 Redis 的重试频率。 // 这里50毫秒是经验值，可以根据实际需求调整 LockSupport.parkNanos(TimeUnit.MILLISECONDS.toNanos(50)); &#125; &#125; return false; &#125; @Override public boolean lock(String key, long leaseTime, TimeUnit unit) &#123; // 使用无限循环，语义更清晰 while (true) &#123; if (tryLock(key, leaseTime, unit)) &#123; return true; &#125; else &#123; // 让当前线程挂起（阻塞），最长不超过指定的纳秒数 // 在竞争失败后，让出 CPU 一小段时间，避免忙等，同时控制对 Redis 的重试频率。 // 这里50毫秒是经验值，可以根据实际需求调整 LockSupport.parkNanos(TimeUnit.MILLISECONDS.toNanos(50)); &#125; &#125; &#125; @Override public void unlock(String key) &#123; String lockKey = LOCK_PREFIX + key; // 先停续期 watchDog.stopRenew(lockKey); // 释放锁 redisTemplate.execute( new DefaultRedisScript&lt;&gt;(UNLOCK_SCRIPT, Long.class), Collections.singletonList(lockKey), ownerId() ); &#125;&#125; 测试类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package com.example;import com.example.lock.RedisReentrantLock;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.util.concurrent.CountDownLatch;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicInteger;@SpringBootTestpublic class LockTests &#123; @Autowired RedisReentrantLock redisReentrantLock; String lockKey = &quot;order:123&quot;; // 测试获取锁 @Test void demo() &#123; if (redisReentrantLock.tryLock(lockKey, 5, 30, TimeUnit.SECONDS)) &#123; try &#123; // 业务逻辑 doBusiness(); &#125; finally &#123; redisReentrantLock.unlock(lockKey); &#125; &#125; &#125; // 测试可重入锁 private void doBusiness() &#123; try &#123; if (redisReentrantLock.lock(lockKey, 30, TimeUnit.SECONDS)) &#123; try &#123; System.out.println(&quot;开始执行业务逻辑&quot;); // 模拟业务逻辑执行时间，这里设置200秒，就是为了测试锁的自动续期功能 TimeUnit.SECONDS.sleep(200); System.out.println(&quot;结束执行业务逻辑&quot;); &#125; finally &#123; redisReentrantLock.unlock(lockKey); &#125; &#125; &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; &#125; // 测试多线程同时获取锁 @Test void demoMultiThread() throws InterruptedException &#123; int threadCount = 5; CountDownLatch latch = new CountDownLatch(threadCount); AtomicInteger successCount = new AtomicInteger(0); for (int i = 0; i &lt; threadCount; i++) &#123; final int threadId = i; new Thread(() -&gt; &#123; try &#123; // 每个线程都尝试获取同一个锁 if (redisReentrantLock.tryLock(lockKey, 10, 30, TimeUnit.SECONDS)) &#123; try &#123; successCount.incrementAndGet(); System.out.println(&quot;线程 &quot; + threadId + &quot; 获取锁成功，开始执行业务&quot;); // 模拟业务执行时间 TimeUnit.SECONDS.sleep(3); System.out.println(&quot;线程 &quot; + threadId + &quot; 业务执行完成&quot;); &#125; finally &#123; redisReentrantLock.unlock(lockKey); System.out.println(&quot;线程 &quot; + threadId + &quot; 释放锁&quot;); &#125; &#125; else &#123; System.out.println(&quot;线程 &quot; + threadId + &quot; 获取锁失败&quot;); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; latch.countDown(); &#125; &#125;).start(); &#125; // 等待所有线程执行完成 latch.await(); System.out.println(&quot;成功获取锁的线程数: &quot; + successCount.get()); &#125;&#125;","summary":"摘要 本文介绍 一个基于 Redis 的可重入分布式锁的实现方案 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ 本文仅为学习原理，生产环境推荐使用 Redisson 分布式锁 吧。","date_published":"2025-12-17T13:30:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/16/redis7-datatype-06-zset/","url":"https://blog.hanqunfeng.com/2025/12/16/redis7-datatype-06-zset/","title":"Redis 命令及数据类型 -- ZSet","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis ZSet 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"ZSet-核心详解\">ZSet 核心详解</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis ZSet 是一种 带权重的有序集合，本质结构为：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key -&gt; &#123; member -&gt; score &#125;</span><br><span class=\"line\"><span class=\"comment\"># 说明</span></span><br><span class=\"line\">member：唯一，不可重复（String，二进制安全）</span><br><span class=\"line\">score：double 类型，用于排序</span><br><span class=\"line\">集合按 score 从小到大 排序</span><br><span class=\"line\">score 相同则按 member 的字典序(Lex)排序</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ZSet = Set（去重） + 排序能力</p>\n</li>\n<li class=\"lvl-2\">\n<p>ZSet 的核心特性</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">元素唯一</span><br><span class=\"line\">天然有序</span><br><span class=\"line\">支持范围查询</span><br><span class=\"line\">支持排名（rank）</span><br><span class=\"line\">支持按 score 增量更新</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis ZSet 的理论最大长度为 2^32 - 1 = 4294967295，但实际业务中，元素数量 ≥ 10,000 就算 BigKey 了。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Redis ZSet 是实现排行榜、延迟队列和有序统计的首选数据结构，在“顺序 + 去重 + 查询效率”之间取得了极佳平衡。</p>\n</li>\n<li class=\"lvl-2\">\n<p>ZSet 的应用场景</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Zset集合操作实现新闻点击排行榜</span></span><br><span class=\"line\">1）点击新闻</span><br><span class=\"line\">ZINCRBY hotNews:20251201 1 news1 <span class=\"comment\"># 点击一次分数 +1</span></span><br><span class=\"line\">2）展示当日点击排行前十</span><br><span class=\"line\">ZREVRANGE hotNews:20251201 0 9 WITHSCORES <span class=\"comment\"># 倒序</span></span><br><span class=\"line\">3）七日搜索榜单计算</span><br><span class=\"line\">ZUNIONSTORE hotNews:20251201-20251207 7 hotNews:20251201 ...省略... hotNews:20251207 <span class=\"comment\"># 合并</span></span><br><span class=\"line\">4）展示七日排行前十</span><br><span class=\"line\">ZREVRANGE hotNews:20251201-20251207 0 9 WITHSCORES</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>生产环境建议</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZSet 适合 排序 + 查询</span><br><span class=\"line\">score 设计要稳定、可扩展</span><br><span class=\"line\">定期裁剪（ZREMRANGEBYRANK / ZREMRANGEBYSCORE）</span><br><span class=\"line\">大 ZSet 避免全量遍历</span><br><span class=\"line\">删除大 ZSet 使用 UNLINK</span><br></pre></td></tr></table></figure>\n<h2 id=\"ZSet-命令\">ZSet 命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot 的 <code>RedisTemplate&lt;K,V&gt;.opsForZSet()</code> 中 ZSet 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p>\n</li>\n</ul>\n<h3 id=\"基础写入-删除-计数\">基础写入 / 删除 / 计数</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>命令备注 / 推荐替代</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>添加元素（含 score）</td>\n<td><code>Boolean add(K key, V value, double score)</code></td>\n<td><code>ZADD key score member</code></td>\n<td>新增返回 <code>true</code></td>\n</tr>\n<tr>\n<td>添加元素（仅不存在时）</td>\n<td><code>Boolean addIfAbsent(K key, V value, double score)</code></td>\n<td><code>ZADD key NX score member</code></td>\n<td>Redis ≥ 3.0</td>\n</tr>\n<tr>\n<td>批量添加</td>\n<td><code>Long add(K key, Set&lt;TypedTuple&lt;V&gt;&gt; tuples)</code></td>\n<td><code>ZADD key score member [score member ...]</code></td>\n<td>返回新增数量</td>\n</tr>\n<tr>\n<td>批量添加（仅不存在）</td>\n<td><code>Long addIfAbsent(K key, Set&lt;TypedTuple&lt;V&gt;&gt; tuples)</code></td>\n<td><code>ZADD key NX ...</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>删除成员</td>\n<td><code>Long remove(K key, Object... values)</code></td>\n<td><code>ZREM key member [member ...]</code></td>\n<td>返回删除数量</td>\n</tr>\n<tr>\n<td>递增 score</td>\n<td><code>Double incrementScore(K key, V value, double delta)</code></td>\n<td><code>ZINCRBY key delta member</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>获取集合大小</td>\n<td><code>Long size(K key)</code></td>\n<td><code>ZCARD key</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>获取集合大小（同义）</td>\n<td><code>Long zCard(K key)</code></td>\n<td><code>ZCARD key</code></td>\n<td>API 别名</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"随机访问\">随机访问</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>命令备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>随机获取成员</td>\n<td><code>V randomMember(K key)</code></td>\n<td><code>ZRANDMEMBER key</code></td>\n<td>不返回 score</td>\n</tr>\n<tr>\n<td>随机获取不重复成员</td>\n<td><code>Set&lt;V&gt; distinctRandomMembers(K key, long count)</code></td>\n<td><code>ZRANDMEMBER key count</code></td>\n<td>count &gt; 0</td>\n</tr>\n<tr>\n<td>随机获取可重复成员</td>\n<td><code>List&lt;V&gt; randomMembers(K key, long count)</code></td>\n<td><code>ZRANDMEMBER key -count</code></td>\n<td>count &lt; 0</td>\n</tr>\n<tr>\n<td>随机获取成员及 score</td>\n<td><code>TypedTuple&lt;V&gt; randomMemberWithScore(K key)</code></td>\n<td><code>ZRANDMEMBER key WITHSCORES</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>随机获取不重复成员及 score</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; distinctRandomMembersWithScore(K key, long count)</code></td>\n<td><code>ZRANDMEMBER key count WITHSCORES</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>随机获取可重复成员及 score</td>\n<td><code>List&lt;TypedTuple&lt;V&gt;&gt; randomMembersWithScore(K key, long count)</code></td>\n<td><code>ZRANDMEMBER key -count WITHSCORES</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"排名-score-查询\">排名 / score 查询</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>获取正序排名</td>\n<td><code>Long rank(K key, Object o)</code></td>\n<td><code>ZRANK key member</code></td>\n<td>从 0 开始</td>\n</tr>\n<tr>\n<td>获取倒序排名</td>\n<td><code>Long reverseRank(K key, Object o)</code></td>\n<td><code>ZREVRANK key member</code></td>\n<td>从 0 开始</td>\n</tr>\n<tr>\n<td>获取 score</td>\n<td><code>Double score(K key, Object o)</code></td>\n<td><code>ZSCORE key member</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>批量获取 score</td>\n<td><code>List&lt;Double&gt; score(K key, Object... o)</code></td>\n<td><code>ZMScore key member [member ...]</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>score 区间计数</td>\n<td><code>Long count(K key, double min, double max)</code></td>\n<td><code>ZCOUNT key min max</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"区间查询（rank-score）\">区间查询（rank / score）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>按 rank 查询</td>\n<td><code>Set&lt;V&gt; range(K key, long start, long end)</code></td>\n<td><code>ZRANGE key start end</code></td>\n<td>正序<br>rank = 元素在 ZSet 中按 score 排序后的下标位置（从 0 开始）</td>\n</tr>\n<tr>\n<td>按 rank 查询（含 score）</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; rangeWithScores(K key, long start, long end)</code></td>\n<td><code>ZRANGE key start end WITHSCORES</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>按 score 查询</td>\n<td><code>Set&lt;V&gt; rangeByScore(K key, double min, double max)</code></td>\n<td><code>ZRANGEBYSCORE key min max</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>按 score 查询（含 score）</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; rangeByScoreWithScores(K key, double min, double max)</code></td>\n<td><code>ZRANGEBYSCORE key min max WITHSCORES</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>score 分页</td>\n<td><code>Set&lt;V&gt; rangeByScore(K key, double min, double max, long offset, long count)</code></td>\n<td><code>ZRANGEBYSCORE key min max LIMIT offset count</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>score 分页（含 score）</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; rangeByScoreWithScores(K key, double min, double max, long offset, long count)</code></td>\n<td><code>ZRANGEBYSCORE key min max WITHSCORES LIMIT offset count</code></td>\n<td>按 score 升序分页，返回 member + score</td>\n</tr>\n<tr>\n<td>倒序 rank 查询</td>\n<td><code>Set&lt;V&gt; reverseRange(K key, long start, long end)</code></td>\n<td><code>ZREVRANGE key start end</code></td>\n<td>按 rank 倒序（高 → 低）</td>\n</tr>\n<tr>\n<td>倒序 rank（含 score）</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; reverseRangeWithScores(K key, long start, long end)</code></td>\n<td><code>ZREVRANGE key start end WITHSCORES</code></td>\n<td>倒序 rank，返回 score</td>\n</tr>\n<tr>\n<td>倒序 score 查询</td>\n<td><code>Set&lt;V&gt; reverseRangeByScore(K key, double min, double max)</code></td>\n<td><code>ZREVRANGEBYSCORE key max min</code></td>\n<td>注意：<strong>max 在前，min 在后</strong></td>\n</tr>\n<tr>\n<td>倒序 score（含 score）</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; reverseRangeByScoreWithScores(K key, double min, double max)</code></td>\n<td><code>ZREVRANGEBYSCORE key max min WITHSCORES</code></td>\n<td>倒序 score，返回 score</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"弹出元素（队列-TopN-场景）\">弹出元素（队列 / TopN 场景）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>弹出最小 score</td>\n<td><code>TypedTuple&lt;V&gt; popMin(K key)</code></td>\n<td><code>ZPOPMIN key</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>批量弹出最小 score</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; popMin(K key, long count)</code></td>\n<td><code>ZPOPMIN key count</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>阻塞弹出最小 score</td>\n<td><code>TypedTuple&lt;V&gt; popMin(K key, timeout)</code></td>\n<td><code>BZPOPMIN key timeout</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>弹出最大 score</td>\n<td><code>TypedTuple&lt;V&gt; popMax(K key)</code></td>\n<td><code>ZPOPMAX key</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>批量弹出最大 score</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; popMax(K key, long count)</code></td>\n<td><code>ZPOPMAX key count</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>阻塞弹出最大 score</td>\n<td><code>TypedTuple&lt;V&gt; popMax(K key, timeout)</code></td>\n<td><code>BZPOPMAX key timeout</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"区间删除\">区间删除</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令（完整）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>按 rank 删除</td>\n<td><code>Long removeRange(K key, long start, long end)</code></td>\n<td><code>ZREMRANGEBYRANK key start end</code></td>\n</tr>\n<tr>\n<td>按 score 删除</td>\n<td><code>Long removeRangeByScore(K key, double min, double max)</code></td>\n<td><code>ZREMRANGEBYSCORE key min max</code></td>\n</tr>\n<tr>\n<td>按 lex 删除</td>\n<td><code>Long removeRangeByLex(K key, Range&lt;String&gt; range)</code></td>\n<td><code>ZREMRANGEBYLEX key min max</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"集合运算（ZSet-特有）\">集合运算（ZSet 特有）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令（完整）</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>差集</td>\n<td><code>Set&lt;V&gt; difference(K key, Collection&lt;K&gt; otherKeys)</code></td>\n<td><code>ZDIFF numkeys key [otherKey ...]</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>差集（含 score）</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; differenceWithScores(K key, Collection&lt;K&gt; otherKeys)</code></td>\n<td><code>ZDIFF numkeys key [otherKey ...] WITHSCORES</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>差集并存储</td>\n<td><code>Long differenceAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td>\n<td><code>ZDIFFSTORE destination numkeys key [otherKey ...]</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>交集</td>\n<td><code>Set&lt;V&gt; intersect(K key, Collection&lt;K&gt; otherKeys)</code></td>\n<td><code>ZINTER numkeys key [otherKey ...]</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>交集（含 score）</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; intersectWithScores(K key, Collection&lt;K&gt; otherKeys)</code></td>\n<td><code>ZINTER numkeys key [otherKey ...] WITHSCORES</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>并集</td>\n<td><code>Set&lt;V&gt; union(K key, Collection&lt;K&gt; otherKeys)</code></td>\n<td><code>ZUNION numkeys key [otherKey ...]</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>并集（含 score）</td>\n<td><code>Set&lt;TypedTuple&lt;V&gt;&gt; unionWithScores(K key, Collection&lt;K&gt; otherKeys)</code></td>\n<td><code>ZUNION numkeys key [otherKey ...] WITHSCORES</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>交集并存储</td>\n<td><code>Long intersectAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td>\n<td><code>ZINTERSTORE destination numkeys key [key ...]</code></td>\n<td></td>\n</tr>\n<tr>\n<td>并集并存储</td>\n<td><code>Long unionAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td>\n<td><code>ZUNIONSTORE destination numkeys key [key ...]</code></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Lex（字典序，仅-score-相同）\">Lex（字典序，仅 score 相同）</h3>\n<blockquote>\n<p>Lex = Lexicographical Order（字典序）,Lex 排序是按 member 的字符串字典序排序，而不是按 score。<br>\n只有当 ZSet 中所有元素的 score 相同时，Lex 排序才有意义<br>\n如果 score 不同，Redis 文档明确说明：结果不可预测</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令（完整）</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>按 lex 查询</td>\n<td><code>Set&lt;V&gt; rangeByLex(...)</code></td>\n<td><code>ZRANGEBYLEX key min max [LIMIT offset count]</code></td>\n<td>score 必须相同</td>\n</tr>\n<tr>\n<td>倒序 lex 查询</td>\n<td><code>Set&lt;V&gt; reverseRangeByLex(...)</code></td>\n<td><code>ZREVRANGEBYLEX key max min [LIMIT offset count]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>lex 范围存储</td>\n<td><code>Long rangeAndStoreByLex(...)</code></td>\n<td><code>ZRANGEBYLEX key min max [LIMIT offset count] → ZADD destKey</code></td>\n<td>Spring 封装</td>\n</tr>\n<tr>\n<td>score 范围存储</td>\n<td><code>Long rangeAndStoreByScore(...)</code></td>\n<td><code>ZRANGEBYSCORE key min max [WITHSCORES] → ZADD destKey</code></td>\n<td>Spring 封装</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>Lex 范围写法规则</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>写法</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>[a</code></td>\n<td>≥ a（包含）</td>\n</tr>\n<tr>\n<td><code>(a</code></td>\n<td>&gt; a（不包含）</td>\n</tr>\n<tr>\n<td><code>[z</code></td>\n<td>≤ z</td>\n</tr>\n<tr>\n<td><code>+</code></td>\n<td>正无穷</td>\n</tr>\n<tr>\n<td><code>-</code></td>\n<td>负无穷</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>示例</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># a ≤ member &lt; d</span></span><br><span class=\"line\">ZRANGEBYLEX my:zset [a (d</span><br></pre></td></tr></table></figure>\n<h3 id=\"遍历\">遍历</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令（完整）</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>游标扫描</td>\n<td><code>Cursor&lt;TypedTuple&lt;V&gt;&gt; scan(K key, ScanOptions options)</code></td>\n<td><code>ZSCAN key cursor [MATCH pattern] [COUNT count]</code></td>\n<td>推荐替代全量查询</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 Redis ZSet 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ ZSet 核心详解 Redis ZSet 是一种 带权重的有序集合，本质结构为： 123456key -&gt; &#123; member -&gt; score &#125;# 说明member：唯一，不可重复（String，二进制安全）score：double 类型，用于排序集合按 score 从小到大 排序score 相同则按 member 的字典序(Lex)排序 ZSet = Set（去重） + 排序能力 ZSet 的核心特性 12345元素唯一天然有序支持范围查询支持排名（rank）支持按 score 增量更新 Redis ZSet 的理论最大长度为 2^32 - 1 = 4294967295，但实际业务中，元素数量 ≥ 10,000 就算 BigKey 了。 Redis ZSet 是实现排行榜、延迟队列和有序统计的首选数据结构，在“顺序 + 去重 + 查询效率”之间取得了极佳平衡。 ZSet 的应用场景 123456789# Zset集合操作实现新闻点击排行榜1）点击新闻ZINCRBY hotNews:20251201 1 news1 # 点击一次分数 +12）展示当日点击排行前十ZREVRANGE hotNews:20251201 0 9 WITHSCORES # 倒序3）七日搜索榜单计算ZUNIONSTORE hotNews:20251201-20251207 7 hotNews:20251201 ...省略... hotNews:20251207 # 合并4）展示七日排行前十ZREVRANGE hotNews:20251201-20251207 0 9 WITHSCORES 生产环境建议 12345ZSet 适合 排序 + 查询score 设计要稳定、可扩展定期裁剪（ZREMRANGEBYRANK / ZREMRANGEBYSCORE）大 ZSet 避免全量遍历删除大 ZSet 使用 UNLINK ZSet 命令 SpringBoot 的 RedisTemplate&lt;K,V&gt;.opsForZSet() 中 ZSet 数据类型 的操作方法与 Redis 原生命令的对应关系如下： 基础写入 / 删除 / 计数 方法功能 方法 Redis 原始命令 命令备注 / 推荐替代 添加元素（含 score） Boolean add(K key, V value, double score) ZADD key score member 新增返回 true 添加元素（仅不存在时） Boolean addIfAbsent(K key, V value, double score) ZADD key NX score member Redis ≥ 3.0 批量添加 Long add(K key, Set&lt;TypedTuple&lt;V&gt;&gt; tuples) ZADD key score member [score member ...] 返回新增数量 批量添加（仅不存在） Long addIfAbsent(K key, Set&lt;TypedTuple&lt;V&gt;&gt; tuples) ZADD key NX ... — 删除成员 Long remove(K key, Object... values) ZREM key member [member ...] 返回删除数量 递增 score Double incrementScore(K key, V value, double delta) ZINCRBY key delta member — 获取集合大小 Long size(K key) ZCARD key — 获取集合大小（同义） Long zCard(K key) ZCARD key API 别名 随机访问 方法功能 方法 Redis 原始命令 命令备注 随机获取成员 V randomMember(K key) ZRANDMEMBER key 不返回 score 随机获取不重复成员 Set&lt;V&gt; distinctRandomMembers(K key, long count) ZRANDMEMBER key count count &gt; 0 随机获取可重复成员 List&lt;V&gt; randomMembers(K key, long count) ZRANDMEMBER key -count count &lt; 0 随机获取成员及 score TypedTuple&lt;V&gt; randomMemberWithScore(K key) ZRANDMEMBER key WITHSCORES Redis ≥ 6.2 随机获取不重复成员及 score Set&lt;TypedTuple&lt;V&gt;&gt; distinctRandomMembersWithScore(K key, long count) ZRANDMEMBER key count WITHSCORES — 随机获取可重复成员及 score List&lt;TypedTuple&lt;V&gt;&gt; randomMembersWithScore(K key, long count) ZRANDMEMBER key -count WITHSCORES — 排名 / score 查询 方法功能 方法 Redis 原始命令 备注 获取正序排名 Long rank(K key, Object o) ZRANK key member 从 0 开始 获取倒序排名 Long reverseRank(K key, Object o) ZREVRANK key member 从 0 开始 获取 score Double score(K key, Object o) ZSCORE key member — 批量获取 score List&lt;Double&gt; score(K key, Object... o) ZMScore key member [member ...] Redis ≥ 6.2 score 区间计数 Long count(K key, double min, double max) ZCOUNT key min max — 区间查询（rank / score） 方法功能 方法 Redis 原始命令 备注 按 rank 查询 Set&lt;V&gt; range(K key, long start, long end) ZRANGE key start end 正序rank = 元素在 ZSet 中按 score 排序后的下标位置（从 0 开始） 按 rank 查询（含 score） Set&lt;TypedTuple&lt;V&gt;&gt; rangeWithScores(K key, long start, long end) ZRANGE key start end WITHSCORES — 按 score 查询 Set&lt;V&gt; rangeByScore(K key, double min, double max) ZRANGEBYSCORE key min max — 按 score 查询（含 score） Set&lt;TypedTuple&lt;V&gt;&gt; rangeByScoreWithScores(K key, double min, double max) ZRANGEBYSCORE key min max WITHSCORES — score 分页 Set&lt;V&gt; rangeByScore(K key, double min, double max, long offset, long count) ZRANGEBYSCORE key min max LIMIT offset count — score 分页（含 score） Set&lt;TypedTuple&lt;V&gt;&gt; rangeByScoreWithScores(K key, double min, double max, long offset, long count) ZRANGEBYSCORE key min max WITHSCORES LIMIT offset count 按 score 升序分页，返回 member + score 倒序 rank 查询 Set&lt;V&gt; reverseRange(K key, long start, long end) ZREVRANGE key start end 按 rank 倒序（高 → 低） 倒序 rank（含 score） Set&lt;TypedTuple&lt;V&gt;&gt; reverseRangeWithScores(K key, long start, long end) ZREVRANGE key start end WITHSCORES 倒序 rank，返回 score 倒序 score 查询 Set&lt;V&gt; reverseRangeByScore(K key, double min, double max) ZREVRANGEBYSCORE key max min 注意：max 在前，min 在后 倒序 score（含 score） Set&lt;TypedTuple&lt;V&gt;&gt; reverseRangeByScoreWithScores(K key, double min, double max) ZREVRANGEBYSCORE key max min WITHSCORES 倒序 score，返回 score 弹出元素（队列 / TopN 场景） 方法功能 方法 Redis 原始命令 备注 弹出最小 score TypedTuple&lt;V&gt; popMin(K key) ZPOPMIN key — 批量弹出最小 score Set&lt;TypedTuple&lt;V&gt;&gt; popMin(K key, long count) ZPOPMIN key count — 阻塞弹出最小 score TypedTuple&lt;V&gt; popMin(K key, timeout) BZPOPMIN key timeout — 弹出最大 score TypedTuple&lt;V&gt; popMax(K key) ZPOPMAX key — 批量弹出最大 score Set&lt;TypedTuple&lt;V&gt;&gt; popMax(K key, long count) ZPOPMAX key count — 阻塞弹出最大 score TypedTuple&lt;V&gt; popMax(K key, timeout) BZPOPMAX key timeout — 区间删除 方法功能 方法 Redis 原始命令（完整） 按 rank 删除 Long removeRange(K key, long start, long end) ZREMRANGEBYRANK key start end 按 score 删除 Long removeRangeByScore(K key, double min, double max) ZREMRANGEBYSCORE key min max 按 lex 删除 Long removeRangeByLex(K key, Range&lt;String&gt; range) ZREMRANGEBYLEX key min max 集合运算（ZSet 特有） 方法功能 方法 Redis 原始命令（完整） 备注 差集 Set&lt;V&gt; difference(K key, Collection&lt;K&gt; otherKeys) ZDIFF numkeys key [otherKey ...] Redis ≥ 6.2 差集（含 score） Set&lt;TypedTuple&lt;V&gt;&gt; differenceWithScores(K key, Collection&lt;K&gt; otherKeys) ZDIFF numkeys key [otherKey ...] WITHSCORES Redis ≥ 6.2 差集并存储 Long differenceAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey) ZDIFFSTORE destination numkeys key [otherKey ...] Redis ≥ 6.2 交集 Set&lt;V&gt; intersect(K key, Collection&lt;K&gt; otherKeys) ZINTER numkeys key [otherKey ...] Redis ≥ 6.2 交集（含 score） Set&lt;TypedTuple&lt;V&gt;&gt; intersectWithScores(K key, Collection&lt;K&gt; otherKeys) ZINTER numkeys key [otherKey ...] WITHSCORES Redis ≥ 6.2 并集 Set&lt;V&gt; union(K key, Collection&lt;K&gt; otherKeys) ZUNION numkeys key [otherKey ...] Redis ≥ 6.2 并集（含 score） Set&lt;TypedTuple&lt;V&gt;&gt; unionWithScores(K key, Collection&lt;K&gt; otherKeys) ZUNION numkeys key [otherKey ...] WITHSCORES Redis ≥ 6.2 交集并存储 Long intersectAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey) ZINTERSTORE destination numkeys key [key ...] 并集并存储 Long unionAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey) ZUNIONSTORE destination numkeys key [key ...] Lex（字典序，仅 score 相同） Lex = Lexicographical Order（字典序）,Lex 排序是按 member 的字符串字典序排序，而不是按 score。 只有当 ZSet 中所有元素的 score 相同时，Lex 排序才有意义 如果 score 不同，Redis 文档明确说明：结果不可预测 方法功能 方法 Redis 原始命令（完整） 备注 按 lex 查询 Set&lt;V&gt; rangeByLex(...) ZRANGEBYLEX key min max [LIMIT offset count] score 必须相同 倒序 lex 查询 Set&lt;V&gt; reverseRangeByLex(...) ZREVRANGEBYLEX key max min [LIMIT offset count] — lex 范围存储 Long rangeAndStoreByLex(...) ZRANGEBYLEX key min max [LIMIT offset count] → ZADD destKey Spring 封装 score 范围存储 Long rangeAndStoreByScore(...) ZRANGEBYSCORE key min max [WITHSCORES] → ZADD destKey Spring 封装 Lex 范围写法规则 写法 含义 [a ≥ a（包含） (a &gt; a（不包含） [z ≤ z + 正无穷 - 负无穷 示例 12# a ≤ member &lt; dZRANGEBYLEX my:zset [a (d 遍历 方法功能 方法 Redis 原始命令（完整） 备注 游标扫描 Cursor&lt;TypedTuple&lt;V&gt;&gt; scan(K key, ScanOptions options) ZSCAN key cursor [MATCH pattern] [COUNT count] 推荐替代全量查询","summary":"摘要 本文介绍 Redis ZSet 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2025-12-16T13:40:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/16/redis7-datatype-05-set/","url":"https://blog.hanqunfeng.com/2025/12/16/redis7-datatype-05-set/","title":"Redis 命令及数据类型 -- Set","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis Set 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Set-核心详解\">Set 核心详解</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis Set 是一个无序、不重复元素集合，本质上是：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key -&gt; Set&lt;String&gt;</span><br><span class=\"line\"><span class=\"comment\"># 说明</span></span><br><span class=\"line\">元素唯一（自动去重）</span><br><span class=\"line\">无顺序（不保证插入顺序）</span><br><span class=\"line\">元素类型为 String（二进制安全）</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Set 的核心特性</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">自动去重</span><br><span class=\"line\">高效成员判断</span><br><span class=\"line\">支持集合运算</span><br><span class=\"line\">操作原子性强</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis Set 的理论最大长度为 2^32 - 1 = 4294967295，但实际业务中，元素数量 ≥ 10,000 就算 BigKey 了。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Set 应用场景</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 微信抽奖小程序</span></span><br><span class=\"line\">1）点击参与抽奖加入集合</span><br><span class=\"line\">SADD key &#123;userlD&#125;</span><br><span class=\"line\">2）查看参与抽奖所有用户</span><br><span class=\"line\">SMEMBERS key</span><br><span class=\"line\">3）抽取count名中奖者</span><br><span class=\"line\">SRANDMEMBER key [count] / SPOP key [count]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 微信微博点赞，收藏，标签</span></span><br><span class=\"line\">1) 点赞</span><br><span class=\"line\">SADD like:&#123;消息ID&#125; &#123;用户ID&#125;</span><br><span class=\"line\">2) 取消点赞</span><br><span class=\"line\">SREM like:&#123;消息ID&#125; &#123;用户ID&#125;</span><br><span class=\"line\">3) 检查用户是否点过赞</span><br><span class=\"line\">SISMEMBER like:&#123;消息ID&#125; &#123;用户ID&#125;</span><br><span class=\"line\">4) 获取点赞的用户列表</span><br><span class=\"line\">SMEMBERS like:&#123;消息ID&#125;</span><br><span class=\"line\">5) 获取点赞用户数</span><br><span class=\"line\">SCARD like:&#123;消息ID&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 集合操作</span></span><br><span class=\"line\"><span class=\"comment\"># 交集：多个集合中同时存在的元素</span></span><br><span class=\"line\">SINTER set1 set2 set3 -&gt; &#123; c &#125; <span class=\"comment\"># 交集，共同关注 / 共同好友 / 共同兴趣</span></span><br><span class=\"line\"><span class=\"comment\"># 并集：存在于任意一个集合中的元素</span></span><br><span class=\"line\">SUNION set1 set2 set3 -&gt; &#123; a,b,c,d,e &#125; <span class=\"comment\"># 多来源合并后的用户全集</span></span><br><span class=\"line\"><span class=\"comment\"># 差集：只存在于第一个集合中的元素</span></span><br><span class=\"line\">SDIFF set1 set2 set3 -&gt; &#123;a&#125; <span class=\"comment\"># 差集，推荐好友</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>生产环境建议</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set 适合 成员资格判断</span><br><span class=\"line\">始终控制成员规模</span><br><span class=\"line\">大 Set 遍历使用 SSCAN</span><br><span class=\"line\">集合运算放在离线或低频场景</span><br><span class=\"line\">删除大 Set 使用 UNLINK</span><br></pre></td></tr></table></figure>\n<h2 id=\"Set-命令\">Set 命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot 的 <code>RedisTemplate&lt;K,V&gt;.opsForSet()</code> 中 Set 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p>\n</li>\n</ul>\n<h3 id=\"写操作（增-删-移动）\">写操作（增 / 删 / 移动）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>向集合添加元素</td>\n<td><code>add(K key, V... values)</code></td>\n<td><code>SADD key member [member ...]</code></td>\n<td>返回新增成员数量</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"移除-弹出成员\">移除 / 弹出成员</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>从集合移除元素</td>\n<td><code>remove(K key, Object... values)</code></td>\n<td><code>SREM key member [member ...]</code></td>\n<td>返回移除成员数量</td>\n</tr>\n<tr>\n<td>随机弹出一个元素</td>\n<td><code>pop(K key)</code></td>\n<td><code>SPOP key</code></td>\n<td>随机且删除</td>\n</tr>\n<tr>\n<td>随机弹出多个元素</td>\n<td><code>pop(K key, long count)</code></td>\n<td><code>SPOP key count</code></td>\n<td>Redis ≥ 3.2</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"成员移动（原子）\">成员移动（原子）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>将成员移动到其他集合</td>\n<td><code>move(K key, V value, K destKey)</code></td>\n<td><code>SMOVE source dest member</code></td>\n<td>原子操作</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"集合大小\">集合大小</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>获取集合大小</td>\n<td><code>size(K key)</code></td>\n<td><code>SCARD key</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"成员存在性判断\">成员存在性判断</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>判断是否是成员</td>\n<td><code>isMember(K key, Object o)</code></td>\n<td><code>SISMEMBER key member</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>批量判断成员是否存在</td>\n<td><code>isMember(K key, Object... objects)</code></td>\n<td><code>SMISMEMBER key member [member ...]</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"交集（Intersection）\">交集（Intersection）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>计算交集</td>\n<td><code>intersect(K key, K otherKey)</code></td>\n<td><code>SINTER key key</code></td>\n<td>O(N × M)</td>\n</tr>\n<tr>\n<td>计算交集</td>\n<td><code>intersect(K key, Collection&lt;K&gt; otherKeys)</code></td>\n<td><code>SINTER key [key ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>计算交集</td>\n<td><code>intersect(Collection&lt;K&gt; keys)</code></td>\n<td><code>SINTER key [key ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>交集并存储</td>\n<td><code>intersectAndStore(K key, K otherKey, K destKey)</code></td>\n<td><code>SINTERSTORE dest key key</code></td>\n<td>返回结果数量</td>\n</tr>\n<tr>\n<td>交集并存储</td>\n<td><code>intersectAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td>\n<td><code>SINTERSTORE dest key [key ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>交集并存储</td>\n<td><code>intersectAndStore(Collection&lt;K&gt; keys, K destKey)</code></td>\n<td><code>SINTERSTORE dest key [key ...]</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"并集（Union）\">并集（Union）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>计算并集</td>\n<td><code>union(K key, K otherKey)</code></td>\n<td><code>SUNION key key</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>计算并集</td>\n<td><code>union(K key, Collection&lt;K&gt; otherKeys)</code></td>\n<td><code>SUNION key [key ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>计算并集</td>\n<td><code>union(Collection&lt;K&gt; keys)</code></td>\n<td><code>SUNION key [key ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>并集并存储</td>\n<td><code>unionAndStore(K key, K otherKey, K destKey)</code></td>\n<td><code>SUNIONSTORE dest key key</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>并集并存储</td>\n<td><code>unionAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td>\n<td><code>SUNIONSTORE dest key [key ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>并集并存储</td>\n<td><code>unionAndStore(Collection&lt;K&gt; keys, K destKey)</code></td>\n<td><code>SUNIONSTORE dest key [key ...]</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"差集（Difference）\">差集（Difference）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>计算差集</td>\n<td><code>difference(K key, K otherKey)</code></td>\n<td><code>SDIFF key key</code></td>\n<td>key 顺序影响结果</td>\n</tr>\n<tr>\n<td>计算差集</td>\n<td><code>difference(K key, Collection&lt;K&gt; otherKeys)</code></td>\n<td><code>SDIFF key [key ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>计算差集</td>\n<td><code>difference(Collection&lt;K&gt; keys)</code></td>\n<td><code>SDIFF key [key ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>差集并存储</td>\n<td><code>differenceAndStore(K key, K otherKey, K destKey)</code></td>\n<td><code>SDIFFSTORE dest key key</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>差集并存储</td>\n<td><code>differenceAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></td>\n<td><code>SDIFFSTORE dest key [key ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>差集并存储</td>\n<td><code>differenceAndStore(Collection&lt;K&gt; keys, K destKey)</code></td>\n<td><code>SDIFFSTORE dest key [key ...]</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"全量-随机读取\">全量 / 随机读取</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>获取所有成员</td>\n<td><code>members(K key)</code></td>\n<td><code>SMEMBERS key</code></td>\n<td>大集合慎用</td>\n</tr>\n<tr>\n<td>随机获取一个成员</td>\n<td><code>randomMember(K key)</code></td>\n<td><code>SRANDMEMBER key</code></td>\n<td>不删除</td>\n</tr>\n<tr>\n<td>随机获取不重复成员</td>\n<td><code>distinctRandomMembers(K key, long count)</code></td>\n<td><code>SRANDMEMBER key count</code></td>\n<td>count &gt; 0</td>\n</tr>\n<tr>\n<td>随机获取可重复成员</td>\n<td><code>randomMembers(K key, long count)</code></td>\n<td><code>SRANDMEMBER key -count</code></td>\n<td>count &lt; 0</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"游标扫描（大集合推荐）\">游标扫描（大集合推荐）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>游标扫描成员</td>\n<td><code>scan(K key, ScanOptions options)</code></td>\n<td><code>SSCAN key cursor [MATCH] [COUNT]</code></td>\n<td>推荐替代 <code>SMEMBERS</code></td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 Redis Set 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ Set 核心详解 Redis Set 是一个无序、不重复元素集合，本质上是： 12345key -&gt; Set&lt;String&gt;# 说明元素唯一（自动去重）无顺序（不保证插入顺序）元素类型为 String（二进制安全） Set 的核心特性 1234自动去重高效成员判断支持集合运算操作原子性强 Redis Set 的理论最大长度为 2^32 - 1 = 4294967295，但实际业务中，元素数量 ≥ 10,000 就算 BigKey 了。 Set 应用场景 12345678910111213141516171819202122232425262728# 微信抽奖小程序1）点击参与抽奖加入集合SADD key &#123;userlD&#125;2）查看参与抽奖所有用户SMEMBERS key3）抽取count名中奖者SRANDMEMBER key [count] / SPOP key [count]# 微信微博点赞，收藏，标签1) 点赞SADD like:&#123;消息ID&#125; &#123;用户ID&#125;2) 取消点赞SREM like:&#123;消息ID&#125; &#123;用户ID&#125;3) 检查用户是否点过赞SISMEMBER like:&#123;消息ID&#125; &#123;用户ID&#125;4) 获取点赞的用户列表SMEMBERS like:&#123;消息ID&#125;5) 获取点赞用户数SCARD like:&#123;消息ID&#125;# 集合操作# 交集：多个集合中同时存在的元素SINTER set1 set2 set3 -&gt; &#123; c &#125; # 交集，共同关注 / 共同好友 / 共同兴趣# 并集：存在于任意一个集合中的元素SUNION set1 set2 set3 -&gt; &#123; a,b,c,d,e &#125; # 多来源合并后的用户全集# 差集：只存在于第一个集合中的元素SDIFF set1 set2 set3 -&gt; &#123;a&#125; # 差集，推荐好友 生产环境建议 12345Set 适合 成员资格判断始终控制成员规模大 Set 遍历使用 SSCAN集合运算放在离线或低频场景删除大 Set 使用 UNLINK Set 命令 SpringBoot 的 RedisTemplate&lt;K,V&gt;.opsForSet() 中 Set 数据类型 的操作方法与 Redis 原生命令的对应关系如下： 写操作（增 / 删 / 移动） 方法功能 方法 Redis 原始命令 备注 向集合添加元素 add(K key, V... values) SADD key member [member ...] 返回新增成员数量 移除 / 弹出成员 方法功能 方法 Redis 原始命令 备注 从集合移除元素 remove(K key, Object... values) SREM key member [member ...] 返回移除成员数量 随机弹出一个元素 pop(K key) SPOP key 随机且删除 随机弹出多个元素 pop(K key, long count) SPOP key count Redis ≥ 3.2 成员移动（原子） 方法功能 方法 Redis 原始命令 备注 将成员移动到其他集合 move(K key, V value, K destKey) SMOVE source dest member 原子操作 集合大小 方法功能 方法 Redis 原始命令 备注 获取集合大小 size(K key) SCARD key — 成员存在性判断 方法功能 方法 Redis 原始命令 备注 判断是否是成员 isMember(K key, Object o) SISMEMBER key member — 批量判断成员是否存在 isMember(K key, Object... objects) SMISMEMBER key member [member ...] Redis ≥ 6.2 交集（Intersection） 方法功能 方法 Redis 原始命令 备注 计算交集 intersect(K key, K otherKey) SINTER key key O(N × M) 计算交集 intersect(K key, Collection&lt;K&gt; otherKeys) SINTER key [key ...] — 计算交集 intersect(Collection&lt;K&gt; keys) SINTER key [key ...] — 交集并存储 intersectAndStore(K key, K otherKey, K destKey) SINTERSTORE dest key key 返回结果数量 交集并存储 intersectAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey) SINTERSTORE dest key [key ...] — 交集并存储 intersectAndStore(Collection&lt;K&gt; keys, K destKey) SINTERSTORE dest key [key ...] — 并集（Union） 方法功能 方法 Redis 原始命令 备注 计算并集 union(K key, K otherKey) SUNION key key — 计算并集 union(K key, Collection&lt;K&gt; otherKeys) SUNION key [key ...] — 计算并集 union(Collection&lt;K&gt; keys) SUNION key [key ...] — 并集并存储 unionAndStore(K key, K otherKey, K destKey) SUNIONSTORE dest key key — 并集并存储 unionAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey) SUNIONSTORE dest key [key ...] — 并集并存储 unionAndStore(Collection&lt;K&gt; keys, K destKey) SUNIONSTORE dest key [key ...] — 差集（Difference） 方法功能 方法 Redis 原始命令 备注 计算差集 difference(K key, K otherKey) SDIFF key key key 顺序影响结果 计算差集 difference(K key, Collection&lt;K&gt; otherKeys) SDIFF key [key ...] — 计算差集 difference(Collection&lt;K&gt; keys) SDIFF key [key ...] — 差集并存储 differenceAndStore(K key, K otherKey, K destKey) SDIFFSTORE dest key key — 差集并存储 differenceAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey) SDIFFSTORE dest key [key ...] — 差集并存储 differenceAndStore(Collection&lt;K&gt; keys, K destKey) SDIFFSTORE dest key [key ...] — 全量 / 随机读取 方法功能 方法 Redis 原始命令 备注 获取所有成员 members(K key) SMEMBERS key 大集合慎用 随机获取一个成员 randomMember(K key) SRANDMEMBER key 不删除 随机获取不重复成员 distinctRandomMembers(K key, long count) SRANDMEMBER key count count &gt; 0 随机获取可重复成员 randomMembers(K key, long count) SRANDMEMBER key -count count &lt; 0 游标扫描（大集合推荐） 方法功能 方法 Redis 原始命令 备注 游标扫描成员 scan(K key, ScanOptions options) SSCAN key cursor [MATCH] [COUNT] 推荐替代 SMEMBERS","summary":"摘要 本文介绍 Redis Set 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2025-12-16T13:38:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/16/redis7-datatype-04-list/","url":"https://blog.hanqunfeng.com/2025/12/16/redis7-datatype-04-list/","title":"Redis 命令及数据类型 -- List","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis List 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"List-核心详解\">List 核心详解</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis List 是一个有序字符串列表，本质上是:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key -&gt; List&lt;String&gt;</span><br><span class=\"line\"><span class=\"comment\"># 说明</span></span><br><span class=\"line\">元素按插入顺序排列</span><br><span class=\"line\">允许重复元素</span><br><span class=\"line\">支持从 左（头） 和 右（尾） 两端操作</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>List 的核心特性</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">有序</span><br><span class=\"line\">可重复</span><br><span class=\"line\">双端操作（Deque）</span><br><span class=\"line\">支持阻塞读</span><br><span class=\"line\">元素类型为 String（二进制安全）</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis List 的理论最大长度为 2^32 - 1 = 4294967295，但实际业务中，元素数量 ≥ 10,000 就算 BigKey 了。</p>\n</li>\n<li class=\"lvl-2\">\n<p>List的底层是一个双向链表，对双端的操作性能很高，但是通过索引下标直接操作某一个中间节点时性能很差</p>\n</li>\n<li class=\"lvl-2\">\n<p>常用数据结构</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stack(栈) = LPUSH + LPOP</span><br><span class=\"line\">Queue(队列）= LPUSH + RPOP</span><br><span class=\"line\">Blocking MQ(阻塞队列）= LPUSH + BRPOP</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>List 的使用场景</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">视频列表、签到列表</span><br><span class=\"line\">排队机</span><br><span class=\"line\">简化版的MQ</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>生产环境建议</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List 只用于 顺序消费</span><br><span class=\"line\">始终限制 List 长度（LTRIM）</span><br><span class=\"line\">避免中间插入、删除</span><br><span class=\"line\">大 List 删除使用 UNLINK</span><br><span class=\"line\">高可靠消息不要用 List</span><br></pre></td></tr></table></figure>\n<h2 id=\"List-命令\">List 命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot 的 <code>RedisTemplate&lt;K,V&gt;.opsForList()</code> 中 List 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p>\n</li>\n</ul>\n<h3 id=\"区间访问与整体控制\">区间访问与整体控制</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>获取指定区间元素</td>\n<td><code>range(K key, long start, long end)</code></td>\n<td><code>LRANGE key start end</code></td>\n<td><code>end = -1</code> 表示到末尾</td>\n</tr>\n<tr>\n<td>裁剪 list，仅保留指定区间</td>\n<td><code>trim(K key, long start, long end)</code></td>\n<td><code>LTRIM key start end</code></td>\n<td><strong>原地修改</strong></td>\n</tr>\n<tr>\n<td>获取 list 长度</td>\n<td><code>size(K key)</code></td>\n<td><code>LLEN key</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>📌 使用建议</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\"><code>LRANGE 0 -1</code> 等价全量读取，小 list 可用</li>\n<li class=\"lvl-6\">大 list 建议分页 + LRANGE</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"左侧入队（Head）\">左侧入队（Head）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>左侧插入一个元素</td>\n<td><code>leftPush(K key, V value)</code></td>\n<td><code>LPUSH key value</code></td>\n<td>返回插入后长度</td>\n</tr>\n<tr>\n<td>左侧批量插入</td>\n<td><code>leftPushAll(K key, V... values)</code></td>\n<td><code>LPUSH key value [value ...]</code></td>\n<td>依次从左插入</td>\n</tr>\n<tr>\n<td>左侧批量插入</td>\n<td><code>leftPushAll(K key, Collection&lt;V&gt; values)</code></td>\n<td><code>LPUSH key value [value ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>key 存在时左侧插入</td>\n<td><code>leftPushIfPresent(K key, V value)</code></td>\n<td><code>LPUSHX key value</code></td>\n<td>key 不存在不执行</td>\n</tr>\n<tr>\n<td>在 pivot 左侧插入</td>\n<td><code>leftPush(K key, V pivot, V value)</code></td>\n<td><code>LINSERT key BEFORE pivot value</code></td>\n<td>pivot 不存在返回 <code>-1</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"右侧入队（Tail）\">右侧入队（Tail）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>右侧插入一个元素</td>\n<td><code>rightPush(K key, V value)</code></td>\n<td><code>RPUSH key value</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>右侧批量插入</td>\n<td><code>rightPushAll(K key, V... values)</code></td>\n<td><code>RPUSH key value [value ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>右侧批量插入</td>\n<td><code>rightPushAll(K key, Collection&lt;V&gt; values)</code></td>\n<td><code>RPUSH key value [value ...]</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>key 存在时右侧插入</td>\n<td><code>rightPushIfPresent(K key, V value)</code></td>\n<td><code>RPUSHX key value</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>在 pivot 右侧插入</td>\n<td><code>rightPush(K key, V pivot, V value)</code></td>\n<td><code>LINSERT key AFTER pivot value</code></td>\n<td>pivot 不存在返回 <code>-1</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"非阻塞弹出\">非阻塞弹出</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>左侧弹出</td>\n<td><code>leftPop(K key)</code></td>\n<td><code>LPOP key</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>左侧批量弹出</td>\n<td><code>leftPop(K key, long count)</code></td>\n<td><code>LPOP key count</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>右侧弹出</td>\n<td><code>rightPop(K key)</code></td>\n<td><code>RPOP key</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>右侧批量弹出</td>\n<td><code>rightPop(K key, long count)</code></td>\n<td><code>RPOP key count</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"阻塞弹出（Blocking-Queue）\">阻塞弹出（Blocking Queue）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>左侧阻塞弹出</td>\n<td><code>leftPop(K key, timeout)</code></td>\n<td><code>BLPOP key timeout</code></td>\n<td>队列为空时阻塞</td>\n</tr>\n<tr>\n<td>右侧阻塞弹出</td>\n<td><code>rightPop(K key, timeout)</code></td>\n<td><code>BRPOP key timeout</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>📌 典型场景：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">消息队列 / 任务队列</li>\n<li class=\"lvl-6\">简单生产者-消费者模型</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"原子移动\">原子移动</h3>\n<blockquote>\n<p>Redis 6.2+ 新模型（统一、可读性更强）</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>原子移动（非阻塞）</td>\n<td><code>move(sourceKey, from, destinationKey, to)</code></td>\n<td><code>LMOVE source dest LEFT|RIGHT LEFT|RIGHT</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>原子移动（阻塞）</td>\n<td><code>move(sourceKey, from, destinationKey, to, timeout)</code></td>\n<td><code>BLMOVE source dest LEFT|RIGHT LEFT|RIGHT timeout</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>语义说明</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">从 sourceKey 的一端 POP</li>\n<li class=\"lvl-6\">向 destinationKey 的一端 PUSH</li>\n<li class=\"lvl-6\">整个过程 原子性保证</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>命令参数说明：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">source:源 List（从这里取一个元素）</li>\n<li class=\"lvl-6\">dest:目标 List（往这里放一个元素）</li>\n<li class=\"lvl-6\">第一个 LEFT/RIGHT:从 source 的哪一端弹出元素</li>\n<li class=\"lvl-6\">第二个 LEFT/RIGHT:从 dest 的哪一端插入元素</li>\n<li class=\"lvl-6\">timeout: 阻塞时间\n<ul class=\"lvl-4\">\n<li class=\"lvl-10\">当 source 为空（或不存在）时，客户端最多阻塞等待 timeout 秒，直到有元素可被移动，或等待超时。</li>\n<li class=\"lvl-10\">timeout = 0：无限期阻塞，直到有数据可用或连接断开</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>旧命令（即将废弃）</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>推荐替代</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>右弹左插</td>\n<td><code>rightPopAndLeftPush(...)</code></td>\n<td><code>RPOPLPUSH</code></td>\n<td><code>LMOVE</code></td>\n</tr>\n<tr>\n<td>阻塞右弹左插</td>\n<td><code>rightPopAndLeftPush(..., timeout)</code></td>\n<td><code>BRPOPLPUSH</code></td>\n<td><code>BLMOVE</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"随机访问与定位（O-N-）\">随机访问与定位（O(N)）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>获取第一个元素</td>\n<td><code>getFirst(K key)</code></td>\n<td><code>LINDEX key 0</code></td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td>获取最后一个元素</td>\n<td><code>getLast(K key)</code></td>\n<td><code>LINDEX key -1</code></td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td>获取指定索引元素</td>\n<td><code>index(K key, long index)</code></td>\n<td><code>LINDEX key index</code></td>\n<td>O(N)</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>⚠️ 注意: List 不是数组，随机访问是线性扫描，不适合频繁随机读取</p>\n</blockquote>\n<h3 id=\"搜索与删除\">搜索与删除</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>删除指定值</td>\n<td><code>remove(K key, long count, Object value)</code></td>\n<td><code>LREM key count value</code></td>\n<td>count &gt;0 从左，&lt;0 从右</td>\n</tr>\n<tr>\n<td>获取首次出现位置</td>\n<td><code>indexOf(K key, V value)</code></td>\n<td><code>LPOS key value</code></td>\n<td>Redis ≥ 6.0</td>\n</tr>\n<tr>\n<td>获取最后出现位置</td>\n<td><code>lastIndexOf(K key, V value)</code></td>\n<td><code>LPOS key value RANK -1</code></td>\n<td>Redis ≥ 6.0</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"List-的典型使用模式总结\">List 的典型使用模式总结</h3>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>推荐方式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>队列（FIFO）</td>\n<td><code>RPUSH + LPOP</code></td>\n</tr>\n<tr>\n<td>栈（LIFO）</td>\n<td><code>LPUSH + LPOP</code></td>\n</tr>\n<tr>\n<td>阻塞队列</td>\n<td><code>BLPOP / BRPOP</code></td>\n</tr>\n<tr>\n<td>可靠队列</td>\n<td><code>LMOVE / BLMOVE</code></td>\n</tr>\n<tr>\n<td>消息转移</td>\n<td><code>LMOVE source dest</code></td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 Redis List 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ List 核心详解 Redis List 是一个有序字符串列表，本质上是: 12345key -&gt; List&lt;String&gt;# 说明元素按插入顺序排列允许重复元素支持从 左（头） 和 右（尾） 两端操作 List 的核心特性 12345有序可重复双端操作（Deque）支持阻塞读元素类型为 String（二进制安全） Redis List 的理论最大长度为 2^32 - 1 = 4294967295，但实际业务中，元素数量 ≥ 10,000 就算 BigKey 了。 List的底层是一个双向链表，对双端的操作性能很高，但是通过索引下标直接操作某一个中间节点时性能很差 常用数据结构 123Stack(栈) = LPUSH + LPOPQueue(队列）= LPUSH + RPOPBlocking MQ(阻塞队列）= LPUSH + BRPOP List 的使用场景 123视频列表、签到列表排队机简化版的MQ 生产环境建议 12345List 只用于 顺序消费始终限制 List 长度（LTRIM）避免中间插入、删除大 List 删除使用 UNLINK高可靠消息不要用 List List 命令 SpringBoot 的 RedisTemplate&lt;K,V&gt;.opsForList() 中 List 数据类型 的操作方法与 Redis 原生命令的对应关系如下： 区间访问与整体控制 方法功能 方法 Redis 原始命令 备注 获取指定区间元素 range(K key, long start, long end) LRANGE key start end end = -1 表示到末尾 裁剪 list，仅保留指定区间 trim(K key, long start, long end) LTRIM key start end 原地修改 获取 list 长度 size(K key) LLEN key — 📌 使用建议 LRANGE 0 -1 等价全量读取，小 list 可用 大 list 建议分页 + LRANGE 左侧入队（Head） 方法功能 方法 Redis 原始命令 备注 左侧插入一个元素 leftPush(K key, V value) LPUSH key value 返回插入后长度 左侧批量插入 leftPushAll(K key, V... values) LPUSH key value [value ...] 依次从左插入 左侧批量插入 leftPushAll(K key, Collection&lt;V&gt; values) LPUSH key value [value ...] — key 存在时左侧插入 leftPushIfPresent(K key, V value) LPUSHX key value key 不存在不执行 在 pivot 左侧插入 leftPush(K key, V pivot, V value) LINSERT key BEFORE pivot value pivot 不存在返回 -1 右侧入队（Tail） 方法功能 方法 Redis 原始命令 备注 右侧插入一个元素 rightPush(K key, V value) RPUSH key value — 右侧批量插入 rightPushAll(K key, V... values) RPUSH key value [value ...] — 右侧批量插入 rightPushAll(K key, Collection&lt;V&gt; values) RPUSH key value [value ...] — key 存在时右侧插入 rightPushIfPresent(K key, V value) RPUSHX key value — 在 pivot 右侧插入 rightPush(K key, V pivot, V value) LINSERT key AFTER pivot value pivot 不存在返回 -1 非阻塞弹出 方法功能 方法 Redis 原始命令 备注 左侧弹出 leftPop(K key) LPOP key — 左侧批量弹出 leftPop(K key, long count) LPOP key count Redis ≥ 6.2 右侧弹出 rightPop(K key) RPOP key — 右侧批量弹出 rightPop(K key, long count) RPOP key count Redis ≥ 6.2 阻塞弹出（Blocking Queue） 方法功能 方法 Redis 原始命令 备注 左侧阻塞弹出 leftPop(K key, timeout) BLPOP key timeout 队列为空时阻塞 右侧阻塞弹出 rightPop(K key, timeout) BRPOP key timeout — 📌 典型场景： 消息队列 / 任务队列 简单生产者-消费者模型 原子移动 Redis 6.2+ 新模型（统一、可读性更强） 方法功能 方法 Redis 原始命令 备注 原子移动（非阻塞） move(sourceKey, from, destinationKey, to) LMOVE source dest LEFT|RIGHT LEFT|RIGHT Redis ≥ 6.2 原子移动（阻塞） move(sourceKey, from, destinationKey, to, timeout) BLMOVE source dest LEFT|RIGHT LEFT|RIGHT timeout Redis ≥ 6.2 语义说明 从 sourceKey 的一端 POP 向 destinationKey 的一端 PUSH 整个过程 原子性保证 命令参数说明： source:源 List（从这里取一个元素） dest:目标 List（往这里放一个元素） 第一个 LEFT/RIGHT:从 source 的哪一端弹出元素 第二个 LEFT/RIGHT:从 dest 的哪一端插入元素 timeout: 阻塞时间 当 source 为空（或不存在）时，客户端最多阻塞等待 timeout 秒，直到有元素可被移动，或等待超时。 timeout = 0：无限期阻塞，直到有数据可用或连接断开 旧命令（即将废弃） 方法功能 方法 Redis 原始命令 推荐替代 右弹左插 rightPopAndLeftPush(...) RPOPLPUSH LMOVE 阻塞右弹左插 rightPopAndLeftPush(..., timeout) BRPOPLPUSH BLMOVE 随机访问与定位（O(N)） 方法功能 方法 Redis 原始命令 备注 获取第一个元素 getFirst(K key) LINDEX key 0 O(N) 获取最后一个元素 getLast(K key) LINDEX key -1 O(N) 获取指定索引元素 index(K key, long index) LINDEX key index O(N) ⚠️ 注意: List 不是数组，随机访问是线性扫描，不适合频繁随机读取 搜索与删除 方法功能 方法 Redis 原始命令 备注 删除指定值 remove(K key, long count, Object value) LREM key count value count &gt;0 从左，&lt;0 从右 获取首次出现位置 indexOf(K key, V value) LPOS key value Redis ≥ 6.0 获取最后出现位置 lastIndexOf(K key, V value) LPOS key value RANK -1 Redis ≥ 6.0 List 的典型使用模式总结 场景 推荐方式 队列（FIFO） RPUSH + LPOP 栈（LIFO） LPUSH + LPOP 阻塞队列 BLPOP / BRPOP 可靠队列 LMOVE / BLMOVE 消息转移 LMOVE source dest","summary":"摘要 本文介绍 Redis List 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2025-12-16T13:35:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/15/redis7-datatype-03-hash/","url":"https://blog.hanqunfeng.com/2025/12/15/redis7-datatype-03-hash/","title":"Redis 命令及数据类型 -- Hash","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis Hash 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Hash-核心详解\">Hash 核心详解</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis Hash 是一种 key → field → value 的数据结构，本质上是</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key -&gt; Map&lt;String, String&gt;</span><br><span class=\"line\"><span class=\"comment\"># 说明</span></span><br><span class=\"line\">key：Redis 的键（只能是 String）</span><br><span class=\"line\">field：Hash 内的字段名（String）</span><br><span class=\"line\">value：字段值（String，二进制安全）</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Hash 的核心特性</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">适合存储对象型数据</span><br><span class=\"line\">支持 字段级别读写</span><br><span class=\"line\">所有操作均为 原子性</span><br><span class=\"line\">内存效率优于「String + JSON」</span><br><span class=\"line\">单个 Hash 理论最大 512 MB</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Hash 的使用场景</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 对象缓存</span></span><br><span class=\"line\">HSET user:1 name zhangsan age 20</span><br><span class=\"line\"><span class=\"comment\"># 电商购物车:1)以用户id为key 2）商品id为field 3）商品数量为value</span></span><br><span class=\"line\">HSET cart:userId commodity:1001 1 commodity:1002 5</span><br><span class=\"line\"><span class=\"comment\"># 分布式锁，一个命令搞不定，需要结合Lua脚本</span></span><br><span class=\"line\">HINCRBY lock uuid:threadId 1 <span class=\"comment\"># 创建锁 或 重入+1</span></span><br><span class=\"line\">EXPIRE lock 30 <span class=\"comment\"># 30 秒后自动释放锁</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Hash结构优缺点</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">• 优点</span><br><span class=\"line\">1）同类数据聚合存储，适合表达对象模型，便于管理与维护</span><br><span class=\"line\">2）相比 string 操作消耗内存与 CPU 更小</span><br><span class=\"line\">    a.当多个小字段被组织在同一个 Hash 中时，整体内存与 CPU 开销通常小于使用多个 String Key，因为Redis 对 小 Hash 使用 ziplist / listpack（紧凑结构），减少了 Key 元数据、过期字典、指针等开销</span><br><span class=\"line\">    b.Hash 过大时（BigHash）优势消失</span><br><span class=\"line\">3）相比 string，减少了 Key 数量，降低元数据与过期字典的额外开销</span><br><span class=\"line\">• 缺点</span><br><span class=\"line\">1) 默认过期只能作用在 key 级别，Hash field 级别过期需 Redis 7.4+ 才支持</span><br><span class=\"line\">```bash</span><br><span class=\"line\"><span class=\"comment\"># user:1 这个 Hash 不会过期</span></span><br><span class=\"line\">HSET user:1 name <span class=\"string\">&quot;Tom&quot;</span> age 18</span><br><span class=\"line\"><span class=\"comment\"># HEXPIRE key seconds [NX|XX|GT|LT] FIELDS numfields field [field ...]</span></span><br><span class=\"line\"><span class=\"comment\"># 只有 name field 60 秒后自动删除</span></span><br><span class=\"line\">HEXPIRE user:1 60 FIELDS 1 name</span><br><span class=\"line\"><span class=\"comment\"># 同时给多个 field 设置过期时间</span></span><br><span class=\"line\">HEXPIRE user:1 60 FIELDS 2 name age</span><br><span class=\"line\"><span class=\"comment\"># 使用毫秒级过期（HPEXPIRE）</span></span><br><span class=\"line\"><span class=\"comment\"># HPEXPIRE key milliseconds [NX|XX|GT|LT] FIELDS numfields field [field ...]</span></span><br><span class=\"line\">HPEXPIRE user:1 60 FIELDS 2 name age</span><br><span class=\"line\"><span class=\"comment\"># 查看 field 剩余秒数（HTTL）,-1 表示 field 永不过期，-2 表示 field 已过期</span></span><br><span class=\"line\"><span class=\"comment\"># HTTL key FIELDS numfields field [field ...]</span></span><br><span class=\"line\">HTTL user:1 FIELDS 1 name</span><br><span class=\"line\"><span class=\"comment\"># 查看毫秒级 TTL（HPTTL）,-1 表示 field 永不过期，-2 表示 field 已过期</span></span><br><span class=\"line\"><span class=\"comment\"># HPTTL key FIELDS numfields field [field ...]</span></span><br><span class=\"line\">HPTTL user:1 FIELDS 1 name</span><br><span class=\"line\"><span class=\"comment\"># 移出过期时间</span></span><br><span class=\"line\"><span class=\"comment\"># HPERSIST key FIELDS numfields field [field ...]</span></span><br><span class=\"line\">HPERSIST user:1 FIELDS 1 name</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>在 Redis Cluster 中，不应设计超大的 Hash Key（BigHash），否则会影响迁移、扩缩容和主从复制性能。</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>生产环境建议</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一个 Hash = 一个对象</span><br><span class=\"line\">field 数量建议 &lt; 100</span><br><span class=\"line\">单 field value 建议 &lt; 1 KB</span><br><span class=\"line\">大对象拆分为多个 Hash</span><br><span class=\"line\">避免在大 Hash 上使用 HGETALL</span><br></pre></td></tr></table></figure>\n<h2 id=\"Hash-命令\">Hash 命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot 的 <code>RedisTemplate&lt;K,V&gt;.opsForHash()</code> 中 Hash 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p>\n</li>\n</ul>\n<h3 id=\"写入-更新\">写入 / 更新</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>设置单个 field-value</td>\n<td><code>put(H key, HK hashKey, HV value)</code></td>\n<td><code>HSET key field value</code></td>\n<td>新增或覆盖</td>\n</tr>\n<tr>\n<td>批量设置 field-value</td>\n<td><code>putAll(H key, Map&lt;HK,HV&gt; m)</code></td>\n<td><code>HSET key field value [field value ...]</code></td>\n<td><code>HMSET</code> 已废弃</td>\n</tr>\n<tr>\n<td>field 不存在时设置</td>\n<td><code>putIfAbsent(H key, HK hashKey, HV value)</code></td>\n<td><code>HSETNX key field value</code></td>\n<td>原子操作</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"读取\">读取</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>获取指定 field 的值</td>\n<td><code>get(H key, Object hashKey)</code></td>\n<td><code>HGET key field</code></td>\n<td>不存在返回 <code>null</code></td>\n</tr>\n<tr>\n<td>批量获取多个 field</td>\n<td><code>multiGet(H key, Collection&lt;HK&gt; hashKeys)</code></td>\n<td><code>HMGET key field [field ...]</code></td>\n<td>不存在返回 <code>null</code></td>\n</tr>\n<tr>\n<td>获取所有 value</td>\n<td><code>values(H key)</code></td>\n<td><code>HVALS key</code></td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td>获取所有 field-value</td>\n<td><code>entries(H key)</code></td>\n<td><code>HGETALL key</code></td>\n<td><strong>生产环境慎用</strong></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"删除-存在性判断\">删除 / 存在性判断</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>删除一个或多个 field</td>\n<td><code>delete(H key, Object... hashKeys)</code></td>\n<td><code>HDEL key field [field ...]</code></td>\n<td>返回删除数量</td>\n</tr>\n<tr>\n<td>判断 field 是否存在</td>\n<td><code>hasKey(H key, Object hashKey)</code></td>\n<td><code>HEXISTS key field</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"计数与数值运算\">计数与数值运算</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>field 整数自增</td>\n<td><code>increment(H key, HK hashKey, long delta)</code></td>\n<td><code>HINCRBY key field increment</code></td>\n<td>value 必须是整数</td>\n</tr>\n<tr>\n<td>field 浮点数自增</td>\n<td><code>increment(H key, HK hashKey, double delta)</code></td>\n<td><code>HINCRBYFLOAT key field increment</code></td>\n<td>Redis ≥ 2.6</td>\n</tr>\n<tr>\n<td>获取 field 对应 value 长度</td>\n<td><code>lengthOfValue(H key, HK hashKey)</code></td>\n<td><code>HSTRLEN key field</code></td>\n<td>不存在返回 0</td>\n</tr>\n<tr>\n<td>获取 hash 中 field 数量</td>\n<td><code>size(H key)</code></td>\n<td><code>HLEN key</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"随机访问（Random-Access）\">随机访问（Random Access）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>⚠️ 随机访问常用于抽样、降级策略，不适合强一致业务</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>随机返回一个 field</td>\n<td><code>randomKey(H key)</code></td>\n<td><code>HRANDFIELD key</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>随机返回一个 field-value</td>\n<td><code>randomEntry(H key)</code></td>\n<td><code>HRANDFIELD key WITHVALUES</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>随机返回多个 field</td>\n<td><code>randomKeys(H key, long count)</code></td>\n<td><code>HRANDFIELD key count</code></td>\n<td>count &lt; 0 可重复</td>\n</tr>\n<tr>\n<td>随机返回多个 field-value</td>\n<td><code>randomEntries(H key, long count)</code></td>\n<td><code>HRANDFIELD key count WITHVALUES</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"遍历与扫描（推荐方式）\">遍历与扫描（推荐方式）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>获取所有 field</td>\n<td><code>keys(H key)</code></td>\n<td><code>HKEYS key</code></td>\n<td>O(N)，大 hash 慎用</td>\n</tr>\n<tr>\n<td>游标扫描 hash</td>\n<td><code>scan(H key, ScanOptions options)</code></td>\n<td><code>HSCAN key cursor [MATCH] [COUNT]</code></td>\n<td><strong>推荐替代 <code>HGETALL</code></strong></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-3\">\n<p>📌 最佳实践</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">小 hash：HGETALL</li>\n<li class=\"lvl-6\">大 hash / 线上系统：HSCAN</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Hash-Field-级别过期（Redis-7-4-）\">Hash Field 级别过期（Redis 7.4+）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-3\">\n<p>Redis 7.4 引入 field 级 TTL，这是 Hash 的重大能力增强</p>\n</li>\n<li class=\"lvl-2\">\n<p>设置过期</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>为指定 field 设置过期时间</td>\n<td><code>expire(H key, Duration timeout, Collection&lt;HK&gt; hashKeys)</code></td>\n<td><code>HEXPIRE key seconds FIELDS n field [...]</code></td>\n<td>Redis ≥ 7.4</td>\n</tr>\n<tr>\n<td>为指定 field 设置过期时间点</td>\n<td><code>expireAt(H key, Instant expireAt, Collection&lt;HK&gt; hashKeys)</code></td>\n<td><code>HEXPIREAT key timestamp FIELDS n field [...]</code></td>\n<td>Redis ≥ 7.4</td>\n</tr>\n<tr>\n<td>高级过期策略</td>\n<td><code>expire(H key, Expiration expiration, ExpirationOptions options, Collection&lt;HK&gt; hashKeys)</code></td>\n<td><code>HEXPIRE / HEXPIREAT</code></td>\n<td>Spring 抽象封装</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>移除过期时间</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>移除指定 field 的过期时间</td>\n<td><code>persist(H key, Collection&lt;HK&gt; hashKeys)</code></td>\n<td><code>HPERSIST key FIELDS n field [...]</code></td>\n<td>Redis ≥ 7.4</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 Redis Hash 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ Hash 核心详解 Redis Hash 是一种 key → field → value 的数据结构，本质上是 12345key -&gt; Map&lt;String, String&gt;# 说明key：Redis 的键（只能是 String）field：Hash 内的字段名（String）value：字段值（String，二进制安全） Hash 的核心特性 12345适合存储对象型数据支持 字段级别读写所有操作均为 原子性内存效率优于「String + JSON」单个 Hash 理论最大 512 MB Hash 的使用场景 1234567# 对象缓存HSET user:1 name zhangsan age 20# 电商购物车:1)以用户id为key 2）商品id为field 3）商品数量为valueHSET cart:userId commodity:1001 1 commodity:1002 5# 分布式锁，一个命令搞不定，需要结合Lua脚本HINCRBY lock uuid:threadId 1 # 创建锁 或 重入+1EXPIRE lock 30 # 30 秒后自动释放锁 Hash结构优缺点 12345678910111213141516171819202122232425262728• 优点1）同类数据聚合存储，适合表达对象模型，便于管理与维护2）相比 string 操作消耗内存与 CPU 更小 a.当多个小字段被组织在同一个 Hash 中时，整体内存与 CPU 开销通常小于使用多个 String Key，因为Redis 对 小 Hash 使用 ziplist / listpack（紧凑结构），减少了 Key 元数据、过期字典、指针等开销 b.Hash 过大时（BigHash）优势消失3）相比 string，减少了 Key 数量，降低元数据与过期字典的额外开销• 缺点1) 默认过期只能作用在 key 级别，Hash field 级别过期需 Redis 7.4+ 才支持```bash# user:1 这个 Hash 不会过期HSET user:1 name &quot;Tom&quot; age 18# HEXPIRE key seconds [NX|XX|GT|LT] FIELDS numfields field [field ...]# 只有 name field 60 秒后自动删除HEXPIRE user:1 60 FIELDS 1 name# 同时给多个 field 设置过期时间HEXPIRE user:1 60 FIELDS 2 name age# 使用毫秒级过期（HPEXPIRE）# HPEXPIRE key milliseconds [NX|XX|GT|LT] FIELDS numfields field [field ...]HPEXPIRE user:1 60 FIELDS 2 name age# 查看 field 剩余秒数（HTTL）,-1 表示 field 永不过期，-2 表示 field 已过期# HTTL key FIELDS numfields field [field ...]HTTL user:1 FIELDS 1 name# 查看毫秒级 TTL（HPTTL）,-1 表示 field 永不过期，-2 表示 field 已过期# HPTTL key FIELDS numfields field [field ...]HPTTL user:1 FIELDS 1 name# 移出过期时间# HPERSIST key FIELDS numfields field [field ...]HPERSIST user:1 FIELDS 1 name 在 Redis Cluster 中，不应设计超大的 Hash Key（BigHash），否则会影响迁移、扩缩容和主从复制性能。 生产环境建议 12345一个 Hash = 一个对象field 数量建议 &lt; 100单 field value 建议 &lt; 1 KB大对象拆分为多个 Hash避免在大 Hash 上使用 HGETALL Hash 命令 SpringBoot 的 RedisTemplate&lt;K,V&gt;.opsForHash() 中 Hash 数据类型 的操作方法与 Redis 原生命令的对应关系如下： 写入 / 更新 方法功能 方法 Redis 原始命令 备注 设置单个 field-value put(H key, HK hashKey, HV value) HSET key field value 新增或覆盖 批量设置 field-value putAll(H key, Map&lt;HK,HV&gt; m) HSET key field value [field value ...] HMSET 已废弃 field 不存在时设置 putIfAbsent(H key, HK hashKey, HV value) HSETNX key field value 原子操作 读取 方法功能 方法 Redis 原始命令 备注 获取指定 field 的值 get(H key, Object hashKey) HGET key field 不存在返回 null 批量获取多个 field multiGet(H key, Collection&lt;HK&gt; hashKeys) HMGET key field [field ...] 不存在返回 null 获取所有 value values(H key) HVALS key O(N) 获取所有 field-value entries(H key) HGETALL key 生产环境慎用 删除 / 存在性判断 方法功能 方法 Redis 原始命令 备注 删除一个或多个 field delete(H key, Object... hashKeys) HDEL key field [field ...] 返回删除数量 判断 field 是否存在 hasKey(H key, Object hashKey) HEXISTS key field — 计数与数值运算 方法功能 方法 Redis 原始命令 备注 field 整数自增 increment(H key, HK hashKey, long delta) HINCRBY key field increment value 必须是整数 field 浮点数自增 increment(H key, HK hashKey, double delta) HINCRBYFLOAT key field increment Redis ≥ 2.6 获取 field 对应 value 长度 lengthOfValue(H key, HK hashKey) HSTRLEN key field 不存在返回 0 获取 hash 中 field 数量 size(H key) HLEN key — 随机访问（Random Access） ⚠️ 随机访问常用于抽样、降级策略，不适合强一致业务 方法功能 方法 Redis 原始命令 备注 随机返回一个 field randomKey(H key) HRANDFIELD key Redis ≥ 6.2 随机返回一个 field-value randomEntry(H key) HRANDFIELD key WITHVALUES Redis ≥ 6.2 随机返回多个 field randomKeys(H key, long count) HRANDFIELD key count count &lt; 0 可重复 随机返回多个 field-value randomEntries(H key, long count) HRANDFIELD key count WITHVALUES — 遍历与扫描（推荐方式） 方法功能 方法 Redis 原始命令 备注 获取所有 field keys(H key) HKEYS key O(N)，大 hash 慎用 游标扫描 hash scan(H key, ScanOptions options) HSCAN key cursor [MATCH] [COUNT] 推荐替代 HGETALL 📌 最佳实践 小 hash：HGETALL 大 hash / 线上系统：HSCAN Hash Field 级别过期（Redis 7.4+） Redis 7.4 引入 field 级 TTL，这是 Hash 的重大能力增强 设置过期 方法功能 方法 Redis 原始命令 备注 为指定 field 设置过期时间 expire(H key, Duration timeout, Collection&lt;HK&gt; hashKeys) HEXPIRE key seconds FIELDS n field [...] Redis ≥ 7.4 为指定 field 设置过期时间点 expireAt(H key, Instant expireAt, Collection&lt;HK&gt; hashKeys) HEXPIREAT key timestamp FIELDS n field [...] Redis ≥ 7.4 高级过期策略 expire(H key, Expiration expiration, ExpirationOptions options, Collection&lt;HK&gt; hashKeys) HEXPIRE / HEXPIREAT Spring 抽象封装 移除过期时间 方法功能 方法 Redis 原始命令 备注 移除指定 field 的过期时间 persist(H key, Collection&lt;HK&gt; hashKeys) HPERSIST key FIELDS n field [...] Redis ≥ 7.4","summary":"摘要 本文介绍 Redis Hash 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2025-12-15T13:33:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/15/redis7-datatype-02-string/","url":"https://blog.hanqunfeng.com/2025/12/15/redis7-datatype-02-string/","title":"Redis 命令及数据类型 -- String","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis String 数据类型</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code>，<code>springboot-3.5.8</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"String-核心详解\">String 核心详解</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 Redis 中，String（字符串） 是最基础、也是使用最广泛的数据类型。它并不只表示“文本字符串”，而是一种二进制安全（binary-safe）的值类型，可以存储多种形式的数据。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Redis 的 String 类型本质上是一个 key → value 的映射，key 和 value 本质上是二进制安全的字节数组。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Redis 不关心 key 和 value 的语义，只当作字节数组处理，可存储文本、数字、序列化对象、图片等</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>数据形式</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>普通字符串</td>\n<td><code>&quot;hello redis&quot;</code></td>\n</tr>\n<tr>\n<td>数字（整型/浮点）</td>\n<td><code>&quot;100&quot;</code>, <code>&quot;3.14&quot;</code></td>\n</tr>\n<tr>\n<td>JSON</td>\n<td><code>&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Tom&quot;&#125;</code></td>\n</tr>\n<tr>\n<td>序列化对象</td>\n<td>Java / JSON / ProtoBuf</td>\n</tr>\n<tr>\n<td>Base64 / 二进制</td>\n<td>图片、Token 等</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>单个 key 和 value 最大都是 512 MB，但实际使用中及其不推荐将其设置为这么大，推荐如下</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>最大存储大小（MB）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Key</td>\n<td>&lt; 1k</td>\n</tr>\n<tr>\n<td>Value</td>\n<td>&lt; 1MB</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>String 数据类型的主要应用场景</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 单值缓存</span></span><br><span class=\"line\">SET k1 v1</span><br><span class=\"line\"><span class=\"comment\"># 对象缓存</span></span><br><span class=\"line\">SET user:1 <span class=\"string\">&#x27;&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:20&#125;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 分布式锁，为了保证可重入，现在更推荐使用 hash 类型</span></span><br><span class=\"line\">SET lock uuid:threadId NX EX 10</span><br></pre></td></tr></table></figure>\n<h2 id=\"Redis-String-的编码类型\">Redis String 的编码类型</h2>\n<blockquote>\n<p>编码类型是针对 value 的编码方式</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>编码类型</th>\n<th>OBJECT ENCODING</th>\n<th>触发条件</th>\n<th>内部存储</th>\n<th>是否可变</th>\n<th>典型命令/场景</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>整数编码</td>\n<td><code>int</code></td>\n<td>value 是<strong>纯数字字符串</strong>且在 <code>[-2^63, 2^63-1]</code> 范围</td>\n<td><code>long</code></td>\n<td>❌</td>\n<td><code>SET k 1</code>、<code>INCR k</code></td>\n<td>最省内存、数值运算最快</td>\n</tr>\n<tr>\n<td>嵌入式字符串</td>\n<td><code>embstr</code></td>\n<td><strong>字符串长度 ≤ 44 字节</strong>（Redis 7.x）且<strong>直接 SET</strong></td>\n<td><code>redisObject + SDS</code> 一次性分配</td>\n<td>⚠️（会升级）</td>\n<td><code>SET k &quot;ok&quot;</code></td>\n<td>不支持扩容</td>\n</tr>\n<tr>\n<td>原始字符串</td>\n<td><code>raw</code></td>\n<td>字符串长度 &gt; 44 字节，或发生<strong>增量修改</strong></td>\n<td><code>redisObject → SDS</code></td>\n<td>✅</td>\n<td><code>APPEND</code>、<code>SETRANGE</code></td>\n<td>最通用</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>可以用命令查看指定key的 value 的编码类型</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OBJECT ENCODING key</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">set</span> k1 123</span><br><span class=\"line\">OBJECT ENCODING k1 <span class=\"comment\"># int</span></span><br><span class=\"line\">APPEND k1 <span class=\"string\">&quot;4&quot;</span> <span class=\"comment\"># 自动升级为 raw，这是因为 APPEND 会强制使用 raw，即使最终字符串长度 ≤ 44 字节</span></span><br><span class=\"line\"></span><br><span class=\"line\">SET k <span class=\"string\">&quot;short&quot;</span></span><br><span class=\"line\">OBJECT ENCODING k <span class=\"comment\"># embstr</span></span><br><span class=\"line\">APPEND k <span class=\"string\">&quot;this-is-a-long-string&quot;</span> <span class=\"comment\"># 自动升级为 raw</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis String 根据“值的形态 + 操作语义”在 int / embstr / raw 之间自动选择；</p>\n</li>\n<li class=\"lvl-2\">\n<p>这种编码自适应机制，是 Redis 高性能与低内存占用的重要基础。</p>\n</li>\n</ul>\n<h2 id=\"String-命令\">String 命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SpringBoot 的 <code>RedisTemplate&lt;K,V&gt;.opsForValue()</code> 中 String 数据类型 的操作方法与 Redis 原生命令的对应关系如下：</p>\n</li>\n</ul>\n<h3 id=\"普通设置\">普通设置</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>设置 key 的值</td>\n<td><code>set(K key, V value)</code></td>\n<td><code>SET key value</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"条件写入（NX-XX）\">条件写入（NX / XX）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>命令备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>key 不存在时设置</td>\n<td><code>setIfAbsent(K key, V value)</code></td>\n<td><code>SET key value NX</code></td>\n<td>NX：key 不存在才设置</td>\n</tr>\n<tr>\n<td>key 存在时设置</td>\n<td><code>setIfPresent(K key, V value)</code></td>\n<td><code>SET key value XX</code></td>\n<td>XX：key 存在才设置</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"条件写入-过期时间\">条件写入 + 过期时间</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>命令备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>key 不存在时设置并指定过期时间</td>\n<td><code>setIfAbsent(K key, V value, timeout, unit)</code></td>\n<td><code>SET key value NX EX seconds</code></td>\n<td>EX 秒 / PX 毫秒</td>\n</tr>\n<tr>\n<td>key 存在时设置并指定过期时间</td>\n<td><code>setIfPresent(K key, V value, timeout, unit)</code></td>\n<td><code>SET key value XX EX seconds</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"直接设置并指定过期时间\">直接设置并指定过期时间</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>命令备注 / 推荐替代</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>设置值并指定过期时间</td>\n<td><code>set(K key, V value, timeout, unit)</code></td>\n<td><code>SETEX key seconds value</code> <strong>即将废弃</strong></td>\n<td><strong>推荐</strong> → <code>SET key value EX seconds</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"保留-TTL-写入（KEEP-TTL）\">保留 TTL 写入（KEEP_TTL）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>设置新值并保留原 TTL</td>\n<td>无直接方法</td>\n<td><code>SET key value KEEPTTL</code></td>\n<td>Redis ≥ 6.0</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setKeepTtl</span><span class=\"params\">(String key, Object value)</span> &#123;</span><br><span class=\"line\">    redisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt;</span><br><span class=\"line\">            connection.stringCommands().set(</span><br><span class=\"line\">                    Objects.requireNonNull(redisTemplate.getStringSerializer().serialize(key)),</span><br><span class=\"line\">                    Objects.requireNonNull(((RedisSerializer&lt;Object&gt;) redisTemplate.getValueSerializer()).serialize(value)),</span><br><span class=\"line\">                    Expiration.keepTtl(),</span><br><span class=\"line\">                    RedisStringCommands.SetOption.UPSERT</span><br><span class=\"line\">            )</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"普通读取\">普通读取</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>获取 key 的值</td>\n<td><code>get(K key)</code></td>\n<td><code>GET key</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"读改写原子操作（GETEX-GETDEL）\">读改写原子操作（GETEX / GETDEL）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>获取值并重置过期时间</td>\n<td><code>getAndExpire(K key, timeout, unit)</code></td>\n<td><code>GETEX key EX seconds</code></td>\n<td>Redis ≥ 6.2<br>GET + EXPIRE（非原子）</td>\n</tr>\n<tr>\n<td>获取 key 的当前值并移除过期时间</td>\n<td><code>getAndPersist(K key)</code></td>\n<td><code>GETEX key PERSIST</code></td>\n<td>Redis ≥ 6.2<br>GET + PERSIST（非原子）</td>\n</tr>\n<tr>\n<td>获取值并删除 key</td>\n<td><code>getAndDelete(K key)</code></td>\n<td><code>GETDEL key</code></td>\n<td>Redis ≥ 6.2<br>GET + DEL（非原子）</td>\n</tr>\n<tr>\n<td>获取旧值并设置新值</td>\n<td><code>getAndSet(K key, V value)</code></td>\n<td><code>GETSET key value</code> <strong>即将废弃</strong></td>\n<td><strong>推荐</strong> → <code>SET key value GET</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"字符串区间读取\">字符串区间读取</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>获取字符串指定区间</td>\n<td><code>get(K key, start, end)</code></td>\n<td><code>GETRANGE key start end</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>获取字符串长度</td>\n<td><code>size(K key)</code></td>\n<td><code>STRLEN key</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"数值运算（计数器场景）\">数值运算（计数器场景）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数值自增 1</td>\n<td><code>increment(K key)</code></td>\n<td><code>INCR key</code></td>\n<td>value 必须是整数</td>\n</tr>\n<tr>\n<td>数值增加指定值</td>\n<td><code>increment(K key, delta)</code></td>\n<td><code>INCRBY key increment</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>数值自减 1</td>\n<td><code>decrement(K key)</code></td>\n<td><code>DECR key</code></td>\n<td>—</td>\n</tr>\n<tr>\n<td>数值减少指定值</td>\n<td><code>decrement(K key, delta)</code></td>\n<td><code>DECRBY key decrement</code></td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"批量写入-读取\">批量写入 / 读取</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>批量设置 key-value</td>\n<td><code>multiSet(map)</code></td>\n<td><code>MSET key value ...</code></td>\n<td>非原子</td>\n</tr>\n<tr>\n<td>批量获取 key 的值</td>\n<td><code>multiGet(keys)</code></td>\n<td><code>MGET key ...</code></td>\n<td>不存在返回 <code>null</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"批量条件写入（原子）\">批量条件写入（原子）</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>批量设置（仅当全部不存在）</td>\n<td><code>multiSetIfAbsent(map)</code></td>\n<td><code>MSETNX key value ...</code></td>\n<td><strong>全成功 / 全失败</strong></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"字符串追加操作\">字符串追加操作</h3>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法</th>\n<th>Redis 原始命令</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>追加字符串并返回新长度</td>\n<td><code>append(K key, String value)</code></td>\n<td><code>APPEND key value</code></td>\n<td>key 不存在等价于 SET</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 Redis String 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ String 核心详解 在 Redis 中，String（字符串） 是最基础、也是使用最广泛的数据类型。它并不只表示“文本字符串”，而是一种二进制安全（binary-safe）的值类型，可以存储多种形式的数据。 Redis 的 String 类型本质上是一个 key → value 的映射，key 和 value 本质上是二进制安全的字节数组。 Redis 不关心 key 和 value 的语义，只当作字节数组处理，可存储文本、数字、序列化对象、图片等 数据形式 示例 普通字符串 &quot;hello redis&quot; 数字（整型/浮点） &quot;100&quot;, &quot;3.14&quot; JSON &#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Tom&quot;&#125; 序列化对象 Java / JSON / ProtoBuf Base64 / 二进制 图片、Token 等 单个 key 和 value 最大都是 512 MB，但实际使用中及其不推荐将其设置为这么大，推荐如下 分类 最大存储大小（MB） Key &lt; 1k Value &lt; 1MB String 数据类型的主要应用场景 123456# 单值缓存SET k1 v1# 对象缓存SET user:1 &#x27;&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:20&#125;&#x27;# 分布式锁，为了保证可重入，现在更推荐使用 hash 类型SET lock uuid:threadId NX EX 10 Redis String 的编码类型 编码类型是针对 value 的编码方式 编码类型 OBJECT ENCODING 触发条件 内部存储 是否可变 典型命令/场景 备注 整数编码 int value 是纯数字字符串且在 [-2^63, 2^63-1] 范围 long ❌ SET k 1、INCR k 最省内存、数值运算最快 嵌入式字符串 embstr 字符串长度 ≤ 44 字节（Redis 7.x）且直接 SET redisObject + SDS 一次性分配 ⚠️（会升级） SET k &quot;ok&quot; 不支持扩容 原始字符串 raw 字符串长度 &gt; 44 字节，或发生增量修改 redisObject → SDS ✅ APPEND、SETRANGE 最通用 可以用命令查看指定key的 value 的编码类型 1OBJECT ENCODING key 示例 1234567set k1 123OBJECT ENCODING k1 # intAPPEND k1 &quot;4&quot; # 自动升级为 raw，这是因为 APPEND 会强制使用 raw，即使最终字符串长度 ≤ 44 字节SET k &quot;short&quot;OBJECT ENCODING k # embstrAPPEND k &quot;this-is-a-long-string&quot; # 自动升级为 raw Redis String 根据“值的形态 + 操作语义”在 int / embstr / raw 之间自动选择； 这种编码自适应机制，是 Redis 高性能与低内存占用的重要基础。 String 命令 SpringBoot 的 RedisTemplate&lt;K,V&gt;.opsForValue() 中 String 数据类型 的操作方法与 Redis 原生命令的对应关系如下： 普通设置 方法功能 方法 Redis 原始命令 备注 设置 key 的值 set(K key, V value) SET key value — 条件写入（NX / XX） 方法功能 方法 Redis 原始命令 命令备注 key 不存在时设置 setIfAbsent(K key, V value) SET key value NX NX：key 不存在才设置 key 存在时设置 setIfPresent(K key, V value) SET key value XX XX：key 存在才设置 条件写入 + 过期时间 方法功能 方法 Redis 原始命令 命令备注 key 不存在时设置并指定过期时间 setIfAbsent(K key, V value, timeout, unit) SET key value NX EX seconds EX 秒 / PX 毫秒 key 存在时设置并指定过期时间 setIfPresent(K key, V value, timeout, unit) SET key value XX EX seconds — 直接设置并指定过期时间 方法功能 方法 Redis 原始命令 命令备注 / 推荐替代 设置值并指定过期时间 set(K key, V value, timeout, unit) SETEX key seconds value 即将废弃 推荐 → SET key value EX seconds 保留 TTL 写入（KEEP_TTL） 方法功能 方法 Redis 原始命令 备注 设置新值并保留原 TTL 无直接方法 SET key value KEEPTTL Redis ≥ 6.0 12345678910public void setKeepTtl(String key, Object value) &#123; redisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt; connection.stringCommands().set( Objects.requireNonNull(redisTemplate.getStringSerializer().serialize(key)), Objects.requireNonNull(((RedisSerializer&lt;Object&gt;) redisTemplate.getValueSerializer()).serialize(value)), Expiration.keepTtl(), RedisStringCommands.SetOption.UPSERT ) );&#125; 普通读取 方法功能 方法 Redis 原始命令 备注 获取 key 的值 get(K key) GET key — 读改写原子操作（GETEX / GETDEL） 方法功能 方法 Redis 原始命令 备注 获取值并重置过期时间 getAndExpire(K key, timeout, unit) GETEX key EX seconds Redis ≥ 6.2GET + EXPIRE（非原子） 获取 key 的当前值并移除过期时间 getAndPersist(K key) GETEX key PERSIST Redis ≥ 6.2GET + PERSIST（非原子） 获取值并删除 key getAndDelete(K key) GETDEL key Redis ≥ 6.2GET + DEL（非原子） 获取旧值并设置新值 getAndSet(K key, V value) GETSET key value 即将废弃 推荐 → SET key value GET 字符串区间读取 方法功能 方法 Redis 原始命令 备注 获取字符串指定区间 get(K key, start, end) GETRANGE key start end — 获取字符串长度 size(K key) STRLEN key — 数值运算（计数器场景） 方法功能 方法 Redis 原始命令 备注 数值自增 1 increment(K key) INCR key value 必须是整数 数值增加指定值 increment(K key, delta) INCRBY key increment — 数值自减 1 decrement(K key) DECR key — 数值减少指定值 decrement(K key, delta) DECRBY key decrement — 批量写入 / 读取 方法功能 方法 Redis 原始命令 备注 批量设置 key-value multiSet(map) MSET key value ... 非原子 批量获取 key 的值 multiGet(keys) MGET key ... 不存在返回 null 批量条件写入（原子） 方法功能 方法 Redis 原始命令 备注 批量设置（仅当全部不存在） multiSetIfAbsent(map) MSETNX key value ... 全成功 / 全失败 字符串追加操作 方法功能 方法 Redis 原始命令 备注 追加字符串并返回新长度 append(K key, String value) APPEND key value key 不存在等价于 SET","summary":"摘要 本文介绍 Redis String 数据类型 本文基于redis-7.4.7，springboot-3.5.8 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2025-12-15T13:31:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/15/redis7-datatype-01-common/","url":"https://blog.hanqunfeng.com/2025/12/15/redis7-datatype-01-common/","title":"Redis 命令及数据类型 -- 通用命令","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">本文介绍 Redis 的 通用命令，即所有数据类型均可使用的命令</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n<li class=\"lvl-2\">Redis 命令文档：<a href=\"https://redis.io/docs/latest/commands/\">https://redis.io/docs/latest/commands/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"通用命令\">通用命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>我们可以在 Redis官网 中查看所有命令的使用方法，也可以在命令行中通过 <code>help command</code> 或 <code>help @group</code> 查看命令的帮助</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看 set 命令的使用方法</span></span><br><span class=\"line\"><span class=\"built_in\">help</span> <span class=\"built_in\">set</span></span><br><span class=\"line\"><span class=\"comment\"># 查看事务相关命令的使用方法</span></span><br><span class=\"line\"><span class=\"built_in\">help</span> @transactions</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis核心分组</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>分组</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>@string</code></td>\n<td>String</td>\n</tr>\n<tr>\n<td><code>@hash</code></td>\n<td>Hash</td>\n</tr>\n<tr>\n<td><code>@list</code></td>\n<td>List</td>\n</tr>\n<tr>\n<td><code>@set</code></td>\n<td>Set</td>\n</tr>\n<tr>\n<td><code>@sortedset</code></td>\n<td>ZSet</td>\n</tr>\n<tr>\n<td><code>@bitmap</code></td>\n<td>Bitmap</td>\n</tr>\n<tr>\n<td><code>@hyperloglog</code></td>\n<td>HLL</td>\n</tr>\n<tr>\n<td><code>@geo</code></td>\n<td>GEO</td>\n</tr>\n<tr>\n<td><code>@stream</code></td>\n<td>Stream</td>\n</tr>\n<tr>\n<td><code>@transactions</code></td>\n<td>MULTI / EXEC</td>\n</tr>\n<tr>\n<td><code>@pubsub</code></td>\n<td>发布订阅</td>\n</tr>\n<tr>\n<td><code>@scripting</code></td>\n<td>Lua</td>\n</tr>\n<tr>\n<td><code>@server</code></td>\n<td>服务器管理</td>\n</tr>\n<tr>\n<td><code>@connection</code></td>\n<td>连接管理</td>\n</tr>\n<tr>\n<td><code>@cluster</code></td>\n<td>集群</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>以下是针对所有数据类型均可使用给的方法和命令</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法功能</th>\n<th>方法 <code>redisTemplate.xxx()</code></th>\n<th>Redis 原始命令</th>\n<th>命令备注 / 推荐替代</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>复制 key 到新 key</td>\n<td><code>Boolean copy(K source, K target, boolean replace)</code></td>\n<td><code>COPY source target [REPLACE]</code></td>\n<td>Redis ≥ 6.2</td>\n</tr>\n<tr>\n<td>判断 key 是否存在（单个）</td>\n<td><code>Boolean hasKey(K key)</code></td>\n<td><code>EXISTS key</code></td>\n<td>CLI 返回存在数量</td>\n</tr>\n<tr>\n<td>统计存在的 key 数量</td>\n<td><code>Long countExistingKeys(Collection&lt;K&gt; keys)</code></td>\n<td><code>EXISTS key [key ...]</code></td>\n<td>返回存在 key 的数量</td>\n</tr>\n<tr>\n<td>删除指定 key（同步）</td>\n<td><code>Boolean delete(K key)</code></td>\n<td><code>DEL key</code></td>\n<td>返回是否删除成功</td>\n</tr>\n<tr>\n<td>批量删除 key（同步）</td>\n<td><code>Long delete(Collection&lt;K&gt; keys)</code></td>\n<td><code>DEL key [key ...]</code></td>\n<td>返回删除数量</td>\n</tr>\n<tr>\n<td>删除 key（异步）</td>\n<td><code>Boolean unlink(K key)</code></td>\n<td><code>UNLINK key</code></td>\n<td>非阻塞删除</td>\n</tr>\n<tr>\n<td>批量删除 key（异步）</td>\n<td><code>Long unlink(Collection&lt;K&gt; keys)</code></td>\n<td><code>UNLINK key [key ...]</code></td>\n<td>推荐大 key 使用</td>\n</tr>\n<tr>\n<td>获取 key 的数据类型</td>\n<td><code>DataType type(K key)</code></td>\n<td><code>TYPE key</code></td>\n<td>返回 string/hash/list/set/zset/none</td>\n</tr>\n<tr>\n<td>按模式匹配 key（阻塞）</td>\n<td><code>Set&lt;K&gt; keys(K pattern)</code></td>\n<td><code>KEYS pattern</code></td>\n<td><strong>生产环境不推荐</strong></td>\n</tr>\n<tr>\n<td>游标方式扫描 key</td>\n<td><code>Cursor&lt;K&gt; scan(ScanOptions options)</code></td>\n<td><code>SCAN cursor [MATCH] [COUNT]</code></td>\n<td>推荐替代 <code>KEYS</code></td>\n</tr>\n<tr>\n<td>随机返回一个 key</td>\n<td><code>K randomKey()</code></td>\n<td><code>RANDOMKEY</code></td>\n<td>可能返回 <code>null</code></td>\n</tr>\n<tr>\n<td>重命名 key</td>\n<td><code>void rename(K oldKey, K newKey)</code></td>\n<td><code>RENAME oldKey newKey</code></td>\n<td>覆盖目标 key</td>\n</tr>\n<tr>\n<td>key 不存在时重命名</td>\n<td><code>Boolean renameIfAbsent(K oldKey, K newKey)</code></td>\n<td><code>RENAMENX oldKey newKey</code></td>\n<td>原子操作</td>\n</tr>\n<tr>\n<td>设置 key 过期时间</td>\n<td><code>Boolean expire(K key, long timeout, TimeUnit unit)</code></td>\n<td><code>PEXPIRE / EXPIRE</code></td>\n<td>优先毫秒精度</td>\n</tr>\n<tr>\n<td>设置 key 在指定时间过期</td>\n<td><code>Boolean expireAt(K key, Date date)</code></td>\n<td><code>PEXPIREAT / EXPIREAT</code></td>\n<td>精度自动降级</td>\n</tr>\n<tr>\n<td>设置过期策略（高级 API）</td>\n<td><code>ExpiryChangeState expire(K key, Expiration expiration, ExpirationOptions options)</code></td>\n<td><code>EXPIRE / PEXPIRE / EXPIREAT</code></td>\n<td>Spring 抽象封装</td>\n</tr>\n<tr>\n<td>清除 key 的过期时间</td>\n<td><code>Boolean persist(K key)</code></td>\n<td><code>PERSIST key</code></td>\n<td>变为永久 key</td>\n</tr>\n<tr>\n<td>获取剩余 TTL（秒）</td>\n<td><code>Long getExpire(K key)</code></td>\n<td><code>TTL key</code></td>\n<td><code>-1</code> 无 TTL，<code>-2</code> 不存在</td>\n</tr>\n<tr>\n<td>获取剩余 TTL（指定单位）</td>\n<td><code>Long getExpire(K key, TimeUnit unit)</code></td>\n<td><code>PTTL / TTL</code></td>\n<td>优先毫秒</td>\n</tr>\n<tr>\n<td>将 key 移动到其他 DB</td>\n<td><code>Boolean move(K key, int dbIndex)</code></td>\n<td><code>MOVE key db</code></td>\n<td>集群模式不可用</td>\n</tr>\n<tr>\n<td>导出 key 的序列化值</td>\n<td><code>byte[] dump(K key)</code></td>\n<td><code>DUMP key</code></td>\n<td>用于迁移</td>\n</tr>\n<tr>\n<td>恢复 key</td>\n<td><code>void restore(K key, byte[] value, long ttl, TimeUnit unit, boolean replace)</code></td>\n<td><code>RESTORE key ttl value [REPLACE]</code></td>\n<td>与 <code>DUMP</code> 配合</td>\n</tr>\n<tr>\n<td>排序并返回结果</td>\n<td><code>List&lt;V&gt; sort(SortQuery&lt;K&gt; query)</code></td>\n<td><code>SORT key</code></td>\n<td>阻塞操作</td>\n</tr>\n<tr>\n<td>排序并指定返回类型</td>\n<td><code>List&lt;T&gt; sort(SortQuery&lt;K&gt; query, RedisSerializer&lt;T&gt; serializer)</code></td>\n<td><code>SORT key</code></td>\n<td>结果反序列化</td>\n</tr>\n<tr>\n<td>排序并映射结果</td>\n<td><code>List&lt;T&gt; sort(SortQuery&lt;K&gt; query, BulkMapper&lt;T,V&gt; mapper)</code></td>\n<td><code>SORT key</code></td>\n<td>Spring 封装</td>\n</tr>\n<tr>\n<td>排序并映射（高级）</td>\n<td><code>List&lt;T&gt; sort(SortQuery&lt;K&gt; query, BulkMapper&lt;T,S&gt; mapper)</code></td>\n<td><code>SORT key</code></td>\n<td>批量映射</td>\n</tr>\n<tr>\n<td>排序并存储结果</td>\n<td><code>Long sort(SortQuery&lt;K&gt; query, K storeKey)</code></td>\n<td><code>SORT key STORE destination</code></td>\n<td>返回结果条数</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>生产环境慎用的命令</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>原因</th>\n<th>推荐</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>KEYS</code></td>\n<td>阻塞、O(N)</td>\n<td><code>SCAN</code></td>\n</tr>\n<tr>\n<td><code>SORT</code></td>\n<td>阻塞、消耗 CPU</td>\n<td>业务侧排序</td>\n</tr>\n<tr>\n<td><code>DEL</code></td>\n<td>阻塞、消耗 CPU</td>\n<td><code>UNLINK</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"避免BigKey\">避免BigKey</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>BigKey 的危害并不在“占内存”，而在操作成本是 O(N)。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Redis 是单线程执行命令，比如 <code>HGETALL</code>、<code>DEL</code>等，运行期间会占用CPU，阻塞 Redis 主线程，直接表现为 RT 飙升 / QPS 下降。</p>\n</li>\n<li class=\"lvl-2\">\n<p>另外BigKey还会导致如下问题：</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">大 Key 返回值过大 → 网络 IO 抖动</span><br><span class=\"line\">主从复制同步 BigKey → 从库延迟</span><br><span class=\"line\">RDB / AOF 重写 → Fork 时间变长</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>BigKey 的阈值</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>元素数量阈值（经验值）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>String</td>\n<td>≥ 10,000 byte</td>\n</tr>\n<tr>\n<td>Hash</td>\n<td>≥ 10,000 field</td>\n</tr>\n<tr>\n<td>List</td>\n<td>≥ 10,000 item</td>\n</tr>\n<tr>\n<td>Set</td>\n<td>≥ 10,000 member</td>\n</tr>\n<tr>\n<td>ZSet</td>\n<td>≥ 10,000 member</td>\n</tr>\n<tr>\n<td>Stream</td>\n<td>≥ 10,000 entry</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>在生产环境中，5,000 就已经需要警惕。<br>\n建议在数据量达到一定阈值时，考虑拆分。</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Reids官方给出了判断BigKey的命令</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli --bigkeys</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>⚠️ 注意：它不是按<code>内存占用最大</code>，而是按<code>元素数/长度</code> 来找<code>最大的 key</code>。</p>\n</li>\n</ul>\n<h3 id=\"BigKey-的处理方式\">BigKey 的处理方式</h3>\n<h4 id=\"避免执行占用CPU的操作\">避免执行占用CPU的操作</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>比如 <code>HGETALL</code>、<code>DEL</code>、<code>Keys *</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 只读取一部分字段</span></span><br><span class=\"line\">HGETALL user:1001 --&gt; HMGET user:1001 name age email</span><br><span class=\"line\"><span class=\"comment\"># 异步清除</span></span><br><span class=\"line\">DEL key --&gt; UNLINK key</span><br><span class=\"line\"><span class=\"comment\"># 避免 KEYS 改用 SCAN</span></span><br><span class=\"line\">keys pattern --&gt; scan cursor match pattern count 1000</span><br><span class=\"line\"><span class=\"comment\"># 避免读取全部数据，而是应该指定读取范围</span></span><br><span class=\"line\">LRANGE key 0 -1 --&gt; LRANGE key 0 999</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>业务侧排序，避免使用<code>SORT</code></p>\n</li>\n</ul>\n<h4 id=\"设计上避免BigKey\">设计上避免BigKey</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>拆分数据</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 错误设计：</span></span><br><span class=\"line\">user:all_profiles -&gt; 超大 JSON</span><br><span class=\"line\"><span class=\"comment\"># 正确设计：</span></span><br><span class=\"line\">user:1001:profile</span><br><span class=\"line\">user:1002:profile</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Hash 分桶（Shard）</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 通过 hash(id) % N 分散</span></span><br><span class=\"line\">order:2025:0</span><br><span class=\"line\">order:2025:1</span><br><span class=\"line\">order:2025:2</span><br></pre></td></tr></table></figure>\n","content_text":"摘要 本文介绍 Redis 的 通用命令，即所有数据类型均可使用的命令 本文基于redis-7.4.7 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/ 通用命令 我们可以在 Redis官网 中查看所有命令的使用方法，也可以在命令行中通过 help command 或 help @group 查看命令的帮助 1234# 查看 set 命令的使用方法help set# 查看事务相关命令的使用方法help @transactions Redis核心分组 分组 说明 @string String @hash Hash @list List @set Set @sortedset ZSet @bitmap Bitmap @hyperloglog HLL @geo GEO @stream Stream @transactions MULTI / EXEC @pubsub 发布订阅 @scripting Lua @server 服务器管理 @connection 连接管理 @cluster 集群 以下是针对所有数据类型均可使用给的方法和命令 方法功能 方法 redisTemplate.xxx() Redis 原始命令 命令备注 / 推荐替代 复制 key 到新 key Boolean copy(K source, K target, boolean replace) COPY source target [REPLACE] Redis ≥ 6.2 判断 key 是否存在（单个） Boolean hasKey(K key) EXISTS key CLI 返回存在数量 统计存在的 key 数量 Long countExistingKeys(Collection&lt;K&gt; keys) EXISTS key [key ...] 返回存在 key 的数量 删除指定 key（同步） Boolean delete(K key) DEL key 返回是否删除成功 批量删除 key（同步） Long delete(Collection&lt;K&gt; keys) DEL key [key ...] 返回删除数量 删除 key（异步） Boolean unlink(K key) UNLINK key 非阻塞删除 批量删除 key（异步） Long unlink(Collection&lt;K&gt; keys) UNLINK key [key ...] 推荐大 key 使用 获取 key 的数据类型 DataType type(K key) TYPE key 返回 string/hash/list/set/zset/none 按模式匹配 key（阻塞） Set&lt;K&gt; keys(K pattern) KEYS pattern 生产环境不推荐 游标方式扫描 key Cursor&lt;K&gt; scan(ScanOptions options) SCAN cursor [MATCH] [COUNT] 推荐替代 KEYS 随机返回一个 key K randomKey() RANDOMKEY 可能返回 null 重命名 key void rename(K oldKey, K newKey) RENAME oldKey newKey 覆盖目标 key key 不存在时重命名 Boolean renameIfAbsent(K oldKey, K newKey) RENAMENX oldKey newKey 原子操作 设置 key 过期时间 Boolean expire(K key, long timeout, TimeUnit unit) PEXPIRE / EXPIRE 优先毫秒精度 设置 key 在指定时间过期 Boolean expireAt(K key, Date date) PEXPIREAT / EXPIREAT 精度自动降级 设置过期策略（高级 API） ExpiryChangeState expire(K key, Expiration expiration, ExpirationOptions options) EXPIRE / PEXPIRE / EXPIREAT Spring 抽象封装 清除 key 的过期时间 Boolean persist(K key) PERSIST key 变为永久 key 获取剩余 TTL（秒） Long getExpire(K key) TTL key -1 无 TTL，-2 不存在 获取剩余 TTL（指定单位） Long getExpire(K key, TimeUnit unit) PTTL / TTL 优先毫秒 将 key 移动到其他 DB Boolean move(K key, int dbIndex) MOVE key db 集群模式不可用 导出 key 的序列化值 byte[] dump(K key) DUMP key 用于迁移 恢复 key void restore(K key, byte[] value, long ttl, TimeUnit unit, boolean replace) RESTORE key ttl value [REPLACE] 与 DUMP 配合 排序并返回结果 List&lt;V&gt; sort(SortQuery&lt;K&gt; query) SORT key 阻塞操作 排序并指定返回类型 List&lt;T&gt; sort(SortQuery&lt;K&gt; query, RedisSerializer&lt;T&gt; serializer) SORT key 结果反序列化 排序并映射结果 List&lt;T&gt; sort(SortQuery&lt;K&gt; query, BulkMapper&lt;T,V&gt; mapper) SORT key Spring 封装 排序并映射（高级） List&lt;T&gt; sort(SortQuery&lt;K&gt; query, BulkMapper&lt;T,S&gt; mapper) SORT key 批量映射 排序并存储结果 Long sort(SortQuery&lt;K&gt; query, K storeKey) SORT key STORE destination 返回结果条数 生产环境慎用的命令 命令 原因 推荐 KEYS 阻塞、O(N) SCAN SORT 阻塞、消耗 CPU 业务侧排序 DEL 阻塞、消耗 CPU UNLINK 避免BigKey BigKey 的危害并不在“占内存”，而在操作成本是 O(N)。 Redis 是单线程执行命令，比如 HGETALL、DEL等，运行期间会占用CPU，阻塞 Redis 主线程，直接表现为 RT 飙升 / QPS 下降。 另外BigKey还会导致如下问题： 123大 Key 返回值过大 → 网络 IO 抖动主从复制同步 BigKey → 从库延迟RDB / AOF 重写 → Fork 时间变长 BigKey 的阈值 数据类型 元素数量阈值（经验值） String ≥ 10,000 byte Hash ≥ 10,000 field List ≥ 10,000 item Set ≥ 10,000 member ZSet ≥ 10,000 member Stream ≥ 10,000 entry 在生产环境中，5,000 就已经需要警惕。 建议在数据量达到一定阈值时，考虑拆分。 Reids官方给出了判断BigKey的命令 1redis-cli --bigkeys ⚠️ 注意：它不是按内存占用最大，而是按元素数/长度 来找最大的 key。 BigKey 的处理方式 避免执行占用CPU的操作 比如 HGETALL、DEL、Keys * 12345678# 只读取一部分字段HGETALL user:1001 --&gt; HMGET user:1001 name age email# 异步清除DEL key --&gt; UNLINK key# 避免 KEYS 改用 SCANkeys pattern --&gt; scan cursor match pattern count 1000# 避免读取全部数据，而是应该指定读取范围LRANGE key 0 -1 --&gt; LRANGE key 0 999 业务侧排序，避免使用SORT 设计上避免BigKey 拆分数据 12345# 错误设计：user:all_profiles -&gt; 超大 JSON# 正确设计：user:1001:profileuser:1002:profile Hash 分桶（Shard） 1234# 通过 hash(id) % N 分散order:2025:0order:2025:1order:2025:2","summary":"摘要 本文介绍 Redis 的 通用命令，即所有数据类型均可使用的命令 本文基于redis-7.4.7 Redis官网：https://redis.io/ Redis 命令文档：https://redis.io/docs/latest/commands/","date_published":"2025-12-15T13:30:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/10/redis7-scan/","url":"https://blog.hanqunfeng.com/2025/12/10/redis7-scan/","title":"Redis SCAN 命令详解：作用、用法与最佳实践","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">在使用 Redis 时，经常需要遍历数据库中的键，例如查找特定前缀的 key、统计 key 数量、批量删除 key 等。</li>\n<li class=\"lvl-2\">Redis 提供了两种思路：使用 <code>KEYS pattern</code> 或使用游标式遍历命令 <code>SCAN</code>。</li>\n<li class=\"lvl-2\"><code>KEYS pattern</code> 是一种非常不安全的方式，因为它会触发 Redis 服务器的阻塞，从而导致性能下降。设置一些注重安全的环境会禁用<code>KEYS pattern</code>等危险命令。</li>\n<li class=\"lvl-2\">所以Redis官方强烈推荐 <code>SCAN</code> 方式，其是最安全、最可控的遍历方法。</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"SCAN-的核心作用\">SCAN 的核心作用</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SCAN 的主要功能是<strong>基于游标的、非阻塞的、渐进式遍历 Redis 数据库中的 key</strong>。</p>\n</li>\n<li class=\"lvl-2\">\n<p>它允许应用在不阻塞服务器的情况下，每次拉取少量 key，从而安全地在生产环境执行 key 遍历操作。</p>\n</li>\n<li class=\"lvl-2\">\n<p>SCAN 的设计目标包括：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-5\">避免阻塞 Redis 主线程</li>\n<li class=\"lvl-5\">分批、渐进扫描大规模 key 集合</li>\n<li class=\"lvl-5\">灵活配合模式匹配（MATCH）</li>\n<li class=\"lvl-5\">控制每次返回 key 的数量（COUNT）</li>\n<li class=\"lvl-5\">在不影响线上业务的情况下处理数百万甚至数千万级别键值扫描</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>SCAN 命令是完整游标遍历族的一部分，还包括：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-5\"><code>HSCAN</code>：遍历哈希表 field/value</li>\n<li class=\"lvl-5\"><code>SSCAN</code>：遍历 set 元素</li>\n<li class=\"lvl-5\"><code>ZSCAN</code>：遍历有序集合</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>为了完成后面的示例演示，这里准备一个测试数据批量生产脚本</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 脚本名称：import_unified_data.sh</span></span><br><span class=\"line\"><span class=\"comment\"># 运行方法：sh $0 &lt;type&gt; [count]</span></span><br><span class=\"line\"><span class=\"comment\"># &lt;type&gt;: string, hash, list, set, 或 zset</span></span><br><span class=\"line\"><span class=\"comment\"># [count]: 导入的数据量 (可选，默认为 100)</span></span><br><span class=\"line\"><span class=\"comment\"># ----------------------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># --- 1. 参数校验与配置 ---</span></span><br><span class=\"line\"></span><br><span class=\"line\">SUPPORTED_TYPES=<span class=\"string\">&quot;string hash list set zset&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 定义每个集合/列表/有序集合要添加的成员数量</span></span><br><span class=\"line\">MEMBERS_PER_KEY=5</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查是否提供了类型参数</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$#</span> -lt 1 ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;❌ 错误：请指定导入类型。&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;支持的类型: <span class=\"variable\">$&#123;SUPPORTED_TYPES&#125;</span>&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;用法: sh <span class=\"variable\">$0</span> &lt;type&gt; [count]&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">exit</span> 1</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取类型参数 (第一个参数)</span></span><br><span class=\"line\">DATA_TYPE=$(<span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$1</span>&quot;</span> | <span class=\"built_in\">tr</span> <span class=\"string\">&#x27;[:upper:]&#x27;</span> <span class=\"string\">&#x27;[:lower:]&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取数据量参数 (第二个参数)，不存在则默认为 1000</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$#</span> -ge 2 ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">    DATA_COUNT=<span class=\"variable\">$2</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    DATA_COUNT=100</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查类型是否有效</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [[ ! <span class=\"string\">&quot; <span class=\"variable\">$&#123;SUPPORTED_TYPES&#125;</span> &quot;</span> =~ <span class=\"string\">&quot; <span class=\"variable\">$&#123;DATA_TYPE&#125;</span> &quot;</span> ]]; <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;❌ 错误：不支持的类型 &#x27;<span class=\"variable\">$DATA_TYPE</span>&#x27;。&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;支持的类型: <span class=\"variable\">$&#123;SUPPORTED_TYPES&#125;</span>&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">exit</span> 1</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Redis 连接配置</span></span><br><span class=\"line\">REDIS_HOST=<span class=\"string\">&quot;127.0.0.1&quot;</span></span><br><span class=\"line\">REDIS_PORT=<span class=\"string\">&quot;6379&quot;</span></span><br><span class=\"line\">REDIS_PASSWORD=<span class=\"string\">&quot;password&quot;</span> <span class=\"comment\"># 替换为你的实际密码或留空</span></span><br><span class=\"line\">KEY_PREFIX=<span class=\"string\">&quot;test_data&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ----------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"># --- 2. 命令生成主逻辑 ---</span></span><br><span class=\"line\"><span class=\"comment\"># ----------------------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;⏳ 正在生成 <span class=\"variable\">$&#123;DATA_COUNT&#125;</span> 条 Redis [<span class=\"variable\">$&#123;DATA_TYPE&#125;</span>] 命令...&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 构建 RESP 命令流</span></span><br><span class=\"line\">i=1</span><br><span class=\"line\"><span class=\"keyword\">while</span> [ <span class=\"variable\">$i</span> -le <span class=\"variable\">$DATA_COUNT</span> ]</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;<span class=\"variable\">$DATA_TYPE</span>&quot;</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"comment\"># --- String 类型导入 (SET key value) ---</span></span><br><span class=\"line\">        string)</span><br><span class=\"line\">            KEY=<span class=\"string\">&quot;<span class=\"variable\">$&#123;KEY_PREFIX&#125;</span>:string:<span class=\"variable\">$&#123;i&#125;</span>&quot;</span></span><br><span class=\"line\">            VALUE=<span class=\"string\">&quot;value_of_<span class=\"variable\">$&#123;i&#125;</span>_<span class=\"subst\">$(date +%s%N)</span>&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\"># SET 命令 RESP 协议: *3 (SET, key, value)</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span> <span class=\"string\">&quot;*3\\r\\n\\$3\\r\\nSET\\r\\n\\$<span class=\"variable\">$&#123;#KEY&#125;</span>\\r\\n<span class=\"variable\">$&#123;KEY&#125;</span>\\r\\n\\$<span class=\"variable\">$&#123;#VALUE&#125;</span>\\r\\n<span class=\"variable\">$&#123;VALUE&#125;</span>\\r\\n&quot;</span></span><br><span class=\"line\">            ;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># --- Hash 类型导入 (HSET key field1 value1 field2 value2) ---</span></span><br><span class=\"line\">        <span class=\"built_in\">hash</span>)</span><br><span class=\"line\">            HASH_KEY=<span class=\"string\">&quot;<span class=\"variable\">$&#123;KEY_PREFIX&#125;</span>:hash:<span class=\"variable\">$&#123;i&#125;</span>&quot;</span></span><br><span class=\"line\">            FIELD1=<span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">            VALUE1=<span class=\"string\">&quot;User_Name_<span class=\"variable\">$&#123;i&#125;</span>&quot;</span></span><br><span class=\"line\">            FIELD2=<span class=\"string\">&quot;age&quot;</span></span><br><span class=\"line\">            VALUE2=$(( (i % <span class=\"number\">50</span>) + <span class=\"number\">20</span> ))</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\"># HSET 命令 RESP 协议: *6 (HSET, key, f1, v1, f2, v2)</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span> <span class=\"string\">&quot;*6\\r\\n\\$4\\r\\nHSET\\r\\n\\$<span class=\"variable\">$&#123;#HASH_KEY&#125;</span>\\r\\n<span class=\"variable\">$&#123;HASH_KEY&#125;</span>\\r\\n&quot;</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span> <span class=\"string\">&quot;\\$<span class=\"variable\">$&#123;#FIELD1&#125;</span>\\r\\n<span class=\"variable\">$&#123;FIELD1&#125;</span>\\r\\n\\$<span class=\"variable\">$&#123;#VALUE1&#125;</span>\\r\\n<span class=\"variable\">$&#123;VALUE1&#125;</span>\\r\\n&quot;</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span> <span class=\"string\">&quot;\\$<span class=\"variable\">$&#123;#FIELD2&#125;</span>\\r\\n<span class=\"variable\">$&#123;FIELD2&#125;</span>\\r\\n\\$<span class=\"variable\">$&#123;#VALUE2&#125;</span>\\r\\n<span class=\"variable\">$&#123;VALUE2&#125;</span>\\r\\n&quot;</span></span><br><span class=\"line\">            ;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># --- List 类型导入 (LPUSH key value) ---</span></span><br><span class=\"line\">        list)</span><br><span class=\"line\">            LIST_KEY=<span class=\"string\">&quot;<span class=\"variable\">$&#123;KEY_PREFIX&#125;</span>:list:<span class=\"variable\">$&#123;i&#125;</span>&quot;</span></span><br><span class=\"line\">            <span class=\"comment\"># 循环添加 5 个成员</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> $(<span class=\"built_in\">seq</span> 1 <span class=\"variable\">$MEMBERS_PER_KEY</span>); <span class=\"keyword\">do</span></span><br><span class=\"line\">                VALUE=<span class=\"string\">&quot;list_element_<span class=\"variable\">$&#123;i&#125;</span>_<span class=\"variable\">$&#123;j&#125;</span>&quot;</span></span><br><span class=\"line\">                <span class=\"comment\"># LPUSH 命令 RESP 协议: *3 (LPUSH, key, value)</span></span><br><span class=\"line\">                <span class=\"built_in\">printf</span> <span class=\"string\">&quot;*3\\r\\n\\$5\\r\\nLPUSH\\r\\n\\$<span class=\"variable\">$&#123;#LIST_KEY&#125;</span>\\r\\n<span class=\"variable\">$&#123;LIST_KEY&#125;</span>\\r\\n\\$<span class=\"variable\">$&#123;#VALUE&#125;</span>\\r\\n<span class=\"variable\">$&#123;VALUE&#125;</span>\\r\\n&quot;</span></span><br><span class=\"line\">            <span class=\"keyword\">done</span></span><br><span class=\"line\">            ;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># --- Set 类型导入 (SADD key member) ---</span></span><br><span class=\"line\">        <span class=\"built_in\">set</span>)</span><br><span class=\"line\">            SET_KEY=<span class=\"string\">&quot;<span class=\"variable\">$&#123;KEY_PREFIX&#125;</span>:set:<span class=\"variable\">$&#123;i&#125;</span>&quot;</span></span><br><span class=\"line\">            <span class=\"comment\"># 循环添加 5 个成员</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> $(<span class=\"built_in\">seq</span> 1 <span class=\"variable\">$MEMBERS_PER_KEY</span>); <span class=\"keyword\">do</span></span><br><span class=\"line\">                MEMBER=<span class=\"string\">&quot;set_member_<span class=\"variable\">$&#123;i&#125;</span>_<span class=\"variable\">$&#123;j&#125;</span>&quot;</span></span><br><span class=\"line\">                <span class=\"comment\"># SADD 命令 RESP 协议: *3 (SADD, key, member)</span></span><br><span class=\"line\">                <span class=\"built_in\">printf</span> <span class=\"string\">&quot;*3\\r\\n\\$4\\r\\nSADD\\r\\n\\$<span class=\"variable\">$&#123;#SET_KEY&#125;</span>\\r\\n<span class=\"variable\">$&#123;SET_KEY&#125;</span>\\r\\n\\$<span class=\"variable\">$&#123;#MEMBER&#125;</span>\\r\\n<span class=\"variable\">$&#123;MEMBER&#125;</span>\\r\\n&quot;</span></span><br><span class=\"line\">            <span class=\"keyword\">done</span></span><br><span class=\"line\">            ;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># --- Sorted Set 类型导入 (ZADD key score member) ---</span></span><br><span class=\"line\">        zset)</span><br><span class=\"line\">            ZSET_KEY=<span class=\"string\">&quot;<span class=\"variable\">$&#123;KEY_PREFIX&#125;</span>:zset:<span class=\"variable\">$&#123;i&#125;</span>&quot;</span></span><br><span class=\"line\">            <span class=\"comment\"># 循环添加 5 个成员</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> $(<span class=\"built_in\">seq</span> 1 <span class=\"variable\">$MEMBERS_PER_KEY</span>); <span class=\"keyword\">do</span></span><br><span class=\"line\">                SCORE=<span class=\"string\">&quot;<span class=\"variable\">$&#123;i&#125;</span><span class=\"variable\">$&#123;j&#125;</span>&quot;</span> <span class=\"comment\"># 生成唯一分数：例如 key 1 的分数是 11, 12...</span></span><br><span class=\"line\">                MEMBER=<span class=\"string\">&quot;zset_member_<span class=\"variable\">$&#123;i&#125;</span>_<span class=\"variable\">$&#123;j&#125;</span>&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\"># ZADD 命令 RESP 协议: *4 (ZADD, key, score, member)</span></span><br><span class=\"line\">                <span class=\"built_in\">printf</span> <span class=\"string\">&quot;*4\\r\\n\\$4\\r\\nZADD\\r\\n\\$<span class=\"variable\">$&#123;#ZSET_KEY&#125;</span>\\r\\n<span class=\"variable\">$&#123;ZSET_KEY&#125;</span>\\r\\n\\$<span class=\"variable\">$&#123;#SCORE&#125;</span>\\r\\n<span class=\"variable\">$&#123;SCORE&#125;</span>\\r\\n\\$<span class=\"variable\">$&#123;#MEMBER&#125;</span>\\r\\n<span class=\"variable\">$&#123;MEMBER&#125;</span>\\r\\n&quot;</span></span><br><span class=\"line\">            <span class=\"keyword\">done</span></span><br><span class=\"line\">            ;;</span><br><span class=\"line\">    <span class=\"keyword\">esac</span></span><br><span class=\"line\"></span><br><span class=\"line\">    i=$((i+<span class=\"number\">1</span>))</span><br><span class=\"line\"><span class=\"keyword\">done</span> | (</span><br><span class=\"line\">    <span class=\"comment\"># ----------------------------------------</span></span><br><span class=\"line\">    <span class=\"comment\"># --- 3. 管道导入到 Redis ---</span></span><br><span class=\"line\">    <span class=\"comment\"># ----------------------------------------</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;📤 正在通过 redis-cli --pipe 导入数据...&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 构建 redis-cli 命令</span></span><br><span class=\"line\">    REDIS_CLI_CMD=<span class=\"string\">&quot;redis-cli -h <span class=\"variable\">$&#123;REDIS_HOST&#125;</span> -p <span class=\"variable\">$&#123;REDIS_PORT&#125;</span>&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 如果设置了密码，则添加 -a 参数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> [ -n <span class=\"string\">&quot;<span class=\"variable\">$&#123;REDIS_PASSWORD&#125;</span>&quot;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">        REDIS_CLI_CMD=<span class=\"string\">&quot;<span class=\"variable\">$&#123;REDIS_CLI_CMD&#125;</span> -a <span class=\"variable\">$&#123;REDIS_PASSWORD&#125;</span>&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 执行导入</span></span><br><span class=\"line\">    <span class=\"variable\">$&#123;REDIS_CLI_CMD&#125;</span> --pipe</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 检查命令是否执行成功</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> [ $? -eq 0 ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"string\">&quot;✅ 数据导入成功！共导入 <span class=\"variable\">$&#123;DATA_COUNT&#125;</span> 条 [<span class=\"variable\">$&#123;DATA_TYPE&#125;</span>] 记录。&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"string\">&quot;❌ 数据导入失败！请检查 Redis 服务是否运行以及配置是否正确。&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">fi</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h2 id=\"SCAN-的基本用法\">SCAN 的基本用法</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SCAN 的基本语法如下：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SCAN cursor [MATCH pattern] [COUNT count] [TYPE <span class=\"built_in\">type</span>]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>参数解释：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cursor</td>\n<td>游标，从 0 开始，返回值用于下一次扫描；当返回值为 0 时表示遍历结束</td>\n</tr>\n<tr>\n<td>MATCH pattern</td>\n<td>使用通配符匹配 key（可选）</td>\n</tr>\n<tr>\n<td>COUNT count</td>\n<td>建议 Redis 每次返回多少 key（可选），尽力而为，并不保证返回的 key 数量与指定的数量一致</td>\n</tr>\n<tr>\n<td>TYPE type</td>\n<td>匹配的 key 类型（可选）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"示例：\">示例：</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>为了测试 SCAN 命令，我们首先创建一些测试数据，通过如下脚本初始化 100 条数据</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh import_unified_data.sh string 100</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol>\n<li class=\"lvl-5\">获取所有 key：</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 游标初始值为0</span></span><br><span class=\"line\">127.0.0.1:6379&gt; scan 0</span><br><span class=\"line\">1) <span class=\"string\">&quot;88&quot;</span>  <span class=\"comment\"># 游标</span></span><br><span class=\"line\">2)  1) <span class=\"string\">&quot;test_data:string:16&quot;</span></span><br><span class=\"line\">    2) <span class=\"string\">&quot;test_data:string:85&quot;</span></span><br><span class=\"line\">    3) <span class=\"string\">&quot;test_data:string:21&quot;</span></span><br><span class=\"line\">    4) <span class=\"string\">&quot;test_data:string:83&quot;</span></span><br><span class=\"line\">    5) <span class=\"string\">&quot;test_data:string:97&quot;</span></span><br><span class=\"line\">    6) <span class=\"string\">&quot;test_data:string:77&quot;</span></span><br><span class=\"line\">    7) <span class=\"string\">&quot;test_data:string:29&quot;</span></span><br><span class=\"line\">    8) <span class=\"string\">&quot;test_data:string:89&quot;</span></span><br><span class=\"line\">    9) <span class=\"string\">&quot;test_data:string:91&quot;</span></span><br><span class=\"line\">   10) <span class=\"string\">&quot;test_data:string:28&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 说明</span></span><br><span class=\"line\"><span class=\"comment\"># 实际上只会返回10条key(默认count为10)，并不会向 keys * 那样返回所有key</span></span><br><span class=\"line\"><span class=\"comment\">## 扫描结果中：</span></span><br><span class=\"line\"><span class=\"comment\"># 第一个元素是游标，不为0时，表示还有更多的 key 可以继续扫描，只有0表示扫描结束</span></span><br><span class=\"line\"><span class=\"comment\"># 第二个元素是匹配的 key列表</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 接着上面给出的游标，继续扫描：</span></span><br><span class=\"line\">127.0.0.1:6379&gt; scan 88</span><br><span class=\"line\">1) <span class=\"string\">&quot;92&quot;</span>  <span class=\"comment\"># 不为0就表示还有更多的 key 可以继续扫描</span></span><br><span class=\"line\">2)  1) <span class=\"string\">&quot;test_data:string:63&quot;</span></span><br><span class=\"line\">    2) <span class=\"string\">&quot;test_data:string:2&quot;</span></span><br><span class=\"line\">    3) <span class=\"string\">&quot;test_data:string:4&quot;</span></span><br><span class=\"line\">    4) <span class=\"string\">&quot;test_data:string:20&quot;</span></span><br><span class=\"line\">    5) <span class=\"string\">&quot;test_data:string:57&quot;</span></span><br><span class=\"line\">    6) <span class=\"string\">&quot;test_data:string:78&quot;</span></span><br><span class=\"line\">    7) <span class=\"string\">&quot;test_data:string:71&quot;</span></span><br><span class=\"line\">    8) <span class=\"string\">&quot;test_data:string:35&quot;</span></span><br><span class=\"line\">    9) <span class=\"string\">&quot;test_data:string:86&quot;</span></span><br><span class=\"line\">   10) <span class=\"string\">&quot;test_data:string:6&quot;</span></span><br><span class=\"line\">   11) <span class=\"string\">&quot;test_data:string:47&quot;</span></span><br><span class=\"line\">……………………………………</span><br><span class=\"line\">127.0.0.1:6379&gt; scan 87</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span> <span class=\"comment\"># 扫描结束 游标为0</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;test_data:68&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;test_data:79&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;test_data:41&quot;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"2\">\n<li class=\"lvl-5\">控制每次获取的 key 数量</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; scan 0 count 20</span><br><span class=\"line\">1) <span class=\"string\">&quot;92&quot;</span></span><br><span class=\"line\">2)  1) <span class=\"string\">&quot;test_data:string:16&quot;</span></span><br><span class=\"line\">    2) <span class=\"string\">&quot;test_data:string:85&quot;</span></span><br><span class=\"line\">    3) <span class=\"string\">&quot;test_data:string:21&quot;</span></span><br><span class=\"line\">    4) <span class=\"string\">&quot;test_data:string:83&quot;</span></span><br><span class=\"line\">    5) <span class=\"string\">&quot;test_data:string:97&quot;</span></span><br><span class=\"line\">    6) <span class=\"string\">&quot;test_data:string:77&quot;</span></span><br><span class=\"line\">    7) <span class=\"string\">&quot;test_data:string:29&quot;</span></span><br><span class=\"line\">    8) <span class=\"string\">&quot;test_data:string:89&quot;</span></span><br><span class=\"line\">    9) <span class=\"string\">&quot;test_data:string:91&quot;</span></span><br><span class=\"line\">   10) <span class=\"string\">&quot;test_data:string:28&quot;</span></span><br><span class=\"line\">   11) <span class=\"string\">&quot;test_data:string:63&quot;</span></span><br><span class=\"line\">   12) <span class=\"string\">&quot;test_data:string:2&quot;</span></span><br><span class=\"line\">   13) <span class=\"string\">&quot;test_data:string:4&quot;</span></span><br><span class=\"line\">   14) <span class=\"string\">&quot;test_data:string:20&quot;</span></span><br><span class=\"line\">   15) <span class=\"string\">&quot;test_data:string:57&quot;</span></span><br><span class=\"line\">   16) <span class=\"string\">&quot;test_data:string:78&quot;</span></span><br><span class=\"line\">   17) <span class=\"string\">&quot;test_data:string:71&quot;</span></span><br><span class=\"line\">   18) <span class=\"string\">&quot;test_data:string:35&quot;</span></span><br><span class=\"line\">   19) <span class=\"string\">&quot;test_data:string:86&quot;</span></span><br><span class=\"line\">   20) <span class=\"string\">&quot;test_data:string:6&quot;</span></span><br><span class=\"line\">   21) <span class=\"string\">&quot;test_data:string:47&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 注意：COUNT 是“尽力而为”，并不保证一定返回 20 条。</span></span><br><span class=\"line\"><span class=\"comment\"># 本示例就返回了21条，比 count 还多了 1 条</span></span><br><span class=\"line\"><span class=\"comment\"># 甚至有可能一条都不会返回，但是游标却并不为0的情况，此时就需要继续扫描，直到游标为0才算扫描结束。</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"3\">\n<li class=\"lvl-5\">扫描以 test_data:string 开头的 key</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; scan 0 match test_data:string*</span><br><span class=\"line\">1) <span class=\"string\">&quot;88&quot;</span></span><br><span class=\"line\">2)  1) <span class=\"string\">&quot;test_data:string:16&quot;</span></span><br><span class=\"line\">    2) <span class=\"string\">&quot;test_data:string:85&quot;</span></span><br><span class=\"line\">    3) <span class=\"string\">&quot;test_data:string:21&quot;</span></span><br><span class=\"line\">    4) <span class=\"string\">&quot;test_data:string:83&quot;</span></span><br><span class=\"line\">    5) <span class=\"string\">&quot;test_data:string:97&quot;</span></span><br><span class=\"line\">    6) <span class=\"string\">&quot;test_data:string:77&quot;</span></span><br><span class=\"line\">    7) <span class=\"string\">&quot;test_data:string:29&quot;</span></span><br><span class=\"line\">    8) <span class=\"string\">&quot;test_data:string:89&quot;</span></span><br><span class=\"line\">    9) <span class=\"string\">&quot;test_data:string:91&quot;</span></span><br><span class=\"line\">   10) <span class=\"string\">&quot;test_data:string:28&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"4\">\n<li class=\"lvl-5\">扫描以 test_data:string 开头的 key，并返回 30 条</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; scan 0 match test_data:string* count 30</span><br><span class=\"line\">1) <span class=\"string\">&quot;10&quot;</span></span><br><span class=\"line\">2)  1) <span class=\"string\">&quot;test_data:string:16&quot;</span></span><br><span class=\"line\">    2) <span class=\"string\">&quot;test_data:string:85&quot;</span></span><br><span class=\"line\">    3) <span class=\"string\">&quot;test_data:string:21&quot;</span></span><br><span class=\"line\">    4) <span class=\"string\">&quot;test_data:string:83&quot;</span></span><br><span class=\"line\">    5) <span class=\"string\">&quot;test_data:string:97&quot;</span></span><br><span class=\"line\">    6) <span class=\"string\">&quot;test_data:string:77&quot;</span></span><br><span class=\"line\">    7) <span class=\"string\">&quot;test_data:string:29&quot;</span></span><br><span class=\"line\">    8) <span class=\"string\">&quot;test_data:string:89&quot;</span></span><br><span class=\"line\">    9) <span class=\"string\">&quot;test_data:string:91&quot;</span></span><br><span class=\"line\">   10) <span class=\"string\">&quot;test_data:string:28&quot;</span></span><br><span class=\"line\">   11) <span class=\"string\">&quot;test_data:string:63&quot;</span></span><br><span class=\"line\">   12) <span class=\"string\">&quot;test_data:string:2&quot;</span></span><br><span class=\"line\">   13) <span class=\"string\">&quot;test_data:string:4&quot;</span></span><br><span class=\"line\">   14) <span class=\"string\">&quot;test_data:string:20&quot;</span></span><br><span class=\"line\">   15) <span class=\"string\">&quot;test_data:string:57&quot;</span></span><br><span class=\"line\">   16) <span class=\"string\">&quot;test_data:string:78&quot;</span></span><br><span class=\"line\">   17) <span class=\"string\">&quot;test_data:string:71&quot;</span></span><br><span class=\"line\">   18) <span class=\"string\">&quot;test_data:string:35&quot;</span></span><br><span class=\"line\">   19) <span class=\"string\">&quot;test_data:string:86&quot;</span></span><br><span class=\"line\">   20) <span class=\"string\">&quot;test_data:string:6&quot;</span></span><br><span class=\"line\">   21) <span class=\"string\">&quot;test_data:string:47&quot;</span></span><br><span class=\"line\">   22) <span class=\"string\">&quot;test_data:string:48&quot;</span></span><br><span class=\"line\">   23) <span class=\"string\">&quot;test_data:string:74&quot;</span></span><br><span class=\"line\">   24) <span class=\"string\">&quot;test_data:string:67&quot;</span></span><br><span class=\"line\">   25) <span class=\"string\">&quot;test_data:string:26&quot;</span></span><br><span class=\"line\">   26) <span class=\"string\">&quot;test_data:string:60&quot;</span></span><br><span class=\"line\">   27) <span class=\"string\">&quot;test_data:string:36&quot;</span></span><br><span class=\"line\">   28) <span class=\"string\">&quot;test_data:string:49&quot;</span></span><br><span class=\"line\">   29) <span class=\"string\">&quot;test_data:string:3&quot;</span></span><br><span class=\"line\">   30) <span class=\"string\">&quot;test_data:string:44&quot;</span></span><br><span class=\"line\">   31) <span class=\"string\">&quot;test_data:string:68&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 这里我们虽然指定了 count 30，但是实际返回的 key 数量却有 31 个</span></span><br><span class=\"line\"><span class=\"comment\"># 也有可能比 count 少，甚至为 0 个</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"5\">\n<li class=\"lvl-5\">扫描以 h_key 开头的 key，并返回 30 条</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 先插入一条记录</span></span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> h_key:1 1</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; scan 0 match h_key* count 30</span><br><span class=\"line\">1) <span class=\"string\">&quot;124&quot;</span></span><br><span class=\"line\">2) (empty array)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 这里我们虽然指定了 count 30，但是实际返回的 key 数量为 0 个</span></span><br><span class=\"line\"><span class=\"comment\"># 虽然我们在redis中设置了h_key:1，但是h_key:1 并没有被返回</span></span><br><span class=\"line\"><span class=\"comment\"># 并且此时返回的游标也不为0，说明我们还需要继续扫描</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 完整的扫描过程如下：</span></span><br><span class=\"line\">127.0.0.1:6379&gt; scan 0 match h_key* count 30</span><br><span class=\"line\">1) <span class=\"string\">&quot;124&quot;</span></span><br><span class=\"line\">2) (empty array)  <span class=\"comment\"># empty array 也不能说明一定没有</span></span><br><span class=\"line\">127.0.0.1:6379&gt; scan 124 match h_key* count 30</span><br><span class=\"line\">1) <span class=\"string\">&quot;9&quot;</span></span><br><span class=\"line\">2) (empty array)</span><br><span class=\"line\">127.0.0.1:6379&gt; scan 9 match h_key* count 30</span><br><span class=\"line\">1) <span class=\"string\">&quot;43&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;h_key:1&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; scan 43 match h_key* count 30</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span>      <span class=\"comment\"># 只有游标为0时才算扫描结束</span></span><br><span class=\"line\">2) (empty array)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 实际上redis官方推荐：当返回的游标不为0，但是key数量为0时，下一次扫描可以增加count的数量，比如扩大2倍，这样可以有效减少扫描次数</span></span><br><span class=\"line\">127.0.0.1:6379&gt; scan 0 match h_key* count 30</span><br><span class=\"line\">1) <span class=\"string\">&quot;124&quot;</span></span><br><span class=\"line\">2) (empty array)</span><br><span class=\"line\">127.0.0.1:6379&gt; scan 124 match h_key* count 60</span><br><span class=\"line\">1) <span class=\"string\">&quot;75&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;h_key:1&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; scan 75 match h_key* count 60</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2) (empty array)</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"6\">\n<li class=\"lvl-5\">扫描指定类型的key</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; scan 0 <span class=\"built_in\">type</span> string</span><br><span class=\"line\">1) <span class=\"string\">&quot;88&quot;</span></span><br><span class=\"line\">2)  1) <span class=\"string\">&quot;test_data:string:16&quot;</span></span><br><span class=\"line\">    2) <span class=\"string\">&quot;test_data:string:85&quot;</span></span><br><span class=\"line\">    3) <span class=\"string\">&quot;test_data:string:21&quot;</span></span><br><span class=\"line\">    4) <span class=\"string\">&quot;test_data:string:83&quot;</span></span><br><span class=\"line\">    5) <span class=\"string\">&quot;test_data:string:97&quot;</span></span><br><span class=\"line\">    6) <span class=\"string\">&quot;test_data:string:77&quot;</span></span><br><span class=\"line\">    7) <span class=\"string\">&quot;test_data:string:29&quot;</span></span><br><span class=\"line\">    8) <span class=\"string\">&quot;test_data:string:89&quot;</span></span><br><span class=\"line\">    9) <span class=\"string\">&quot;test_data:string:91&quot;</span></span><br><span class=\"line\">   10) <span class=\"string\">&quot;test_data:string:28&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 支持的类型有：</span></span><br><span class=\"line\"><span class=\"comment\"># string list set zset hash stream</span></span><br><span class=\"line\"><span class=\"comment\"># 注意一个小问题，某些 Redis 类型，如 GeoHashes、HyperLogLogs、Bitmaps 和 Bitfield，内部可能用其他 Redis 类型实现，如字符串或 zset，因此无法通过 type 区分 。</span></span><br><span class=\"line\"><span class=\"comment\"># 例如，ZSET 和 GEOHASH 都是 zset 类型。</span></span><br><span class=\"line\">127.0.0.1:6379&gt; GEOADD geokey 0 0 value</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">type</span> geokey</span><br><span class=\"line\">zset</span><br><span class=\"line\">127.0.0.1:6379&gt; ZADD zkey 1000 value</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; SCAN 0 TYPE zset count 1000</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;zkey&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;geokey&quot;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"HSCAN-的基本使用方法\">HSCAN 的基本使用方法</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>HSCAN 的基本语法如下：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HSCAN key cursor [MATCH pattern] [COUNT count] [NOVALUES]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>参数解释：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>key</td>\n<td>键名</td>\n</tr>\n<tr>\n<td>cursor</td>\n<td>游标，从 0 开始，返回值用于下一次扫描；当返回值为 0 时表示遍历结束</td>\n</tr>\n<tr>\n<td>MATCH pattern</td>\n<td>使用通配符匹配 key（可选）</td>\n</tr>\n<tr>\n<td>COUNT count</td>\n<td>建议 Redis 每次返回多少 key（可选），尽力而为，并不保证返回的 key 数量与指定的数量一致</td>\n</tr>\n<tr>\n<td>NOVALUES</td>\n<td>redis8+增加的属性，只返回key，不返回 value（可选）</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>为了测试 HSCAN，我们先插入一些数据：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh import_unified_data.sh <span class=\"built_in\">hash</span> 100</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用示例\">使用示例</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol>\n<li class=\"lvl-5\">获取所有 field 和 value：</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; scan 0 <span class=\"built_in\">type</span> <span class=\"built_in\">hash</span></span><br><span class=\"line\">1) <span class=\"string\">&quot;48&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;test_data:hash:42&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;test_data:hash:71&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;test_data:hash:54&quot;</span></span><br><span class=\"line\">   4) <span class=\"string\">&quot;test_data:hash:87&quot;</span></span><br><span class=\"line\">   5) <span class=\"string\">&quot;test_data:hash:96&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;test_data:hash:49&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 获取 test_data:hash:42 的所有 field 和 value</span></span><br><span class=\"line\">127.0.0.1:6379&gt; hscan test_data:<span class=\"built_in\">hash</span>:42 0</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;User_Name_42&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;age&quot;</span></span><br><span class=\"line\">   4) <span class=\"string\">&quot;62&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"2\">\n<li class=\"lvl-5\">模糊匹配 field：</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; hscan test_data:<span class=\"built_in\">hash</span>:42 0 match age*</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;age&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;62&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"3\">\n<li class=\"lvl-5\">模糊匹配 field，并返回 10 条数据：</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; hscan test_data:<span class=\"built_in\">hash</span>:42 0 match *e* count 10</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;User_Name_42&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;age&quot;</span></span><br><span class=\"line\">   4) <span class=\"string\">&quot;62&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"4\">\n<li class=\"lvl-5\">不显示value(需要redis8+)</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; hscan test_data:<span class=\"built_in\">hash</span>:42 0 novalues</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;age&quot;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"SSCAN-的基本使用方法\">SSCAN 的基本使用方法</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SSCAN 的基本语法如下：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SSCAN key cursor [MATCH pattern] [COUNT count]</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用示例-2\">使用示例</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol>\n<li class=\"lvl-5\">获取指定key的所有元素：</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; scan 0 <span class=\"built_in\">type</span> <span class=\"built_in\">set</span></span><br><span class=\"line\">1) <span class=\"string\">&quot;112&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;test_data:set:43&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;test_data:set:33&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;test_data:set:98&quot;</span></span><br><span class=\"line\">   4) <span class=\"string\">&quot;test_data:set:61&quot;</span></span><br><span class=\"line\">   5) <span class=\"string\">&quot;test_data:set:2&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;test_data:set:70&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; sscan test_data:<span class=\"built_in\">set</span>:43 0</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;set_member_43_1&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;set_member_43_2&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;set_member_43_3&quot;</span></span><br><span class=\"line\">   4) <span class=\"string\">&quot;set_member_43_4&quot;</span></span><br><span class=\"line\">   5) <span class=\"string\">&quot;set_member_43_5&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"2\">\n<li class=\"lvl-5\">模糊匹配元素：</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; sscan test_data:<span class=\"built_in\">set</span>:43 0 match *_3*</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;set_member_43_3&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"3\">\n<li class=\"lvl-5\">返回 1 个元素: 实际上控制不住，大概率会返回所有元素</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; sscan test_data:<span class=\"built_in\">set</span>:43 0 count 1</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;set_member_43_1&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;set_member_43_2&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;set_member_43_3&quot;</span></span><br><span class=\"line\">   4) <span class=\"string\">&quot;set_member_43_4&quot;</span></span><br><span class=\"line\">   5) <span class=\"string\">&quot;set_member_43_5&quot;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"ZSCAN-的基本使用方法\">ZSCAN 的基本使用方法</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ZSCAN 的基本语法如下：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZSCAN key cursor [MATCH pattern] [COUNT count]</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用示例-3\">使用示例</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol>\n<li class=\"lvl-5\">获取指定key的所有元素：</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; scan 0 <span class=\"built_in\">type</span> zset</span><br><span class=\"line\">1) <span class=\"string\">&quot;112&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;test_data:zset:89&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;test_data:zset:81&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;test_data:zset:73&quot;</span></span><br><span class=\"line\">   4) <span class=\"string\">&quot;test_data:zset:79&quot;</span></span><br><span class=\"line\">   5) <span class=\"string\">&quot;test_data:zset:15&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:6379&gt; zscan test_data:zset:89 0</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2)  1) <span class=\"string\">&quot;zset_member_89_1&quot;</span></span><br><span class=\"line\">    2) <span class=\"string\">&quot;891&quot;</span></span><br><span class=\"line\">    3) <span class=\"string\">&quot;zset_member_89_2&quot;</span></span><br><span class=\"line\">    4) <span class=\"string\">&quot;892&quot;</span></span><br><span class=\"line\">    5) <span class=\"string\">&quot;zset_member_89_3&quot;</span></span><br><span class=\"line\">    6) <span class=\"string\">&quot;893&quot;</span></span><br><span class=\"line\">    7) <span class=\"string\">&quot;zset_member_89_4&quot;</span></span><br><span class=\"line\">    8) <span class=\"string\">&quot;894&quot;</span></span><br><span class=\"line\">    9) <span class=\"string\">&quot;zset_member_89_5&quot;</span></span><br><span class=\"line\">   10) <span class=\"string\">&quot;895&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"2\">\n<li class=\"lvl-5\">模糊匹配元素：</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; zscan test_data:zset:89 0 match *_3*</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;zset_member_89_3&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;893&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"3\">\n<li class=\"lvl-5\">获取指定key的所有元素，并返回 1 个元素，同样控制不住</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt;  zscan test_data:zset:89 0 count 1</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2)  1) <span class=\"string\">&quot;zset_member_89_1&quot;</span></span><br><span class=\"line\">    2) <span class=\"string\">&quot;891&quot;</span></span><br><span class=\"line\">    3) <span class=\"string\">&quot;zset_member_89_2&quot;</span></span><br><span class=\"line\">    4) <span class=\"string\">&quot;892&quot;</span></span><br><span class=\"line\">    5) <span class=\"string\">&quot;zset_member_89_3&quot;</span></span><br><span class=\"line\">    6) <span class=\"string\">&quot;893&quot;</span></span><br><span class=\"line\">    7) <span class=\"string\">&quot;zset_member_89_4&quot;</span></span><br><span class=\"line\">    8) <span class=\"string\">&quot;894&quot;</span></span><br><span class=\"line\">    9) <span class=\"string\">&quot;zset_member_89_5&quot;</span></span><br><span class=\"line\">   10) <span class=\"string\">&quot;895&quot;</span></span><br></pre></td></tr></table></figure>\n","content_text":"摘要 在使用 Redis 时，经常需要遍历数据库中的键，例如查找特定前缀的 key、统计 key 数量、批量删除 key 等。 Redis 提供了两种思路：使用 KEYS pattern 或使用游标式遍历命令 SCAN。 KEYS pattern 是一种非常不安全的方式，因为它会触发 Redis 服务器的阻塞，从而导致性能下降。设置一些注重安全的环境会禁用KEYS pattern等危险命令。 所以Redis官方强烈推荐 SCAN 方式，其是最安全、最可控的遍历方法。 本文基于redis-7.4.7 Redis官网：https://redis.io/ SCAN 的核心作用 SCAN 的主要功能是基于游标的、非阻塞的、渐进式遍历 Redis 数据库中的 key。 它允许应用在不阻塞服务器的情况下，每次拉取少量 key，从而安全地在生产环境执行 key 遍历操作。 SCAN 的设计目标包括： 避免阻塞 Redis 主线程 分批、渐进扫描大规模 key 集合 灵活配合模式匹配（MATCH） 控制每次返回 key 的数量（COUNT） 在不影响线上业务的情况下处理数百万甚至数千万级别键值扫描 SCAN 命令是完整游标遍历族的一部分，还包括： HSCAN：遍历哈希表 field/value SSCAN：遍历 set 元素 ZSCAN：遍历有序集合 为了完成后面的示例演示，这里准备一个测试数据批量生产脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#!/bin/bash# 脚本名称：import_unified_data.sh# 运行方法：sh $0 &lt;type&gt; [count]# &lt;type&gt;: string, hash, list, set, 或 zset# [count]: 导入的数据量 (可选，默认为 100)# ----------------------------------------# --- 1. 参数校验与配置 ---SUPPORTED_TYPES=&quot;string hash list set zset&quot;# 定义每个集合/列表/有序集合要添加的成员数量MEMBERS_PER_KEY=5# 检查是否提供了类型参数if [ $# -lt 1 ]; then echo &quot;❌ 错误：请指定导入类型。&quot; echo &quot;支持的类型: $&#123;SUPPORTED_TYPES&#125;&quot; echo &quot;用法: sh $0 &lt;type&gt; [count]&quot; exit 1fi# 获取类型参数 (第一个参数)DATA_TYPE=$(echo &quot;$1&quot; | tr &#x27;[:upper:]&#x27; &#x27;[:lower:]&#x27;)# 获取数据量参数 (第二个参数)，不存在则默认为 1000if [ $# -ge 2 ]; then DATA_COUNT=$2else DATA_COUNT=100fi# 检查类型是否有效if [[ ! &quot; $&#123;SUPPORTED_TYPES&#125; &quot; =~ &quot; $&#123;DATA_TYPE&#125; &quot; ]]; then echo &quot;❌ 错误：不支持的类型 &#x27;$DATA_TYPE&#x27;。&quot; echo &quot;支持的类型: $&#123;SUPPORTED_TYPES&#125;&quot; exit 1fi# Redis 连接配置REDIS_HOST=&quot;127.0.0.1&quot;REDIS_PORT=&quot;6379&quot;REDIS_PASSWORD=&quot;password&quot; # 替换为你的实际密码或留空KEY_PREFIX=&quot;test_data&quot;# ----------------------------------------# --- 2. 命令生成主逻辑 ---# ----------------------------------------echo &quot;⏳ 正在生成 $&#123;DATA_COUNT&#125; 条 Redis [$&#123;DATA_TYPE&#125;] 命令...&quot;# 构建 RESP 命令流i=1while [ $i -le $DATA_COUNT ]do case &quot;$DATA_TYPE&quot; in # --- String 类型导入 (SET key value) --- string) KEY=&quot;$&#123;KEY_PREFIX&#125;:string:$&#123;i&#125;&quot; VALUE=&quot;value_of_$&#123;i&#125;_$(date +%s%N)&quot; # SET 命令 RESP 协议: *3 (SET, key, value) printf &quot;*3\\r\\n\\$3\\r\\nSET\\r\\n\\$$&#123;#KEY&#125;\\r\\n$&#123;KEY&#125;\\r\\n\\$$&#123;#VALUE&#125;\\r\\n$&#123;VALUE&#125;\\r\\n&quot; ;; # --- Hash 类型导入 (HSET key field1 value1 field2 value2) --- hash) HASH_KEY=&quot;$&#123;KEY_PREFIX&#125;:hash:$&#123;i&#125;&quot; FIELD1=&quot;name&quot; VALUE1=&quot;User_Name_$&#123;i&#125;&quot; FIELD2=&quot;age&quot; VALUE2=$(( (i % 50) + 20 )) # HSET 命令 RESP 协议: *6 (HSET, key, f1, v1, f2, v2) printf &quot;*6\\r\\n\\$4\\r\\nHSET\\r\\n\\$$&#123;#HASH_KEY&#125;\\r\\n$&#123;HASH_KEY&#125;\\r\\n&quot; printf &quot;\\$$&#123;#FIELD1&#125;\\r\\n$&#123;FIELD1&#125;\\r\\n\\$$&#123;#VALUE1&#125;\\r\\n$&#123;VALUE1&#125;\\r\\n&quot; printf &quot;\\$$&#123;#FIELD2&#125;\\r\\n$&#123;FIELD2&#125;\\r\\n\\$$&#123;#VALUE2&#125;\\r\\n$&#123;VALUE2&#125;\\r\\n&quot; ;; # --- List 类型导入 (LPUSH key value) --- list) LIST_KEY=&quot;$&#123;KEY_PREFIX&#125;:list:$&#123;i&#125;&quot; # 循环添加 5 个成员 for j in $(seq 1 $MEMBERS_PER_KEY); do VALUE=&quot;list_element_$&#123;i&#125;_$&#123;j&#125;&quot; # LPUSH 命令 RESP 协议: *3 (LPUSH, key, value) printf &quot;*3\\r\\n\\$5\\r\\nLPUSH\\r\\n\\$$&#123;#LIST_KEY&#125;\\r\\n$&#123;LIST_KEY&#125;\\r\\n\\$$&#123;#VALUE&#125;\\r\\n$&#123;VALUE&#125;\\r\\n&quot; done ;; # --- Set 类型导入 (SADD key member) --- set) SET_KEY=&quot;$&#123;KEY_PREFIX&#125;:set:$&#123;i&#125;&quot; # 循环添加 5 个成员 for j in $(seq 1 $MEMBERS_PER_KEY); do MEMBER=&quot;set_member_$&#123;i&#125;_$&#123;j&#125;&quot; # SADD 命令 RESP 协议: *3 (SADD, key, member) printf &quot;*3\\r\\n\\$4\\r\\nSADD\\r\\n\\$$&#123;#SET_KEY&#125;\\r\\n$&#123;SET_KEY&#125;\\r\\n\\$$&#123;#MEMBER&#125;\\r\\n$&#123;MEMBER&#125;\\r\\n&quot; done ;; # --- Sorted Set 类型导入 (ZADD key score member) --- zset) ZSET_KEY=&quot;$&#123;KEY_PREFIX&#125;:zset:$&#123;i&#125;&quot; # 循环添加 5 个成员 for j in $(seq 1 $MEMBERS_PER_KEY); do SCORE=&quot;$&#123;i&#125;$&#123;j&#125;&quot; # 生成唯一分数：例如 key 1 的分数是 11, 12... MEMBER=&quot;zset_member_$&#123;i&#125;_$&#123;j&#125;&quot; # ZADD 命令 RESP 协议: *4 (ZADD, key, score, member) printf &quot;*4\\r\\n\\$4\\r\\nZADD\\r\\n\\$$&#123;#ZSET_KEY&#125;\\r\\n$&#123;ZSET_KEY&#125;\\r\\n\\$$&#123;#SCORE&#125;\\r\\n$&#123;SCORE&#125;\\r\\n\\$$&#123;#MEMBER&#125;\\r\\n$&#123;MEMBER&#125;\\r\\n&quot; done ;; esac i=$((i+1))done | ( # ---------------------------------------- # --- 3. 管道导入到 Redis --- # ---------------------------------------- echo &quot;📤 正在通过 redis-cli --pipe 导入数据...&quot; # 构建 redis-cli 命令 REDIS_CLI_CMD=&quot;redis-cli -h $&#123;REDIS_HOST&#125; -p $&#123;REDIS_PORT&#125;&quot; # 如果设置了密码，则添加 -a 参数 if [ -n &quot;$&#123;REDIS_PASSWORD&#125;&quot; ]; then REDIS_CLI_CMD=&quot;$&#123;REDIS_CLI_CMD&#125; -a $&#123;REDIS_PASSWORD&#125;&quot; fi # 执行导入 $&#123;REDIS_CLI_CMD&#125; --pipe # 检查命令是否执行成功 if [ $? -eq 0 ]; then echo &quot;✅ 数据导入成功！共导入 $&#123;DATA_COUNT&#125; 条 [$&#123;DATA_TYPE&#125;] 记录。&quot; else echo &quot;❌ 数据导入失败！请检查 Redis 服务是否运行以及配置是否正确。&quot; fi) SCAN 的基本用法 SCAN 的基本语法如下： 1SCAN cursor [MATCH pattern] [COUNT count] [TYPE type] 参数解释： 参数 说明 cursor 游标，从 0 开始，返回值用于下一次扫描；当返回值为 0 时表示遍历结束 MATCH pattern 使用通配符匹配 key（可选） COUNT count 建议 Redis 每次返回多少 key（可选），尽力而为，并不保证返回的 key 数量与指定的数量一致 TYPE type 匹配的 key 类型（可选） 示例： 为了测试 SCAN 命令，我们首先创建一些测试数据，通过如下脚本初始化 100 条数据 1sh import_unified_data.sh string 100 获取所有 key： 1234567891011121314151617181920212223242526272829303132333435363738394041# 游标初始值为0127.0.0.1:6379&gt; scan 01) &quot;88&quot; # 游标2) 1) &quot;test_data:string:16&quot; 2) &quot;test_data:string:85&quot; 3) &quot;test_data:string:21&quot; 4) &quot;test_data:string:83&quot; 5) &quot;test_data:string:97&quot; 6) &quot;test_data:string:77&quot; 7) &quot;test_data:string:29&quot; 8) &quot;test_data:string:89&quot; 9) &quot;test_data:string:91&quot; 10) &quot;test_data:string:28&quot;## 说明# 实际上只会返回10条key(默认count为10)，并不会向 keys * 那样返回所有key## 扫描结果中：# 第一个元素是游标，不为0时，表示还有更多的 key 可以继续扫描，只有0表示扫描结束# 第二个元素是匹配的 key列表# 接着上面给出的游标，继续扫描：127.0.0.1:6379&gt; scan 881) &quot;92&quot; # 不为0就表示还有更多的 key 可以继续扫描2) 1) &quot;test_data:string:63&quot; 2) &quot;test_data:string:2&quot; 3) &quot;test_data:string:4&quot; 4) &quot;test_data:string:20&quot; 5) &quot;test_data:string:57&quot; 6) &quot;test_data:string:78&quot; 7) &quot;test_data:string:71&quot; 8) &quot;test_data:string:35&quot; 9) &quot;test_data:string:86&quot; 10) &quot;test_data:string:6&quot; 11) &quot;test_data:string:47&quot;……………………………………127.0.0.1:6379&gt; scan 871) &quot;0&quot; # 扫描结束 游标为02) 1) &quot;test_data:68&quot; 2) &quot;test_data:79&quot; 3) &quot;test_data:41&quot; 控制每次获取的 key 数量 1234567891011121314151617181920212223242526127.0.0.1:6379&gt; scan 0 count 201) &quot;92&quot;2) 1) &quot;test_data:string:16&quot; 2) &quot;test_data:string:85&quot; 3) &quot;test_data:string:21&quot; 4) &quot;test_data:string:83&quot; 5) &quot;test_data:string:97&quot; 6) &quot;test_data:string:77&quot; 7) &quot;test_data:string:29&quot; 8) &quot;test_data:string:89&quot; 9) &quot;test_data:string:91&quot; 10) &quot;test_data:string:28&quot; 11) &quot;test_data:string:63&quot; 12) &quot;test_data:string:2&quot; 13) &quot;test_data:string:4&quot; 14) &quot;test_data:string:20&quot; 15) &quot;test_data:string:57&quot; 16) &quot;test_data:string:78&quot; 17) &quot;test_data:string:71&quot; 18) &quot;test_data:string:35&quot; 19) &quot;test_data:string:86&quot; 20) &quot;test_data:string:6&quot; 21) &quot;test_data:string:47&quot;# 注意：COUNT 是“尽力而为”，并不保证一定返回 20 条。# 本示例就返回了21条，比 count 还多了 1 条# 甚至有可能一条都不会返回，但是游标却并不为0的情况，此时就需要继续扫描，直到游标为0才算扫描结束。 扫描以 test_data:string 开头的 key 123456789101112127.0.0.1:6379&gt; scan 0 match test_data:string*1) &quot;88&quot;2) 1) &quot;test_data:string:16&quot; 2) &quot;test_data:string:85&quot; 3) &quot;test_data:string:21&quot; 4) &quot;test_data:string:83&quot; 5) &quot;test_data:string:97&quot; 6) &quot;test_data:string:77&quot; 7) &quot;test_data:string:29&quot; 8) &quot;test_data:string:89&quot; 9) &quot;test_data:string:91&quot; 10) &quot;test_data:string:28&quot; 扫描以 test_data:string 开头的 key，并返回 30 条 123456789101112131415161718192021222324252627282930313233343536127.0.0.1:6379&gt; scan 0 match test_data:string* count 301) &quot;10&quot;2) 1) &quot;test_data:string:16&quot; 2) &quot;test_data:string:85&quot; 3) &quot;test_data:string:21&quot; 4) &quot;test_data:string:83&quot; 5) &quot;test_data:string:97&quot; 6) &quot;test_data:string:77&quot; 7) &quot;test_data:string:29&quot; 8) &quot;test_data:string:89&quot; 9) &quot;test_data:string:91&quot; 10) &quot;test_data:string:28&quot; 11) &quot;test_data:string:63&quot; 12) &quot;test_data:string:2&quot; 13) &quot;test_data:string:4&quot; 14) &quot;test_data:string:20&quot; 15) &quot;test_data:string:57&quot; 16) &quot;test_data:string:78&quot; 17) &quot;test_data:string:71&quot; 18) &quot;test_data:string:35&quot; 19) &quot;test_data:string:86&quot; 20) &quot;test_data:string:6&quot; 21) &quot;test_data:string:47&quot; 22) &quot;test_data:string:48&quot; 23) &quot;test_data:string:74&quot; 24) &quot;test_data:string:67&quot; 25) &quot;test_data:string:26&quot; 26) &quot;test_data:string:60&quot; 27) &quot;test_data:string:36&quot; 28) &quot;test_data:string:49&quot; 29) &quot;test_data:string:3&quot; 30) &quot;test_data:string:44&quot; 31) &quot;test_data:string:68&quot;# 这里我们虽然指定了 count 30，但是实际返回的 key 数量却有 31 个# 也有可能比 count 少，甚至为 0 个 扫描以 h_key 开头的 key，并返回 30 条 1234567891011121314151617181920212223242526272829303132333435# 先插入一条记录127.0.0.1:6379&gt; set h_key:1 1OK127.0.0.1:6379&gt; scan 0 match h_key* count 301) &quot;124&quot;2) (empty array)# 这里我们虽然指定了 count 30，但是实际返回的 key 数量为 0 个# 虽然我们在redis中设置了h_key:1，但是h_key:1 并没有被返回# 并且此时返回的游标也不为0，说明我们还需要继续扫描# 完整的扫描过程如下：127.0.0.1:6379&gt; scan 0 match h_key* count 301) &quot;124&quot;2) (empty array) # empty array 也不能说明一定没有127.0.0.1:6379&gt; scan 124 match h_key* count 301) &quot;9&quot;2) (empty array)127.0.0.1:6379&gt; scan 9 match h_key* count 301) &quot;43&quot;2) 1) &quot;h_key:1&quot;127.0.0.1:6379&gt; scan 43 match h_key* count 301) &quot;0&quot; # 只有游标为0时才算扫描结束2) (empty array)# 实际上redis官方推荐：当返回的游标不为0，但是key数量为0时，下一次扫描可以增加count的数量，比如扩大2倍，这样可以有效减少扫描次数127.0.0.1:6379&gt; scan 0 match h_key* count 301) &quot;124&quot;2) (empty array)127.0.0.1:6379&gt; scan 124 match h_key* count 601) &quot;75&quot;2) 1) &quot;h_key:1&quot;127.0.0.1:6379&gt; scan 75 match h_key* count 601) &quot;0&quot;2) (empty array) 扫描指定类型的key 123456789101112131415161718192021222324252627127.0.0.1:6379&gt; scan 0 type string1) &quot;88&quot;2) 1) &quot;test_data:string:16&quot; 2) &quot;test_data:string:85&quot; 3) &quot;test_data:string:21&quot; 4) &quot;test_data:string:83&quot; 5) &quot;test_data:string:97&quot; 6) &quot;test_data:string:77&quot; 7) &quot;test_data:string:29&quot; 8) &quot;test_data:string:89&quot; 9) &quot;test_data:string:91&quot; 10) &quot;test_data:string:28&quot;# 支持的类型有：# string list set zset hash stream# 注意一个小问题，某些 Redis 类型，如 GeoHashes、HyperLogLogs、Bitmaps 和 Bitfield，内部可能用其他 Redis 类型实现，如字符串或 zset，因此无法通过 type 区分 。# 例如，ZSET 和 GEOHASH 都是 zset 类型。127.0.0.1:6379&gt; GEOADD geokey 0 0 value(integer) 1127.0.0.1:6379&gt; type geokeyzset127.0.0.1:6379&gt; ZADD zkey 1000 value(integer) 1127.0.0.1:6379&gt; SCAN 0 TYPE zset count 10001) &quot;0&quot;2) 1) &quot;zkey&quot; 2) &quot;geokey&quot; HSCAN 的基本使用方法 HSCAN 的基本语法如下： 1HSCAN key cursor [MATCH pattern] [COUNT count] [NOVALUES] 参数解释： 参数 说明 key 键名 cursor 游标，从 0 开始，返回值用于下一次扫描；当返回值为 0 时表示遍历结束 MATCH pattern 使用通配符匹配 key（可选） COUNT count 建议 Redis 每次返回多少 key（可选），尽力而为，并不保证返回的 key 数量与指定的数量一致 NOVALUES redis8+增加的属性，只返回key，不返回 value（可选） 为了测试 HSCAN，我们先插入一些数据： 1sh import_unified_data.sh hash 100 使用示例 获取所有 field 和 value： 123456789101112131415127.0.0.1:6379&gt; scan 0 type hash1) &quot;48&quot;2) 1) &quot;test_data:hash:42&quot; 2) &quot;test_data:hash:71&quot; 3) &quot;test_data:hash:54&quot; 4) &quot;test_data:hash:87&quot; 5) &quot;test_data:hash:96&quot; 6) &quot;test_data:hash:49&quot;# 获取 test_data:hash:42 的所有 field 和 value127.0.0.1:6379&gt; hscan test_data:hash:42 01) &quot;0&quot;2) 1) &quot;name&quot; 2) &quot;User_Name_42&quot; 3) &quot;age&quot; 4) &quot;62&quot; 模糊匹配 field： 1234127.0.0.1:6379&gt; hscan test_data:hash:42 0 match age*1) &quot;0&quot;2) 1) &quot;age&quot; 2) &quot;62&quot; 模糊匹配 field，并返回 10 条数据： 123456127.0.0.1:6379&gt; hscan test_data:hash:42 0 match *e* count 101) &quot;0&quot;2) 1) &quot;name&quot; 2) &quot;User_Name_42&quot; 3) &quot;age&quot; 4) &quot;62&quot; 不显示value(需要redis8+) 1234127.0.0.1:6379&gt; hscan test_data:hash:42 0 novalues1) &quot;0&quot;2) 1) &quot;name&quot; 2) &quot;age&quot; SSCAN 的基本使用方法 SSCAN 的基本语法如下： 1SSCAN key cursor [MATCH pattern] [COUNT count] 使用示例 获取指定key的所有元素： 123456789101112131415127.0.0.1:6379&gt; scan 0 type set1) &quot;112&quot;2) 1) &quot;test_data:set:43&quot; 2) &quot;test_data:set:33&quot; 3) &quot;test_data:set:98&quot; 4) &quot;test_data:set:61&quot; 5) &quot;test_data:set:2&quot; 6) &quot;test_data:set:70&quot;127.0.0.1:6379&gt; sscan test_data:set:43 01) &quot;0&quot;2) 1) &quot;set_member_43_1&quot; 2) &quot;set_member_43_2&quot; 3) &quot;set_member_43_3&quot; 4) &quot;set_member_43_4&quot; 5) &quot;set_member_43_5&quot; 模糊匹配元素： 123127.0.0.1:6379&gt; sscan test_data:set:43 0 match *_3*1) &quot;0&quot;2) 1) &quot;set_member_43_3&quot; 返回 1 个元素: 实际上控制不住，大概率会返回所有元素 1234567127.0.0.1:6379&gt; sscan test_data:set:43 0 count 11) &quot;0&quot;2) 1) &quot;set_member_43_1&quot; 2) &quot;set_member_43_2&quot; 3) &quot;set_member_43_3&quot; 4) &quot;set_member_43_4&quot; 5) &quot;set_member_43_5&quot; ZSCAN 的基本使用方法 ZSCAN 的基本语法如下： 1ZSCAN key cursor [MATCH pattern] [COUNT count] 使用示例 获取指定key的所有元素： 1234567891011121314151617181920127.0.0.1:6379&gt; scan 0 type zset1) &quot;112&quot;2) 1) &quot;test_data:zset:89&quot; 2) &quot;test_data:zset:81&quot; 3) &quot;test_data:zset:73&quot; 4) &quot;test_data:zset:79&quot; 5) &quot;test_data:zset:15&quot;127.0.0.1:6379&gt; zscan test_data:zset:89 01) &quot;0&quot;2) 1) &quot;zset_member_89_1&quot; 2) &quot;891&quot; 3) &quot;zset_member_89_2&quot; 4) &quot;892&quot; 5) &quot;zset_member_89_3&quot; 6) &quot;893&quot; 7) &quot;zset_member_89_4&quot; 8) &quot;894&quot; 9) &quot;zset_member_89_5&quot; 10) &quot;895&quot; 模糊匹配元素： 1234127.0.0.1:6379&gt; zscan test_data:zset:89 0 match *_3*1) &quot;0&quot;2) 1) &quot;zset_member_89_3&quot; 2) &quot;893&quot; 获取指定key的所有元素，并返回 1 个元素，同样控制不住 123456789101112127.0.0.1:6379&gt; zscan test_data:zset:89 0 count 11) &quot;0&quot;2) 1) &quot;zset_member_89_1&quot; 2) &quot;891&quot; 3) &quot;zset_member_89_2&quot; 4) &quot;892&quot; 5) &quot;zset_member_89_3&quot; 6) &quot;893&quot; 7) &quot;zset_member_89_4&quot; 8) &quot;894&quot; 9) &quot;zset_member_89_5&quot; 10) &quot;895&quot;","summary":"摘要 在使用 Redis 时，经常需要遍历数据库中的键，例如查找特定前缀的 key、统计 key 数量、批量删除 key 等。 Redis 提供了两种思路：使用 KEYS pattern 或使用游标式遍历命令 SCAN。 KEYS pattern 是一种非常不安全的方式，因为它会触发 Redis 服务器的阻塞，从而导致性能下降。设置一些注重安全的环境会禁用KEYS pattern等危险命令。 所以Redis官方强烈推荐 SCAN 方式，其是最安全、最可控的遍历方法。 本文基于redis-7.4.7 Redis官网：https://redis.io/","date_published":"2025-12-10T13:30:05.000Z","tags":["技术","redis","redis"]},{"id":"https://blog.hanqunfeng.com/2025/12/07/maven-mvnd/","url":"https://blog.hanqunfeng.com/2025/12/07/maven-mvnd/","title":"Maven 新一代构建工具 mvnd","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 Maven 新一代构建工具 mvnd</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/apache/maven-mvnd\">mvnd GitHub</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文安装的是 mvnd 1.0.3。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"mvnd-简介\">mvnd 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>mvnd 是 Maven 新一代构建工具，使用 Java 语言编写。</p>\n</li>\n<li class=\"lvl-2\">\n<p>mvnd 借鉴 Gradle 和 Takari 中的技术从而提供更快的Maven构建速度。</p>\n</li>\n</ul>\n<h3 id=\"架构概述\">架构概述</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>mvnd内嵌Maven（因此不需要单独安装Maven）。1.x版本内嵌maven3.x版本，2.x版本内嵌maven4.x版本。</p>\n</li>\n<li class=\"lvl-2\">\n<p>实际构建发生在一个长驻后台进程中，又名守护程序。</p>\n</li>\n<li class=\"lvl-2\">\n<p>一个守护程序实例可以服务来自mvnd客户端的多个连续请求。</p>\n</li>\n<li class=\"lvl-2\">\n<p>mvnd客户端是使用GraalVM构建的原生可执行文件。与启动传统的JVM相比，它启动速度更快，占用的内存更少。</p>\n</li>\n<li class=\"lvl-2\">\n<p>如果没有闲置守护程序来服务构建请求，则可以并行生成多个守护程序。</p>\n</li>\n<li class=\"lvl-2\">\n<p>这种架构带来了以下优点：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">不需要每次构建重新启动 JVM，大大节省时间。</li>\n<li class=\"lvl-6\">持有Maven插件类的classloaders被缓存在多个构建中。因此，插件jar只被读取和解析一次。Maven插件的SNAPSHOT版本没有缓存。</li>\n<li class=\"lvl-6\">JVM内Just-In-Time（JIT）编译器生成的原生代码也被保留。与传统的Maven相比，JIT编译花费的时间更少。在重复构建期间，JIT优化的代码立即可用。这不仅适用于来自Maven插件和Maven Core的代码，也适用于来自JDK本身的所有代码。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>默认情况下，mvnd 使用多个 CPU 内核并行构建模块，使用的核心数由以下公式给出: <code>availableProcessors - 1</code></p>\n</li>\n</ul>\n<h2 id=\"mvnd-安装\">mvnd 安装</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>mvnd 安装包下载地址：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\"><a href=\"https://github.com/apache/maven-mvnd/releases\">mvnd Github Release</a></li>\n<li class=\"lvl-6\"><a href=\"https://maven.apache.org/download.cgi\">maven 官网下载页</a></li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>本文以 macOS 为例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载 mvnd 对应的安装包</span></span><br><span class=\"line\">curl -L https://github.com/apache/maven-mvnd/releases/download/1.0.3/maven-mvnd-1.0.3-darwin-amd64.tar.gz | tar xz</span><br><span class=\"line\"><span class=\"built_in\">ln</span> -s mvnd-1.0.3-darwin-amd64 mvnd</span><br><span class=\"line\"><span class=\"comment\"># 添加 mvnd 到环境变量</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;MVND_HOME=$HOME/develop_soft/mvnd&#x27;</span> &gt;&gt; ~/.zshrc</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;export PATH=$MVND_HOME/bin:$PATH&#x27;</span> &gt;&gt; ~/.zshrc</span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.zshrc</span><br><span class=\"line\"><span class=\"comment\"># 检查 mvnd 是否安装成功</span></span><br><span class=\"line\">mvnd --version</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>mvnd 内嵌 maven，其本质上还是依赖于maven，所以需要创建maven的配置文件 <code>~/.m2/settings.xml</code> ，由于本机之前安装过 Maven，所以这一步就省略了。</p>\n</li>\n<li class=\"lvl-2\">\n<p>[推荐]将 mvnd 的配置文件拷贝到 <code>~/.m2</code> 目录下</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 与 maven了类似，`~/.m2/mvnd.properties` 优先级高于 `$MVND_HOME/conf/mvnd.properties`</span></span><br><span class=\"line\"><span class=\"built_in\">cp</span> <span class=\"variable\">$MVND_HOME</span>/conf/mvnd.properties <span class=\"variable\">$HOME</span>/.m2/mvnd.properties</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>mvnd 配置项说明，一般不需要修改，可能会修改的我用 <code>[*]</code> 做了标注</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>配置项</th>\n<th>默认值</th>\n<th>中文解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>mvnd.noBuffering</strong> <code>[*]</code></td>\n<td>false</td>\n<td>是否禁用输出缓冲，从而像普通 Maven 一样实时显示日志。命令行传递 <code>-B</code> 或 <code>--batch-mode</code> 也会启用此行为</td>\n</tr>\n<tr>\n<td><strong>mvnd.rollingWindowSize</strong></td>\n<td>0</td>\n<td>构建并行模块时，每个模块显示的日志行数</td>\n</tr>\n<tr>\n<td><strong>mvnd.logPurgePeriod</strong></td>\n<td>7d</td>\n<td>自动清理日志的周期（如：7天），日志保存路径： <code>$HOME/.m2/mvnd/registry/1.0.3/</code></td>\n</tr>\n<tr>\n<td><strong>mvnd.noDaemon</strong></td>\n<td>false</td>\n<td>禁止使用 daemon（守护进程）。一般用于调试，仅在非 native 模式下有效</td>\n</tr>\n<tr>\n<td><strong>mvnd.debug</strong></td>\n<td>false</td>\n<td>使用调试模式启动 daemon，JVM 参数为：<code>-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=8000</code></td>\n</tr>\n<tr>\n<td><strong>mvnd.idleTimeout</strong></td>\n<td>3 hours</td>\n<td>守护进程在空闲多久后自动关闭</td>\n</tr>\n<tr>\n<td><strong>mvnd.keepAlive</strong></td>\n<td>100 ms</td>\n<td>如果构建过程没有输出，daemon 向客户端发送保活消息的时间间隔</td>\n</tr>\n<tr>\n<td><strong>mvnd.maxLostKeepAlive</strong></td>\n<td>30</td>\n<td>允许丢失的最大保活消息数量，超过则客户端认为 daemon 已失败</td>\n</tr>\n<tr>\n<td><strong>mvnd.minThreads</strong></td>\n<td>1</td>\n<td>构建时要使用的最少线程数量。如果显式指定了 <code>-T</code>、<code>--threads</code> 或 <code>mvnd.threads</code>，该值将被忽略</td>\n</tr>\n<tr>\n<td><strong>mvnd.threads</strong> <code>[*]</code></td>\n<td>未设置</td>\n<td>传递给 daemon 的线程数，与 Maven 的 <code>-T / --threads</code> 语法一致</td>\n</tr>\n<tr>\n<td><strong>mvnd.builder</strong></td>\n<td>smart</td>\n<td>指定使用的 Maven 构建器名称（等同于 <code>-b</code> 或 <code>--builder</code>）</td>\n</tr>\n<tr>\n<td><strong>mvnd.minHeapSize</strong></td>\n<td>128M</td>\n<td>守护进程 JVM 的最小堆内存</td>\n</tr>\n<tr>\n<td><strong>mvnd.maxHeapSize</strong> <code>[*]</code></td>\n<td>2G</td>\n<td>守护进程 JVM 的最大堆内存</td>\n</tr>\n<tr>\n<td><strong>mvnd.threadStackSize</strong></td>\n<td>1M</td>\n<td>守护进程线程栈大小</td>\n</tr>\n<tr>\n<td><strong>mvnd.jvmArgs</strong></td>\n<td>未设置</td>\n<td>传递给 daemon 的额外 JVM 参数</td>\n</tr>\n<tr>\n<td><strong>mvnd.enableAssertions</strong></td>\n<td>false</td>\n<td>是否为 daemon 启用 JVM 断言（-ea）</td>\n</tr>\n<tr>\n<td><strong>mvnd.expirationCheckDelay</strong></td>\n<td>10 seconds</td>\n<td>守护进程检测自身是否需要过期的时间间隔</td>\n</tr>\n<tr>\n<td><strong>mvnd.duplicateDaemonGracePeriod</strong></td>\n<td>10 seconds</td>\n<td>多个 daemon 存在时，多余 daemon 的宽限退出时间</td>\n</tr>\n<tr>\n<td><strong>mvnd.home</strong></td>\n<td>自动设置</td>\n<td>mvnd 安装目录，客户端通常会根据 mvnd 可执行文件位置设置</td>\n</tr>\n<tr>\n<td><strong>java.home</strong></td>\n<td>使用环境变量</td>\n<td>启动 daemon 的 Java 目录（等同 JAVA_HOME）</td>\n</tr>\n<tr>\n<td><strong>maven.settings</strong> <code>[*]</code></td>\n<td>~/.m2/settings.xml</td>\n<td>maven 的 settings.xml 路径</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"mvnd-使用\">mvnd 使用</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>命令行使用方式与 mvn 一样，比如：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvnd clean install</span><br><span class=\"line\">mvnd clean package -Dmaven.test.skip=<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>mvnd 的 daemon 缓存了一切，所以运行 <code>mvnd clean install</code> 后，之后再次运行 <code>mvnd clean install</code> 时，mvnd 会直接从缓存中读取构建结果，从而节省了构建时间。</p>\n</li>\n<li class=\"lvl-2\">\n<p>mvnd 还有些特殊用法，比如：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看当前所有的守护进程列表，守护进程空闲超过 mvnd.idleTimeout=3 hours 会自动关闭</span></span><br><span class=\"line\">mvnd --status</span><br><span class=\"line\"><span class=\"comment\"># 手动停止所有运行的守护进程</span></span><br><span class=\"line\">mvnd --stop</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在IDEA中使用<code>mvnd</code>，在Maven设置中将<code>mvnd</code>的安装目录添加到 <code>Maven Home Path</code> 中<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/7oSR8O.png\" alt=\"\"></p>\n</li>\n</ul>\n<h2 id=\"mvnd-与-mvnw-的区别\">mvnd 与 mvnw 的区别</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>我们现在大部分创建的项目都是Springboot项目，通过IDEA创建Springboot项目时会自动创建如下文件</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.mvn： 文件夹，其内部存放了 `wrapper/maven-wrapper.properties` 文件，该文件用于声明  mvn 的 url</span><br><span class=\"line\">mvnw： linux 脚本文件</span><br><span class=\"line\">mvnw.cmd： windows 脚本文件</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>实际上 <code>mvnw</code> 是一个 Maven 启动脚本，用于自动下载指定版本的Maven，并运行 Maven 构建。</p>\n</li>\n<li class=\"lvl-2\">\n<p>第一次使用<code>mvnw</code>时会通过<code>wrapper/maven-wrapper.properties</code> 文件中的声明自动下载maven，并保存在 <code>~/.m2/wrapper/dists/</code> 目录下</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>mvnw</code>使用方式如下:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./mvnw clean install</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>运行速度： <code>mvnd &gt;&gt; mvnw ≈ mvn</code></p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>对比项</th>\n<th>mvnd</th>\n<th>mvnw（Maven Wrapper）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>是什么</td>\n<td>一个「常驻的 Maven 守护进程」</td>\n<td>一个「Maven 启动脚本」</td>\n</tr>\n<tr>\n<td>是否常驻</td>\n<td>✅ 是（daemon）</td>\n<td>❌ 否（一次性）</td>\n</tr>\n<tr>\n<td>是否下载 Maven</td>\n<td>❌ 不下载，自己就是程序</td>\n<td>✅ 会自动下载指定版本</td>\n</tr>\n<tr>\n<td>主要目的</td>\n<td>加速构建</td>\n<td>保证版本一致</td>\n</tr>\n<tr>\n<td>是否推荐在 CI</td>\n<td>一般不建议</td>\n<td>✅ 非常推荐</td>\n</tr>\n<tr>\n<td>使用方式</td>\n<td><code>mvnd clean install</code></td>\n<td><code>./mvnw clean install</code></td>\n</tr>\n<tr>\n<td>是否与项目绑定</td>\n<td>❌ 全局使用</td>\n<td>✅ 和项目绑定</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 Maven 新一代构建工具 mvnd mvnd GitHub 本文安装的是 mvnd 1.0.3。 mvnd 简介 mvnd 是 Maven 新一代构建工具，使用 Java 语言编写。 mvnd 借鉴 Gradle 和 Takari 中的技术从而提供更快的Maven构建速度。 架构概述 mvnd内嵌Maven（因此不需要单独安装Maven）。1.x版本内嵌maven3.x版本，2.x版本内嵌maven4.x版本。 实际构建发生在一个长驻后台进程中，又名守护程序。 一个守护程序实例可以服务来自mvnd客户端的多个连续请求。 mvnd客户端是使用GraalVM构建的原生可执行文件。与启动传统的JVM相比，它启动速度更快，占用的内存更少。 如果没有闲置守护程序来服务构建请求，则可以并行生成多个守护程序。 这种架构带来了以下优点： 不需要每次构建重新启动 JVM，大大节省时间。 持有Maven插件类的classloaders被缓存在多个构建中。因此，插件jar只被读取和解析一次。Maven插件的SNAPSHOT版本没有缓存。 JVM内Just-In-Time（JIT）编译器生成的原生代码也被保留。与传统的Maven相比，JIT编译花费的时间更少。在重复构建期间，JIT优化的代码立即可用。这不仅适用于来自Maven插件和Maven Core的代码，也适用于来自JDK本身的所有代码。 默认情况下，mvnd 使用多个 CPU 内核并行构建模块，使用的核心数由以下公式给出: availableProcessors - 1 mvnd 安装 mvnd 安装包下载地址： mvnd Github Release maven 官网下载页 本文以 macOS 为例 123456789# 下载 mvnd 对应的安装包curl -L https://github.com/apache/maven-mvnd/releases/download/1.0.3/maven-mvnd-1.0.3-darwin-amd64.tar.gz | tar xzln -s mvnd-1.0.3-darwin-amd64 mvnd# 添加 mvnd 到环境变量echo &#x27;MVND_HOME=$HOME/develop_soft/mvnd&#x27; &gt;&gt; ~/.zshrcecho &#x27;export PATH=$MVND_HOME/bin:$PATH&#x27; &gt;&gt; ~/.zshrcsource ~/.zshrc# 检查 mvnd 是否安装成功mvnd --version mvnd 内嵌 maven，其本质上还是依赖于maven，所以需要创建maven的配置文件 ~/.m2/settings.xml ，由于本机之前安装过 Maven，所以这一步就省略了。 [推荐]将 mvnd 的配置文件拷贝到 ~/.m2 目录下 12# 与 maven了类似，`~/.m2/mvnd.properties` 优先级高于 `$MVND_HOME/conf/mvnd.properties`cp $MVND_HOME/conf/mvnd.properties $HOME/.m2/mvnd.properties mvnd 配置项说明，一般不需要修改，可能会修改的我用 [*] 做了标注 配置项 默认值 中文解释 mvnd.noBuffering [*] false 是否禁用输出缓冲，从而像普通 Maven 一样实时显示日志。命令行传递 -B 或 --batch-mode 也会启用此行为 mvnd.rollingWindowSize 0 构建并行模块时，每个模块显示的日志行数 mvnd.logPurgePeriod 7d 自动清理日志的周期（如：7天），日志保存路径： $HOME/.m2/mvnd/registry/1.0.3/ mvnd.noDaemon false 禁止使用 daemon（守护进程）。一般用于调试，仅在非 native 模式下有效 mvnd.debug false 使用调试模式启动 daemon，JVM 参数为：-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=8000 mvnd.idleTimeout 3 hours 守护进程在空闲多久后自动关闭 mvnd.keepAlive 100 ms 如果构建过程没有输出，daemon 向客户端发送保活消息的时间间隔 mvnd.maxLostKeepAlive 30 允许丢失的最大保活消息数量，超过则客户端认为 daemon 已失败 mvnd.minThreads 1 构建时要使用的最少线程数量。如果显式指定了 -T、--threads 或 mvnd.threads，该值将被忽略 mvnd.threads [*] 未设置 传递给 daemon 的线程数，与 Maven 的 -T / --threads 语法一致 mvnd.builder smart 指定使用的 Maven 构建器名称（等同于 -b 或 --builder） mvnd.minHeapSize 128M 守护进程 JVM 的最小堆内存 mvnd.maxHeapSize [*] 2G 守护进程 JVM 的最大堆内存 mvnd.threadStackSize 1M 守护进程线程栈大小 mvnd.jvmArgs 未设置 传递给 daemon 的额外 JVM 参数 mvnd.enableAssertions false 是否为 daemon 启用 JVM 断言（-ea） mvnd.expirationCheckDelay 10 seconds 守护进程检测自身是否需要过期的时间间隔 mvnd.duplicateDaemonGracePeriod 10 seconds 多个 daemon 存在时，多余 daemon 的宽限退出时间 mvnd.home 自动设置 mvnd 安装目录，客户端通常会根据 mvnd 可执行文件位置设置 java.home 使用环境变量 启动 daemon 的 Java 目录（等同 JAVA_HOME） maven.settings [*] ~/.m2/settings.xml maven 的 settings.xml 路径 mvnd 使用 命令行使用方式与 mvn 一样，比如： 12mvnd clean installmvnd clean package -Dmaven.test.skip=true mvnd 的 daemon 缓存了一切，所以运行 mvnd clean install 后，之后再次运行 mvnd clean install 时，mvnd 会直接从缓存中读取构建结果，从而节省了构建时间。 mvnd 还有些特殊用法，比如： 1234# 查看当前所有的守护进程列表，守护进程空闲超过 mvnd.idleTimeout=3 hours 会自动关闭mvnd --status# 手动停止所有运行的守护进程mvnd --stop 在IDEA中使用mvnd，在Maven设置中将mvnd的安装目录添加到 Maven Home Path 中 mvnd 与 mvnw 的区别 我们现在大部分创建的项目都是Springboot项目，通过IDEA创建Springboot项目时会自动创建如下文件 123.mvn： 文件夹，其内部存放了 `wrapper/maven-wrapper.properties` 文件，该文件用于声明 mvn 的 urlmvnw： linux 脚本文件mvnw.cmd： windows 脚本文件 实际上 mvnw 是一个 Maven 启动脚本，用于自动下载指定版本的Maven，并运行 Maven 构建。 第一次使用mvnw时会通过wrapper/maven-wrapper.properties 文件中的声明自动下载maven，并保存在 ~/.m2/wrapper/dists/ 目录下 mvnw使用方式如下: 1./mvnw clean install 运行速度： mvnd &gt;&gt; mvnw ≈ mvn 对比项 mvnd mvnw（Maven Wrapper） 是什么 一个「常驻的 Maven 守护进程」 一个「Maven 启动脚本」 是否常驻 ✅ 是（daemon） ❌ 否（一次性） 是否下载 Maven ❌ 不下载，自己就是程序 ✅ 会自动下载指定版本 主要目的 加速构建 保证版本一致 是否推荐在 CI 一般不建议 ✅ 非常推荐 使用方式 mvnd clean install ./mvnw clean install 是否与项目绑定 ❌ 全局使用 ✅ 和项目绑定","summary":"摘要 本文介绍 Maven 新一代构建工具 mvnd mvnd GitHub 本文安装的是 mvnd 1.0.3。","date_published":"2025-12-07T14:30:05.000Z","tags":["技术","maven","mvnd","mavne","mvnd"]},{"id":"https://blog.hanqunfeng.com/2025/12/07/redis7-acl/","url":"https://blog.hanqunfeng.com/2025/12/07/redis7-acl/","title":"Redis 7 + ACL 简介","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">Redis 7 + ACL 简介</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Redis-ACL-简介\">Redis ACL 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>从 Redis 6.0 开始，引入了 ACL 功能，用来精细化控制不同用户能做什么，代替过去只有一个全局密码（requirepass）的粗粒度模式。</p>\n</li>\n<li class=\"lvl-2\">\n<p>ACL 可以控制的维度包括：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-5\">谁能登录（用户、密码）</li>\n<li class=\"lvl-5\">可以执行哪些命令</li>\n<li class=\"lvl-5\">可以访问哪些 key（按前缀 / 正则）</li>\n<li class=\"lvl-5\">可否通过网络访问</li>\n<li class=\"lvl-5\">是否启用 / 禁用某个用户</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>一句话：Redis ACL 实现了多用户 + 权限最小化 + 资源隔离</p>\n</li>\n</ul>\n<h2 id=\"Redis-ACL-的使用\">Redis ACL 的使用</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 <code>redis.conf</code> 中添加如下内容：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 指定 ACL 文件</span></span><br><span class=\"line\">aclfile /etc/redis/users.acl</span><br><span class=\"line\"><span class=\"comment\"># 关闭 密码</span></span><br><span class=\"line\"><span class=\"comment\"># requirepass foobared</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>也可以不配置 <code>aclfile</code>，而是将用户信息直接编写在 <code>redis.conf</code> 中，但不建议这样做。</p>\n</li>\n</ul>\n<h3 id=\"ACL-的配置方式\">ACL 的配置方式</h3>\n<h4 id=\"直接编辑-aclfile\">直接编辑 aclfile</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建一个 <code>users.acl</code> 文件，并写入如下内容：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 配置一个管理员</span></span><br><span class=\"line\">user admin on ~* &amp;* +@all &gt;password</span><br><span class=\"line\"><span class=\"comment\"># 配置一个应用用户</span></span><br><span class=\"line\">user appuser on  ~cache:* &amp;app:* +get +<span class=\"built_in\">set</span> &gt;password</span><br><span class=\"line\"><span class=\"comment\"># 配置一个只读用户</span></span><br><span class=\"line\">user <span class=\"built_in\">readonly</span> on ~* -@all +@<span class=\"built_in\">read</span> +ping +info +client +config|get &gt;password</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里要特别注意，aclfile 不支持注释行，所有行都必须以 user 开头，否则会报错。</p>\n</li>\n<li class=\"lvl-2\">\n<p>格式说明</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user: 固定前缀</span><br><span class=\"line\">username: 用户名</span><br><span class=\"line\">on: 启用 off: 禁用</span><br><span class=\"line\">~pattern: key 匹配模式，~*：匹配所有 key，~cache:*： 匹配 cache: 开头的所有 key</span><br><span class=\"line\">&amp;pattern: 频道匹配模式，&amp;*：匹配所有频道，&amp;app:*：匹配 app:* 开头的所有频道，通道就是 pub/sub 的频道</span><br><span class=\"line\">+<span class=\"built_in\">command</span>: 允许的命令，可以直接输入命令名称，如 +get +<span class=\"built_in\">set</span>，子命令 +config|get，也可以是命令的类别，命令类别 通过 acl <span class=\"built_in\">cat</span> 命令查看，以@开头，比如 @<span class=\"built_in\">read</span> @write，+ 表示允许命令，- 表示禁止命令</span><br><span class=\"line\">&gt;password: 密码明文，注意 &gt; 与 密码之间不能有空格</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>为了兼容以前的版本，Redis 提供了一个默认的用户：<code>default</code>，不指定用户名的时候，默认使用的就是 <code>default</code> 用户，其对应的acl权限为</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 实际上就是一个超级管理员权限</span></span><br><span class=\"line\">user default on nopass sanitize-payload ~* &amp;* +@all</span><br><span class=\"line\"><span class=\"comment\"># 如果设置了 requirepass 密码</span></span><br><span class=\"line\">user default on sanitize-payload <span class=\"comment\">#5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 ~* &amp;* +@all</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>开启<code>ACL</code>后，推荐关闭 <code>default</code> 用户。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 关闭默认用户，禁止匿名访问</span></span><br><span class=\"line\">user default off</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>登录redis</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 连接时直接登录, --pass == -a</span></span><br><span class=\"line\">redis-cli --user username --pass password -h host -p port</span><br><span class=\"line\"><span class=\"comment\"># 或者</span></span><br><span class=\"line\">redis-cli -u redis://admin:123456@127.0.0.1:6379</span><br><span class=\"line\"><span class=\"comment\"># 本机登录</span></span><br><span class=\"line\">redis-cli -u redis://admin:123456@</span><br><span class=\"line\"><span class=\"comment\"># 本机登录时端口不是默认的6379时</span></span><br><span class=\"line\">redis-cli -u redis://admin:123456@:6380</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 先连接后登录</span></span><br><span class=\"line\">redis-cli -h host -p port</span><br><span class=\"line\">&gt; auth username password</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis ACL 规则中文说明</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>规则 / 语法</th>\n<th>中文说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>on</code></td>\n<td>启用用户：可以使用该用户进行认证登录</td>\n</tr>\n<tr>\n<td><code>off</code></td>\n<td>禁用用户：无法再使用该用户认证，但<strong>已认证的连接仍然有效</strong></td>\n</tr>\n<tr>\n<td><code>skip-sanitize-payload</code></td>\n<td>跳过对 <code>RESTORE</code> 命令的 dump 数据载荷过滤（跳过安全检查）</td>\n</tr>\n<tr>\n<td><code>sanitize-payload</code></td>\n<td>对 <code>RESTORE</code> 命令的 dump 数据载荷进行过滤（默认）</td>\n</tr>\n<tr>\n<td><code>+&lt;command&gt;</code></td>\n<td>允许执行指定命令；可以指定子命令，例如：<code>+config | get</code></td>\n</tr>\n<tr>\n<td><code>-&lt;command&gt;</code></td>\n<td>禁止执行指定命令；可以指定子命令，例如：<code>-config | set</code></td>\n</tr>\n<tr>\n<td><code>+@&lt;category&gt;</code></td>\n<td>允许一个命令分类的所有命令，如：<code>@admin</code>, <code>@set</code>, <code>@sortedset</code> 等。完整分类在 <code>server.c</code> 的命令表中</td>\n</tr>\n<tr>\n<td><code>@all</code></td>\n<td>特殊分类，表示所有<strong>当前已有命令 + 未来模块加载的命令</strong></td>\n</tr>\n<tr>\n<td><code>+&lt;command&gt;|first-arg</code></td>\n<td>只允许使用某命令的第一个参数（<strong>已废弃，将可能移除</strong>）；只支持新增，不支持禁止（如 <code>-SELECT|1</code> 不允许）</td>\n</tr>\n<tr>\n<td><code>allcommands</code></td>\n<td><code>+@all</code> 的别名，允许所有命令（包括将来可能加载的模块命令）</td>\n</tr>\n<tr>\n<td><code>nocommands</code></td>\n<td><code>-@all</code> 的别名，禁止所有命令</td>\n</tr>\n<tr>\n<td><code>~&lt;pattern&gt;</code></td>\n<td>添加允许访问的 key 模式（glob 风格），如：<code>~user:*</code>；可以有多个</td>\n</tr>\n<tr>\n<td><code>%R~&lt;pattern&gt;</code></td>\n<td>添加<strong>允许读取</strong>的 key 模式</td>\n</tr>\n<tr>\n<td><code>%W~&lt;pattern&gt;</code></td>\n<td>添加<strong>允许写入</strong>的 key 模式</td>\n</tr>\n<tr>\n<td><code>allkeys</code></td>\n<td><code>~*</code> 的别名，允许所有 key</td>\n</tr>\n<tr>\n<td><code>resetkeys</code></td>\n<td>清空允许访问的 key 模式</td>\n</tr>\n<tr>\n<td><code>&amp;&lt;pattern&gt;</code></td>\n<td>添加可访问的 Pub/Sub channel 模式（glob 风格），可多个</td>\n</tr>\n<tr>\n<td><code>allchannels</code></td>\n<td><code>&amp;*</code> 的别名，允许所有 channel</td>\n</tr>\n<tr>\n<td><code>resetchannels</code></td>\n<td>清空 Pub/Sub channel 模式列表</td>\n</tr>\n<tr>\n<td><code>&gt;&lt;password&gt;</code></td>\n<td>添加密码，例如：<code>&gt;mypass</code>；此指令会清除 <code>nopass</code> 标志</td>\n</tr>\n<tr>\n<td><code>&lt;&lt;password&gt;</code></td>\n<td>移除指定密码</td>\n</tr>\n<tr>\n<td><code>nopass</code></td>\n<td>移除所有密码，且任何密码都可登录。如果用于 <code>default</code> 用户，则新连接<strong>无需 AUTH 即自动登录为 default</strong></td>\n</tr>\n<tr>\n<td><code>resetpass</code></td>\n<td>清空所有密码，并移除 <code>nopass</code> 状态。此后<strong>没有密码将无法认证</strong></td>\n</tr>\n<tr>\n<td><code>reset</code></td>\n<td>重置所有设置：包括 <code>resetpass</code>、<code>resetkeys</code>、<code>resetchannels</code>、<code>allchannels</code>（如果开启 acl-pubsub-default）、<code>off</code>、<code>clearseletors</code>、<code>-@all</code></td>\n</tr>\n<tr>\n<td><code>(&lt;options&gt;)</code></td>\n<td>创建一个新的 selector（选择器），括号内为该 selector 的独立权限规则</td>\n</tr>\n<tr>\n<td><code>clearselectors</code></td>\n<td>删除所有 selector，但不会影响根权限（直接赋给用户的权限）</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"通过-ACL-命令\">通过 ACL 命令</h4>\n<p><img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/iddYko.png\" alt=\"\"></p>\n<h5 id=\"ACL-SETUSER\">ACL SETUSER</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建/修改用户</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 关闭 default 用户</span></span><br><span class=\"line\">ACL SETUSER default off</span><br><span class=\"line\"><span class=\"comment\"># 创建一个管理员</span></span><br><span class=\"line\">ACL SETUSER admin on ~* &amp;* +@all &gt;password</span><br><span class=\"line\"><span class=\"comment\"># 创建一个普通用户</span></span><br><span class=\"line\">ACL SETUSER appuser on &gt;password ~cache:* &amp;app:* +get +<span class=\"built_in\">set</span></span><br><span class=\"line\"><span class=\"comment\"># 创建一个只读用户</span></span><br><span class=\"line\">ACL SETUSER <span class=\"built_in\">readonly</span> on ~* -@all +@<span class=\"built_in\">read</span> +ping +info +client +config|get &gt;password</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>可以看的出来，<code>ACL SETUSER</code> 后面的命令格式与直接编辑 <code>users.acl</code> 文件是一样的</p>\n</li>\n<li class=\"lvl-2\">\n<p>这里要注意 <code>ACL SETUSER</code> 即可以创建用户，也可以修改用户，当用户不存在时创建用户，当用户存在时修改用户，修改用户时并不会覆盖旧用户，而是会将权限进行合并，比如：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 第一次执行</span></span><br><span class=\"line\">ACL SETUSER testuser on ~* -@all +@<span class=\"built_in\">read</span> +ping  &gt;password</span><br><span class=\"line\"><span class=\"comment\"># 第二次执行，只添加新的权限</span></span><br><span class=\"line\">ACL SETUSER testuser +info +client +config|get</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>运行后的结果</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;user testuser on sanitize-payload #5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 ~* resetchannels -@all +@read +ping +info +client +config|get&quot;</span></span><br></pre></td></tr></table></figure>\n<h6 id=\"修改用户权限\">修改用户权限</h6>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>重置权限</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 重置所有权限</span></span><br><span class=\"line\">ACL SETUSER testuser reset</span><br><span class=\"line\"><span class=\"comment\">## 运行结果：去除所有频道和命令权限，禁止登录</span></span><br><span class=\"line\"><span class=\"string\">&quot;user testuser off sanitize-payload resetchannels -@all&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>取消密码，但保留权限</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL SETUSER testuser nopass</span><br><span class=\"line\"><span class=\"comment\">## 运行结果：取消密码</span></span><br><span class=\"line\"><span class=\"string\">&quot;user testuser on nopass sanitize-payload ~* resetchannels -@all +@read +ping&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>去除所有频道</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL SETUSER testuser resetchannels</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>去除所有<code>selectors</code>，关于<code>selectors</code>后面会详细介绍</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL SETUSER testuser clearselectors</span><br></pre></td></tr></table></figure>\n<h5 id=\"ACL-LIST\">ACL LIST</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>可以通过如下命令查看当前 Redis 中所有的用户</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL LIST</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">1) <span class=\"string\">&quot;user admin on sanitize-payload #8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92 ~* &amp;* +@all&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;user appuser on sanitize-payload #5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 ~cache:* resetchannels &amp;app:* -@all +get +set&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;user default off sanitize-payload resetchannels -@all&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;user readonly on sanitize-payload #5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 ~* resetchannels -@all +@read +ping +info +client +config|get&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里显示的并不是设置权限时的命令格式，而是经过翻译后的命令格式</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user: 固定前缀</span><br><span class=\"line\">username: 用户名</span><br><span class=\"line\">on: 启用</span><br><span class=\"line\">sanitize-payload: 是在用 RESTORE 命令导入 RDB 数据时，帮你“体检 + 消毒 + 清洗”这份数据，防止恶意内容被导进去。</span><br><span class=\"line\">#xxx: 密码的加密哈希值（通常是 SHA-256）, &gt;xxx = 明文密码，两种方式都可以，但推荐使用哈希值，实际上我们可以先通过明文配置，然后通过 ACL SAVE 命令保存就会将密码变成哈希值了</span><br><span class=\"line\">~pattern: key 匹配模式，~*：匹配所有 key，~cache:*： 匹配 cache: 开头的所有 key</span><br><span class=\"line\">resetchannels: 重置频道权限，就是先删除所有频道权限，后面根据 &amp; 的配置再添加新的频道权限。</span><br><span class=\"line\">&amp;pattern: 频道匹配模式，&amp;*：匹配所有频道，&amp;app:*：匹配 app:* 开头的所有频道，通道就是 pub/sub 的频道</span><br><span class=\"line\">+command: 允许的命令，可以直接输入命令名称，如 +get +set，子命令 +config|get，也可以是命令的类别，命令类别 通过 acl cat 命令查看，以@开头，比如 @read @write，+ 表示允许命令，- 表示禁止命令</span><br></pre></td></tr></table></figure>\n<h5 id=\"ACL-LOAD\">ACL LOAD</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当通过 ACL SETUSER 创建用户时，可以通过如下命令将其保存到 <code>users.acl</code> 文件中</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL SAVE</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时保存的文件内容就是 <code>ACL LIST</code> 命令的输出</p>\n</li>\n</ul>\n<h5 id=\"ACL-SAVE\">ACL SAVE</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当修改了 <code>users.acl</code> 文件后，可以通过如下命令将其重新加载到 Redis 中</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL LOAD</span><br></pre></td></tr></table></figure>\n<h5 id=\"ACL-USERS\">ACL USERS</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>列出所有已创建的用户</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL USERS</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">1) <span class=\"string\">&quot;admin&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;appuser&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;default&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;readonly&quot;</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"ACL-GETUSER\">ACL GETUSER</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>获取指定用户的权限信息</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL GETUSER appuser</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">1) <span class=\"string\">&quot;flags&quot;</span></span><br><span class=\"line\"> 2) 1) <span class=\"string\">&quot;on&quot;</span></span><br><span class=\"line\">    2) <span class=\"string\">&quot;sanitize-payload&quot;</span></span><br><span class=\"line\"> 3) <span class=\"string\">&quot;passwords&quot;</span></span><br><span class=\"line\"> 4) 1) <span class=\"string\">&quot;5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8&quot;</span></span><br><span class=\"line\"> 5) <span class=\"string\">&quot;commands&quot;</span></span><br><span class=\"line\"> 6) <span class=\"string\">&quot;-@all +get +set&quot;</span></span><br><span class=\"line\"> 7) <span class=\"string\">&quot;keys&quot;</span></span><br><span class=\"line\"> 8) <span class=\"string\">&quot;~cache:*&quot;</span></span><br><span class=\"line\"> 9) <span class=\"string\">&quot;channels&quot;</span></span><br><span class=\"line\">10) <span class=\"string\">&quot;&amp;app:*&quot;</span></span><br><span class=\"line\">11) <span class=\"string\">&quot;selectors&quot;</span></span><br><span class=\"line\">12) (empty array)</span><br></pre></td></tr></table></figure>\n<h6 id=\"selectors-选择器规则\">selectors(选择器规则)</h6>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里看到最后有一个<code>selectors</code>，这个是Redis 7.0 引入的一个新能力，它允许一个用户同时拥有多套不同的 ACL 规则，而不是只能有一套规则。</p>\n</li>\n<li class=\"lvl-2\">\n<p>以前 = 一个用户一条规则</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 根权限（全局规则）</span></span><br><span class=\"line\">ACL SETUSER selectoruser on ~cache:* +get +<span class=\"built_in\">set</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>现在 = 一个用户可以有多个“权限分身”</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 选择器规则</span></span><br><span class=\"line\"><span class=\"comment\"># 注意命令最后的两个()，这里设置了两个规则，每个()代表一个规则，根据不同的key前缀授予用户不同的权限</span></span><br><span class=\"line\">ACL SETUSER selectoruser on (~cache:* +get) (~session:* +get +<span class=\"built_in\">set</span>) &gt;123456</span><br><span class=\"line\"><span class=\"comment\">## 翻译后的结果</span></span><br><span class=\"line\"><span class=\"string\">&quot;user selectoruser on sanitize-payload resetchannels -@all (~cache:* resetchannels -@all +get) (~session:* resetchannels -@all +get +set)&quot;</span> &gt;123456</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果一个用户同时拥有 根权限规则 和 选择器规则，则 选择器规则 优先级更高。</p>\n</li>\n</ul>\n<h5 id=\"ACL-DELUSER\">ACL DELUSER</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>删除一个用户</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL DELUSER 用户名</span><br></pre></td></tr></table></figure>\n<h5 id=\"ACL-WHOAMI\">ACL WHOAMI</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>获取当前登录的用户名</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL WHOAMI</span><br></pre></td></tr></table></figure>\n<h5 id=\"ACL-CAT\">ACL CAT</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>获取所有权限类别</p>\n</li>\n<li class=\"lvl-2\">\n<p>前面我们在为用户授权时介绍过，<code>@</code> 后面跟的是一个权限类别，比如 @all、@dangerous，你可以理解为其是一组权限(命令)的集合。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>ACL CAT</code> 命令可以获取所有权限类别，然后你可以根据需要选择需要的权限类别。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取所有权限类别</span></span><br><span class=\"line\">ACL CAT</span><br><span class=\"line\"><span class=\"comment\"># 获取指定类别中的命令列表</span></span><br><span class=\"line\">ACL CAT 分类名称</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里有一个特殊的权限类别 <code>@all</code> 并不在列出的权限类别中，其表示所有命令。</p>\n</li>\n</ul>\n<h5 id=\"ACL-DRYRUN\">ACL DRYRUN</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>ACL DRYRUN</code> 命令可以模拟执行命令，并返回模拟结果，并不是真的执行命令。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Redis 7.0.0 新增。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; ACL SETUSER VIRGINIA +SET ~*</span><br><span class=\"line\"><span class=\"string\">&quot;OK&quot;</span></span><br><span class=\"line\">&gt; ACL DRYRUN VIRGINIA SET foo bar</span><br><span class=\"line\"><span class=\"string\">&quot;OK&quot;</span></span><br><span class=\"line\">&gt; ACL DRYRUN VIRGINIA GET foo</span><br><span class=\"line\"><span class=\"string\">&quot;User VIRGINIA has no permissions to run the &#x27;get&#x27; command&quot;</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"ACL-LOG\">ACL LOG</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>ACL LOG</code> 命令可以查看 ACL 命令执行日志。</p>\n</li>\n<li class=\"lvl-2\">\n<p>它记录了 ACL（访问控制）相关的事件，也就是用户在操作被拒绝或触发 ACL 规则时的行为记录。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACL LOG          <span class=\"comment\"># 查看默认最新的 ACL 日志条目</span></span><br><span class=\"line\">ACL LOG RESET    <span class=\"comment\"># 清空 ACL 日志</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>日志格式</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1) <span class=\"string\">&quot;count&quot;</span> =&gt; 1</span><br><span class=\"line\">   2) <span class=\"string\">&quot;reason&quot;</span> =&gt; <span class=\"string\">&quot;command&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;context&quot;</span> =&gt; <span class=\"string\">&quot;toplevel&quot;</span></span><br><span class=\"line\">   4) <span class=\"string\">&quot;object&quot;</span> =&gt; <span class=\"string\">&quot;acl|log&quot;</span></span><br><span class=\"line\">   5) <span class=\"string\">&quot;username&quot;</span> =&gt; <span class=\"string\">&quot;selectoruser&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;age-seconds&quot;</span> =&gt; 1589.819</span><br><span class=\"line\">   7) <span class=\"string\">&quot;client-info&quot;</span> =&gt; <span class=\"string\">&quot;id=8 addr=127.0.0.1:56424 laddr=127.0.0.1:6379 fd=11 name= age=1390 idle=0 flags=N db=0 ... cmd=acl|log user=selectoruser ...&quot;</span></span><br><span class=\"line\">   8) <span class=\"string\">&quot;entry-id&quot;</span> =&gt; 3</span><br><span class=\"line\">   9) <span class=\"string\">&quot;timestamp-created&quot;</span> =&gt; 1765089007352</span><br><span class=\"line\">   10) <span class=\"string\">&quot;timestamp-last-updated&quot;</span> =&gt; 1765089007352</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>count</code></td>\n<td>触发该日志的次数。比如同一事件触发 1 次就是 1</td>\n</tr>\n<tr>\n<td><code>reason</code></td>\n<td>日志触发的原因，通常是 <code>command</code> 表示某个命令被执行或被 ACL 检查</td>\n</tr>\n<tr>\n<td><code>context</code></td>\n<td>执行命令的上下文，<code>toplevel</code> 表示直接在客户端执行</td>\n</tr>\n<tr>\n<td><code>object</code></td>\n<td>触发事件的对象，例如 <code>acl|log</code>表示执行了<code>ACL LOG</code> 命令，<code>acl|list</code>表示执行了<code>ACL LIST</code></td>\n</tr>\n<tr>\n<td><code>username</code></td>\n<td>触发事件的用户</td>\n</tr>\n<tr>\n<td><code>age-seconds</code></td>\n<td>事件距离当前的时间（秒），越大表示越久远</td>\n</tr>\n<tr>\n<td><code>client-info</code></td>\n<td>客户端详细信息，包括客户端 ID、IP 地址、端口、本地地址、文件描述符、客户端名称、DB、执行命令等</td>\n</tr>\n<tr>\n<td><code>entry-id</code></td>\n<td>日志条目 ID</td>\n</tr>\n<tr>\n<td><code>timestamp-created</code></td>\n<td>日志创建时间（毫秒）</td>\n</tr>\n<tr>\n<td><code>timestamp-last-updated</code></td>\n<td>日志最后更新时间（毫秒）</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"ACL-GENPASS\">ACL GENPASS</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>生成一个随机的 ACL 密码</p>\n</li>\n<li class=\"lvl-2\">\n<p>生成复杂密码的工具有很多，没必要用这玩意。</p>\n</li>\n<li class=\"lvl-2\">\n<p>该命令的输出是二进制字符串的十六进制表示形式。默认情况下，它会生成 256 位（即 64 个十六进制字符）。用户可以通过提供一个参数来指定生成的位数，范围从 1 到 1024 位，以改变输出长度。需要注意的是，所提供的位数总是会向上取整到 4 的倍数。例如，如果请求生成 1 位密码，实际上会生成 4 位，并以 单个十六进制字符的形式输出。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 默认64个十六进制字符，相当于 ACL GENPASS 256</span></span><br><span class=\"line\">&gt; ACL GENPASS</span><br><span class=\"line\"><span class=\"string\">&quot;dd721260bfe1b3d9601e7fbab36de6d04e2e67b0ef1c53de59d45950db0dd3cc&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 指定长度，32/4 = 8</span></span><br><span class=\"line\">&gt; ACL GENPASS 32</span><br><span class=\"line\"><span class=\"string\">&quot;355ef3dd&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 指定长度，5 向上取4的倍数，就是 8，长度就是 8/4 = 2</span></span><br><span class=\"line\">&gt; ACL GENPASS 5</span><br><span class=\"line\"><span class=\"string\">&quot;90&quot;</span></span><br></pre></td></tr></table></figure>","content_text":"摘要 Redis 7 + ACL 简介 本文基于redis-7.4.7 Redis官网：https://redis.io/ Redis ACL 简介 从 Redis 6.0 开始，引入了 ACL 功能，用来精细化控制不同用户能做什么，代替过去只有一个全局密码（requirepass）的粗粒度模式。 ACL 可以控制的维度包括： 谁能登录（用户、密码） 可以执行哪些命令 可以访问哪些 key（按前缀 / 正则） 可否通过网络访问 是否启用 / 禁用某个用户 一句话：Redis ACL 实现了多用户 + 权限最小化 + 资源隔离 Redis ACL 的使用 在 redis.conf 中添加如下内容： 1234# 指定 ACL 文件aclfile /etc/redis/users.acl# 关闭 密码# requirepass foobared 也可以不配置 aclfile，而是将用户信息直接编写在 redis.conf 中，但不建议这样做。 ACL 的配置方式 直接编辑 aclfile 创建一个 users.acl 文件，并写入如下内容： 123456# 配置一个管理员user admin on ~* &amp;* +@all &gt;password# 配置一个应用用户user appuser on ~cache:* &amp;app:* +get +set &gt;password# 配置一个只读用户user readonly on ~* -@all +@read +ping +info +client +config|get &gt;password 这里要特别注意，aclfile 不支持注释行，所有行都必须以 user 开头，否则会报错。 格式说明 1234567user: 固定前缀username: 用户名on: 启用 off: 禁用~pattern: key 匹配模式，~*：匹配所有 key，~cache:*： 匹配 cache: 开头的所有 key&amp;pattern: 频道匹配模式，&amp;*：匹配所有频道，&amp;app:*：匹配 app:* 开头的所有频道，通道就是 pub/sub 的频道+command: 允许的命令，可以直接输入命令名称，如 +get +set，子命令 +config|get，也可以是命令的类别，命令类别 通过 acl cat 命令查看，以@开头，比如 @read @write，+ 表示允许命令，- 表示禁止命令&gt;password: 密码明文，注意 &gt; 与 密码之间不能有空格 为了兼容以前的版本，Redis 提供了一个默认的用户：default，不指定用户名的时候，默认使用的就是 default 用户，其对应的acl权限为 1234# 实际上就是一个超级管理员权限user default on nopass sanitize-payload ~* &amp;* +@all# 如果设置了 requirepass 密码user default on sanitize-payload #5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 ~* &amp;* +@all 开启ACL后，推荐关闭 default 用户。 12# 关闭默认用户，禁止匿名访问user default off 登录redis 12345678910111213# 连接时直接登录, --pass == -aredis-cli --user username --pass password -h host -p port# 或者redis-cli -u redis://admin:123456@127.0.0.1:6379# 本机登录redis-cli -u redis://admin:123456@# 本机登录时端口不是默认的6379时redis-cli -u redis://admin:123456@:6380# 先连接后登录redis-cli -h host -p port&gt; auth username password Redis ACL 规则中文说明 规则 / 语法 中文说明 on 启用用户：可以使用该用户进行认证登录 off 禁用用户：无法再使用该用户认证，但已认证的连接仍然有效 skip-sanitize-payload 跳过对 RESTORE 命令的 dump 数据载荷过滤（跳过安全检查） sanitize-payload 对 RESTORE 命令的 dump 数据载荷进行过滤（默认） +&lt;command&gt; 允许执行指定命令；可以指定子命令，例如：+config | get -&lt;command&gt; 禁止执行指定命令；可以指定子命令，例如：-config | set +@&lt;category&gt; 允许一个命令分类的所有命令，如：@admin, @set, @sortedset 等。完整分类在 server.c 的命令表中 @all 特殊分类，表示所有当前已有命令 + 未来模块加载的命令 +&lt;command&gt;|first-arg 只允许使用某命令的第一个参数（已废弃，将可能移除）；只支持新增，不支持禁止（如 -SELECT|1 不允许） allcommands +@all 的别名，允许所有命令（包括将来可能加载的模块命令） nocommands -@all 的别名，禁止所有命令 ~&lt;pattern&gt; 添加允许访问的 key 模式（glob 风格），如：~user:*；可以有多个 %R~&lt;pattern&gt; 添加允许读取的 key 模式 %W~&lt;pattern&gt; 添加允许写入的 key 模式 allkeys ~* 的别名，允许所有 key resetkeys 清空允许访问的 key 模式 &amp;&lt;pattern&gt; 添加可访问的 Pub/Sub channel 模式（glob 风格），可多个 allchannels &amp;* 的别名，允许所有 channel resetchannels 清空 Pub/Sub channel 模式列表 &gt;&lt;password&gt; 添加密码，例如：&gt;mypass；此指令会清除 nopass 标志 &lt;&lt;password&gt; 移除指定密码 nopass 移除所有密码，且任何密码都可登录。如果用于 default 用户，则新连接无需 AUTH 即自动登录为 default resetpass 清空所有密码，并移除 nopass 状态。此后没有密码将无法认证 reset 重置所有设置：包括 resetpass、resetkeys、resetchannels、allchannels（如果开启 acl-pubsub-default）、off、clearseletors、-@all (&lt;options&gt;) 创建一个新的 selector（选择器），括号内为该 selector 的独立权限规则 clearselectors 删除所有 selector，但不会影响根权限（直接赋给用户的权限） 通过 ACL 命令 ACL SETUSER 创建/修改用户 12345678# 关闭 default 用户ACL SETUSER default off# 创建一个管理员ACL SETUSER admin on ~* &amp;* +@all &gt;password# 创建一个普通用户ACL SETUSER appuser on &gt;password ~cache:* &amp;app:* +get +set# 创建一个只读用户ACL SETUSER readonly on ~* -@all +@read +ping +info +client +config|get &gt;password 可以看的出来，ACL SETUSER 后面的命令格式与直接编辑 users.acl 文件是一样的 这里要注意 ACL SETUSER 即可以创建用户，也可以修改用户，当用户不存在时创建用户，当用户存在时修改用户，修改用户时并不会覆盖旧用户，而是会将权限进行合并，比如： 1234# 第一次执行ACL SETUSER testuser on ~* -@all +@read +ping &gt;password# 第二次执行，只添加新的权限ACL SETUSER testuser +info +client +config|get 运行后的结果 1&quot;user testuser on sanitize-payload #5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 ~* resetchannels -@all +@read +ping +info +client +config|get&quot; 修改用户权限 重置权限 1234# 重置所有权限ACL SETUSER testuser reset## 运行结果：去除所有频道和命令权限，禁止登录&quot;user testuser off sanitize-payload resetchannels -@all&quot; 取消密码，但保留权限 123ACL SETUSER testuser nopass## 运行结果：取消密码&quot;user testuser on nopass sanitize-payload ~* resetchannels -@all +@read +ping&quot; 去除所有频道 1ACL SETUSER testuser resetchannels 去除所有selectors，关于selectors后面会详细介绍 1ACL SETUSER testuser clearselectors ACL LIST 可以通过如下命令查看当前 Redis 中所有的用户 123456ACL LIST## 输出1) &quot;user admin on sanitize-payload #8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92 ~* &amp;* +@all&quot;2) &quot;user appuser on sanitize-payload #5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 ~cache:* resetchannels &amp;app:* -@all +get +set&quot;3) &quot;user default off sanitize-payload resetchannels -@all&quot;4) &quot;user readonly on sanitize-payload #5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 ~* resetchannels -@all +@read +ping +info +client +config|get&quot; 这里显示的并不是设置权限时的命令格式，而是经过翻译后的命令格式 123456789user: 固定前缀username: 用户名on: 启用sanitize-payload: 是在用 RESTORE 命令导入 RDB 数据时，帮你“体检 + 消毒 + 清洗”这份数据，防止恶意内容被导进去。#xxx: 密码的加密哈希值（通常是 SHA-256）, &gt;xxx = 明文密码，两种方式都可以，但推荐使用哈希值，实际上我们可以先通过明文配置，然后通过 ACL SAVE 命令保存就会将密码变成哈希值了~pattern: key 匹配模式，~*：匹配所有 key，~cache:*： 匹配 cache: 开头的所有 keyresetchannels: 重置频道权限，就是先删除所有频道权限，后面根据 &amp; 的配置再添加新的频道权限。&amp;pattern: 频道匹配模式，&amp;*：匹配所有频道，&amp;app:*：匹配 app:* 开头的所有频道，通道就是 pub/sub 的频道+command: 允许的命令，可以直接输入命令名称，如 +get +set，子命令 +config|get，也可以是命令的类别，命令类别 通过 acl cat 命令查看，以@开头，比如 @read @write，+ 表示允许命令，- 表示禁止命令 ACL LOAD 当通过 ACL SETUSER 创建用户时，可以通过如下命令将其保存到 users.acl 文件中 1ACL SAVE 此时保存的文件内容就是 ACL LIST 命令的输出 ACL SAVE 当修改了 users.acl 文件后，可以通过如下命令将其重新加载到 Redis 中 1ACL LOAD ACL USERS 列出所有已创建的用户 123456ACL USERS## 输出1) &quot;admin&quot;2) &quot;appuser&quot;3) &quot;default&quot;4) &quot;readonly&quot; ACL GETUSER 获取指定用户的权限信息 123456789101112131415ACL GETUSER appuser## 输出1) &quot;flags&quot; 2) 1) &quot;on&quot; 2) &quot;sanitize-payload&quot; 3) &quot;passwords&quot; 4) 1) &quot;5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8&quot; 5) &quot;commands&quot; 6) &quot;-@all +get +set&quot; 7) &quot;keys&quot; 8) &quot;~cache:*&quot; 9) &quot;channels&quot;10) &quot;&amp;app:*&quot;11) &quot;selectors&quot;12) (empty array) selectors(选择器规则) 这里看到最后有一个selectors，这个是Redis 7.0 引入的一个新能力，它允许一个用户同时拥有多套不同的 ACL 规则，而不是只能有一套规则。 以前 = 一个用户一条规则 12# 根权限（全局规则）ACL SETUSER selectoruser on ~cache:* +get +set 现在 = 一个用户可以有多个“权限分身” 12345# 选择器规则# 注意命令最后的两个()，这里设置了两个规则，每个()代表一个规则，根据不同的key前缀授予用户不同的权限ACL SETUSER selectoruser on (~cache:* +get) (~session:* +get +set) &gt;123456## 翻译后的结果&quot;user selectoruser on sanitize-payload resetchannels -@all (~cache:* resetchannels -@all +get) (~session:* resetchannels -@all +get +set)&quot; &gt;123456 如果一个用户同时拥有 根权限规则 和 选择器规则，则 选择器规则 优先级更高。 ACL DELUSER 删除一个用户 1ACL DELUSER 用户名 ACL WHOAMI 获取当前登录的用户名 1ACL WHOAMI ACL CAT 获取所有权限类别 前面我们在为用户授权时介绍过，@ 后面跟的是一个权限类别，比如 @all、@dangerous，你可以理解为其是一组权限(命令)的集合。 ACL CAT 命令可以获取所有权限类别，然后你可以根据需要选择需要的权限类别。 1234# 获取所有权限类别ACL CAT# 获取指定类别中的命令列表ACL CAT 分类名称 这里有一个特殊的权限类别 @all 并不在列出的权限类别中，其表示所有命令。 ACL DRYRUN ACL DRYRUN 命令可以模拟执行命令，并返回模拟结果，并不是真的执行命令。 Redis 7.0.0 新增。 123456&gt; ACL SETUSER VIRGINIA +SET ~*&quot;OK&quot;&gt; ACL DRYRUN VIRGINIA SET foo bar&quot;OK&quot;&gt; ACL DRYRUN VIRGINIA GET foo&quot;User VIRGINIA has no permissions to run the &#x27;get&#x27; command&quot; ACL LOG ACL LOG 命令可以查看 ACL 命令执行日志。 它记录了 ACL（访问控制）相关的事件，也就是用户在操作被拒绝或触发 ACL 规则时的行为记录。 12ACL LOG # 查看默认最新的 ACL 日志条目ACL LOG RESET # 清空 ACL 日志 日志格式 123456789101) &quot;count&quot; =&gt; 1 2) &quot;reason&quot; =&gt; &quot;command&quot; 3) &quot;context&quot; =&gt; &quot;toplevel&quot; 4) &quot;object&quot; =&gt; &quot;acl|log&quot; 5) &quot;username&quot; =&gt; &quot;selectoruser&quot; 6) &quot;age-seconds&quot; =&gt; 1589.819 7) &quot;client-info&quot; =&gt; &quot;id=8 addr=127.0.0.1:56424 laddr=127.0.0.1:6379 fd=11 name= age=1390 idle=0 flags=N db=0 ... cmd=acl|log user=selectoruser ...&quot; 8) &quot;entry-id&quot; =&gt; 3 9) &quot;timestamp-created&quot; =&gt; 1765089007352 10) &quot;timestamp-last-updated&quot; =&gt; 1765089007352 字段 含义 count 触发该日志的次数。比如同一事件触发 1 次就是 1 reason 日志触发的原因，通常是 command 表示某个命令被执行或被 ACL 检查 context 执行命令的上下文，toplevel 表示直接在客户端执行 object 触发事件的对象，例如 acl|log表示执行了ACL LOG 命令，acl|list表示执行了ACL LIST username 触发事件的用户 age-seconds 事件距离当前的时间（秒），越大表示越久远 client-info 客户端详细信息，包括客户端 ID、IP 地址、端口、本地地址、文件描述符、客户端名称、DB、执行命令等 entry-id 日志条目 ID timestamp-created 日志创建时间（毫秒） timestamp-last-updated 日志最后更新时间（毫秒） ACL GENPASS 生成一个随机的 ACL 密码 生成复杂密码的工具有很多，没必要用这玩意。 该命令的输出是二进制字符串的十六进制表示形式。默认情况下，它会生成 256 位（即 64 个十六进制字符）。用户可以通过提供一个参数来指定生成的位数，范围从 1 到 1024 位，以改变输出长度。需要注意的是，所提供的位数总是会向上取整到 4 的倍数。例如，如果请求生成 1 位密码，实际上会生成 4 位，并以 单个十六进制字符的形式输出。 123456789# 默认64个十六进制字符，相当于 ACL GENPASS 256&gt; ACL GENPASS&quot;dd721260bfe1b3d9601e7fbab36de6d04e2e67b0ef1c53de59d45950db0dd3cc&quot;# 指定长度，32/4 = 8&gt; ACL GENPASS 32&quot;355ef3dd&quot;# 指定长度，5 向上取4的倍数，就是 8，长度就是 8/4 = 2&gt; ACL GENPASS 5&quot;90&quot;","summary":"摘要 Redis 7 + ACL 简介 本文基于redis-7.4.7 Redis官网：https://redis.io/","date_published":"2025-12-07T13:30:05.000Z","tags":["技术","redis","redis","redis cluster"]},{"id":"https://blog.hanqunfeng.com/2025/12/05/redis7-config/","url":"https://blog.hanqunfeng.com/2025/12/05/redis7-config/","title":"Redis 7 + ACL 单节点、主从、哨兵、集群构建方法","content_html":"<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">Redis 7 + ACL 单节点、主从、哨兵、集群构建方法</li>\n<li class=\"lvl-2\">本文基于<code>redis-7.4.7</code></li>\n<li class=\"lvl-2\">传统的非ACL版本，可以参考 <a href=\"/2022/09/09/redis5-config/\" title=\"Redis单节点、主从、哨兵、集群构建方法\">Redis单节点、主从、哨兵、集群构建方法</a></li>\n<li class=\"lvl-2\">Redis官网：<a href=\"https://redis.io/\">https://redis.io/</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"redis安装\">redis安装</h2>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载到指定目录</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> -p /usr/local/soft</span><br><span class=\"line\">wget https://download.redis.io/releases/redis-7.4.7.tar.gz -P /usr/local/soft</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 解压</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /usr/local/soft</span><br><span class=\"line\">tar -zxvf redis-7.4.7.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 编译</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> yum install gcc gcc-c++ -y</span><br><span class=\"line\"><span class=\"built_in\">cd</span> redis-7.4.7</span><br><span class=\"line\"><span class=\"comment\"># 编译，会将编译好的可执行文件放在src目录下</span></span><br><span class=\"line\">make</span><br><span class=\"line\"><span class=\"comment\"># 编译安装到指定目录，redis相关命令会被安装到 $(pwd)/build_dir/bin目录下</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> build_dir</span><br><span class=\"line\">make install PREFIX=$(<span class=\"built_in\">pwd</span>)/build_dir</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 编辑配置文件，不建议在原有配置文件中修改，可以新建一个配置文件</span></span><br><span class=\"line\"><span class=\"built_in\">cp</span> redis.conf redis-6379.conf</span><br><span class=\"line\">vim redis-6379.conf <span class=\"comment\">#见下面的配置信息</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 加入环境变量 /etc/bashrc，注意这里要是单引号，否则 $PATH 会被解析</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;export PATH=$PATH:/usr/local/soft/redis-7.4.7/build_dir/bin&#x27;</span> &gt;&gt; /etc/bashrc</span><br><span class=\"line\"><span class=\"built_in\">source</span> /etc/bashrc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 验证</span></span><br><span class=\"line\">redis-cli --version</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">redis-cli 7.4.7</span><br></pre></td></tr></table></figure>\n<h2 id=\"单节点\">单节点</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>redis-6379.conf</code> 的主要配置</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 端口，默认 6379</span></span><br><span class=\"line\">port 6379</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 后台启动，默认 no</span></span><br><span class=\"line\">daemonize <span class=\"built_in\">yes</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># yes: 当没有 bind / requirepass / ACL 时，只允许本机访问</span></span><br><span class=\"line\"><span class=\"comment\"># no: 允许任意访问</span></span><br><span class=\"line\"><span class=\"comment\"># 这里会启用ACL，所以设置为 yes，默认 yes</span></span><br><span class=\"line\">protected-mode <span class=\"built_in\">yes</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 注释掉bind，绑定的是自己机器网卡的ip，如果有多块网卡可以配多个ip,代表允许客户端通过机器的哪些网卡ip去访问，内网一般可以不配置</span></span><br><span class=\"line\"><span class=\"comment\">#bind 127.0.0.1</span></span><br><span class=\"line\"><span class=\"comment\"># 可以配置为，本机IP 内网IP 外网IP</span></span><br><span class=\"line\"><span class=\"comment\"># bind 127.0.0.1 10.250.0.103 18.163.188.20</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 关闭rdb快照，因为会启用混合持久化，所以这里不需要开启rdb快照</span></span><br><span class=\"line\"><span class=\"comment\"># 这里只是关闭了自动快照，如果手动执行了 bgsave 命令，还是会生成一个 dump.rdb 文件</span></span><br><span class=\"line\">save <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置dir路径，redis日志、aof和rdb文件都会生成在这个路径下，需要提前创建好这个目录</span></span><br><span class=\"line\"><span class=\"built_in\">dir</span> /usr/local/soft/dir-redis7/6379</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 开启aof，实际上只需要开启这个配置，以下aof相关配置默认即可，默认 no</span></span><br><span class=\"line\"><span class=\"comment\"># 开启aof，重启redis时，会主动加载 appendonlydir 下的 相关 aof文件进行数据恢复</span></span><br><span class=\"line\"><span class=\"comment\"># 生成环境必须开启</span></span><br><span class=\"line\">appendonly <span class=\"built_in\">yes</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># aof文件名称，默认 appendonly.aof</span></span><br><span class=\"line\">appendfilename <span class=\"string\">&quot;appendonly.aof&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># aof文件保存目录，基于为当前dir路径，默认值就是 appendonlydir</span></span><br><span class=\"line\"><span class=\"comment\"># redis6+会生成3个文件，每个文件都以 appendfilename 配置的文件名称开头，如下：</span></span><br><span class=\"line\"><span class=\"comment\"># appendonly.aof.N.base.rdb：每次触发aof重写时都会生成这个文件，N是当前aof文件序号，base.rdb是当前rdb文件</span></span><br><span class=\"line\"><span class=\"comment\"># appendonly.aof.N.incr.aof：记录每个写操作命令</span></span><br><span class=\"line\"><span class=\"comment\"># appendonly.aof.manifest：记录 base.rdb 和 incr.aof 文件的最新索引(N)</span></span><br><span class=\"line\">appenddirname <span class=\"string\">&quot;appendonlydir&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># aof将数据fsync到磁盘的策略，默认即可，表示每秒一次，故障时最多会丢失一秒的数据，默认 everysec</span></span><br><span class=\"line\">appendfsync everysec</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 自动触发aof重写需要满足如下条件，如果需要手动触发aof重写，可以执行 BGREWRITEAOF 命令</span></span><br><span class=\"line\"><span class=\"comment\"># 重写时会删除旧的 appendonly.aof.N.base.rdb(RDB 快照) 文件，生成新的 appendonly.aof.N+1.base.rdb</span></span><br><span class=\"line\"><span class=\"comment\"># 当 AOF 重写完成后，当前的 appendonly.aof.N.incr.aof 会封存，Redis 会新建一个 appendonly.aof.N+1.incr.aof 来继续记录写命令</span></span><br><span class=\"line\"><span class=\"comment\"># 而此时 appendonly.aof.manifest(索引文件) 也会记录最新的 appendonly.aof.N.incr.aof 和 appendonly.aof.N.base.rdb</span></span><br><span class=\"line\"><span class=\"comment\"># aof文件至少要达到64M才会自动重写，文件太小恢复速度本来就很快，重写的意义不大，默认即可，默认 64mb</span></span><br><span class=\"line\">auto-aof-rewrite-min-size 64mb</span><br><span class=\"line\"><span class=\"comment\"># aof文件自上一次重写后文件大小增长了100%则再次触发重写，默认 100</span></span><br><span class=\"line\">auto-aof-rewrite-percentage 100</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 开启混合持久化，4.0以后版本支持，需要先开启aof，默认 yes</span></span><br><span class=\"line\"><span class=\"comment\"># 开启混合持久化后，appendonly.aof.N.base.rdb 的文件后缀就是 rdb，否则是 aof</span></span><br><span class=\"line\">aof-use-rdb-preamble <span class=\"built_in\">yes</span></span><br><span class=\"line\"><span class=\"comment\"># 防止 AOF 意外截断导致 Redis 起不来，默认 yes</span></span><br><span class=\"line\">aof-load-truncated <span class=\"built_in\">yes</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># pid文件路径，默认 /var/run/redis_6379.pid</span></span><br><span class=\"line\">pidfile <span class=\"string\">&quot;redis_6379.pid&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 日志文件名称，默认 &quot;&quot;</span></span><br><span class=\"line\">logfile <span class=\"string\">&quot;6379.log&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定最大内存，单位bytes，这里设置4G</span></span><br><span class=\"line\"><span class=\"comment\"># 如果不设置最大内存，redis会默认为物理内存，达到上限时会频繁与磁盘发生交换，使redis性能急剧下降</span></span><br><span class=\"line\">maxmemory 4294967296</span><br><span class=\"line\"><span class=\"comment\"># 达到最大内存时的清除策略，推荐 allkeys-lru，淘汰很久没被访问过的数据，基于最近一次的访问时间</span></span><br><span class=\"line\"><span class=\"comment\"># volatile-lru: 只会淘汰「设置了过期时间」的 key</span></span><br><span class=\"line\"><span class=\"comment\"># allkeys-lru: 淘汰最久没有被访问过的数据，最近最久没被访问的</span></span><br><span class=\"line\"><span class=\"comment\"># allkeys-lfu: 淘汰最不经常被访问过的数据，访问次数最少的</span></span><br><span class=\"line\"><span class=\"comment\"># noeviction: 不淘汰，默认</span></span><br><span class=\"line\">maxmemory-policy allkeys-lru</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 慢查询日志</span></span><br><span class=\"line\"><span class=\"comment\"># 单位微妙，这里表示10毫秒，即超过10毫秒的操作都会记录下来</span></span><br><span class=\"line\">slowlog-log-slower-than 10000</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置慢查询日志记录保存数量，如果数量已满会删除最早的记录</span></span><br><span class=\"line\">slowlog-max-len 1024</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 性能优化</span></span><br><span class=\"line\"><span class=\"comment\"># Redis 用多少附加线程来处理网络 I/O（不是执行命令），推荐：核心数 / 2，默认为1，超过 8 几乎就没有明显收益了</span></span><br><span class=\"line\">io-threads 4</span><br><span class=\"line\"><span class=\"comment\"># 多线程同时用于 读取 + 写回， no ：多线程仅用于 写回客户端</span></span><br><span class=\"line\"><span class=\"comment\"># 推荐&gt;=4核才开启，否则开了反而更慢</span></span><br><span class=\"line\">io-threads-do-reads <span class=\"built_in\">yes</span></span><br><span class=\"line\"><span class=\"comment\"># 操作系统 TCP 层的健康检测，默认值300，这里如果 60 秒内没有数据流动，内核会发送探测包，判断连接是否活着</span></span><br><span class=\"line\">tcp-keepalive 60</span><br><span class=\"line\"><span class=\"comment\"># 客户端在 &quot;多少秒不操作&quot; 就强制断开，0：永不超时（推荐）,默认 0</span></span><br><span class=\"line\"><span class=\"comment\"># 因为有 tcp-keepalive 60，会每 60 秒检测一下对面还在不在，如果不在，Redis 会主动断开该连接，所以不会导致连接永不释放</span></span><br><span class=\"line\"><span class=\"built_in\">timeout</span> 0</span><br><span class=\"line\"><span class=\"comment\"># 最大客户端连接数，默认 10000</span></span><br><span class=\"line\">maxclients 10000</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 禁用危险命令，根据需要自行添加，redis6+ 支持在 acl 文件中为不同的用户禁用危险命令</span></span><br><span class=\"line\">rename-command FLUSHALL <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">rename-command FLUSHDB <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># rename-command SHUTDOWN &quot;&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># rename-command CONFIG &quot;&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># rename-command KEYS &quot;&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># rename-command SAVE &quot;&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># rename-command BGSAVE &quot;&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># rename-command DEBUG &quot;&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># rename-command EVAL &quot;&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># rename-command SCRIPT &quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Redis 在内部存在大量“隐式删除”场景（过期、覆盖写、eviction、rename、replication flush 等）。默认情况下，这些删除都是同步阻塞的（类似 DEL），可能导致主线程卡顿。Lazy Freeing 机制允许 Redis 在后台线程中释放大对象的内存（类似 UNLINK），从而减少阻塞。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 当启用 maxmemory + eviction 策略（如 allkeys-lru、volatile-ttl）时，被淘汰的 key 是否采用异步释放（后台线程 UNLINK 模式）。适用场景：高吞吐、高并发、大对象（如大型 hash、set、zset、列表）场景才明显受益。</span></span><br><span class=\"line\">lazyfree-lazy-eviction <span class=\"built_in\">yes</span></span><br><span class=\"line\"><span class=\"comment\"># 当 key 到期（EXPIRE 触发删除）时，是否异步释放其 Value。各种使用带 TTL 的缓存系统，尤其 value 是大型对象（JSON、大 Set、Hash 等）。过期 key 数量大、对象结构大时，推荐开启。</span></span><br><span class=\"line\">lazyfree-lazy-expire <span class=\"built_in\">yes</span></span><br><span class=\"line\"><span class=\"comment\"># 针对“服务器内部因命令副作用导致的删除操作”是否异步释放，例如：</span></span><br><span class=\"line\"><span class=\"comment\">#    RENAME 替换旧 key 时删除旧 value</span></span><br><span class=\"line\"><span class=\"comment\">#    SET 操作覆盖旧值时删除旧 value</span></span><br><span class=\"line\"><span class=\"comment\">#    SUNIONSTORE / SORT STORE 覆盖目标 key 时删除旧 value</span></span><br><span class=\"line\"><span class=\"comment\">#    重写函数、脚本时删除旧对象</span></span><br><span class=\"line\"><span class=\"comment\"># 适用场景：对象特别大，且存在覆盖写、rename 操作频繁的应用。</span></span><br><span class=\"line\">lazyfree-lazy-server-del <span class=\"built_in\">yes</span></span><br><span class=\"line\"><span class=\"comment\"># 当副本（Replica/Slave）因全量同步而执行 FLUSHDB 时，是否异步释放原有数据。</span></span><br><span class=\"line\"><span class=\"comment\"># 此配置只影响副本不会影响主节点。</span></span><br><span class=\"line\">replica-lazy-flush <span class=\"built_in\">yes</span></span><br><span class=\"line\"><span class=\"comment\"># 让用户执行 DEL 时也自动使用异步释放（等价于默认把 DEL 转换为 UNLINK）。</span></span><br><span class=\"line\"><span class=\"comment\"># 代码中大量使用 DEL 删除大对象又不方便统一改成 UNLINK 时。</span></span><br><span class=\"line\"><span class=\"comment\"># 一般生产环境我们倾向保持显式的语义（DEL/UNLINK），不建议轻易改写 DEL 行为。</span></span><br><span class=\"line\">lazyfree-lazy-user-del no</span><br><span class=\"line\"><span class=\"comment\"># FLUSHDB / FLUSHALL / SCRIPT FLUSH / FUNCTION FLUSH 在未显式指定 SYNC/ASYNC 时是否异步执行</span></span><br><span class=\"line\"><span class=\"comment\"># 大部分情况下建议保持 no，由应用决定是否用 FLUSHDB ASYNC。</span></span><br><span class=\"line\">lazyfree-lazy-user-flush no</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 开启 ACL 文件</span></span><br><span class=\"line\">aclfile /usr/local/soft/redis-7.4.7/users.acl</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Redis 7 支持的淘汰策略</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>策略</th>\n<th>是否只淘汰带 TTL 的 key</th>\n<th>淘汰规则</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>noeviction</strong></td>\n<td>❌ 不淘汰</td>\n<td>不删任何 key</td>\n<td>内存满了直接返回错误（默认）</td>\n</tr>\n<tr>\n<td><strong>allkeys-lru</strong></td>\n<td>❌ 所有 key</td>\n<td>最近最久未使用</td>\n<td>✅ 最常用</td>\n</tr>\n<tr>\n<td><strong>allkeys-lfu</strong></td>\n<td>❌ 所有 key</td>\n<td>访问频率最少</td>\n<td>✅ 热点场景最好</td>\n</tr>\n<tr>\n<td><strong>allkeys-random</strong></td>\n<td>❌ 所有 key</td>\n<td>随机删除</td>\n<td>❌ 很少用</td>\n</tr>\n<tr>\n<td><strong>volatile-lru</strong></td>\n<td>✅ 只淘汰有 TTL 的</td>\n<td>最近最久未使用</td>\n<td>你之前用的</td>\n</tr>\n<tr>\n<td><strong>volatile-lfu</strong></td>\n<td>✅ 只淘汰有 TTL 的</td>\n<td>访问频率最少</td>\n<td>较少使用</td>\n</tr>\n<tr>\n<td><strong>volatile-random</strong></td>\n<td>✅ 只淘汰有 TTL 的</td>\n<td>随机删除</td>\n<td>很少用</td>\n</tr>\n<tr>\n<td><strong>volatile-ttl</strong></td>\n<td>✅ 只淘汰有 TTL 的</td>\n<td>TTL 最小（马上过期的）</td>\n<td>特殊场景用</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>users.acl</code> 文件: 该文件不支持添加注释，所以使用时需要去掉如下注释行，关于ACL的详细说明，可以参考 <a href=\"/2025/12/07/redis7-acl/\" title=\"Redis 7 + ACL 简介\">Redis 7 + ACL 简介</a></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 关闭默认用户，禁止匿名访问</span></span><br><span class=\"line\">user default off</span><br><span class=\"line\"><span class=\"comment\"># 超级管理员</span></span><br><span class=\"line\">user admin on ~* &amp;* +@all &gt;123456</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>redis 服务启动与关闭</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启动服务</span></span><br><span class=\"line\">redis-server redis-6379.conf</span><br><span class=\"line\"><span class=\"comment\"># 登录服务，本机访问可以省略 -h -p</span></span><br><span class=\"line\">redis-cli -h 127.0.0.1 -p 6379 --user admin --pass 123456</span><br><span class=\"line\"><span class=\"comment\"># 或者</span></span><br><span class=\"line\">redis-cli -u redis://admin:123456@127.0.0.1:6379</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 关闭服务</span></span><br><span class=\"line\"><span class=\"comment\"># shutdown == shutdown save</span></span><br><span class=\"line\">redis-cli -u redis://admin:123456@127.0.0.1:6379 shutdown</span><br><span class=\"line\"><span class=\"comment\"># 关闭服务，不保存数据，已经开了 AOF（尤其是 everysec) 的场景下，可以</span></span><br><span class=\"line\">redis-cli -u redis://admin:123456@127.0.0.1:6379 shutdown nosave</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>推荐命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>正常下线（生产）</td>\n<td><code>shutdown nosave</code></td>\n</tr>\n<tr>\n<td>已开 AOF</td>\n<td><code>shutdown nosave</code></td>\n</tr>\n<tr>\n<td>数据很大</td>\n<td><code>shutdown nosave</code></td>\n</tr>\n<tr>\n<td>单机调试</td>\n<td><code>shutdown</code></td>\n</tr>\n<tr>\n<td>确定要生成快照</td>\n<td><code>shutdown save</code></td>\n</tr>\n<tr>\n<td>强制杀死(redis卡死)</td>\n<td><code>kill -9</code>（极端情况）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"单节点优点\">单节点优点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>单机部署简单方便</p>\n</li>\n</ul>\n<h3 id=\"单节点缺点\">单节点缺点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>不保证数据的可靠性，不适用于数据可靠性要求高的场景</p>\n</li>\n<li class=\"lvl-2\">\n<p>单点故障导致无法提供服务，或者硬盘损坏导致数据丢失</p>\n</li>\n<li class=\"lvl-2\">\n<p>redis单节点最大qps为10w(取决于单核cpu的处理能力)，超过这个qps就需要做前端限流</p>\n</li>\n</ul>\n<h2 id=\"主从\">主从</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>规划</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">master 10.250.0.235</span><br><span class=\"line\">slave1 10.250.0.58</span><br><span class=\"line\">slave2 10.250.0.36</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>主从配置时，主节点不需要做任何修改</p>\n</li>\n<li class=\"lvl-2\">\n<p>从节点配置文件增加同步主节点信息，其余配置与主节点相同</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 指定主节点，从节点会从主节点同步数据，这里10.250.0.235 6379是主节点的ip和端口号</span></span><br><span class=\"line\">replicaof 10.250.0.235 6379</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置从节点只读，默认开启，避免数据写入从节点导致主从数据不一致</span></span><br><span class=\"line\">replica-read-only <span class=\"built_in\">yes</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果主节点开启了ACL认证，则从节点需要设置主节点的认证信息，这里设置为管理员帐号</span></span><br><span class=\"line\">masteruser admin</span><br><span class=\"line\">masterauth 123456</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时启动从节点<code>redis-server redis-6379.conf</code>，会自动从主节点同步数据，同步前如果从节点已经有数据，则会先清除原有数据再进行同步</p>\n</li>\n<li class=\"lvl-2\">\n<p>主节点接收到从节点的同步请求后，会通过bgsave将内存数据dump到rdb文件中并传递给从节点</p>\n</li>\n<li class=\"lvl-2\">\n<p>主节点生成rdb文件并传递给从节点期间会继续处理客户端的请求，并将这部分数据缓存到内存中，待从节点接收到主节点发过来的rdb文件并完成内存加载后，主节点会将这部分缓存在内存中的数据发送给从节点</p>\n</li>\n<li class=\"lvl-2\">\n<p>从节点相当于主节点的备份，主节点挂了，从节点不能自动切换为主节点，如果需要自动切换，可以使用哨兵或者集群部署方式</p>\n</li>\n<li class=\"lvl-2\">\n<p>此时登录master的redis并执行<code>info replication</code>命令</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Replication</span></span><br><span class=\"line\">role:master     <span class=\"comment\"># 表示当前是从节点</span></span><br><span class=\"line\">connected_slaves:1 <span class=\"comment\"># 从节点数量</span></span><br><span class=\"line\">slave0:ip=10.250.0.36,port=6379,state=online,offset=56,lag=1 <span class=\"comment\"># 从节点信息</span></span><br><span class=\"line\">master_failover_state:no-failover <span class=\"comment\"># 主节点切换状态，无</span></span><br><span class=\"line\">master_replid:93e564c18d27418e52fc40254c764d76c1dc3f67 <span class=\"comment\"># 主节点的复制ID</span></span><br><span class=\"line\">master_replid2:0000000000000000000000000000000000000000</span><br><span class=\"line\">master_repl_offset:56  <span class=\"comment\"># 主节点复制的偏移量</span></span><br><span class=\"line\">second_repl_offset:-1</span><br><span class=\"line\">repl_backlog_active:1  <span class=\"comment\"># 是否开启复制回放</span></span><br><span class=\"line\">repl_backlog_size:1048576 <span class=\"comment\"># 复制回放缓冲区大小</span></span><br><span class=\"line\">repl_backlog_first_byte_offset:1 <span class=\"comment\"># 复制回放缓冲区第一个字节的偏移量</span></span><br><span class=\"line\">repl_backlog_histlen:56 <span class=\"comment\"># 复制回放缓冲区历史长度</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时登录从节点的redis并执行<code>info replication</code>命令</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Replication</span></span><br><span class=\"line\">role:slave               <span class=\"comment\"># 表示当前是从节点</span></span><br><span class=\"line\">master_host:10.250.0.235 <span class=\"comment\"># 主节点的ip</span></span><br><span class=\"line\">master_port:6379         <span class=\"comment\"># 主节点的端口</span></span><br><span class=\"line\">master_link_status:up    <span class=\"comment\"># 主从节点连接状态，up 表示已经连接上主节点</span></span><br><span class=\"line\">master_last_io_seconds_ago:6 <span class=\"comment\"># 主从节点最后一次io操作时间</span></span><br><span class=\"line\">master_sync_in_progress:0 <span class=\"comment\"># 主从节点是否正在同步数据，0表示已完成</span></span><br><span class=\"line\">slave_read_repl_offset:112 <span class=\"comment\"># 从节点已经读取的复制偏移量</span></span><br><span class=\"line\">slave_repl_offset:112   <span class=\"comment\"># 从节点已经写入的复制偏移量</span></span><br><span class=\"line\">slave_priority:100      <span class=\"comment\"># 从节点的优先级</span></span><br><span class=\"line\">slave_read_only:1       <span class=\"comment\"># 从节点是否只读</span></span><br><span class=\"line\">replica_announced:1     <span class=\"comment\"># 从节点是否被其他节点所代理</span></span><br><span class=\"line\">connected_slaves:0      <span class=\"comment\"># 从节点所代理的从节点数量</span></span><br><span class=\"line\">master_failover_state:no-failover <span class=\"comment\"># 主节点的故障转移状态，no-failover表示没有进行故障转移</span></span><br><span class=\"line\">master_replid:93e564c18d27418e52fc40254c764d76c1dc3f67 <span class=\"comment\"># 主节点的复制ID</span></span><br><span class=\"line\">master_replid2:0000000000000000000000000000000000000000</span><br><span class=\"line\">master_repl_offset:112  <span class=\"comment\"># 主节点已经写入的复制偏移量 slave_read_repl_offset ≈ master_repl_offset，说明数据已经同步</span></span><br><span class=\"line\">second_repl_offset:-1</span><br><span class=\"line\">repl_backlog_active:1</span><br><span class=\"line\">repl_backlog_size:1048576</span><br><span class=\"line\">repl_backlog_first_byte_offset:15</span><br><span class=\"line\">repl_backlog_histlen:98</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>主从数据同步是否完成判断规则，在从节点上执行命令<code>info replication</code></p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>正常值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>role</code></td>\n<td>slave</td>\n<td>表示当前是从节点</td>\n</tr>\n<tr>\n<td><code>master_link_status</code></td>\n<td>up</td>\n<td>表示已经连上主库</td>\n</tr>\n<tr>\n<td><code>master_sync_in_progress</code></td>\n<td>0</td>\n<td>同步不在进行中 = 已完成</td>\n</tr>\n<tr>\n<td><code>slave_read_repl_offset</code> ≈ <code>master_repl_offset</code></td>\n<td>接近</td>\n<td>说明数据已追上</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>参照上面的配置，再添加一个从节点后，在主节点执行命令 <code>info replication</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Replication</span></span><br><span class=\"line\">role:master</span><br><span class=\"line\">connected_slaves:2  <span class=\"comment\"># 从节点数量</span></span><br><span class=\"line\">slave0:ip=10.250.0.36,port=6379,state=online,offset=4313,lag=0</span><br><span class=\"line\">slave1:ip=10.250.0.58,port=6379,state=online,offset=4313,lag=0  <span class=\"comment\"># 第二个从节点信息</span></span><br><span class=\"line\">master_failover_state:no-failover</span><br><span class=\"line\">master_replid:93e564c18d27418e52fc40254c764d76c1dc3f67</span><br><span class=\"line\">master_replid2:0000000000000000000000000000000000000000</span><br><span class=\"line\">master_repl_offset:4313</span><br><span class=\"line\">second_repl_offset:-1</span><br><span class=\"line\">repl_backlog_active:1</span><br><span class=\"line\">repl_backlog_size:1048576</span><br><span class=\"line\">repl_backlog_first_byte_offset:1</span><br><span class=\"line\">repl_backlog_histlen:4313</span><br></pre></td></tr></table></figure>\n<h3 id=\"主从优点\">主从优点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>对请求进行读写分离，提高处理效率</p>\n</li>\n<li class=\"lvl-2\">\n<p>可以提供多个副本，提高数据安全性</p>\n</li>\n</ul>\n<h3 id=\"主从缺点\">主从缺点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>不具备自动容错和恢复功能，主节点故障，集群则无法进行工作，可用性比较低，从节点升主节点需要人工手动干预</p>\n</li>\n</ul>\n<h2 id=\"哨兵\">哨兵</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建三个哨兵，为了方便就在上面主从配置的3台服务器上启动哨兵</p>\n</li>\n<li class=\"lvl-2\">\n<p>规划</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">master 10.250.0.235</span><br><span class=\"line\">slave1 10.250.0.58</span><br><span class=\"line\">slave2 10.250.0.36</span><br><span class=\"line\">sentinel1 10.250.0.71</span><br><span class=\"line\">sentinel2 10.250.0.131</span><br><span class=\"line\">sentinel3 10.250.0.63</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>分别编辑各自的 <code>sentinel.conf</code></p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 端口号</span></span><br><span class=\"line\">port 26379</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 后台启动</span></span><br><span class=\"line\">daemonize <span class=\"built_in\">yes</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># dir，需要提前创建好</span></span><br><span class=\"line\"><span class=\"built_in\">dir</span> /usr/local/soft/dir-redis7/sentinel</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># pid文件路径</span></span><br><span class=\"line\">pidfile redis-sentinel.pid</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 日志文件名称</span></span><br><span class=\"line\">logfile <span class=\"string\">&quot;sentinel.log&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置监听的主节点地址和端口，mymaster为自定义的名称，最后的2表示，只要有2个哨兵节点认为主节点挂了就会进行重新选主，一般设置为sentinel总数/2+1</span></span><br><span class=\"line\">sentinel monitor mymaster 10.250.0.235 6379 2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 主观下线时间（5秒），默认30秒</span></span><br><span class=\"line\">sentinel down-after-milliseconds mymaster 5000</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 故障转移超时时间 60秒，默认180秒</span></span><br><span class=\"line\">sentinel failover-timeout mymaster 60000</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 每次允许多少个slave重新同步，默认就是 1</span></span><br><span class=\"line\">sentinel parallel-syncs mymaster 1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># acl用户名和密码，这里为了方便也是用的管理员帐号</span></span><br><span class=\"line\">sentinel auth-user mymaster admin</span><br><span class=\"line\">sentinel auth-pass mymaster 123456</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>分别启动三个哨兵节点<code>redis-sentinel sentinel.conf</code>，此时登录哨兵节点<code>redis-cli -p 26379</code>，并执行<code>info Sentinel</code>命令，查看其是否正确识别了主从</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Sentinel</span></span><br><span class=\"line\">sentinel_masters:1      <span class=\"comment\"># 哨兵集群中主从节点的数量</span></span><br><span class=\"line\">sentinel_tilt:0         <span class=\"comment\"># 是否处于 tilt 状态</span></span><br><span class=\"line\">sentinel_tilt_since_seconds:-1 <span class=\"comment\"># tilt 状态的开始时间</span></span><br><span class=\"line\">sentinel_running_scripts:0 <span class=\"comment\"># 正在运行的脚本数量</span></span><br><span class=\"line\">sentinel_scripts_queue_length:0 <span class=\"comment\"># 脚本队列长度</span></span><br><span class=\"line\">sentinel_simulate_failure_flags:0 <span class=\"comment\"># 模拟故障的标志</span></span><br><span class=\"line\">master0:name=mymaster,status=ok,address=10.250.0.235:6379,slaves=2,sentinels=3 <span class=\"comment\"># 主节点的地址，从节点数量和哨兵数量</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时查看<code>sentinel.conf</code>可以在文件最后看到从节点信息和其它的哨兵节点信息(<em><strong>但实测无法感知其它哨兵节点</strong></em>)，类似于</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Generated by CONFIG REWRITE</span></span><br><span class=\"line\">latency-tracking-info-percentiles 50 99 99.9  <span class=\"comment\"># 延迟追踪信息百分比</span></span><br><span class=\"line\">user default on nopass sanitize-payload ~* &amp;* +@all <span class=\"comment\"># 用户信息，当前的哨兵没有开启权限认证，所以缺省为default用户，无密码</span></span><br><span class=\"line\">sentinel myid 8b9d55a581f2e41b4f8d92f4a9434d9b8a78b3e6 <span class=\"comment\"># 本节点的id</span></span><br><span class=\"line\">sentinel config-epoch mymaster 0</span><br><span class=\"line\">sentinel leader-epoch mymaster 0</span><br><span class=\"line\">sentinel current-epoch 0</span><br><span class=\"line\"><span class=\"comment\"># 一个从节点信息</span></span><br><span class=\"line\">sentinel known-replica mymaster 10.250.0.58 6379</span><br><span class=\"line\"><span class=\"comment\"># 另一个从节点信息</span></span><br><span class=\"line\">sentinel known-replica mymaster 10.250.0.36 6379</span><br><span class=\"line\"><span class=\"comment\"># 一个哨兵节点信息</span></span><br><span class=\"line\">sentinel known-sentinel mymaster 10.250.0.71 26379 b230f6a6076c23eed1923b29027d9ba7b24bee5a</span><br><span class=\"line\"><span class=\"comment\"># 另一个哨兵节点信息</span></span><br><span class=\"line\">sentinel known-sentinel mymaster 10.250.0.63 26379 74ef58ef3616a27cc63d83bcfe422f15e11731b8</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时关闭master节点(10.250.0.235:6379)，然后登录哨兵节点查看<code>info Sentinel</code>，就会发现master节点变成了从节点其中的一个了</p>\n</li>\n<li class=\"lvl-2\">\n<p>此时再次开启原master节点，会发现其变成了从节点，相应的配置文件(redis-6379.conf)也发生了变更</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Generated by CONFIG REWRITE</span></span><br><span class=\"line\">latency-tracking-info-percentiles 50 99 99.9</span><br><span class=\"line\">replicaof 10.250.0.36 6379</span><br><span class=\"line\">save 3600 1</span><br><span class=\"line\">save 300 100</span><br><span class=\"line\">save 60 10000</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里有一点需要注意，就是master节点重启前也需要配置如下认证信息，因为master在哨兵模式下发生故障后重新启动会变成slave</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果主节点开启了ACL认证，则从节点需要设置主节点的认证信息，这里设置为管理员帐号</span></span><br><span class=\"line\">masteruser admin</span><br><span class=\"line\">masterauth 123456</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>顺便说一下，关闭哨兵服务的命令如下：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli -p 26379 shutdown</span><br></pre></td></tr></table></figure>\n<h3 id=\"哨兵优点\">哨兵优点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>主节点故障，可以自动在从节点中重新选主</p>\n</li>\n</ul>\n<h3 id=\"哨兵缺点\">哨兵缺点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>哨兵单点故障，则集群无法完整自主选举主节点，所以需要对哨兵集群部署，增加服务器成本，但是并没有提升负载</p>\n</li>\n<li class=\"lvl-2\">\n<p>另外，主节点故障时，哨兵介入有时间差，会导致响应延迟</p>\n</li>\n<li class=\"lvl-2\">\n<p>从节点仅作为备份不提供对外服务，只有当master出现故障时其晋升为master后才能提供服务，所以不支持读写分离</p>\n</li>\n</ul>\n<h2 id=\"集群\">集群</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>搭建6个redis的集群，3主3从</p>\n</li>\n<li class=\"lvl-2\">\n<p>规划</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis1 10.250.0.235</span><br><span class=\"line\">redis2 10.250.0.58</span><br><span class=\"line\">redis3 10.250.0.36</span><br><span class=\"line\">redis4 10.250.0.71</span><br><span class=\"line\">redis5 10.250.0.131</span><br><span class=\"line\">redis6 10.250.0.63</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>还是基于单节点配置文件，只是将节点配置成集群模式，redis-6379.conf文件增加如下信息</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ACL认证，所有节点都要配置</span></span><br><span class=\"line\">masteruser <span class=\"string\">&quot;admin&quot;</span></span><br><span class=\"line\">masterauth <span class=\"string\">&quot;123456&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动集群模式</span></span><br><span class=\"line\">cluster-enabled <span class=\"built_in\">yes</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 集群节点信息文件，这里最好和port对应上</span></span><br><span class=\"line\">cluster-config-file nodes-6379.conf</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 集群节点间通信的超时时间，单位毫秒，默认15000，这个时间别设置太短，避免网络抖动等原因干扰</span></span><br><span class=\"line\">cluster-node-timeout 15000</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 写数据成功最少同步的slave数量，默认数据写入master就返回给client了，加上这个配置，就需要数据同步到指定数量的slave后才能返回，</span></span><br><span class=\"line\"><span class=\"comment\"># 注意这个配置不仅会延长client的等待时间，而且可能会影响集群的可用性，比如这里配置至少同步1个slave，但是如果此时master对应可用的slave不足1个，集群就不能提供服务了，所以建议每个master至少配置了2个以上的slave时才开启这个配置</span></span><br><span class=\"line\"><span class=\"comment\"># 开启这个配置可以预防集群脑裂问题，默认为3</span></span><br><span class=\"line\">min-replicas-to-write 1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果集群中某个master/slave全部挂掉，整个集群的其它master/slave是否还可以对外提供服务，默认yes，不能</span></span><br><span class=\"line\"><span class=\"comment\"># 如果设置为no，则表示依旧可以提供服务，不过如果有key落在了挂掉的主从上就会失败</span></span><br><span class=\"line\">cluster-require-full-coverage <span class=\"built_in\">yes</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>分别启动6个redis服务</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-server redis-6379.conf</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建集群，3主3从，注意创建集群前所有redis不能有数据，如果有需要先清空(<em><strong>删除dir配置的目录中的所有文件即可</strong></em>)，然后在任意一个redis执行</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli --user admin --pass 123456 --cluster create --cluster-replicas 1 10.250.0.235:6379 10.250.0.58:6379 10.250.0.36:6379 10.250.0.71:6379 10.250.0.131:6379 10.250.0.63:6379</span><br><span class=\"line\"><span class=\"comment\"># 参数说明：</span></span><br><span class=\"line\"><span class=\"comment\"># --cluster create：创建集群</span></span><br><span class=\"line\"><span class=\"comment\"># --cluster-replicas 1：设置从节点数量，这里设置为1，表示每个主节点都对应一个从节点</span></span><br><span class=\"line\"><span class=\"comment\"># 这里配置了6个节点组建集群，要保证每个master节点都有一个从节点，所以刚好是3主3从</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时会列出集群内主从和槽位的分配方案，输入<code>yes</code>即可</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Warning: Using a password with <span class=\"string\">&#x27;-a&#x27;</span> or <span class=\"string\">&#x27;-u&#x27;</span> option on the <span class=\"built_in\">command</span> line interface may not be safe.</span><br><span class=\"line\">&gt;&gt;&gt; Performing <span class=\"built_in\">hash</span> slots allocation on 6 nodes...</span><br><span class=\"line\">Master[0] -&gt; Slots 0 - 5460</span><br><span class=\"line\">Master[1] -&gt; Slots 5461 - 10922</span><br><span class=\"line\">Master[2] -&gt; Slots 10923 - 16383</span><br><span class=\"line\">Adding replica 10.250.0.131:6379 to 10.250.0.235:6379</span><br><span class=\"line\">Adding replica 10.250.0.63:6379 to 10.250.0.58:6379</span><br><span class=\"line\">Adding replica 10.250.0.71:6379 to 10.250.0.36:6379</span><br><span class=\"line\">M: afcb754ce8cc79122fe9bcd8c1567bbf13258fce 10.250.0.235:6379</span><br><span class=\"line\">   slots:[0-5460] (5461 slots) master</span><br><span class=\"line\">M: 2527142b7cffaf6bb92608550c919a0db0607c39 10.250.0.58:6379</span><br><span class=\"line\">   slots:[5461-10922] (5462 slots) master</span><br><span class=\"line\">M: 88762f7d0bbb99bbaf68556ef5fd113cba46d295 10.250.0.36:6379</span><br><span class=\"line\">   slots:[10923-16383] (5461 slots) master</span><br><span class=\"line\">S: 547fbd934293ddb5eb770e111b65910f4e604023 10.250.0.71:6379</span><br><span class=\"line\">   replicates 88762f7d0bbb99bbaf68556ef5fd113cba46d295</span><br><span class=\"line\">S: 17b33861e6b086b86902fe75f79e5b878bd26f94 10.250.0.131:6379</span><br><span class=\"line\">   replicates afcb754ce8cc79122fe9bcd8c1567bbf13258fce</span><br><span class=\"line\">S: 119e5823cccafef506b9b256aad206678eab7d41 10.250.0.63:6379</span><br><span class=\"line\">   replicates 2527142b7cffaf6bb92608550c919a0db0607c39</span><br><span class=\"line\">Can I <span class=\"built_in\">set</span> the above configuration? (<span class=\"built_in\">type</span> <span class=\"string\">&#x27;yes&#x27;</span> to accept): <span class=\"built_in\">yes</span></span><br><span class=\"line\">&gt;&gt;&gt; Nodes configuration updated</span><br><span class=\"line\">&gt;&gt;&gt; Assign a different config epoch to each node</span><br><span class=\"line\">&gt;&gt;&gt; Sending CLUSTER MEET messages to <span class=\"built_in\">join</span> the cluster</span><br><span class=\"line\">Waiting <span class=\"keyword\">for</span> the cluster to <span class=\"built_in\">join</span></span><br><span class=\"line\">.</span><br><span class=\"line\">&gt;&gt;&gt; Performing Cluster Check (using node 10.250.0.235:6379)</span><br><span class=\"line\">M: afcb754ce8cc79122fe9bcd8c1567bbf13258fce 10.250.0.235:6379</span><br><span class=\"line\">   slots:[0-5460] (5461 slots) master</span><br><span class=\"line\">   1 additional replica(s)</span><br><span class=\"line\">S: 547fbd934293ddb5eb770e111b65910f4e604023 10.250.0.71:6379</span><br><span class=\"line\">   slots: (0 slots) slave</span><br><span class=\"line\">   replicates 88762f7d0bbb99bbaf68556ef5fd113cba46d295</span><br><span class=\"line\">S: 119e5823cccafef506b9b256aad206678eab7d41 10.250.0.63:6379</span><br><span class=\"line\">   slots: (0 slots) slave</span><br><span class=\"line\">   replicates 2527142b7cffaf6bb92608550c919a0db0607c39</span><br><span class=\"line\">S: 17b33861e6b086b86902fe75f79e5b878bd26f94 10.250.0.131:6379</span><br><span class=\"line\">   slots: (0 slots) slave</span><br><span class=\"line\">   replicates afcb754ce8cc79122fe9bcd8c1567bbf13258fce</span><br><span class=\"line\">M: 88762f7d0bbb99bbaf68556ef5fd113cba46d295 10.250.0.36:6379</span><br><span class=\"line\">   slots:[10923-16383] (5461 slots) master</span><br><span class=\"line\">   1 additional replica(s)</span><br><span class=\"line\">M: 2527142b7cffaf6bb92608550c919a0db0607c39 10.250.0.58:6379</span><br><span class=\"line\">   slots:[5461-10922] (5462 slots) master</span><br><span class=\"line\">   1 additional replica(s)</span><br><span class=\"line\">[OK] All nodes agree about slots configuration.</span><br><span class=\"line\">&gt;&gt;&gt; Check <span class=\"keyword\">for</span> open slots...</span><br><span class=\"line\">&gt;&gt;&gt; Check slots coverage...</span><br><span class=\"line\">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>登录集群并查询集群配置信息</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -c 表示以集群模式登录，-h 集群内任意ip</span></span><br><span class=\"line\">redis-cli --user admin --pass 123456 -c -h 10.250.0.235</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看集群信息</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10.250.0.235:6379&gt; cluster info</span><br><span class=\"line\"><span class=\"comment\"># 输出集群状态</span></span><br><span class=\"line\">cluster_state:ok                                <span class=\"comment\"># 集群整体状态：ok 表示集群当前可用、健康</span></span><br><span class=\"line\">cluster_slots_assigned:16384                    <span class=\"comment\"># 已分配的哈希槽数量（总槽数固定为 16384）</span></span><br><span class=\"line\">cluster_slots_ok:16384                          <span class=\"comment\"># 正常工作的槽数量（等于已分配槽，说明全部正常）</span></span><br><span class=\"line\">cluster_slots_pfail:0                           <span class=\"comment\"># 处于“疑似失败(pfail)”状态的槽数量</span></span><br><span class=\"line\">cluster_slots_fail:0                            <span class=\"comment\"># 被判定为失败(fail)的槽数量</span></span><br><span class=\"line\">cluster_known_nodes:6                           <span class=\"comment\"># 当前节点已知的集群节点总数（主节点 + 从节点）</span></span><br><span class=\"line\">cluster_size:3                                  <span class=\"comment\"># 主节点数量（3 主节点，典型的 3 主 3 从结构）</span></span><br><span class=\"line\">cluster_current_epoch:6                         <span class=\"comment\"># 集群当前的全局纪元（用于选举和配置同步）</span></span><br><span class=\"line\">cluster_my_epoch:1                              <span class=\"comment\"># 当前这个节点所在的纪元</span></span><br><span class=\"line\">cluster_stats_messages_ping_sent:159           <span class=\"comment\"># 当前节点已发送的 PING 消息数量（心跳）</span></span><br><span class=\"line\">cluster_stats_messages_pong_sent:156           <span class=\"comment\"># 当前节点已发送的 PONG 消息数量（心跳响应）</span></span><br><span class=\"line\">cluster_stats_messages_sent:315                <span class=\"comment\"># 当前节点发送的所有集群消息总数</span></span><br><span class=\"line\">cluster_stats_messages_ping_received:151       <span class=\"comment\"># 当前节点收到的 PING 消息数量</span></span><br><span class=\"line\">cluster_stats_messages_pong_received:159       <span class=\"comment\"># 当前节点收到的 PONG 消息数量</span></span><br><span class=\"line\">cluster_stats_messages_meet_received:5         <span class=\"comment\"># 当前节点收到的 MEET 消息数量（新节点加入发现）</span></span><br><span class=\"line\">cluster_stats_messages_received:315            <span class=\"comment\"># 当前节点收到的所有集群消息总数</span></span><br><span class=\"line\">total_cluster_links_buffer_limit_exceeded:0    <span class=\"comment\"># 因输出缓冲区超限被强制断开的集群连接数（0 = 正常）</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看节点列表</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10.250.0.235:6379&gt; cluster nodes</span><br><span class=\"line\"><span class=\"comment\"># 当前节点（myself），角色为 master，负责槽位 0-5460，是本机所在的主节点</span></span><br><span class=\"line\">afcb754ce8cc79122fe9bcd8c1567bbf13258fce 10.250.0.235:6379@16379 myself,master - 0 0 1 connected 0-5460</span><br><span class=\"line\"><span class=\"comment\"># 从节点（slave），对应的主节点是 10.250.0.36 这个 master（负责槽位 10923-16383）</span></span><br><span class=\"line\">547fbd934293ddb5eb770e111b65910f4e604023 10.250.0.71:6379@16379 slave 88762f7d0bbb99bbaf68556ef5fd113cba46d295 0 1765033120132 3 connected</span><br><span class=\"line\"><span class=\"comment\"># 从节点（slave），对应的主节点是 10.250.0.58 这个 master（负责槽位 5461-10922）</span></span><br><span class=\"line\">119e5823cccafef506b9b256aad206678eab7d41 10.250.0.63:6379@16379 slave 2527142b7cffaf6bb92608550c919a0db0607c39 0 1765033118000 2 connected</span><br><span class=\"line\"><span class=\"comment\"># 从节点（slave），对应的主节点是当前节点 10.250.0.235（负责槽位 0-5460）</span></span><br><span class=\"line\">17b33861e6b086b86902fe75f79e5b878bd26f94 10.250.0.131:6379@16379 slave afcb754ce8cc79122fe9bcd8c1567bbf13258fce 0 1765033119000 1 connected</span><br><span class=\"line\"><span class=\"comment\"># 主节点（master），负责槽位 10923-16383（集群中第三段槽位）</span></span><br><span class=\"line\">88762f7d0bbb99bbaf68556ef5fd113cba46d295 10.250.0.36:6379@16379 master - 0 1765033117000 3 connected 10923-16383</span><br><span class=\"line\"><span class=\"comment\"># 主节点（master），负责槽位 5461-10922（集群中第二段槽位）</span></span><br><span class=\"line\">2527142b7cffaf6bb92608550c919a0db0607c39 10.250.0.58:6379@16379 master - 0 1765033119126 2 connected 5461-10922</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时查看<code>nodes-6379.conf</code>也会看到和上面一样的节点信息</p>\n</li>\n<li class=\"lvl-2\">\n<p>此时关闭其中一个master节点，比如<code>10.250.0.36</code>，则其对应的slave节点<code>10.250.0.71</code>会切换为新的master节点，此时<code>10.250.0.36</code>的状态最终变为<code>fail</code></p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10.250.0.235:6379&gt; cluster nodes</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">afcb754ce8cc79122fe9bcd8c1567bbf13258fce 10.250.0.235:6379@16379 myself,master - 0 0 1 connected 0-5460</span><br><span class=\"line\">547fbd934293ddb5eb770e111b65910f4e604023 10.250.0.71:6379@16379 master - 0 1765033733534 7 connected 10923-16383</span><br><span class=\"line\">119e5823cccafef506b9b256aad206678eab7d41 10.250.0.63:6379@16379 slave 2527142b7cffaf6bb92608550c919a0db0607c39 0 1765033734542 2 connected</span><br><span class=\"line\">17b33861e6b086b86902fe75f79e5b878bd26f94 10.250.0.131:6379@16379 slave afcb754ce8cc79122fe9bcd8c1567bbf13258fce 0 1765033732526 1 connected</span><br><span class=\"line\">88762f7d0bbb99bbaf68556ef5fd113cba46d295 10.250.0.36:6379@16379 master,fail - 1765033690200 1765033686170 3 connected</span><br><span class=\"line\">2527142b7cffaf6bb92608550c919a0db0607c39 10.250.0.58:6379@16379 master - 0 1765033735550 2 connected 5461-10922</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>再次启动<code>10.250.0.36</code>，其会变成<code>10.250.0.71</code>的slave节点</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10.250.0.235:6379&gt; cluster nodes</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">afcb754ce8cc79122fe9bcd8c1567bbf13258fce 10.250.0.235:6379@16379 myself,master - 0 0 1 connected 0-5460</span><br><span class=\"line\">547fbd934293ddb5eb770e111b65910f4e604023 10.250.0.71:6379@16379 master - 0 1765033859000 7 connected 10923-16383</span><br><span class=\"line\">119e5823cccafef506b9b256aad206678eab7d41 10.250.0.63:6379@16379 slave 2527142b7cffaf6bb92608550c919a0db0607c39 0 1765033860493 2 connected</span><br><span class=\"line\">17b33861e6b086b86902fe75f79e5b878bd26f94 10.250.0.131:6379@16379 slave afcb754ce8cc79122fe9bcd8c1567bbf13258fce 0 1765033858000 1 connected</span><br><span class=\"line\">88762f7d0bbb99bbaf68556ef5fd113cba46d295 10.250.0.36:6379@16379 slave 547fbd934293ddb5eb770e111b65910f4e604023 0 1765033859488 7 connected</span><br><span class=\"line\">2527142b7cffaf6bb92608550c919a0db0607c39 10.250.0.58:6379@16379 master - 0 1765033859000 2 connected 5461-10922</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>若此时还是希望 <code>10.250.0.36</code> 做为主节点，则需要先登录<code>10.250.0.36</code>，再执行如下命令</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 注意要加 -c</span></span><br><span class=\"line\">redis-cli -c --user admin --pass 123456 -h 10.250.0.36</span><br><span class=\"line\">10.250.0.36:6379&gt; cluster failover <span class=\"comment\"># 安全版（等待复制同步）</span></span><br><span class=\"line\"><span class=\"comment\"># 或者</span></span><br><span class=\"line\">10.250.0.36:6379&gt; CLUSTER FAILOVER TAKEOVER <span class=\"comment\"># TAKEOVER 会立即切主，不会等待复制数据，非常强制(生产环境不推荐)</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>redis集群会将2的14次幂(16384)的slot平均分配到所有master上，然后对key进行hash后计算应该存储到那个slot</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HASH_SLOT=CRC16(key) mod 16384</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 跳转重定位</span></span><br><span class=\"line\">10.250.0.235:6379&gt; <span class=\"built_in\">set</span> name zhangsan</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">-&gt; Redirected to slot [5798] located at 10.250.0.58:6379</span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>关闭集群，6个redis分别关闭</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli -c -h 10.250.0.235 -p 6379 --user admin --pass 123456 shutdown</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>重启集群，6个redis分别启动即可</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-server redis-6379.conf</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>mset/mget要求key都落在同一个slot上，每个key都加上哈希标签（Hash Tag）-- <code>&#123;xxx&#125;</code>，其必须用<code>&#123;&#125;</code>括起来，<code>xxx</code>可以是任意字符串，计算slot时，只会根据<code>xxx</code>来计算hash值，这样就保证了所有key中包含<code>&#123;xxx&#125;</code>的key都会落到同一个slot，<code>&#123;xxx&#125;</code>可以放在key的任意位置</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10.250.0.235:6379&gt; mset name1 lisi name2 wangwu</span><br><span class=\"line\">(error) CROSSSLOT Keys <span class=\"keyword\">in</span> request don<span class=\"string\">&#x27;t hash to the same slot</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">10.250.0.235:6379&gt; mset &#123;user&#125;:name1 lisi &#123;user&#125;:name2 wangwu</span></span><br><span class=\"line\"><span class=\"string\">OK</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">10.250.0.235:6379&gt; mget &#123;user&#125;:name1 &#123;user&#125;:name2</span></span><br><span class=\"line\"><span class=\"string\">-&gt; Redirected to slot [5474] located at 10.250.0.58:6379</span></span><br><span class=\"line\"><span class=\"string\">1) &quot;lisi&quot;</span></span><br><span class=\"line\"><span class=\"string\">2) &quot;wangwu&quot;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意:<br>\n{…} 让多个 key 落在同一个 slot，支持跨 key 原子操作<br>\n只有 第一个匹配的 {…} 会被当做 tag<br>\n{} 不能嵌套<br>\n空标签 {} 是非法的<br>\n{abc} 和 {def} 就落不同 slot</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如何判断 key 落在哪个节点?</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10.250.0.235:6379&gt; cluster keyslot name1</span><br><span class=\"line\"><span class=\"comment\"># 输出的数值就表示 slot</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 5461 <span class=\"comment\"># slot值</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如何查看指定的slot中有多少个key?</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10.250.0.235:6379&gt; cluster countkeysinslot 5461</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1 <span class=\"comment\"># 表示slot中key的个数，这里显示只有1个key</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>集群推举新的master时要求至少一半的master同意，所以一个集群至少需要3个master，官方推荐master节点数为奇数，比如3个和4个master节点，都至多允许一个master节点挂掉时进行选主，但是3个master可以节省资源</p>\n</li>\n<li class=\"lvl-2\">\n<p>集群通过<code>10000+port</code>这个端口号进行集群间通信，所以除了要开放<code>prot</code>这个端口，还要开放<code>10000+port</code>这个端口</p>\n</li>\n<li class=\"lvl-2\">\n<p>有关redis集群及其水平扩展的进一步说明，可以参看<a href=\"/2018/12/27/redis-cluster/\" title=\"Redis集群\">Redis集群</a></p>\n</li>\n</ul>\n<h3 id=\"集群优点\">集群优点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>无中心架构，集群内部自行维护数据的分片和主从的切换</p>\n</li>\n<li class=\"lvl-2\">\n<p>数据分片存储，提供很高的访问效率</p>\n</li>\n<li class=\"lvl-2\">\n<p>高可用性，可实现部分节点不可用时，集群仍可用</p>\n</li>\n<li class=\"lvl-2\">\n<p>高扩展性，可以横向扩展1000个节点后依旧保证访问效率，扩容缩容都支持</p>\n</li>\n</ul>\n<h3 id=\"集群缺点\">集群缺点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>数据通过异步复制，不保证数据的强一致性</p>\n</li>\n<li class=\"lvl-2\">\n<p>不支持多数据库空间，单机下的redis可以支持到16个数据库，集群模式下只能使用1个数据库空间，即db 0</p>\n</li>\n<li class=\"lvl-2\">\n<p>不支持跨slot操作，如使用mset、mget目前只支持具有相同slot值的Key执行批量操作</p>\n</li>\n<li class=\"lvl-2\">\n<p>Key作为数据分区的最小粒度，不能将一个很大的键值对象如hash、list等映射到不同的节点</p>\n</li>\n<li class=\"lvl-2\">\n<p>Key事务操作支持有限，只支持多key在同一节点上的事务操作，当多个Key分布于不同的节点上时无法使用事务功能</p>\n</li>\n<li class=\"lvl-2\">\n<p>不建议使用pipeline和multi-keys操作</p>\n</li>\n<li class=\"lvl-2\">\n<p>另外，如果集群内节点时间不同步，可能存在脏写</p>\n</li>\n</ul>\n<h3 id=\"redis-cli-的-Cluster-管理命令（用于管理-创建-调整集群）\">redis-cli 的 Cluster 管理命令（用于管理/创建/调整集群）</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>redis-cli --cluster create host1:port host2:port ...</code></td>\n<td>创建 Redis Cluster 集群（自动分配 slots）</td>\n<td><code>redis-cli --cluster create 10.0.0.1:7000 10.0.0.2:7000 --cluster-replicas 1</code></td>\n</tr>\n<tr>\n<td><code>redis-cli --cluster check host:port</code></td>\n<td>检查集群状态、健壮性</td>\n<td><code>redis-cli --cluster check 10.0.0.1:7000</code></td>\n</tr>\n<tr>\n<td><code>redis-cli --cluster info host:port</code></td>\n<td>显示集群结构、节点、slots 分布</td>\n<td><code>redis-cli --cluster info 10.0.0.1:7000</code></td>\n</tr>\n<tr>\n<td><code>redis-cli --cluster fix host:port</code></td>\n<td>修复 slots 移动、节点中断等异常状态</td>\n<td><code>redis-cli --cluster fix 10.0.0.1:7000</code></td>\n</tr>\n<tr>\n<td><code>redis-cli --cluster rebalance host:port</code></td>\n<td>重新分布 slots（自动均衡负载）</td>\n<td><code>redis-cli --cluster rebalance 10.0.0.1:7000</code></td>\n</tr>\n<tr>\n<td><code>redis-cli --cluster rebalance --cluster-threshold &lt;percent&gt; host:port</code></td>\n<td>手动设置 rebalance 阈值；低于此阈值才会调整（百分比）</td>\n<td><code>redis-cli --cluster rebalance --cluster-threshold 1 10.0.0.1:7000</code></td>\n</tr>\n<tr>\n<td><code>redis-cli --cluster add-node newHost:newPort existingHost:existingPort</code></td>\n<td>将新节点加入集群</td>\n<td><code>redis-cli --cluster add-node 10.0.0.3:7000 10.0.0.1:7000</code></td>\n</tr>\n<tr>\n<td><code>redis-cli --cluster add-node --cluster-slave newHost:newPort existingMaster:port</code></td>\n<td>将新节点作为某主节点的 slave 加入</td>\n<td><code>redis-cli --cluster add-node --cluster-slave 10.0.0.4:7000 10.0.0.1:7000</code></td>\n</tr>\n<tr>\n<td><code>redis-cli --cluster del-node host:port node_id</code></td>\n<td>从集群删除某节点（必须无 slots）</td>\n<td><code>redis-cli --cluster del-node 10.0.0.1:7000 &lt;node-id&gt;</code></td>\n</tr>\n<tr>\n<td><code>redis-cli --cluster call host:port command ...</code></td>\n<td>在所有节点上批量执行命令</td>\n<td><code>redis-cli --cluster call 10.0.0.1:7000 PING</code></td>\n</tr>\n<tr>\n<td><code>redis-cli --cluster help</code></td>\n<td>显示 cluster 子命令帮助</td>\n<td><code>redis-cli --cluster help</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Redis-内置的-Cluster-操作命令\">Redis 内置的 Cluster 操作命令</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>CLUSTER INFO</code></td>\n<td>查看集群状态、failover 状态、slot 分布统计</td>\n<td><code>CLUSTER INFO</code></td>\n</tr>\n<tr>\n<td><code>CLUSTER NODES</code></td>\n<td>显示所有节点和角色（master/slave）</td>\n<td><code>CLUSTER NODES</code></td>\n</tr>\n<tr>\n<td><code>CLUSTER MYID</code></td>\n<td>输出本节点 ID</td>\n<td><code>CLUSTER MYID</code></td>\n</tr>\n<tr>\n<td><code>CLUSTER REPLICATE &lt;node-id&gt;</code></td>\n<td>将当前节点设置为某个 master 的 slave</td>\n<td><code>CLUSTER REPLICATE &lt;node-id&gt;</code></td>\n</tr>\n<tr>\n<td><code>CLUSTER FAILOVER</code></td>\n<td>主动 failover（slave 升级为 master）</td>\n<td>从节点执行：<code>CLUSTER FAILOVER</code></td>\n</tr>\n<tr>\n<td><code>CLUSTER FAILOVER FORCE</code></td>\n<td>不等待复制同步，立刻切主</td>\n<td><code>CLUSTER FAILOVER FORCE</code></td>\n</tr>\n<tr>\n<td><code>CLUSTER FAILOVER TAKEOVER</code></td>\n<td>强制接管 slot（完全覆盖 master）（危险）</td>\n<td><code>CLUSTER FAILOVER TAKEOVER</code></td>\n</tr>\n<tr>\n<td><code>CLUSTER ADDSLOTS &lt;slot...&gt;</code></td>\n<td>将 slots 分配给当前 master</td>\n<td><code>CLUSTER ADDSLOTS 0 1 2</code></td>\n</tr>\n<tr>\n<td><code>CLUSTER DELSLOTS &lt;slot...&gt;</code></td>\n<td>从当前节点移除 slots</td>\n<td><code>CLUSTER DELSLOTS 0 1 2</code></td>\n</tr>\n<tr>\n<td><code>CLUSTER SETSLOT &lt;slot&gt; NODE &lt;node-id&gt;</code></td>\n<td>直接指定某个 slot 属于某个节点</td>\n<td><code>CLUSTER SETSLOT 0 NODE &lt;id&gt;</code></td>\n</tr>\n<tr>\n<td><code>CLUSTER SETSLOT &lt;slot&gt; IMPORTING &lt;node-id&gt;</code></td>\n<td>设定迁移 key 的源节点（用于 slot 迁移）</td>\n<td>-</td>\n</tr>\n<tr>\n<td><code>CLUSTER SETSLOT &lt;slot&gt; MIGRATING &lt;node-id&gt;</code></td>\n<td>设定迁移 key 的目标节点（用于 slot 迁移）</td>\n<td>-</td>\n</tr>\n<tr>\n<td><code>CLUSTER KEYSLOT key</code></td>\n<td>返回 key 所属 slot</td>\n<td><code>CLUSTER KEYSLOT mykey</code></td>\n</tr>\n<tr>\n<td><code>CLUSTER COUNT-FAILURE-REPORTS &lt;node-id&gt;</code></td>\n<td>查看某节点的 fail 票数</td>\n<td>-</td>\n</tr>\n<tr>\n<td><code>CLUSTER RESET</code></td>\n<td>删除节点全部集群信息（用来重置为 standalone）</td>\n<td><code>CLUSTER RESET HARD</code></td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 Redis 7 + ACL 单节点、主从、哨兵、集群构建方法 本文基于redis-7.4.7 传统的非ACL版本，可以参考 Redis单节点、主从、哨兵、集群构建方法 Redis官网：https://redis.io/ redis安装 1234567891011121314151617181920212223242526272829# 下载到指定目录mkdir -p /usr/local/softwget https://download.redis.io/releases/redis-7.4.7.tar.gz -P /usr/local/soft# 解压cd /usr/local/softtar -zxvf redis-7.4.7.tar.gz# 编译sudo yum install gcc gcc-c++ -ycd redis-7.4.7# 编译，会将编译好的可执行文件放在src目录下make# 编译安装到指定目录，redis相关命令会被安装到 $(pwd)/build_dir/bin目录下mkdir build_dirmake install PREFIX=$(pwd)/build_dir# 编辑配置文件，不建议在原有配置文件中修改，可以新建一个配置文件cp redis.conf redis-6379.confvim redis-6379.conf #见下面的配置信息# 加入环境变量 /etc/bashrc，注意这里要是单引号，否则 $PATH 会被解析echo &#x27;export PATH=$PATH:/usr/local/soft/redis-7.4.7/build_dir/bin&#x27; &gt;&gt; /etc/bashrcsource /etc/bashrc# 验证redis-cli --version# 输出redis-cli 7.4.7 单节点 redis-6379.conf 的主要配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130# 端口，默认 6379port 6379# 后台启动，默认 nodaemonize yes# yes: 当没有 bind / requirepass / ACL 时，只允许本机访问# no: 允许任意访问# 这里会启用ACL，所以设置为 yes，默认 yesprotected-mode yes# 注释掉bind，绑定的是自己机器网卡的ip，如果有多块网卡可以配多个ip,代表允许客户端通过机器的哪些网卡ip去访问，内网一般可以不配置#bind 127.0.0.1# 可以配置为，本机IP 内网IP 外网IP# bind 127.0.0.1 10.250.0.103 18.163.188.20# 关闭rdb快照，因为会启用混合持久化，所以这里不需要开启rdb快照# 这里只是关闭了自动快照，如果手动执行了 bgsave 命令，还是会生成一个 dump.rdb 文件save &quot;&quot;# 设置dir路径，redis日志、aof和rdb文件都会生成在这个路径下，需要提前创建好这个目录dir /usr/local/soft/dir-redis7/6379# 开启aof，实际上只需要开启这个配置，以下aof相关配置默认即可，默认 no# 开启aof，重启redis时，会主动加载 appendonlydir 下的 相关 aof文件进行数据恢复# 生成环境必须开启appendonly yes# aof文件名称，默认 appendonly.aofappendfilename &quot;appendonly.aof&quot;# aof文件保存目录，基于为当前dir路径，默认值就是 appendonlydir# redis6+会生成3个文件，每个文件都以 appendfilename 配置的文件名称开头，如下：# appendonly.aof.N.base.rdb：每次触发aof重写时都会生成这个文件，N是当前aof文件序号，base.rdb是当前rdb文件# appendonly.aof.N.incr.aof：记录每个写操作命令# appendonly.aof.manifest：记录 base.rdb 和 incr.aof 文件的最新索引(N)appenddirname &quot;appendonlydir&quot;# aof将数据fsync到磁盘的策略，默认即可，表示每秒一次，故障时最多会丢失一秒的数据，默认 everysecappendfsync everysec# 自动触发aof重写需要满足如下条件，如果需要手动触发aof重写，可以执行 BGREWRITEAOF 命令# 重写时会删除旧的 appendonly.aof.N.base.rdb(RDB 快照) 文件，生成新的 appendonly.aof.N+1.base.rdb# 当 AOF 重写完成后，当前的 appendonly.aof.N.incr.aof 会封存，Redis 会新建一个 appendonly.aof.N+1.incr.aof 来继续记录写命令# 而此时 appendonly.aof.manifest(索引文件) 也会记录最新的 appendonly.aof.N.incr.aof 和 appendonly.aof.N.base.rdb# aof文件至少要达到64M才会自动重写，文件太小恢复速度本来就很快，重写的意义不大，默认即可，默认 64mbauto-aof-rewrite-min-size 64mb# aof文件自上一次重写后文件大小增长了100%则再次触发重写，默认 100auto-aof-rewrite-percentage 100# 开启混合持久化，4.0以后版本支持，需要先开启aof，默认 yes# 开启混合持久化后，appendonly.aof.N.base.rdb 的文件后缀就是 rdb，否则是 aofaof-use-rdb-preamble yes# 防止 AOF 意外截断导致 Redis 起不来，默认 yesaof-load-truncated yes# pid文件路径，默认 /var/run/redis_6379.pidpidfile &quot;redis_6379.pid&quot;# 日志文件名称，默认 &quot;&quot;logfile &quot;6379.log&quot;# 指定最大内存，单位bytes，这里设置4G# 如果不设置最大内存，redis会默认为物理内存，达到上限时会频繁与磁盘发生交换，使redis性能急剧下降maxmemory 4294967296# 达到最大内存时的清除策略，推荐 allkeys-lru，淘汰很久没被访问过的数据，基于最近一次的访问时间# volatile-lru: 只会淘汰「设置了过期时间」的 key# allkeys-lru: 淘汰最久没有被访问过的数据，最近最久没被访问的# allkeys-lfu: 淘汰最不经常被访问过的数据，访问次数最少的# noeviction: 不淘汰，默认maxmemory-policy allkeys-lru# 慢查询日志# 单位微妙，这里表示10毫秒，即超过10毫秒的操作都会记录下来slowlog-log-slower-than 10000# 设置慢查询日志记录保存数量，如果数量已满会删除最早的记录slowlog-max-len 1024# 性能优化# Redis 用多少附加线程来处理网络 I/O（不是执行命令），推荐：核心数 / 2，默认为1，超过 8 几乎就没有明显收益了io-threads 4# 多线程同时用于 读取 + 写回， no ：多线程仅用于 写回客户端# 推荐&gt;=4核才开启，否则开了反而更慢io-threads-do-reads yes# 操作系统 TCP 层的健康检测，默认值300，这里如果 60 秒内没有数据流动，内核会发送探测包，判断连接是否活着tcp-keepalive 60# 客户端在 &quot;多少秒不操作&quot; 就强制断开，0：永不超时（推荐）,默认 0# 因为有 tcp-keepalive 60，会每 60 秒检测一下对面还在不在，如果不在，Redis 会主动断开该连接，所以不会导致连接永不释放timeout 0# 最大客户端连接数，默认 10000maxclients 10000# 禁用危险命令，根据需要自行添加，redis6+ 支持在 acl 文件中为不同的用户禁用危险命令rename-command FLUSHALL &quot;&quot;rename-command FLUSHDB &quot;&quot;# rename-command SHUTDOWN &quot;&quot;# rename-command CONFIG &quot;&quot;# rename-command KEYS &quot;&quot;# rename-command SAVE &quot;&quot;# rename-command BGSAVE &quot;&quot;# rename-command DEBUG &quot;&quot;# rename-command EVAL &quot;&quot;# rename-command SCRIPT &quot;&quot;# Redis 在内部存在大量“隐式删除”场景（过期、覆盖写、eviction、rename、replication flush 等）。默认情况下，这些删除都是同步阻塞的（类似 DEL），可能导致主线程卡顿。Lazy Freeing 机制允许 Redis 在后台线程中释放大对象的内存（类似 UNLINK），从而减少阻塞。# 当启用 maxmemory + eviction 策略（如 allkeys-lru、volatile-ttl）时，被淘汰的 key 是否采用异步释放（后台线程 UNLINK 模式）。适用场景：高吞吐、高并发、大对象（如大型 hash、set、zset、列表）场景才明显受益。lazyfree-lazy-eviction yes# 当 key 到期（EXPIRE 触发删除）时，是否异步释放其 Value。各种使用带 TTL 的缓存系统，尤其 value 是大型对象（JSON、大 Set、Hash 等）。过期 key 数量大、对象结构大时，推荐开启。lazyfree-lazy-expire yes# 针对“服务器内部因命令副作用导致的删除操作”是否异步释放，例如：# RENAME 替换旧 key 时删除旧 value# SET 操作覆盖旧值时删除旧 value# SUNIONSTORE / SORT STORE 覆盖目标 key 时删除旧 value# 重写函数、脚本时删除旧对象# 适用场景：对象特别大，且存在覆盖写、rename 操作频繁的应用。lazyfree-lazy-server-del yes# 当副本（Replica/Slave）因全量同步而执行 FLUSHDB 时，是否异步释放原有数据。# 此配置只影响副本不会影响主节点。replica-lazy-flush yes# 让用户执行 DEL 时也自动使用异步释放（等价于默认把 DEL 转换为 UNLINK）。# 代码中大量使用 DEL 删除大对象又不方便统一改成 UNLINK 时。# 一般生产环境我们倾向保持显式的语义（DEL/UNLINK），不建议轻易改写 DEL 行为。lazyfree-lazy-user-del no# FLUSHDB / FLUSHALL / SCRIPT FLUSH / FUNCTION FLUSH 在未显式指定 SYNC/ASYNC 时是否异步执行# 大部分情况下建议保持 no，由应用决定是否用 FLUSHDB ASYNC。lazyfree-lazy-user-flush no# 开启 ACL 文件aclfile /usr/local/soft/redis-7.4.7/users.acl Redis 7 支持的淘汰策略 策略 是否只淘汰带 TTL 的 key 淘汰规则 说明 noeviction ❌ 不淘汰 不删任何 key 内存满了直接返回错误（默认） allkeys-lru ❌ 所有 key 最近最久未使用 ✅ 最常用 allkeys-lfu ❌ 所有 key 访问频率最少 ✅ 热点场景最好 allkeys-random ❌ 所有 key 随机删除 ❌ 很少用 volatile-lru ✅ 只淘汰有 TTL 的 最近最久未使用 你之前用的 volatile-lfu ✅ 只淘汰有 TTL 的 访问频率最少 较少使用 volatile-random ✅ 只淘汰有 TTL 的 随机删除 很少用 volatile-ttl ✅ 只淘汰有 TTL 的 TTL 最小（马上过期的） 特殊场景用 users.acl 文件: 该文件不支持添加注释，所以使用时需要去掉如下注释行，关于ACL的详细说明，可以参考 Redis 7 + ACL 简介 1234# 关闭默认用户，禁止匿名访问user default off# 超级管理员user admin on ~* &amp;* +@all &gt;123456 redis 服务启动与关闭 123456789101112# 启动服务redis-server redis-6379.conf# 登录服务，本机访问可以省略 -h -predis-cli -h 127.0.0.1 -p 6379 --user admin --pass 123456# 或者redis-cli -u redis://admin:123456@127.0.0.1:6379# 关闭服务# shutdown == shutdown saveredis-cli -u redis://admin:123456@127.0.0.1:6379 shutdown# 关闭服务，不保存数据，已经开了 AOF（尤其是 everysec) 的场景下，可以redis-cli -u redis://admin:123456@127.0.0.1:6379 shutdown nosave 场景 推荐命令 正常下线（生产） shutdown nosave 已开 AOF shutdown nosave 数据很大 shutdown nosave 单机调试 shutdown 确定要生成快照 shutdown save 强制杀死(redis卡死) kill -9（极端情况） 单节点优点 单机部署简单方便 单节点缺点 不保证数据的可靠性，不适用于数据可靠性要求高的场景 单点故障导致无法提供服务，或者硬盘损坏导致数据丢失 redis单节点最大qps为10w(取决于单核cpu的处理能力)，超过这个qps就需要做前端限流 主从 规划 123master 10.250.0.235slave1 10.250.0.58slave2 10.250.0.36 主从配置时，主节点不需要做任何修改 从节点配置文件增加同步主节点信息，其余配置与主节点相同 123456789# 指定主节点，从节点会从主节点同步数据，这里10.250.0.235 6379是主节点的ip和端口号replicaof 10.250.0.235 6379# 配置从节点只读，默认开启，避免数据写入从节点导致主从数据不一致replica-read-only yes# 如果主节点开启了ACL认证，则从节点需要设置主节点的认证信息，这里设置为管理员帐号masteruser adminmasterauth 123456 此时启动从节点redis-server redis-6379.conf，会自动从主节点同步数据，同步前如果从节点已经有数据，则会先清除原有数据再进行同步 主节点接收到从节点的同步请求后，会通过bgsave将内存数据dump到rdb文件中并传递给从节点 主节点生成rdb文件并传递给从节点期间会继续处理客户端的请求，并将这部分数据缓存到内存中，待从节点接收到主节点发过来的rdb文件并完成内存加载后，主节点会将这部分缓存在内存中的数据发送给从节点 从节点相当于主节点的备份，主节点挂了，从节点不能自动切换为主节点，如果需要自动切换，可以使用哨兵或者集群部署方式 此时登录master的redis并执行info replication命令 12345678910111213# Replicationrole:master # 表示当前是从节点connected_slaves:1 # 从节点数量slave0:ip=10.250.0.36,port=6379,state=online,offset=56,lag=1 # 从节点信息master_failover_state:no-failover # 主节点切换状态，无master_replid:93e564c18d27418e52fc40254c764d76c1dc3f67 # 主节点的复制IDmaster_replid2:0000000000000000000000000000000000000000master_repl_offset:56 # 主节点复制的偏移量second_repl_offset:-1repl_backlog_active:1 # 是否开启复制回放repl_backlog_size:1048576 # 复制回放缓冲区大小repl_backlog_first_byte_offset:1 # 复制回放缓冲区第一个字节的偏移量repl_backlog_histlen:56 # 复制回放缓冲区历史长度 此时登录从节点的redis并执行info replication命令 12345678910111213141516171819202122# Replicationrole:slave # 表示当前是从节点master_host:10.250.0.235 # 主节点的ipmaster_port:6379 # 主节点的端口master_link_status:up # 主从节点连接状态，up 表示已经连接上主节点master_last_io_seconds_ago:6 # 主从节点最后一次io操作时间master_sync_in_progress:0 # 主从节点是否正在同步数据，0表示已完成slave_read_repl_offset:112 # 从节点已经读取的复制偏移量slave_repl_offset:112 # 从节点已经写入的复制偏移量slave_priority:100 # 从节点的优先级slave_read_only:1 # 从节点是否只读replica_announced:1 # 从节点是否被其他节点所代理connected_slaves:0 # 从节点所代理的从节点数量master_failover_state:no-failover # 主节点的故障转移状态，no-failover表示没有进行故障转移master_replid:93e564c18d27418e52fc40254c764d76c1dc3f67 # 主节点的复制IDmaster_replid2:0000000000000000000000000000000000000000master_repl_offset:112 # 主节点已经写入的复制偏移量 slave_read_repl_offset ≈ master_repl_offset，说明数据已经同步second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:15repl_backlog_histlen:98 主从数据同步是否完成判断规则，在从节点上执行命令info replication 字段 正常值 说明 role slave 表示当前是从节点 master_link_status up 表示已经连上主库 master_sync_in_progress 0 同步不在进行中 = 已完成 slave_read_repl_offset ≈ master_repl_offset 接近 说明数据已追上 参照上面的配置，再添加一个从节点后，在主节点执行命令 info replication 1234567891011121314# Replicationrole:masterconnected_slaves:2 # 从节点数量slave0:ip=10.250.0.36,port=6379,state=online,offset=4313,lag=0slave1:ip=10.250.0.58,port=6379,state=online,offset=4313,lag=0 # 第二个从节点信息master_failover_state:no-failovermaster_replid:93e564c18d27418e52fc40254c764d76c1dc3f67master_replid2:0000000000000000000000000000000000000000master_repl_offset:4313second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:4313 主从优点 对请求进行读写分离，提高处理效率 可以提供多个副本，提高数据安全性 主从缺点 不具备自动容错和恢复功能，主节点故障，集群则无法进行工作，可用性比较低，从节点升主节点需要人工手动干预 哨兵 创建三个哨兵，为了方便就在上面主从配置的3台服务器上启动哨兵 规划 123456master 10.250.0.235slave1 10.250.0.58slave2 10.250.0.36sentinel1 10.250.0.71sentinel2 10.250.0.131sentinel3 10.250.0.63 分别编辑各自的 sentinel.conf 123456789101112131415161718192021222324252627282930# 端口号port 26379# 后台启动daemonize yes# dir，需要提前创建好dir /usr/local/soft/dir-redis7/sentinel# pid文件路径pidfile redis-sentinel.pid# 日志文件名称logfile &quot;sentinel.log&quot;# 配置监听的主节点地址和端口，mymaster为自定义的名称，最后的2表示，只要有2个哨兵节点认为主节点挂了就会进行重新选主，一般设置为sentinel总数/2+1sentinel monitor mymaster 10.250.0.235 6379 2# 主观下线时间（5秒），默认30秒sentinel down-after-milliseconds mymaster 5000# 故障转移超时时间 60秒，默认180秒sentinel failover-timeout mymaster 60000# 每次允许多少个slave重新同步，默认就是 1sentinel parallel-syncs mymaster 1# acl用户名和密码，这里为了方便也是用的管理员帐号sentinel auth-user mymaster adminsentinel auth-pass mymaster 123456 分别启动三个哨兵节点redis-sentinel sentinel.conf，此时登录哨兵节点redis-cli -p 26379，并执行info Sentinel命令，查看其是否正确识别了主从 12345678# Sentinelsentinel_masters:1 # 哨兵集群中主从节点的数量sentinel_tilt:0 # 是否处于 tilt 状态sentinel_tilt_since_seconds:-1 # tilt 状态的开始时间sentinel_running_scripts:0 # 正在运行的脚本数量sentinel_scripts_queue_length:0 # 脚本队列长度sentinel_simulate_failure_flags:0 # 模拟故障的标志master0:name=mymaster,status=ok,address=10.250.0.235:6379,slaves=2,sentinels=3 # 主节点的地址，从节点数量和哨兵数量 此时查看sentinel.conf可以在文件最后看到从节点信息和其它的哨兵节点信息(但实测无法感知其它哨兵节点)，类似于 123456789101112131415# Generated by CONFIG REWRITElatency-tracking-info-percentiles 50 99 99.9 # 延迟追踪信息百分比user default on nopass sanitize-payload ~* &amp;* +@all # 用户信息，当前的哨兵没有开启权限认证，所以缺省为default用户，无密码sentinel myid 8b9d55a581f2e41b4f8d92f4a9434d9b8a78b3e6 # 本节点的idsentinel config-epoch mymaster 0sentinel leader-epoch mymaster 0sentinel current-epoch 0# 一个从节点信息sentinel known-replica mymaster 10.250.0.58 6379# 另一个从节点信息sentinel known-replica mymaster 10.250.0.36 6379# 一个哨兵节点信息sentinel known-sentinel mymaster 10.250.0.71 26379 b230f6a6076c23eed1923b29027d9ba7b24bee5a# 另一个哨兵节点信息sentinel known-sentinel mymaster 10.250.0.63 26379 74ef58ef3616a27cc63d83bcfe422f15e11731b8 此时关闭master节点(10.250.0.235:6379)，然后登录哨兵节点查看info Sentinel，就会发现master节点变成了从节点其中的一个了 此时再次开启原master节点，会发现其变成了从节点，相应的配置文件(redis-6379.conf)也发生了变更 123456# Generated by CONFIG REWRITElatency-tracking-info-percentiles 50 99 99.9replicaof 10.250.0.36 6379save 3600 1save 300 100save 60 10000 这里有一点需要注意，就是master节点重启前也需要配置如下认证信息，因为master在哨兵模式下发生故障后重新启动会变成slave 123# 如果主节点开启了ACL认证，则从节点需要设置主节点的认证信息，这里设置为管理员帐号masteruser adminmasterauth 123456 顺便说一下，关闭哨兵服务的命令如下： 1redis-cli -p 26379 shutdown 哨兵优点 主节点故障，可以自动在从节点中重新选主 哨兵缺点 哨兵单点故障，则集群无法完整自主选举主节点，所以需要对哨兵集群部署，增加服务器成本，但是并没有提升负载 另外，主节点故障时，哨兵介入有时间差，会导致响应延迟 从节点仅作为备份不提供对外服务，只有当master出现故障时其晋升为master后才能提供服务，所以不支持读写分离 集群 搭建6个redis的集群，3主3从 规划 123456redis1 10.250.0.235redis2 10.250.0.58redis3 10.250.0.36redis4 10.250.0.71redis5 10.250.0.131redis6 10.250.0.63 还是基于单节点配置文件，只是将节点配置成集群模式，redis-6379.conf文件增加如下信息 123456789101112131415161718192021# ACL认证，所有节点都要配置masteruser &quot;admin&quot;masterauth &quot;123456&quot;# 启动集群模式cluster-enabled yes# 集群节点信息文件，这里最好和port对应上cluster-config-file nodes-6379.conf# 集群节点间通信的超时时间，单位毫秒，默认15000，这个时间别设置太短，避免网络抖动等原因干扰cluster-node-timeout 15000# 写数据成功最少同步的slave数量，默认数据写入master就返回给client了，加上这个配置，就需要数据同步到指定数量的slave后才能返回，# 注意这个配置不仅会延长client的等待时间，而且可能会影响集群的可用性，比如这里配置至少同步1个slave，但是如果此时master对应可用的slave不足1个，集群就不能提供服务了，所以建议每个master至少配置了2个以上的slave时才开启这个配置# 开启这个配置可以预防集群脑裂问题，默认为3min-replicas-to-write 1# 如果集群中某个master/slave全部挂掉，整个集群的其它master/slave是否还可以对外提供服务，默认yes，不能# 如果设置为no，则表示依旧可以提供服务，不过如果有key落在了挂掉的主从上就会失败cluster-require-full-coverage yes 分别启动6个redis服务 1redis-server redis-6379.conf 创建集群，3主3从，注意创建集群前所有redis不能有数据，如果有需要先清空(删除dir配置的目录中的所有文件即可)，然后在任意一个redis执行 12345redis-cli --user admin --pass 123456 --cluster create --cluster-replicas 1 10.250.0.235:6379 10.250.0.58:6379 10.250.0.36:6379 10.250.0.71:6379 10.250.0.131:6379 10.250.0.63:6379# 参数说明：# --cluster create：创建集群# --cluster-replicas 1：设置从节点数量，这里设置为1，表示每个主节点都对应一个从节点# 这里配置了6个节点组建集群，要保证每个master节点都有一个从节点，所以刚好是3主3从 此时会列出集群内主从和槽位的分配方案，输入yes即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849Warning: Using a password with &#x27;-a&#x27; or &#x27;-u&#x27; option on the command line interface may not be safe.&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...Master[0] -&gt; Slots 0 - 5460Master[1] -&gt; Slots 5461 - 10922Master[2] -&gt; Slots 10923 - 16383Adding replica 10.250.0.131:6379 to 10.250.0.235:6379Adding replica 10.250.0.63:6379 to 10.250.0.58:6379Adding replica 10.250.0.71:6379 to 10.250.0.36:6379M: afcb754ce8cc79122fe9bcd8c1567bbf13258fce 10.250.0.235:6379 slots:[0-5460] (5461 slots) masterM: 2527142b7cffaf6bb92608550c919a0db0607c39 10.250.0.58:6379 slots:[5461-10922] (5462 slots) masterM: 88762f7d0bbb99bbaf68556ef5fd113cba46d295 10.250.0.36:6379 slots:[10923-16383] (5461 slots) masterS: 547fbd934293ddb5eb770e111b65910f4e604023 10.250.0.71:6379 replicates 88762f7d0bbb99bbaf68556ef5fd113cba46d295S: 17b33861e6b086b86902fe75f79e5b878bd26f94 10.250.0.131:6379 replicates afcb754ce8cc79122fe9bcd8c1567bbf13258fceS: 119e5823cccafef506b9b256aad206678eab7d41 10.250.0.63:6379 replicates 2527142b7cffaf6bb92608550c919a0db0607c39Can I set the above configuration? (type &#x27;yes&#x27; to accept): yes&gt;&gt;&gt; Nodes configuration updated&gt;&gt;&gt; Assign a different config epoch to each node&gt;&gt;&gt; Sending CLUSTER MEET messages to join the clusterWaiting for the cluster to join.&gt;&gt;&gt; Performing Cluster Check (using node 10.250.0.235:6379)M: afcb754ce8cc79122fe9bcd8c1567bbf13258fce 10.250.0.235:6379 slots:[0-5460] (5461 slots) master 1 additional replica(s)S: 547fbd934293ddb5eb770e111b65910f4e604023 10.250.0.71:6379 slots: (0 slots) slave replicates 88762f7d0bbb99bbaf68556ef5fd113cba46d295S: 119e5823cccafef506b9b256aad206678eab7d41 10.250.0.63:6379 slots: (0 slots) slave replicates 2527142b7cffaf6bb92608550c919a0db0607c39S: 17b33861e6b086b86902fe75f79e5b878bd26f94 10.250.0.131:6379 slots: (0 slots) slave replicates afcb754ce8cc79122fe9bcd8c1567bbf13258fceM: 88762f7d0bbb99bbaf68556ef5fd113cba46d295 10.250.0.36:6379 slots:[10923-16383] (5461 slots) master 1 additional replica(s)M: 2527142b7cffaf6bb92608550c919a0db0607c39 10.250.0.58:6379 slots:[5461-10922] (5462 slots) master 1 additional replica(s)[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered. 登录集群并查询集群配置信息 12# -c 表示以集群模式登录，-h 集群内任意ipredis-cli --user admin --pass 123456 -c -h 10.250.0.235 查看集群信息 1234567891011121314151617181910.250.0.235:6379&gt; cluster info# 输出集群状态cluster_state:ok # 集群整体状态：ok 表示集群当前可用、健康cluster_slots_assigned:16384 # 已分配的哈希槽数量（总槽数固定为 16384）cluster_slots_ok:16384 # 正常工作的槽数量（等于已分配槽，说明全部正常）cluster_slots_pfail:0 # 处于“疑似失败(pfail)”状态的槽数量cluster_slots_fail:0 # 被判定为失败(fail)的槽数量cluster_known_nodes:6 # 当前节点已知的集群节点总数（主节点 + 从节点）cluster_size:3 # 主节点数量（3 主节点，典型的 3 主 3 从结构）cluster_current_epoch:6 # 集群当前的全局纪元（用于选举和配置同步）cluster_my_epoch:1 # 当前这个节点所在的纪元cluster_stats_messages_ping_sent:159 # 当前节点已发送的 PING 消息数量（心跳）cluster_stats_messages_pong_sent:156 # 当前节点已发送的 PONG 消息数量（心跳响应）cluster_stats_messages_sent:315 # 当前节点发送的所有集群消息总数cluster_stats_messages_ping_received:151 # 当前节点收到的 PING 消息数量cluster_stats_messages_pong_received:159 # 当前节点收到的 PONG 消息数量cluster_stats_messages_meet_received:5 # 当前节点收到的 MEET 消息数量（新节点加入发现）cluster_stats_messages_received:315 # 当前节点收到的所有集群消息总数total_cluster_links_buffer_limit_exceeded:0 # 因输出缓冲区超限被强制断开的集群连接数（0 = 正常） 查看节点列表 1234567891011121310.250.0.235:6379&gt; cluster nodes# 当前节点（myself），角色为 master，负责槽位 0-5460，是本机所在的主节点afcb754ce8cc79122fe9bcd8c1567bbf13258fce 10.250.0.235:6379@16379 myself,master - 0 0 1 connected 0-5460# 从节点（slave），对应的主节点是 10.250.0.36 这个 master（负责槽位 10923-16383）547fbd934293ddb5eb770e111b65910f4e604023 10.250.0.71:6379@16379 slave 88762f7d0bbb99bbaf68556ef5fd113cba46d295 0 1765033120132 3 connected# 从节点（slave），对应的主节点是 10.250.0.58 这个 master（负责槽位 5461-10922）119e5823cccafef506b9b256aad206678eab7d41 10.250.0.63:6379@16379 slave 2527142b7cffaf6bb92608550c919a0db0607c39 0 1765033118000 2 connected# 从节点（slave），对应的主节点是当前节点 10.250.0.235（负责槽位 0-5460）17b33861e6b086b86902fe75f79e5b878bd26f94 10.250.0.131:6379@16379 slave afcb754ce8cc79122fe9bcd8c1567bbf13258fce 0 1765033119000 1 connected# 主节点（master），负责槽位 10923-16383（集群中第三段槽位）88762f7d0bbb99bbaf68556ef5fd113cba46d295 10.250.0.36:6379@16379 master - 0 1765033117000 3 connected 10923-16383# 主节点（master），负责槽位 5461-10922（集群中第二段槽位）2527142b7cffaf6bb92608550c919a0db0607c39 10.250.0.58:6379@16379 master - 0 1765033119126 2 connected 5461-10922 此时查看nodes-6379.conf也会看到和上面一样的节点信息 此时关闭其中一个master节点，比如10.250.0.36，则其对应的slave节点10.250.0.71会切换为新的master节点，此时10.250.0.36的状态最终变为fail 1234567810.250.0.235:6379&gt; cluster nodes## 输出afcb754ce8cc79122fe9bcd8c1567bbf13258fce 10.250.0.235:6379@16379 myself,master - 0 0 1 connected 0-5460547fbd934293ddb5eb770e111b65910f4e604023 10.250.0.71:6379@16379 master - 0 1765033733534 7 connected 10923-16383119e5823cccafef506b9b256aad206678eab7d41 10.250.0.63:6379@16379 slave 2527142b7cffaf6bb92608550c919a0db0607c39 0 1765033734542 2 connected17b33861e6b086b86902fe75f79e5b878bd26f94 10.250.0.131:6379@16379 slave afcb754ce8cc79122fe9bcd8c1567bbf13258fce 0 1765033732526 1 connected88762f7d0bbb99bbaf68556ef5fd113cba46d295 10.250.0.36:6379@16379 master,fail - 1765033690200 1765033686170 3 connected2527142b7cffaf6bb92608550c919a0db0607c39 10.250.0.58:6379@16379 master - 0 1765033735550 2 connected 5461-10922 再次启动10.250.0.36，其会变成10.250.0.71的slave节点 1234567810.250.0.235:6379&gt; cluster nodes## 输出afcb754ce8cc79122fe9bcd8c1567bbf13258fce 10.250.0.235:6379@16379 myself,master - 0 0 1 connected 0-5460547fbd934293ddb5eb770e111b65910f4e604023 10.250.0.71:6379@16379 master - 0 1765033859000 7 connected 10923-16383119e5823cccafef506b9b256aad206678eab7d41 10.250.0.63:6379@16379 slave 2527142b7cffaf6bb92608550c919a0db0607c39 0 1765033860493 2 connected17b33861e6b086b86902fe75f79e5b878bd26f94 10.250.0.131:6379@16379 slave afcb754ce8cc79122fe9bcd8c1567bbf13258fce 0 1765033858000 1 connected88762f7d0bbb99bbaf68556ef5fd113cba46d295 10.250.0.36:6379@16379 slave 547fbd934293ddb5eb770e111b65910f4e604023 0 1765033859488 7 connected2527142b7cffaf6bb92608550c919a0db0607c39 10.250.0.58:6379@16379 master - 0 1765033859000 2 connected 5461-10922 若此时还是希望 10.250.0.36 做为主节点，则需要先登录10.250.0.36，再执行如下命令 12345# 注意要加 -credis-cli -c --user admin --pass 123456 -h 10.250.0.3610.250.0.36:6379&gt; cluster failover # 安全版（等待复制同步）# 或者10.250.0.36:6379&gt; CLUSTER FAILOVER TAKEOVER # TAKEOVER 会立即切主，不会等待复制数据，非常强制(生产环境不推荐) redis集群会将2的14次幂(16384)的slot平均分配到所有master上，然后对key进行hash后计算应该存储到那个slot 1234567HASH_SLOT=CRC16(key) mod 16384# 跳转重定位10.250.0.235:6379&gt; set name zhangsan# 输出-&gt; Redirected to slot [5798] located at 10.250.0.58:6379OK 关闭集群，6个redis分别关闭 1redis-cli -c -h 10.250.0.235 -p 6379 --user admin --pass 123456 shutdown 重启集群，6个redis分别启动即可 1redis-server redis-6379.conf mset/mget要求key都落在同一个slot上，每个key都加上哈希标签（Hash Tag）-- &#123;xxx&#125;，其必须用&#123;&#125;括起来，xxx可以是任意字符串，计算slot时，只会根据xxx来计算hash值，这样就保证了所有key中包含&#123;xxx&#125;的key都会落到同一个slot，&#123;xxx&#125;可以放在key的任意位置 1234567891010.250.0.235:6379&gt; mset name1 lisi name2 wangwu(error) CROSSSLOT Keys in request don&#x27;t hash to the same slot10.250.0.235:6379&gt; mset &#123;user&#125;:name1 lisi &#123;user&#125;:name2 wangwuOK10.250.0.235:6379&gt; mget &#123;user&#125;:name1 &#123;user&#125;:name2-&gt; Redirected to slot [5474] located at 10.250.0.58:63791) &quot;lisi&quot;2) &quot;wangwu&quot; 注意: {…} 让多个 key 落在同一个 slot，支持跨 key 原子操作 只有 第一个匹配的 {…} 会被当做 tag {} 不能嵌套 空标签 {} 是非法的 {abc} 和 {def} 就落不同 slot 如何判断 key 落在哪个节点? 12310.250.0.235:6379&gt; cluster keyslot name1# 输出的数值就表示 slot(integer) 5461 # slot值 如何查看指定的slot中有多少个key? 12310.250.0.235:6379&gt; cluster countkeysinslot 5461# 输出(integer) 1 # 表示slot中key的个数，这里显示只有1个key 集群推举新的master时要求至少一半的master同意，所以一个集群至少需要3个master，官方推荐master节点数为奇数，比如3个和4个master节点，都至多允许一个master节点挂掉时进行选主，但是3个master可以节省资源 集群通过10000+port这个端口号进行集群间通信，所以除了要开放prot这个端口，还要开放10000+port这个端口 有关redis集群及其水平扩展的进一步说明，可以参看Redis集群 集群优点 无中心架构，集群内部自行维护数据的分片和主从的切换 数据分片存储，提供很高的访问效率 高可用性，可实现部分节点不可用时，集群仍可用 高扩展性，可以横向扩展1000个节点后依旧保证访问效率，扩容缩容都支持 集群缺点 数据通过异步复制，不保证数据的强一致性 不支持多数据库空间，单机下的redis可以支持到16个数据库，集群模式下只能使用1个数据库空间，即db 0 不支持跨slot操作，如使用mset、mget目前只支持具有相同slot值的Key执行批量操作 Key作为数据分区的最小粒度，不能将一个很大的键值对象如hash、list等映射到不同的节点 Key事务操作支持有限，只支持多key在同一节点上的事务操作，当多个Key分布于不同的节点上时无法使用事务功能 不建议使用pipeline和multi-keys操作 另外，如果集群内节点时间不同步，可能存在脏写 redis-cli 的 Cluster 管理命令（用于管理/创建/调整集群） 命令 作用 示例 redis-cli --cluster create host1:port host2:port ... 创建 Redis Cluster 集群（自动分配 slots） redis-cli --cluster create 10.0.0.1:7000 10.0.0.2:7000 --cluster-replicas 1 redis-cli --cluster check host:port 检查集群状态、健壮性 redis-cli --cluster check 10.0.0.1:7000 redis-cli --cluster info host:port 显示集群结构、节点、slots 分布 redis-cli --cluster info 10.0.0.1:7000 redis-cli --cluster fix host:port 修复 slots 移动、节点中断等异常状态 redis-cli --cluster fix 10.0.0.1:7000 redis-cli --cluster rebalance host:port 重新分布 slots（自动均衡负载） redis-cli --cluster rebalance 10.0.0.1:7000 redis-cli --cluster rebalance --cluster-threshold &lt;percent&gt; host:port 手动设置 rebalance 阈值；低于此阈值才会调整（百分比） redis-cli --cluster rebalance --cluster-threshold 1 10.0.0.1:7000 redis-cli --cluster add-node newHost:newPort existingHost:existingPort 将新节点加入集群 redis-cli --cluster add-node 10.0.0.3:7000 10.0.0.1:7000 redis-cli --cluster add-node --cluster-slave newHost:newPort existingMaster:port 将新节点作为某主节点的 slave 加入 redis-cli --cluster add-node --cluster-slave 10.0.0.4:7000 10.0.0.1:7000 redis-cli --cluster del-node host:port node_id 从集群删除某节点（必须无 slots） redis-cli --cluster del-node 10.0.0.1:7000 &lt;node-id&gt; redis-cli --cluster call host:port command ... 在所有节点上批量执行命令 redis-cli --cluster call 10.0.0.1:7000 PING redis-cli --cluster help 显示 cluster 子命令帮助 redis-cli --cluster help Redis 内置的 Cluster 操作命令 命令 作用 示例 CLUSTER INFO 查看集群状态、failover 状态、slot 分布统计 CLUSTER INFO CLUSTER NODES 显示所有节点和角色（master/slave） CLUSTER NODES CLUSTER MYID 输出本节点 ID CLUSTER MYID CLUSTER REPLICATE &lt;node-id&gt; 将当前节点设置为某个 master 的 slave CLUSTER REPLICATE &lt;node-id&gt; CLUSTER FAILOVER 主动 failover（slave 升级为 master） 从节点执行：CLUSTER FAILOVER CLUSTER FAILOVER FORCE 不等待复制同步，立刻切主 CLUSTER FAILOVER FORCE CLUSTER FAILOVER TAKEOVER 强制接管 slot（完全覆盖 master）（危险） CLUSTER FAILOVER TAKEOVER CLUSTER ADDSLOTS &lt;slot...&gt; 将 slots 分配给当前 master CLUSTER ADDSLOTS 0 1 2 CLUSTER DELSLOTS &lt;slot...&gt; 从当前节点移除 slots CLUSTER DELSLOTS 0 1 2 CLUSTER SETSLOT &lt;slot&gt; NODE &lt;node-id&gt; 直接指定某个 slot 属于某个节点 CLUSTER SETSLOT 0 NODE &lt;id&gt; CLUSTER SETSLOT &lt;slot&gt; IMPORTING &lt;node-id&gt; 设定迁移 key 的源节点（用于 slot 迁移） - CLUSTER SETSLOT &lt;slot&gt; MIGRATING &lt;node-id&gt; 设定迁移 key 的目标节点（用于 slot 迁移） - CLUSTER KEYSLOT key 返回 key 所属 slot CLUSTER KEYSLOT mykey CLUSTER COUNT-FAILURE-REPORTS &lt;node-id&gt; 查看某节点的 fail 票数 - CLUSTER RESET 删除节点全部集群信息（用来重置为 standalone） CLUSTER RESET HARD","summary":"摘要 Redis 7 + ACL 单节点、主从、哨兵、集群构建方法 本文基于redis-7.4.7 传统的非ACL版本，可以参考 Redis单节点、主从、哨兵、集群构建方法 Redis官网：https://redis.io/","date_published":"2025-12-05T13:30:05.000Z","tags":["技术","redis","redis","redis cluster"]},{"id":"https://blog.hanqunfeng.com/2025/12/02/brew-my-formula/","url":"https://blog.hanqunfeng.com/2025/12/02/brew-my-formula/","title":"brew -- 创建自己的 Formula","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n-->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://brew.sh\">brew</a>是一个软件包管理器，同时支持MacOS和Linux，可以很方便地安装各种软件，比如<code>git</code>、<code>node</code>、<code>python</code>等。</p>\n</li>\n<li class=\"lvl-2\">\n<p>本文介绍如何在macos下创建自己的 Formula</p>\n</li>\n<li class=\"lvl-2\">\n<p>本文基于 MacOS 15.7.2，brew 版本为 Homebrew 5.0.3。</p>\n</li>\n<li class=\"lvl-2\">\n<p>关于 brew 的安装及使用可以参考 <a href=\"/2024/11/28/brew/\" title=\"MacOS软件包管理器--brew\">MacOS软件包管理器--brew</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"从一个简单示例开始\">从一个简单示例开始</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里使用我自己编写的一个命令行脚本为例，脚本名称：color_echo，具体内容可以查看<a href=\"https://github.com/hanqunfeng/color_echo/blob/main/bin/color_echo\">color_echo</a>，这是一个用于终端打印彩色文本的命令。</p>\n</li>\n</ul>\n<h3 id=\"创建一个Github仓库，用于存储-color-echo-命令\">创建一个Github仓库，用于存储 color_echo 命令</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建一个Github仓库，用于存储 <code>color_echo</code> 命令文件，仓库名称: <code>hanqunfeng/color_echo</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>编写命令文件</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> color_echo_dir</span><br><span class=\"line\"><span class=\"built_in\">cd</span> color_echo_dir</span><br><span class=\"line\"><span class=\"comment\"># 感兴趣的自己去github上查看文件内容吧，这里就不贴出来了</span></span><br><span class=\"line\"><span class=\"comment\"># 这里将命令存储在了 bin 目录下，这个路径后面编写 Formula 文件时会用到</span></span><br><span class=\"line\">bin/color_echo</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>提交代码并打Tag</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在 color_echo_dir 目录下初始化仓库</span></span><br><span class=\"line\">git init</span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;Initial commit&quot;</span></span><br><span class=\"line\">git branch -M main</span><br><span class=\"line\">git remote add origin https://github.com/hanqunfeng/color_echo.git</span><br><span class=\"line\">git push -u origin main</span><br><span class=\"line\"><span class=\"comment\"># 创建Tag</span></span><br><span class=\"line\">git tag v1.0.0</span><br><span class=\"line\"><span class=\"comment\"># 推送Tag</span></span><br><span class=\"line\">git push --tags</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>获取tag的sha256值</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://github.com/hanqunfeng/color_echo/archive/refs/tags/v1.0.0.tar.gz</span><br><span class=\"line\">shasum -a 256 v1.0.0.tar.gz</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">9450952a4b477c83ea2d7e28386d6ae38132bf68c46746aa218c03c21aa75f6d  v1.0.0.tar.gz</span><br></pre></td></tr></table></figure>\n<h3 id=\"发布-color-echo\">发布 color_echo</h3>\n<blockquote>\n<p><code>brew create</code> 命令已经失效，需要手工创建</p>\n</blockquote>\n<h4 id=\"创建-tap-仓库\">创建 tap 仓库</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew tap-new hanqunfeng/color_echo</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">Warning: tap-new is a developer <span class=\"built_in\">command</span>, so Homebrew<span class=\"string\">&#x27;s</span></span><br><span class=\"line\"><span class=\"string\">developer mode has been automatically turned on.      # 提示开发者模式已自动打开</span></span><br><span class=\"line\"><span class=\"string\">To turn developer mode off, run:</span></span><br><span class=\"line\"><span class=\"string\">  brew developer off  # 如后续需要关闭开发者模式可以运行该命令</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">## 初始化仓库</span></span><br><span class=\"line\"><span class=\"string\">Initialized empty Git repository in /usr/local/Homebrew/Library/Taps/hanqunfeng/homebrew-color_echo/.git/</span></span><br><span class=\"line\"><span class=\"string\">[main (root-commit) 35d602b] Create hanqunfeng/color_echo tap</span></span><br><span class=\"line\"><span class=\"string\"> 3 files changed, 107 insertions(+)</span></span><br><span class=\"line\"><span class=\"string\"> create mode 100644 .github/workflows/publish.yml</span></span><br><span class=\"line\"><span class=\"string\"> create mode 100644 .github/workflows/tests.yml</span></span><br><span class=\"line\"><span class=\"string\"> create mode 100644 README.md</span></span><br><span class=\"line\"><span class=\"string\">==&gt; Created hanqunfeng/color_echo</span></span><br><span class=\"line\"><span class=\"string\">/usr/local/Homebrew/Library/Taps/hanqunfeng/homebrew-color_echo</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">When a pull request making changes to a formula (or formulae) becomes green</span></span><br><span class=\"line\"><span class=\"string\">(all checks passed), then you can publish the built bottles.</span></span><br><span class=\"line\"><span class=\"string\">To do so, label your PR as `pr-pull` and the workflow will be triggered.</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"手写一个-Formula-文件\">手写一个 Formula 文件</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/local/Homebrew/Library/Taps/hanqunfeng/homebrew-color_echo/Formula</span><br><span class=\"line\"><span class=\"built_in\">touch</span> color_echo.rb</span><br></pre></td></tr></table></figure>\n<p>写入内容（模板）：模板格式后面会详细介绍</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ColorEcho &lt; Formula</span><br><span class=\"line\">  desc <span class=\"string\">&quot;Print colorful text in terminal&quot;</span></span><br><span class=\"line\">  homepage <span class=\"string\">&quot;https://github.com/hanqunfeng/color_echo&quot;</span></span><br><span class=\"line\">  url <span class=\"string\">&quot;https://github.com/hanqunfeng/color_echo/archive/refs/tags/v1.0.0.tar.gz&quot;</span></span><br><span class=\"line\">  sha256 <span class=\"string\">&quot;9450952a4b477c83ea2d7e28386d6ae38132bf68c46746aa218c03c21aa75f6d&quot;</span></span><br><span class=\"line\">  license <span class=\"string\">&quot;MIT&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  def install</span><br><span class=\"line\">    bin.install <span class=\"string\">&quot;bin/color_echo&quot;</span></span><br><span class=\"line\">  end</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">test</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">    system <span class=\"string\">&quot;#&#123;bin&#125;/color_echo&quot;</span>, <span class=\"string\">&quot;--help&quot;</span></span><br><span class=\"line\">  end</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<h4 id=\"提交-Formula-文件到Github仓库\">提交 Formula 文件到Github仓库</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建一个Github仓库，用于存储 Formula 文件: <code>hanqunfeng/homebrew-color_echo</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>添加 Formula 文件到仓库</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> $(brew --repo hanqunfeng/color_echo)</span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;Add color_echo 1.0.0&quot;</span></span><br><span class=\"line\">git remote add origin https://github.com/hanqunfeng/homebrew-color_echo.git</span><br><span class=\"line\">git push -u origin main</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">Enumerating objects: 11, <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Counting objects: 100% (11/11), <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Delta compression using up to 12 threads</span><br><span class=\"line\">Compressing objects: 100% (9/9), <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Writing objects: 100% (11/11), 2.11 KiB | 2.11 MiB/s, <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Total 11 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)</span><br><span class=\"line\">To https://github.com/hanqunfeng/homebrew-color_echo.git</span><br><span class=\"line\">! [remote rejected] main -&gt; main (refusing to allow a Personal Access Token to create or update workflow `.github/workflows/publish.yml` without `workflow` scope)</span><br><span class=\"line\">error: failed to push some refs to <span class=\"string\">&#x27;https://github.com/hanqunfeng/homebrew-color_echo.git&#x27;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>提示缺少权限，需要给仓库添加权限。在 Github 中添加一个 Personal Access Token，并添加权限<code>repo</code> 和 <code>workflow</code>，重新推送</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 设置远程仓库地址，注意替换为你的仓库地址，并且密钥替换为实际的密钥</span></span><br><span class=\"line\">git remote set-url origin https://ghp_xxxxx@github.com/hanqunfeng/homebrew-color_echo.git</span><br><span class=\"line\">git push -u origin main</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">Enumerating objects: 11, <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Counting objects: 100% (11/11), <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Delta compression using up to 12 threads</span><br><span class=\"line\">Compressing objects: 100% (9/9), <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Writing objects: 100% (11/11), 2.11 KiB | 2.11 MiB/s, <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Total 11 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)</span><br><span class=\"line\">To https://github.com/hanqunfeng/homebrew-color_echo.git</span><br><span class=\"line\">* [new branch]      main -&gt; main</span><br><span class=\"line\">branch <span class=\"string\">&#x27;main&#x27;</span> <span class=\"built_in\">set</span> up to track <span class=\"string\">&#x27;origin/main&#x27;</span>.</span><br></pre></td></tr></table></figure>\n<h4 id=\"安装-Formula\">安装 Formula</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 切换 tap，注意: 执行搜索和安装时需要先切换 tap，否则需要使用完整包名 hanqunfeng/color_echo/color_echo</span></span><br><span class=\"line\">brew tap hanqunfeng/color_echo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 搜索</span></span><br><span class=\"line\">brew search color_echo</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">==&gt; Formulae</span><br><span class=\"line\">hanqunfeng/color_echo/color_echo              color-code</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 完整包名搜索</span></span><br><span class=\"line\">brew search hanqunfeng/color_echo/color_echo</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">==&gt; Formulae</span><br><span class=\"line\">color_echo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装</span></span><br><span class=\"line\">brew install color_echo</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">==&gt; Fetching downloads <span class=\"keyword\">for</span>: color_echo</span><br><span class=\"line\">✔︎ Formula color_echo (1.0.0)                                   [Verifying     2.1KB/  2.1KB]</span><br><span class=\"line\">==&gt; Installing color_echo from hanqunfeng/color_echo</span><br><span class=\"line\">🍺  /usr/local/Cellar/color_echo/1.0.0: 4 files, 7.4KB, built <span class=\"keyword\">in</span> 5 seconds</span><br><span class=\"line\">==&gt; Running `brew cleanup color_echo`...</span><br><span class=\"line\">Disable this behaviour by setting `HOMEBREW_NO_INSTALL_CLEANUP=1`.</span><br><span class=\"line\">Hide these hints with `HOMEBREW_NO_ENV_HINTS=1` (see `man brew`).</span><br></pre></td></tr></table></figure>\n<h4 id=\"测试-Formula\">测试 Formula</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">color_echo --<span class=\"built_in\">help</span></span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">用法: color_echo [参数] 内容</span><br><span class=\"line\"></span><br><span class=\"line\">参数说明:</span><br><span class=\"line\">  -c, --color &lt;color&gt;        设置前景色（文字颜色）</span><br><span class=\"line\">                             可选颜色: black red green yellow blue magenta cyan white</span><br><span class=\"line\"></span><br><span class=\"line\">  -b, --<span class=\"built_in\">bg</span> &lt;color&gt;           设置背景色</span><br><span class=\"line\">                             可选颜色: black red green yellow blue magenta cyan white</span><br><span class=\"line\"></span><br><span class=\"line\">      --bold                 加粗字体</span><br><span class=\"line\">      --underline            下划线</span><br><span class=\"line\">      --italic               斜体字体（仅部分终端,Terminal 不支持，iTerm2 支持）</span><br><span class=\"line\"></span><br><span class=\"line\">  -n                         不换行输出，兼容 <span class=\"built_in\">echo</span> 的 -n 参数</span><br><span class=\"line\"></span><br><span class=\"line\">  -h, --<span class=\"built_in\">help</span>                 显示帮助信息</span><br><span class=\"line\"></span><br><span class=\"line\">示例:</span><br><span class=\"line\">  color_echo --color green <span class=\"string\">&quot;Hello World&quot;</span></span><br><span class=\"line\">  color_echo -c red -b yellow --bold <span class=\"string\">&quot;Error Message&quot;</span></span><br><span class=\"line\">  color_echo --underline <span class=\"string\">&quot;This is underlined&quot;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"formula-文件模板\">formula 文件模板</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Ruby语法，定义一个Formula的子类</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class 子类 &lt; 父类</span></span><br><span class=\"line\">class ColorEcho &lt; Formula</span><br><span class=\"line\"></span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>添加属性</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">desc <span class=\"string\">&quot;Print colorful text in terminal&quot;</span>  <span class=\"comment\"># 描述</span></span><br><span class=\"line\">homepage <span class=\"string\">&quot;https://github.com/hanqunfeng/color_echo&quot;</span>  <span class=\"comment\"># 项目地址</span></span><br><span class=\"line\">url <span class=\"string\">&quot;https://github.com/hanqunfeng/color_echo/archive/refs/tags/v1.0.0.tar.gz&quot;</span>  <span class=\"comment\"># 下载地址，安装时会自动下载并解压</span></span><br><span class=\"line\">sha256 <span class=\"string\">&quot;9450952a4b477c83ea2d7e28386d6ae38132bf68c46746aa218c03c21aa75f6d&quot;</span>  <span class=\"comment\"># sha256，校验v1.0.0.tar.gz</span></span><br><span class=\"line\">license <span class=\"string\">&quot;MIT&quot;</span>   <span class=\"comment\"># 许可</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>添加安装方法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def install  <span class=\"comment\"># Homebrew 会执行的安装步骤，工作目录为解压后的文件目录</span></span><br><span class=\"line\">  <span class=\"comment\"># 这里只有一个步骤，如果要一次安装多个命令，可以多次添加 bin.install</span></span><br><span class=\"line\">  bin.install <span class=\"string\">&quot;bin/color_echo&quot;</span> <span class=\"comment\"># 将 bin/color_echo 安装到 /usr/local/bin/color_echo</span></span><br><span class=\"line\">  <span class=\"comment\"># 如果要指定安装后的命令名称，可以使用如下方式</span></span><br><span class=\"line\">  <span class=\"comment\"># bin.install &quot;bin/color_echo.sh&quot; =&gt; &quot;color_echo&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 如果需要执行系统命令可以使用如下方式</span></span><br><span class=\"line\">  <span class=\"comment\"># system &quot;echo&quot;, &quot;hello world&quot;</span></span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>添加测试方法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">test</span> <span class=\"keyword\">do</span>  <span class=\"comment\"># Homebrew 在安装完你的 formula 之后，会在一个隔离环境中执行这段代码</span></span><br><span class=\"line\">  <span class=\"comment\"># system 指令用于执行系统命令，逗号分隔相当于空格</span></span><br><span class=\"line\">  system <span class=\"string\">&quot;#&#123;bin&#125;/color_echo&quot;</span>, <span class=\"string\">&quot;--help&quot;</span>  <span class=\"comment\"># 相当于执行 color_echo --help</span></span><br><span class=\"line\">  <span class=\"comment\"># 断言测试</span></span><br><span class=\"line\">  <span class=\"comment\"># assert_equal &quot;2\\n&quot;, pipe_output(&quot;#&#123;bin&#125;/jq .bar&quot;, &#x27;&#123;&quot;foo&quot;:1, &quot;bar&quot;:2&#125;&#x27;)</span></span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>#{bin}: 当前这个 formula 的「安装目录里的 bin 目录」，不同平台会不同</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>系统 / 架构</th>\n<th>实际路径示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Intel Mac</td>\n<td><code>/usr/local/Cellar/color_echo/1.0.0/bin</code></td>\n</tr>\n<tr>\n<td>Apple Silicon</td>\n<td><code>/opt/homebrew/Cellar/color_echo/1.0.0/bin</code></td>\n</tr>\n<tr>\n<td>Linuxbrew</td>\n<td><code>/home/linuxbrew/.linuxbrew/Cellar/.../bin</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果当前安装的命令依赖其它命令，可以使用如下方式添加依赖</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 放在 def install 方法之前</span></span><br><span class=\"line\">depends_on <span class=\"string\">&quot;jq&quot;</span> <span class=\"comment\"># 在安装你的 formula 之前，Homebrew 会先自动安装 jq，并保证在你的 install / test 阶段可以用</span></span><br><span class=\"line\">depends_on <span class=\"string\">&quot;jq&quot;</span> =&gt; :build   <span class=\"comment\"># 只在构建时需要</span></span><br><span class=\"line\">depends_on <span class=\"string\">&quot;jq&quot;</span> =&gt; :<span class=\"built_in\">test</span>    <span class=\"comment\"># 测试时需要</span></span><br><span class=\"line\">depends_on <span class=\"string\">&quot;jq&quot;</span> =&gt; [:build, :<span class=\"built_in\">test</span>] <span class=\"comment\"># 构建和测试都需要</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 环境约束</span></span><br><span class=\"line\">depends_on macos: :sonoma          <span class=\"comment\"># 仅 macOS Sonoma</span></span><br><span class=\"line\">depends_on <span class=\"built_in\">arch</span>: :x86_64           <span class=\"comment\"># 仅 x86_64</span></span><br><span class=\"line\">depends_on xcode: [<span class=\"string\">&quot;9.3&quot;</span>, :build]  <span class=\"comment\"># 仅当 Xcode≥9.3 且用于 build</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 依赖第三方库中的命令要用完整包名</span></span><br><span class=\"line\">depends_on <span class=\"string\">&quot;hanqunfeng/color_echo/color_echo&quot;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"后记\">后记</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>关于更多的 Formula 文件模板，可以参考：<a href=\"https://docs.brew.sh/Formula-Cookbook\">https://docs.brew.sh/Formula-Cookbook</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>同时也可以通过 <code>brew edit xxx</code> 命令查看该 Formula 文件的内容进行学习</p>\n</li>\n</ul>\n","content_text":"摘要 brew是一个软件包管理器，同时支持MacOS和Linux，可以很方便地安装各种软件，比如git、node、python等。 本文介绍如何在macos下创建自己的 Formula 本文基于 MacOS 15.7.2，brew 版本为 Homebrew 5.0.3。 关于 brew 的安装及使用可以参考 MacOS软件包管理器--brew 从一个简单示例开始 这里使用我自己编写的一个命令行脚本为例，脚本名称：color_echo，具体内容可以查看color_echo，这是一个用于终端打印彩色文本的命令。 创建一个Github仓库，用于存储 color_echo 命令 创建一个Github仓库，用于存储 color_echo 命令文件，仓库名称: hanqunfeng/color_echo 编写命令文件 12345mkdir color_echo_dircd color_echo_dir# 感兴趣的自己去github上查看文件内容吧，这里就不贴出来了# 这里将命令存储在了 bin 目录下，这个路径后面编写 Formula 文件时会用到bin/color_echo 提交代码并打Tag 1234567891011# 在 color_echo_dir 目录下初始化仓库git initgit add .git commit -m &quot;Initial commit&quot;git branch -M maingit remote add origin https://github.com/hanqunfeng/color_echo.gitgit push -u origin main# 创建Taggit tag v1.0.0# 推送Taggit push --tags 获取tag的sha256值 1234wget https://github.com/hanqunfeng/color_echo/archive/refs/tags/v1.0.0.tar.gzshasum -a 256 v1.0.0.tar.gz## 输出9450952a4b477c83ea2d7e28386d6ae38132bf68c46746aa218c03c21aa75f6d v1.0.0.tar.gz 发布 color_echo brew create 命令已经失效，需要手工创建 创建 tap 仓库 1234567891011121314151617181920brew tap-new hanqunfeng/color_echo## 输出Warning: tap-new is a developer command, so Homebrew&#x27;sdeveloper mode has been automatically turned on. # 提示开发者模式已自动打开To turn developer mode off, run: brew developer off # 如后续需要关闭开发者模式可以运行该命令## 初始化仓库Initialized empty Git repository in /usr/local/Homebrew/Library/Taps/hanqunfeng/homebrew-color_echo/.git/[main (root-commit) 35d602b] Create hanqunfeng/color_echo tap 3 files changed, 107 insertions(+) create mode 100644 .github/workflows/publish.yml create mode 100644 .github/workflows/tests.yml create mode 100644 README.md==&gt; Created hanqunfeng/color_echo/usr/local/Homebrew/Library/Taps/hanqunfeng/homebrew-color_echoWhen a pull request making changes to a formula (or formulae) becomes green(all checks passed), then you can publish the built bottles.To do so, label your PR as `pr-pull` and the workflow will be triggered. 手写一个 Formula 文件 12cd /usr/local/Homebrew/Library/Taps/hanqunfeng/homebrew-color_echo/Formulatouch color_echo.rb 写入内容（模板）：模板格式后面会详细介绍 123456789101112131415class ColorEcho &lt; Formula desc &quot;Print colorful text in terminal&quot; homepage &quot;https://github.com/hanqunfeng/color_echo&quot; url &quot;https://github.com/hanqunfeng/color_echo/archive/refs/tags/v1.0.0.tar.gz&quot; sha256 &quot;9450952a4b477c83ea2d7e28386d6ae38132bf68c46746aa218c03c21aa75f6d&quot; license &quot;MIT&quot; def install bin.install &quot;bin/color_echo&quot; end test do system &quot;#&#123;bin&#125;/color_echo&quot;, &quot;--help&quot; endend 提交 Formula 文件到Github仓库 创建一个Github仓库，用于存储 Formula 文件: hanqunfeng/homebrew-color_echo 添加 Formula 文件到仓库 123456789101112131415cd $(brew --repo hanqunfeng/color_echo)git add .git commit -m &quot;Add color_echo 1.0.0&quot;git remote add origin https://github.com/hanqunfeng/homebrew-color_echo.gitgit push -u origin main## 输出Enumerating objects: 11, done.Counting objects: 100% (11/11), done.Delta compression using up to 12 threadsCompressing objects: 100% (9/9), done.Writing objects: 100% (11/11), 2.11 KiB | 2.11 MiB/s, done.Total 11 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)To https://github.com/hanqunfeng/homebrew-color_echo.git! [remote rejected] main -&gt; main (refusing to allow a Personal Access Token to create or update workflow `.github/workflows/publish.yml` without `workflow` scope)error: failed to push some refs to &#x27;https://github.com/hanqunfeng/homebrew-color_echo.git&#x27; 提示缺少权限，需要给仓库添加权限。在 Github 中添加一个 Personal Access Token，并添加权限repo 和 workflow，重新推送 12345678910111213# 设置远程仓库地址，注意替换为你的仓库地址，并且密钥替换为实际的密钥git remote set-url origin https://ghp_xxxxx@github.com/hanqunfeng/homebrew-color_echo.gitgit push -u origin main## 输出Enumerating objects: 11, done.Counting objects: 100% (11/11), done.Delta compression using up to 12 threadsCompressing objects: 100% (9/9), done.Writing objects: 100% (11/11), 2.11 KiB | 2.11 MiB/s, done.Total 11 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)To https://github.com/hanqunfeng/homebrew-color_echo.git* [new branch] main -&gt; mainbranch &#x27;main&#x27; set up to track &#x27;origin/main&#x27;. 安装 Formula 12345678910111213141516171819202122232425# 切换 tap，注意: 执行搜索和安装时需要先切换 tap，否则需要使用完整包名 hanqunfeng/color_echo/color_echobrew tap hanqunfeng/color_echo# 搜索brew search color_echo## 输出==&gt; Formulaehanqunfeng/color_echo/color_echo color-code# 完整包名搜索brew search hanqunfeng/color_echo/color_echo## 输出==&gt; Formulaecolor_echo# 安装brew install color_echo## 输出==&gt; Fetching downloads for: color_echo✔︎ Formula color_echo (1.0.0) [Verifying 2.1KB/ 2.1KB]==&gt; Installing color_echo from hanqunfeng/color_echo🍺 /usr/local/Cellar/color_echo/1.0.0: 4 files, 7.4KB, built in 5 seconds==&gt; Running `brew cleanup color_echo`...Disable this behaviour by setting `HOMEBREW_NO_INSTALL_CLEANUP=1`.Hide these hints with `HOMEBREW_NO_ENV_HINTS=1` (see `man brew`). 测试 Formula 1234567891011121314151617181920212223color_echo --help## 输出用法: color_echo [参数] 内容参数说明: -c, --color &lt;color&gt; 设置前景色（文字颜色） 可选颜色: black red green yellow blue magenta cyan white -b, --bg &lt;color&gt; 设置背景色 可选颜色: black red green yellow blue magenta cyan white --bold 加粗字体 --underline 下划线 --italic 斜体字体（仅部分终端,Terminal 不支持，iTerm2 支持） -n 不换行输出，兼容 echo 的 -n 参数 -h, --help 显示帮助信息示例: color_echo --color green &quot;Hello World&quot; color_echo -c red -b yellow --bold &quot;Error Message&quot; color_echo --underline &quot;This is underlined&quot; formula 文件模板 Ruby语法，定义一个Formula的子类 1234# class 子类 &lt; 父类class ColorEcho &lt; Formulaend 添加属性 12345desc &quot;Print colorful text in terminal&quot; # 描述homepage &quot;https://github.com/hanqunfeng/color_echo&quot; # 项目地址url &quot;https://github.com/hanqunfeng/color_echo/archive/refs/tags/v1.0.0.tar.gz&quot; # 下载地址，安装时会自动下载并解压sha256 &quot;9450952a4b477c83ea2d7e28386d6ae38132bf68c46746aa218c03c21aa75f6d&quot; # sha256，校验v1.0.0.tar.gzlicense &quot;MIT&quot; # 许可 添加安装方法 123456789def install # Homebrew 会执行的安装步骤，工作目录为解压后的文件目录 # 这里只有一个步骤，如果要一次安装多个命令，可以多次添加 bin.install bin.install &quot;bin/color_echo&quot; # 将 bin/color_echo 安装到 /usr/local/bin/color_echo # 如果要指定安装后的命令名称，可以使用如下方式 # bin.install &quot;bin/color_echo.sh&quot; =&gt; &quot;color_echo&quot; # 如果需要执行系统命令可以使用如下方式 # system &quot;echo&quot;, &quot;hello world&quot;end 添加测试方法 123456test do # Homebrew 在安装完你的 formula 之后，会在一个隔离环境中执行这段代码 # system 指令用于执行系统命令，逗号分隔相当于空格 system &quot;#&#123;bin&#125;/color_echo&quot;, &quot;--help&quot; # 相当于执行 color_echo --help # 断言测试 # assert_equal &quot;2\\n&quot;, pipe_output(&quot;#&#123;bin&#125;/jq .bar&quot;, &#x27;&#123;&quot;foo&quot;:1, &quot;bar&quot;:2&#125;&#x27;)end #{bin}: 当前这个 formula 的「安装目录里的 bin 目录」，不同平台会不同 系统 / 架构 实际路径示例 Intel Mac /usr/local/Cellar/color_echo/1.0.0/bin Apple Silicon /opt/homebrew/Cellar/color_echo/1.0.0/bin Linuxbrew /home/linuxbrew/.linuxbrew/Cellar/.../bin 如果当前安装的命令依赖其它命令，可以使用如下方式添加依赖 123456789101112131415# 放在 def install 方法之前depends_on &quot;jq&quot; # 在安装你的 formula 之前，Homebrew 会先自动安装 jq，并保证在你的 install / test 阶段可以用depends_on &quot;jq&quot; =&gt; :build # 只在构建时需要depends_on &quot;jq&quot; =&gt; :test # 测试时需要depends_on &quot;jq&quot; =&gt; [:build, :test] # 构建和测试都需要# 环境约束depends_on macos: :sonoma # 仅 macOS Sonomadepends_on arch: :x86_64 # 仅 x86_64depends_on xcode: [&quot;9.3&quot;, :build] # 仅当 Xcode≥9.3 且用于 build# 依赖第三方库中的命令要用完整包名depends_on &quot;hanqunfeng/color_echo/color_echo&quot; 后记 关于更多的 Formula 文件模板，可以参考：https://docs.brew.sh/Formula-Cookbook 同时也可以通过 brew edit xxx 命令查看该 Formula 文件的内容进行学习","summary":"摘要 brew是一个软件包管理器，同时支持MacOS和Linux，可以很方便地安装各种软件，比如git、node、python等。 本文介绍如何在macos下创建自己的 Formula 本文基于 MacOS 15.7.2，brew 版本为 Homebrew 5.0.3。 关于 brew 的安装及使用可以参考 MacOS软件包管理器--brew","date_published":"2025-12-02T13:55:05.000Z","tags":["macos","macos","brew"]},{"id":"https://blog.hanqunfeng.com/2025/11/26/linux-command16-lsof/","url":"https://blog.hanqunfeng.com/2025/11/26/linux-command16-lsof/","title":"Linux常用命令--lsof","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 lsof 命令的使用方法</p>\n</li>\n<li class=\"lvl-2\">\n<p>本文基于CentOS8。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"lsof-是什么？\">lsof 是什么？</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>lsof = list open files</p>\n</li>\n<li class=\"lvl-2\">\n<p>它用来查看：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">当前系统中所有进程打开的文件</li>\n<li class=\"lvl-4\">包含普通文件、目录、socket、管道、网络连接、设备等</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>在 Linux 中：“一切皆文件”</p>\n</li>\n<li class=\"lvl-2\">\n<p>所以你可以用 lsof 查看：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">谁在占用你的端口？</li>\n<li class=\"lvl-4\">哪个进程正在读/写某个文件？</li>\n<li class=\"lvl-4\">为什么文件删除了却还占磁盘？</li>\n<li class=\"lvl-4\">哪个文件被锁住？</li>\n<li class=\"lvl-4\">哪些程序在访问某个目录？</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>CentOS 默认包含 lsof，但如果没有，可以通过 yum 安装</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install lsof -y</span><br></pre></td></tr></table></figure>\n<h2 id=\"lsof-的基本用法\">lsof 的基本用法</h2>\n<h3 id=\"查看被删除但仍被占用的文件\">查看被删除但仍被占用的文件</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果进程正在运行且保持文件的句柄，此时没有停止进程就执行了<code>rm</code>命令，此时文件的**目录项（名字）**被删除，但是文件数据本身没有被删除，只要有进程还在打开这个文件（保持文件句柄），它就继续占用磁盘空间。</p>\n</li>\n<li class=\"lvl-2\">\n<p>文件已经被删除（unlink），但进程仍然持有该文件的打开句柄，这种文件在：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">ls</span> 中看不到</span><br><span class=\"line\"><span class=\"built_in\">du</span> 不会统计空间</span><br><span class=\"line\">只有 lsof 能看到，这是典型的 “deleted but still open” 状态。</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时可以通过如下命令查询哪些被删除的文件还被占用：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出所有 link count 小于 1 的（deleted）文件</span></span><br><span class=\"line\">lsof +L1</span><br><span class=\"line\"><span class=\"comment\"># 列出所有被删除的文件</span></span><br><span class=\"line\">lsof | grep deleted</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果查询到这种文件，则需要停止进程，才能真正删除文件。</p>\n</li>\n</ul>\n<div class=\"tips\">\n<p><em><strong>记一次线上服务器磁盘空间告警问题排查</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">监控系统告警磁盘空间小于15%，通过如下命令查看确实如此</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">df</span> -hT</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">Filesystem Type  Size Used Avail Use% Mounted on</span><br><span class=\"line\">/dev/xvda1 ext4  7.9G 3.3G 4.6G  42%  /</span><br><span class=\"line\">tmpfs      tmpfs 2.0G 0    2.0G  0%   /dev/shm</span><br><span class=\"line\">/dev/xvdf1 ext4  99G  80G  15G   85%  /usr/local/boss/logs</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">但通过如下命令具体查看目录占用空间时，发现占用的空间比实际占用的空间少很多</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">du</span> -sh /usr/local/boss/logs</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">2.3G    /usr/local/boss/logs</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">此时想到可能是删除的文件句柄没有被释放，可以通过如下命令查看：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsof +L1</span><br><span class=\"line\"><span class=\"comment\">## 输出示例，NLINK:硬链接数量（Number of Links），=0 表示文件被删除，但是进程没有释放文件句柄</span></span><br><span class=\"line\">COMMAND    PID      USER    FD      TYPE    DEVICE  SIZE/OFF      NLINK   NODE    NAME</span><br><span class=\"line\">java       1836     boss    1w      REG     202,81  82677994584   0       917554  /usr/local/boss/logs/tomcat_log/catalina.out (deleted)</span><br><span class=\"line\">java       1836     boss    2w      REG     202,81  82677994584   0       917554  /usr/local/boss/logs/tomcat_log/catalina.out (deleted)</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">结果如预期，这是一个tomcat进程，应该是删除了其日志文件，但是删除时没有停止tomcat进程，导致文件被继续占用，此时已经占用了80多个G的磁盘空间，如果要释放磁盘空间需要停止tomcat。</li>\n</ul>\n</div>\n<h3 id=\"查端口被哪个进程占用\">查端口被哪个进程占用</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>通过如下命令查询：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出指定端口对应的进程</span></span><br><span class=\"line\">lsof -i tcp:8080</span><br><span class=\"line\"><span class=\"comment\"># 协议可以省略</span></span><br><span class=\"line\">lsof -i :8080</span><br><span class=\"line\"><span class=\"comment\">## 输出示例</span></span><br><span class=\"line\">COMMAND   PID USER   FD   TYPE     DEVICE SIZE/OFF NODE NAME</span><br><span class=\"line\">java    18548 boss   39u  IPv6 1251548211      0t0  TCP *:webcache (LISTEN)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将服务名称替换为端口</span></span><br><span class=\"line\">lsof -i :8080 -P</span><br><span class=\"line\"><span class=\"comment\">## 输出示例</span></span><br><span class=\"line\">COMMAND   PID USER   FD   TYPE     DEVICE SIZE/OFF NODE NAME</span><br><span class=\"line\">java    18548 boss   39u  IPv6 1251548211      0t0  TCP *:8080 (LISTEN)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"查看某个进程打开的所有文件\">查看某个进程打开的所有文件</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>通过如下命令查询：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsof -p &lt;PID&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 输出示例</span></span><br><span class=\"line\">COMMAND   PID USER   FD   TYPE     DEVICE  SIZE/OFF       NODE NAME</span><br><span class=\"line\">java    18548 boss  cwd    DIR      202,1      4096      35377 /home/boss</span><br><span class=\"line\">java    18548 boss  rtd    DIR      202,1      4096          2 /</span><br><span class=\"line\">java    18548 boss  mem    REG      202,1 106065056      60671 /usr/lib/locale/locale-archive</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>能看到这个进程：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">打开的日志文件</li>\n<li class=\"lvl-4\">使用的 jar 文件</li>\n<li class=\"lvl-4\">使用的 socket</li>\n<li class=\"lvl-4\">使用的 config 文件</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>输出结果字段说明</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>COMMAND</td>\n<td>程序名（java）</td>\n</tr>\n<tr>\n<td>PID</td>\n<td>进程号（18548）</td>\n</tr>\n<tr>\n<td>USER</td>\n<td>运行用户（boss）</td>\n</tr>\n<tr>\n<td>FD</td>\n<td>文件描述符</td>\n</tr>\n<tr>\n<td>TYPE</td>\n<td>文件类型</td>\n</tr>\n<tr>\n<td>DEVICE</td>\n<td>所在磁盘分区 ID</td>\n</tr>\n<tr>\n<td>SIZE/OFF</td>\n<td>文件大小（字节）</td>\n</tr>\n<tr>\n<td>NODE</td>\n<td>inode 编号</td>\n</tr>\n<tr>\n<td>NAME</td>\n<td>文件名（或网络连接信息）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"查看指定用户占用的文件\">查看指定用户占用的文件</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>通过如下命令查询：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出用户 boss 所有进程打开的文件</span></span><br><span class=\"line\">lsof -u &lt;USER&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看指定程序-COMMAND-打开的文件\">查看指定程序(COMMAND)打开的文件</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>通过如下命令查询：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsof -c &lt;<span class=\"built_in\">command</span>&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"查某个目录或文件正在被哪些进程占用\">查某个目录或文件正在被哪些进程占用</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 目录 +D</span></span><br><span class=\"line\"><span class=\"comment\"># 能显示所有正在访问该目录中文件的进程</span></span><br><span class=\"line\">lsof +D /home/boss/logs</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 文件</span></span><br><span class=\"line\">lsof /home/boss/logs/access.log</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 只列出 nginx 用户占用的文件目录中的哪些文件</span></span><br><span class=\"line\"><span class=\"comment\"># -a: 逻辑与，不加 -a 则表示 逻辑或</span></span><br><span class=\"line\">lsof -a -u nginx +D /usr/local/nginx/logs</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"查看网络连接\">查看网络连接</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsof -i</span><br><span class=\"line\"><span class=\"comment\"># 过滤协议</span></span><br><span class=\"line\">lsof -i tcp</span><br><span class=\"line\">lsof -i udp</span><br><span class=\"line\"><span class=\"comment\"># 过滤状态</span></span><br><span class=\"line\">lsof -i -s tcp:listen</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 列出所有监听端口，</span></span><br><span class=\"line\"><span class=\"comment\"># -i: 显示网络相关的文件</span></span><br><span class=\"line\"><span class=\"comment\"># -P: 显示端口(不加-P则显示的是服务名)</span></span><br><span class=\"line\"><span class=\"comment\"># -n: 不将 IP 映射成主机名（禁用 DNS 查询）</span></span><br><span class=\"line\"><span class=\"comment\"># -s: 过滤显示连接状态</span></span><br><span class=\"line\">lsof -i -P -n -s tcp:listen</span><br><span class=\"line\"><span class=\"comment\">## 输出示例</span></span><br><span class=\"line\">mongod     1782     root    5u  IPv4       8697      0t0  TCP *:27017 (LISTEN)</span><br><span class=\"line\">java       1808     boss   36u  IPv6       9221      0t0  TCP *:8082 (LISTEN)</span><br><span class=\"line\">java       1808     boss   39u  IPv6       9230      0t0  TCP 127.0.0.1:7093 (LISTEN)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 列出用户 boss 的网络连接</span></span><br><span class=\"line\"><span class=\"comment\"># -a: 逻辑与，不加 -a 则表示 逻辑或</span></span><br><span class=\"line\">lsof -a -u boss -i</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"常用参数详解\">常用参数详解</h2>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>作用</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-i</code></td>\n<td>查看网络相关文件/端口</td>\n<td><code>lsof -i</code></td>\n</tr>\n<tr>\n<td><code>-i :端口</code></td>\n<td>查看指定端口</td>\n<td><code>lsof -i :8080</code></td>\n</tr>\n<tr>\n<td><code>-p PID</code></td>\n<td>查看某个进程所有打开文件</td>\n<td><code>lsof -p 1836</code></td>\n</tr>\n<tr>\n<td><code>-u 用户名</code></td>\n<td>查看某个用户进程的打开文件</td>\n<td><code>lsof -u nginx</code></td>\n</tr>\n<tr>\n<td><code>-c 进程名关键字</code></td>\n<td>查看某个进程名相关的文件</td>\n<td><code>lsof -c java</code></td>\n</tr>\n<tr>\n<td><code>+D 目录</code></td>\n<td>查看目录中所有被访问的文件</td>\n<td><code>lsof +D /usr/local/netqin/boss/netqin/logs</code></td>\n</tr>\n<tr>\n<td><code>+L1</code></td>\n<td>查找已删除但仍被打开的文件</td>\n<td><code>lsof +L1</code>（=查找“(deleted)”占盘问题）</td>\n</tr>\n<tr>\n<td><code>-d FD</code></td>\n<td>查看指定文件描述符</td>\n<td><code>lsof -d 1 -p 1836</code>（看进程 stdout）</td>\n</tr>\n<tr>\n<td><code>-n</code></td>\n<td>不做 DNS 解析，提高速度</td>\n<td><code>lsof -i -n</code></td>\n</tr>\n<tr>\n<td><code>-P</code></td>\n<td>显示端口号（不解析为服务名）</td>\n<td><code>lsof -i -P</code></td>\n</tr>\n<tr>\n<td><code>-s</code></td>\n<td>按连接状态过滤（TCP/UDP）</td>\n<td><code>lsof -i -sTCP:LISTEN</code></td>\n</tr>\n<tr>\n<td><code>-r</code></td>\n<td>持续输出（实时监控）</td>\n<td><code>lsof -i -r 1</code>（每秒刷新网络连接）</td>\n</tr>\n<tr>\n<td><code>-a</code></td>\n<td>逻辑 AND，不加 -a 都是 逻辑 OR</td>\n<td><code>lsof -u boss -i</code>（列出用户 boss 的网络连接）</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"lsof-文件-FD-字段详细解释\">lsof 文件 FD 字段详细解释</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>FD（文件描述符）格式总规则：数字 + 标志位</p>\n</li>\n<li class=\"lvl-2\">\n<p>lsof 输出中的 FD（文件描述符）列，每一个都代表进程打开的一个“文件”（包括普通文件、目录、设备、socket、pipe 等）。</p>\n</li>\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10r   → FD=10，<span class=\"built_in\">read</span> only（只读）</span><br><span class=\"line\">1w    → FD=1，write only（只写）</span><br><span class=\"line\">36u   → FD=36，<span class=\"built_in\">read</span>/write（可读可写）</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>解释</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>部分</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>数字（0、1、2、3、10、36…）</strong></td>\n<td>文件描述符编号</td>\n</tr>\n<tr>\n<td><strong>字母（r / w / u）</strong></td>\n<td>访问模式：读/写/读写</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>FD 编号</th>\n<th>标准含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>0</strong></td>\n<td>stdin（标准输入）</td>\n</tr>\n<tr>\n<td><strong>1</strong></td>\n<td>stdout（标准输出）</td>\n</tr>\n<tr>\n<td><strong>2</strong></td>\n<td>stderr（标准错误输出）</td>\n</tr>\n<tr>\n<td><strong>3</strong> 及以上</td>\n<td>进程打开的普通文件、日志、socket、管道等</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>特殊 FD 类型（没有数字）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>cwd</code></td>\n<td>当前工作目录，说明进程在这个目录下运行</td>\n</tr>\n<tr>\n<td><code>rtd</code></td>\n<td>进程的根目录，大多数情况下是 /，容器里可能是别的 rootfs</td>\n</tr>\n<tr>\n<td><code>txt</code></td>\n<td>可执行文件本体</td>\n</tr>\n<tr>\n<td><code>mem</code></td>\n<td>内存映射（mmap）文件，进程加载到内存中的库 / jar / so 文件</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"lsof-文件-TYPE-字段详细解释\">lsof 文件 TYPE 字段详细解释</h2>\n<table>\n<thead>\n<tr>\n<th>文件类型</th>\n<th>全称</th>\n<th>含义</th>\n<th>常见场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>REG</strong></td>\n<td>Regular file</td>\n<td>普通文件</td>\n<td>日志、配置、可执行程序等</td>\n</tr>\n<tr>\n<td><strong>DIR</strong></td>\n<td>Directory</td>\n<td>目录</td>\n<td>进程访问的目录，例如当前工作目录</td>\n</tr>\n<tr>\n<td><strong>CHR</strong></td>\n<td>Character special file</td>\n<td>字符设备文件</td>\n<td><code>/dev/null</code>、<code>/dev/tty</code>、串口、键盘等</td>\n</tr>\n<tr>\n<td><strong>BLK</strong></td>\n<td>Block special file</td>\n<td>块设备文件</td>\n<td><code>/dev/sda</code>、硬盘、分区等</td>\n</tr>\n<tr>\n<td><strong>FIFO</strong></td>\n<td>Named pipe</td>\n<td>命名管道</td>\n<td>Linux 进程间通信，如 Nginx 和 PHP-FPM 的通信</td>\n</tr>\n<tr>\n<td><strong>sock</strong></td>\n<td>Socket</td>\n<td>套接字（Unix 域 socket）</td>\n<td><code>/var/run/docker.sock</code>、MySQL UNix socket</td>\n</tr>\n<tr>\n<td><strong>IPv4</strong></td>\n<td>IPv4 socket</td>\n<td>IPv4 网络连接/监听</td>\n<td><code>TCP *:80</code>、<code>UDP 127.0.0.1:53</code></td>\n</tr>\n<tr>\n<td><strong>IPv6</strong></td>\n<td>IPv6 socket</td>\n<td>IPv6 网络连接/监听</td>\n<td><code>TCP [::]:22</code></td>\n</tr>\n<tr>\n<td><strong>unix</strong></td>\n<td>Unix domain socket</td>\n<td>本地进程通信</td>\n<td><code>/run/systemd/journal/stdout</code></td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 lsof 命令的使用方法 本文基于CentOS8。 lsof 是什么？ lsof = list open files 它用来查看： 当前系统中所有进程打开的文件 包含普通文件、目录、socket、管道、网络连接、设备等 在 Linux 中：“一切皆文件” 所以你可以用 lsof 查看： 谁在占用你的端口？ 哪个进程正在读/写某个文件？ 为什么文件删除了却还占磁盘？ 哪个文件被锁住？ 哪些程序在访问某个目录？ CentOS 默认包含 lsof，但如果没有，可以通过 yum 安装 1yum install lsof -y lsof 的基本用法 查看被删除但仍被占用的文件 如果进程正在运行且保持文件的句柄，此时没有停止进程就执行了rm命令，此时文件的**目录项（名字）**被删除，但是文件数据本身没有被删除，只要有进程还在打开这个文件（保持文件句柄），它就继续占用磁盘空间。 文件已经被删除（unlink），但进程仍然持有该文件的打开句柄，这种文件在： 123ls 中看不到du 不会统计空间只有 lsof 能看到，这是典型的 “deleted but still open” 状态。 此时可以通过如下命令查询哪些被删除的文件还被占用： 1234# 列出所有 link count 小于 1 的（deleted）文件lsof +L1# 列出所有被删除的文件lsof | grep deleted 如果查询到这种文件，则需要停止进程，才能真正删除文件。 记一次线上服务器磁盘空间告警问题排查 监控系统告警磁盘空间小于15%，通过如下命令查看确实如此 123456$ df -hT# 输出Filesystem Type Size Used Avail Use% Mounted on/dev/xvda1 ext4 7.9G 3.3G 4.6G 42% /tmpfs tmpfs 2.0G 0 2.0G 0% /dev/shm/dev/xvdf1 ext4 99G 80G 15G 85% /usr/local/boss/logs 但通过如下命令具体查看目录占用空间时，发现占用的空间比实际占用的空间少很多 123$ du -sh /usr/local/boss/logs# 输出2.3G /usr/local/boss/logs 此时想到可能是删除的文件句柄没有被释放，可以通过如下命令查看： 12345lsof +L1## 输出示例，NLINK:硬链接数量（Number of Links），=0 表示文件被删除，但是进程没有释放文件句柄COMMAND PID USER FD TYPE DEVICE SIZE/OFF NLINK NODE NAMEjava 1836 boss 1w REG 202,81 82677994584 0 917554 /usr/local/boss/logs/tomcat_log/catalina.out (deleted)java 1836 boss 2w REG 202,81 82677994584 0 917554 /usr/local/boss/logs/tomcat_log/catalina.out (deleted) 结果如预期，这是一个tomcat进程，应该是删除了其日志文件，但是删除时没有停止tomcat进程，导致文件被继续占用，此时已经占用了80多个G的磁盘空间，如果要释放磁盘空间需要停止tomcat。 查端口被哪个进程占用 通过如下命令查询： 1234567891011121314# 列出指定端口对应的进程lsof -i tcp:8080# 协议可以省略lsof -i :8080## 输出示例COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEjava 18548 boss 39u IPv6 1251548211 0t0 TCP *:webcache (LISTEN)# 将服务名称替换为端口lsof -i :8080 -P## 输出示例COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEjava 18548 boss 39u IPv6 1251548211 0t0 TCP *:8080 (LISTEN) 查看某个进程打开的所有文件 通过如下命令查询： 12345678lsof -p &lt;PID&gt;## 输出示例COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEjava 18548 boss cwd DIR 202,1 4096 35377 /home/bossjava 18548 boss rtd DIR 202,1 4096 2 /java 18548 boss mem REG 202,1 106065056 60671 /usr/lib/locale/locale-archive 能看到这个进程： 打开的日志文件 使用的 jar 文件 使用的 socket 使用的 config 文件 输出结果字段说明 字段 含义 COMMAND 程序名（java） PID 进程号（18548） USER 运行用户（boss） FD 文件描述符 TYPE 文件类型 DEVICE 所在磁盘分区 ID SIZE/OFF 文件大小（字节） NODE inode 编号 NAME 文件名（或网络连接信息） 查看指定用户占用的文件 通过如下命令查询： 12# 列出用户 boss 所有进程打开的文件lsof -u &lt;USER&gt; 查看指定程序(COMMAND)打开的文件 通过如下命令查询： 1lsof -c &lt;command&gt; 查某个目录或文件正在被哪些进程占用 1234567891011# 目录 +D# 能显示所有正在访问该目录中文件的进程lsof +D /home/boss/logs# 文件lsof /home/boss/logs/access.log# 只列出 nginx 用户占用的文件目录中的哪些文件# -a: 逻辑与，不加 -a 则表示 逻辑或lsof -a -u nginx +D /usr/local/nginx/logs 查看网络连接 12345678910111213141516171819202122lsof -i# 过滤协议lsof -i tcplsof -i udp# 过滤状态lsof -i -s tcp:listen# 列出所有监听端口，# -i: 显示网络相关的文件# -P: 显示端口(不加-P则显示的是服务名)# -n: 不将 IP 映射成主机名（禁用 DNS 查询）# -s: 过滤显示连接状态lsof -i -P -n -s tcp:listen## 输出示例mongod 1782 root 5u IPv4 8697 0t0 TCP *:27017 (LISTEN)java 1808 boss 36u IPv6 9221 0t0 TCP *:8082 (LISTEN)java 1808 boss 39u IPv6 9230 0t0 TCP 127.0.0.1:7093 (LISTEN)# 列出用户 boss 的网络连接# -a: 逻辑与，不加 -a 则表示 逻辑或lsof -a -u boss -i 常用参数详解 参数 作用 示例 -i 查看网络相关文件/端口 lsof -i -i :端口 查看指定端口 lsof -i :8080 -p PID 查看某个进程所有打开文件 lsof -p 1836 -u 用户名 查看某个用户进程的打开文件 lsof -u nginx -c 进程名关键字 查看某个进程名相关的文件 lsof -c java +D 目录 查看目录中所有被访问的文件 lsof +D /usr/local/netqin/boss/netqin/logs +L1 查找已删除但仍被打开的文件 lsof +L1（=查找“(deleted)”占盘问题） -d FD 查看指定文件描述符 lsof -d 1 -p 1836（看进程 stdout） -n 不做 DNS 解析，提高速度 lsof -i -n -P 显示端口号（不解析为服务名） lsof -i -P -s 按连接状态过滤（TCP/UDP） lsof -i -sTCP:LISTEN -r 持续输出（实时监控） lsof -i -r 1（每秒刷新网络连接） -a 逻辑 AND，不加 -a 都是 逻辑 OR lsof -u boss -i（列出用户 boss 的网络连接） lsof 文件 FD 字段详细解释 FD（文件描述符）格式总规则：数字 + 标志位 lsof 输出中的 FD（文件描述符）列，每一个都代表进程打开的一个“文件”（包括普通文件、目录、设备、socket、pipe 等）。 示例 12310r → FD=10，read only（只读）1w → FD=1，write only（只写）36u → FD=36，read/write（可读可写） 解释 部分 含义 数字（0、1、2、3、10、36…） 文件描述符编号 字母（r / w / u） 访问模式：读/写/读写 FD 编号 标准含义 0 stdin（标准输入） 1 stdout（标准输出） 2 stderr（标准错误输出） 3 及以上 进程打开的普通文件、日志、socket、管道等 特殊 FD 类型（没有数字） 字段 含义 cwd 当前工作目录，说明进程在这个目录下运行 rtd 进程的根目录，大多数情况下是 /，容器里可能是别的 rootfs txt 可执行文件本体 mem 内存映射（mmap）文件，进程加载到内存中的库 / jar / so 文件 lsof 文件 TYPE 字段详细解释 文件类型 全称 含义 常见场景 REG Regular file 普通文件 日志、配置、可执行程序等 DIR Directory 目录 进程访问的目录，例如当前工作目录 CHR Character special file 字符设备文件 /dev/null、/dev/tty、串口、键盘等 BLK Block special file 块设备文件 /dev/sda、硬盘、分区等 FIFO Named pipe 命名管道 Linux 进程间通信，如 Nginx 和 PHP-FPM 的通信 sock Socket 套接字（Unix 域 socket） /var/run/docker.sock、MySQL UNix socket IPv4 IPv4 socket IPv4 网络连接/监听 TCP *:80、UDP 127.0.0.1:53 IPv6 IPv6 socket IPv6 网络连接/监听 TCP [::]:22 unix Unix domain socket 本地进程通信 /run/systemd/journal/stdout","summary":"摘要 本文介绍 lsof 命令的使用方法 本文基于CentOS8。","date_published":"2025-11-26T13:30:05.000Z","tags":["技术","linux","linux常用命令","linux常用命令"]},{"id":"https://blog.hanqunfeng.com/2025/11/20/utc/","url":"https://blog.hanqunfeng.com/2025/11/20/utc/","title":"什么是 UTC？一篇人人都能看懂的科普文章","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在生活中，我们经常听到“UTC 时间”“北京时间 UTC+8”“服务器时间是 UTC”，但许多人并不了解 UTC 到底是什么。本文将用尽量简单的方式，带你搞清楚现代世界所依赖的全球通用时间标准——UTC。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"一、为什么世界需要统一时间？\">一、为什么世界需要统一时间？</h2>\n<p>早期，每个城市甚至每个乡镇都根据 <strong>太阳位置</strong>确定时间：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>太阳在头顶就是 12 点</p>\n</li>\n<li class=\"lvl-2\">\n<p>不同地方经度不同，每地时间都不同</p>\n</li>\n</ul>\n<p>这种方法在本地没问题，但到了 <strong>跨区域铁路、通信、航海、航空、互联网时代</strong>，问题巨大：</p>\n<blockquote>\n<p>两地时间不统一，火车、舰队、订单、通信都没法同步记录。</p>\n</blockquote>\n<p>因此世界需要：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>一个 <strong>全球统一、精确的标准时间</strong></p>\n</li>\n<li class=\"lvl-2\">\n<p>所有人、所有系统都能对齐使用</p>\n</li>\n</ul>\n<p>UTC 就是在这个背景下诞生的。</p>\n<hr>\n<h2 id=\"二、UTC-是什么？\">二、UTC 是什么？</h2>\n<p>UTC 的全称：</p>\n<blockquote>\n<p><strong>Coordinated Universal Time（协调世界时）</strong></p>\n</blockquote>\n<p>它是当今全球使用的 <strong>标准时间系统</strong>。</p>\n<p>它的主要特点：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>不是某个国家的时间</p>\n</li>\n<li class=\"lvl-2\">\n<p>是国际组织共同维护</p>\n</li>\n<li class=\"lvl-2\">\n<p>全世界所有机房、通信、卫星、航班、GPS、金融系统都以它为基准</p>\n</li>\n</ul>\n<p>一句话：</p>\n<blockquote>\n<p><strong>UTC 是现代世界共同使用的“世界时间”。</strong></p>\n</blockquote>\n<hr>\n<h2 id=\"三、UTC-和-GMT-的关系\">三、UTC 和 GMT 的关系</h2>\n<p>很多人听过 GMT（格林尼治时间），历史上 GMT 是世界标准时间，后来被 UTC 取代。</p>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th>GMT</th>\n<th>UTC</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>出现年代</td>\n<td>19 世纪</td>\n<td>1972 年</td>\n</tr>\n<tr>\n<td>基准</td>\n<td>地球自转（天文时间）</td>\n<td>原子钟（更精确）</td>\n</tr>\n<tr>\n<td>是否仍是标准</td>\n<td>已被替代</td>\n<td>当前唯一标准</td>\n</tr>\n</tbody>\n</table>\n<p>但在日常使用中：</p>\n<blockquote>\n<p><strong>UTC ≈ GMT（同为零时区）</strong></p>\n</blockquote>\n<p>所以：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>英国冬季使用 GMT（UTC+0）</p>\n</li>\n<li class=\"lvl-2\">\n<p>技术系统使用 UTC（UTC+0）</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"四、UTC-是如何确定的？\">四、UTC 是如何确定的？</h2>\n<p>UTC 并不是按太阳走，而是：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>由全世界 <strong>原子钟网络统一生成</strong></p>\n</li>\n<li class=\"lvl-2\">\n<p>每秒误差小于 <strong>十亿分之一秒</strong></p>\n</li>\n<li class=\"lvl-2\">\n<p>然后根据地球自转误差偶尔加“闰秒”</p>\n</li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-12-31 23:59:60 UTC   ← 曾经加过闰秒</span><br></pre></td></tr></table></figure>\n<p>这样：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>保证时间极其准确</p>\n</li>\n<li class=\"lvl-2\">\n<p>又不会与地球真实昼夜偏离太多</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"五、UTC-与时区\">五、UTC 与时区</h2>\n<p>UTC 是 0 时区。</p>\n<p>所有时区都是 <strong>在 UTC 基础上加减偏移</strong>：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>北京时间：UTC + 8</p>\n</li>\n<li class=\"lvl-2\">\n<p>纽约时间：UTC – 5（冬季）或 –4（夏令时）</p>\n</li>\n<li class=\"lvl-2\">\n<p>日本时间：UTC + 9</p>\n</li>\n</ul>\n<p>所以你常看到：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UTC+8 或 UTC-5</span><br></pre></td></tr></table></figure>\n<p>表示该地区比 UTC 早或晚多少小时。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UTC+8  &gt;  UTC+0  &gt;  UTC−5</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>换成生活语言：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">UTC+8（例如北京时间）比 UTC 早 8 小时</li>\n<li class=\"lvl-4\">UTC−5（例如美国东部冬令时）比 UTC 晚 5 小时</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>举例：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">UTC(即UTC+0) 时间是 12:00</li>\n<li class=\"lvl-4\">UTC+8 = 20:00（已经晚上）</li>\n<li class=\"lvl-4\">UTC−5 = 07:00（还在早上）</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"六、UTC-在计算机世界的重要性\">六、UTC 在计算机世界的重要性</h2>\n<p>几乎所有 IT 系统都推荐：</p>\n<blockquote>\n<p><strong>存储用 UTC，展示给用户再转换成当地时区。</strong></p>\n</blockquote>\n<p>原因很简单：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>全球一致，不会混乱</p>\n</li>\n<li class=\"lvl-2\">\n<p>不受时区或夏令时影响</p>\n</li>\n<li class=\"lvl-2\">\n<p>跨国系统日志可对齐分析</p>\n</li>\n</ul>\n<p>你在日志里经常见到：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2025-11-20T08:30:00Z</span><br></pre></td></tr></table></figure>\n<p>结尾的 <code>Z</code> 就表示：</p>\n<blockquote>\n<p><strong>这是 UTC 时间</strong></p>\n</blockquote>\n<hr>\n<h2 id=\"七、UTC、GMT、CST-总结对比\">七、UTC、GMT、CST 总结对比</h2>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>全称</th>\n<th>现在地位</th>\n<th>是否标准</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>UTC</td>\n<td>Coordinated Universal Time</td>\n<td>全球标准</td>\n<td>✔</td>\n</tr>\n<tr>\n<td>GMT</td>\n<td>Greenwich Mean Time</td>\n<td>被 UTC 替代</td>\n<td>✖（历史含义）</td>\n</tr>\n<tr>\n<td>CST</td>\n<td>China Standard Time（中国）或 Central Standard Time（美国）</td>\n<td>本地时区</td>\n<td>不是世界统一基准</td>\n</tr>\n</tbody>\n</table>\n<p>注意：</p>\n<blockquote>\n<p>“CST” 既可能是中国区，也可能是美国区，需要结合 UTC 偏移判断。</p>\n</blockquote>\n<hr>\n<h2 id=\"八、一句话总结\">八、一句话总结</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><strong>UTC 是现代全球统一的标准时间</strong></p>\n</li>\n<li class=\"lvl-2\">\n<p><strong>所有时区都是相对于 UTC 偏移</strong></p>\n</li>\n<li class=\"lvl-2\">\n<p><strong>计算机领域普遍使用 UTC 存储时间</strong></p>\n</li>\n<li class=\"lvl-2\">\n<p><strong>GMT 是 UTC 的历史前身</strong></p>\n</li>\n<li class=\"lvl-2\">\n<p><strong>北京时间 = UTC + 8</strong></p>\n</li>\n</ul>\n<p>只要理解这几点，你已经掌握了世界时间体系的核心。</p>\n","content_text":"摘要 在生活中，我们经常听到“UTC 时间”“北京时间 UTC+8”“服务器时间是 UTC”，但许多人并不了解 UTC 到底是什么。本文将用尽量简单的方式，带你搞清楚现代世界所依赖的全球通用时间标准——UTC。 一、为什么世界需要统一时间？ 早期，每个城市甚至每个乡镇都根据 太阳位置确定时间： 太阳在头顶就是 12 点 不同地方经度不同，每地时间都不同 这种方法在本地没问题，但到了 跨区域铁路、通信、航海、航空、互联网时代，问题巨大： 两地时间不统一，火车、舰队、订单、通信都没法同步记录。 因此世界需要： 一个 全球统一、精确的标准时间 所有人、所有系统都能对齐使用 UTC 就是在这个背景下诞生的。 二、UTC 是什么？ UTC 的全称： Coordinated Universal Time（协调世界时） 它是当今全球使用的 标准时间系统。 它的主要特点： 不是某个国家的时间 是国际组织共同维护 全世界所有机房、通信、卫星、航班、GPS、金融系统都以它为基准 一句话： UTC 是现代世界共同使用的“世界时间”。 三、UTC 和 GMT 的关系 很多人听过 GMT（格林尼治时间），历史上 GMT 是世界标准时间，后来被 UTC 取代。 项目 GMT UTC 出现年代 19 世纪 1972 年 基准 地球自转（天文时间） 原子钟（更精确） 是否仍是标准 已被替代 当前唯一标准 但在日常使用中： UTC ≈ GMT（同为零时区） 所以： 英国冬季使用 GMT（UTC+0） 技术系统使用 UTC（UTC+0） 四、UTC 是如何确定的？ UTC 并不是按太阳走，而是： 由全世界 原子钟网络统一生成 每秒误差小于 十亿分之一秒 然后根据地球自转误差偶尔加“闰秒” 例如： 12016-12-31 23:59:60 UTC ← 曾经加过闰秒 这样： 保证时间极其准确 又不会与地球真实昼夜偏离太多 五、UTC 与时区 UTC 是 0 时区。 所有时区都是 在 UTC 基础上加减偏移： 北京时间：UTC + 8 纽约时间：UTC – 5（冬季）或 –4（夏令时） 日本时间：UTC + 9 所以你常看到： 1UTC+8 或 UTC-5 表示该地区比 UTC 早或晚多少小时。 1UTC+8 &gt; UTC+0 &gt; UTC−5 换成生活语言： UTC+8（例如北京时间）比 UTC 早 8 小时 UTC−5（例如美国东部冬令时）比 UTC 晚 5 小时 举例： UTC(即UTC+0) 时间是 12:00 UTC+8 = 20:00（已经晚上） UTC−5 = 07:00（还在早上） 六、UTC 在计算机世界的重要性 几乎所有 IT 系统都推荐： 存储用 UTC，展示给用户再转换成当地时区。 原因很简单： 全球一致，不会混乱 不受时区或夏令时影响 跨国系统日志可对齐分析 你在日志里经常见到： 12025-11-20T08:30:00Z 结尾的 Z 就表示： 这是 UTC 时间 七、UTC、GMT、CST 总结对比 名称 全称 现在地位 是否标准 UTC Coordinated Universal Time 全球标准 ✔ GMT Greenwich Mean Time 被 UTC 替代 ✖（历史含义） CST China Standard Time（中国）或 Central Standard Time（美国） 本地时区 不是世界统一基准 注意： “CST” 既可能是中国区，也可能是美国区，需要结合 UTC 偏移判断。 八、一句话总结 UTC 是现代全球统一的标准时间 所有时区都是相对于 UTC 偏移 计算机领域普遍使用 UTC 存储时间 GMT 是 UTC 的历史前身 北京时间 = UTC + 8 只要理解这几点，你已经掌握了世界时间体系的核心。","summary":"摘要 在生活中，我们经常听到“UTC 时间”“北京时间 UTC+8”“服务器时间是 UTC”，但许多人并不了解 UTC 到底是什么。本文将用尽量简单的方式，带你搞清楚现代世界所依赖的全球通用时间标准——UTC。","date_published":"2025-11-20T14:30:05.000Z","tags":["技术","UTC","UTC"]},{"id":"https://blog.hanqunfeng.com/2025/10/31/rocketmq-08-acl2.0/","url":"https://blog.hanqunfeng.com/2025/10/31/rocketmq-08-acl2.0/","title":"RocketMQ ACL 2.0","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 RocketMQ ACL 2.0 的使用方法。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://rocketmq.apache.org/zh/\">RocketMQ官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文使用的 RocketMQ 版本为 5.3.2。</p>\n</li>\n<li class=\"lvl-2\">\n<p>RocketMQ 从 5.3.0 起引入安全性更高的 ACL 2.0，5.3.2 是最后一个还支持 ACL 1.0 的版本，5.3.3 移除了 ACL 1.0，官方建议所有使用 Apache RocketMQ ACL 的用户迁移到 ACL 2.0。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"ACL-2-0-简介\">ACL 2.0 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 <a href=\"https://rocketmq.apache.org/zh/\">RocketMQ官网</a> 中没有找到关于 ACL 2.0 的介绍，但是有介绍 ACL 1.0 的使用方法: <a href=\"https://rocketmq.apache.org/zh/docs/bestPractice/03access\">https://rocketmq.apache.org/zh/docs/bestPractice/03access</a>。</p>\n</li>\n<li class=\"lvl-2\">\n<p>在阿里云上找到一篇参考资料：<a href=\"https://developer.aliyun.com/article/1569146\">Apache RocketMQ ACL 2.0 全新升级</a></p>\n</li>\n</ul>\n<h2 id=\"配置步骤\">配置步骤</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文在 <a href=\"/2025/10/23/rocketmq-01-install/\" title=\"RocketMQ 的安装及使用\">RocketMQ 的安装及使用</a> 中 集群 安装完成之后，开始配置 ACL 2.0。</p>\n</li>\n<li class=\"lvl-2\">\n<p>在所有 Broker 的配置文件<code>broker.conf</code>中增加认证与授权配置:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># broker.conf</span></span><br><span class=\"line\"><span class=\"comment\"># 认证配置</span></span><br><span class=\"line\">authenticationEnabled = <span class=\"literal\">true</span></span><br><span class=\"line\">authenticationProvider = org.apache.rocketmq.auth.authentication.provider.DefaultAuthenticationProvider</span><br><span class=\"line\">initAuthenticationUser = &#123;<span class=\"string\">&quot;username&quot;</span>:<span class=\"string\">&quot;mqadmin&quot;</span>,<span class=\"string\">&quot;password&quot;</span>:<span class=\"string\">&quot;1234567&quot;</span>&#125;</span><br><span class=\"line\">innerClientAuthenticationCredentials = &#123;<span class=\"string\">&quot;accessKey&quot;</span>:<span class=\"string\">&quot;mqadmin&quot;</span>,<span class=\"string\">&quot;secretKey&quot;</span>:<span class=\"string\">&quot;1234567&quot;</span>&#125;</span><br><span class=\"line\">authenticationMetadataProvider = org.apache.rocketmq.auth.authentication.provider.LocalAuthenticationMetadataProvider</span><br><span class=\"line\"><span class=\"comment\"># 授权配置</span></span><br><span class=\"line\">authorizationEnabled = <span class=\"literal\">true</span></span><br><span class=\"line\">authorizationProvider = org.apache.rocketmq.auth.authorization.provider.DefaultAuthorizationProvider</span><br><span class=\"line\">authorizationMetadataProvider = org.apache.rocketmq.auth.authorization.provider.LocalAuthorizationMetadataProvider</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数定义</th>\n<th style=\"text-align:left\">参数名称</th>\n<th style=\"text-align:left\">参数描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>authenticationEnabled</strong></td>\n<td style=\"text-align:left\">是否打开认证开关</td>\n<td style=\"text-align:left\">用于判断认证是否打开。<br>可选值：<br>• <code>true</code> – 是<br>• <code>false</code> – 否</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>authenticationProvider</strong></td>\n<td style=\"text-align:left\">认证方式提供者</td>\n<td style=\"text-align:left\">用于提供请求访问时的认证方式。<br>可选值：<br>• <code>org.apache.rocketmq.auth.authentication.provider.DefaultAuthenticationProvider</code> – 默认的认证方式</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>initAuthenticationUser</strong></td>\n<td style=\"text-align:left\">系统初始化用户</td>\n<td style=\"text-align:left\">用于系统初始化时自动创建的用户账号。<br>示例：<br><code>&#123;&quot;username&quot;:&quot;rocketmq&quot;,&quot;password&quot;:&quot;12345678&quot;&#125;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>innerClientAuthenticationCredentials</strong></td>\n<td style=\"text-align:left\">组件间认证用户</td>\n<td style=\"text-align:left\">用于设置集群内组件之间的访问凭证。<br>示例：<br><code>&#123;&quot;accessKey&quot;:&quot;rocketmq&quot;,&quot;secretKey&quot;:&quot;12345678&quot;&#125;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>authenticationMetadataProvider</strong></td>\n<td style=\"text-align:left\">认证元数据提供者</td>\n<td style=\"text-align:left\">用于提供认证相关的元数据（如用户）。<br>可选值：<br>• <code>org.apache.rocketmq.auth.authentication.provider.LocalAuthenticationMetadataProvider</code> – 本地认证元数据提供者<br>• <code>org.apache.rocketmq.proxy.auth.ProxyAuthenticationMetadataProvider</code> – Proxy认证元数据提供者</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>authenticationStrategy</strong></td>\n<td style=\"text-align:left\">认证策略</td>\n<td style=\"text-align:left\">用于指定请求访问时的认证策略。<br>可选值：<br>• <code>org.apache.rocketmq.auth.authentication.strategy.StatelessAuthenticationStrategy</code> – 每次请求认证策略<br>• <code>org.apache.rocketmq.auth.authentication.strategy.StatefulAuthenticationStrategy</code> – 首次请求认证策略</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>重启启动所有 Broker</p>\n</li>\n</ul>\n<h2 id=\"命令行管理用户\">命令行管理用户</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果 RocketMQ 开启了 ACL，无论是 ACL 1.0 还是 ACL 2.0，都需要在 <code>conf/tools.yml</code> 配置正确的账号密码，否则无法执行 <code>mqadmin</code> 命令。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">accessKey:</span> <span class=\"string\">mqadmin</span></span><br><span class=\"line\"><span class=\"attr\">secretKey:</span> <span class=\"number\">1234567</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"用户管理\">用户管理</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">接口定义</th>\n<th style=\"text-align:left\">接口名称</th>\n<th style=\"text-align:left\">接口参数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>createUser</strong></td>\n<td style=\"text-align:left\">创建用户</td>\n<td style=\"text-align:left\">-n namesrv 地址<br>-b broker 地址<br>-c 集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-u 用户名称<br>-p 用户密码<br>-t 用户类型（Super、Normal）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>updateUser</strong></td>\n<td style=\"text-align:left\">更新用户</td>\n<td style=\"text-align:left\">-n namesrv 地址<br>-b broker 地址<br>-c 集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-u 用户名称<br>-p 用户密码<br>-t 用户类型（Super、Normal）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>deleteUser</strong></td>\n<td style=\"text-align:left\">删除用户</td>\n<td style=\"text-align:left\">-b broker 地址<br>-c 集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-u 用户名称</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>getUser</strong></td>\n<td style=\"text-align:left\">查询用户详情</td>\n<td style=\"text-align:left\">-n namesrv 地址<br>-b broker 地址<br>-c 集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-u 用户名称</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>listUser</strong></td>\n<td style=\"text-align:left\">查询用户列表</td>\n<td style=\"text-align:left\">-n namesrv 地址<br>-b broker 地址<br>-c 集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-u 用户名称<br>-f 过滤条件（支持用户名称模糊查询，可选）</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建用户</span></span><br><span class=\"line\">sh bin/mqadmin createUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq -p rocketmq</span><br><span class=\"line\"><span class=\"comment\"># 创建用户，指定用户类型</span></span><br><span class=\"line\">sh bin/mqadmin createUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq -p rocketmq -t Super</span><br><span class=\"line\"><span class=\"comment\"># 更新用户</span></span><br><span class=\"line\">sh bin/mqadmin updateUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq -p 12345678</span><br><span class=\"line\"><span class=\"comment\"># 删除用户</span></span><br><span class=\"line\">sh bin/mqadmin deleteUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq</span><br><span class=\"line\"><span class=\"comment\"># 查询用户详情</span></span><br><span class=\"line\">sh bin/mqadmin getUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq</span><br><span class=\"line\"><span class=\"comment\"># 查询用户列表</span></span><br><span class=\"line\">sh bin/mqadmin listUser -n 127.0.0.1:9876 -c DefaultCluster</span><br><span class=\"line\"><span class=\"comment\"># 查询用户列表，带过滤条件</span></span><br><span class=\"line\">sh bin/mqadmin listUser -n 127.0.0.1:9876 -c DefaultCluster -f mq</span><br></pre></td></tr></table></figure>\n<h3 id=\"权限管理\">权限管理</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>管理员(Super)拥有所以资源的访问权限，普通用户(Normal)则只有对应资源类型的访问权限。以下是为普通用户设置权限的命令。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">命令名称</th>\n<th style=\"text-align:left\">操作定义</th>\n<th style=\"text-align:left\">命令参数及解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong><code>createAcl</code></strong></td>\n<td style=\"text-align:left\">创建授权</td>\n<td style=\"text-align:left\">-n <strong>127.0.0.1:9876</strong>：NameServer 地址（多个以 <code>;</code> 分隔）<br>-b broker 地址<br>-c <strong>DefaultCluster</strong>：集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-s <strong>User:rocketmq</strong>：授权的用户（<code>User:rocketmq</code> 表示给用户 <code>rocketmq</code> 授权）<br>-r <strong>Topic:*,Group:</strong>：资源类型与名称，<code>*</code> 表示所有 Topic 和 Group<br>-a <strong>Pub,Sub</strong>：授权操作类型，<code>Pub</code> 表示发布权限，<code>Sub</code> 表示订阅权限<br>-i <strong>192.168.1.0/24</strong>：授权的 IP 地址范围<br>-d <strong>Allow</strong>：授权类型，<code>Allow</code> 允许，<code>Deny</code> 拒绝</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong><code>updateAcl</code></strong></td>\n<td style=\"text-align:left\">更新授权</td>\n<td style=\"text-align:left\">-n <strong>127.0.0.1:9876</strong>：NameServer 地址<br>-b broker 地址<br>-c <strong>DefaultCluster</strong>：集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-s <strong>User:rocketmq</strong>：授权的用户<br>-r <strong>Topic:*,Group:</strong>：资源类型与名称<br>-a <strong>Pub,Sub</strong>：授权操作类型<br>-i <strong>192.168.1.0/24</strong>：IP 地址范围<br>-d <strong>Deny</strong>：授权类型，更新为 <code>Deny</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong><code>deleteAcl</code></strong></td>\n<td style=\"text-align:left\">删除授权</td>\n<td style=\"text-align:left\">-n <strong>127.0.0.1:9876</strong>：NameServer 地址<br>-b broker 地址<br>-c <strong>DefaultCluster</strong>：集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-s <strong>User:rocketmq</strong>：授权的用户<br>-r <strong>Topic:</strong>：指定删除某个资源（如 Topic）授权</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong><code>listAcl</code></strong></td>\n<td style=\"text-align:left\">查询授权列表</td>\n<td style=\"text-align:left\">-n <strong>127.0.0.1:9876</strong>：NameServer 地址<br>-b broker 地址<br>-c <strong>DefaultCluster</strong>：集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-s <strong>User:rocketmq</strong>：授权的用户<br>-r <strong>Topic:</strong>：指定资源类型（如 Topic）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong><code>getAcl</code></strong></td>\n<td style=\"text-align:left\">查询授权详情</td>\n<td style=\"text-align:left\">-n <strong>127.0.0.1:9876</strong>：NameServer 地址<br>-b broker 地址<br>-c <strong>DefaultCluster</strong>：集群名称<br><strong>注：</strong><code>-b</code> 和 <code>-c</code> 参数二选一<br>-s <strong>User:rocketmq</strong>：授权的用户</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建授权</span></span><br><span class=\"line\">sh bin/mqadmin createAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq -r Topic:*,Group:* -a Pub,Sub -i 192.168.1.0/24 -d Allow</span><br><span class=\"line\"><span class=\"comment\"># 更新授权</span></span><br><span class=\"line\">sh bin/mqadmin updateAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq -r Topic:*,Group:* -a Pub,Sub -i 192.168.1.0/24 -d Deny</span><br><span class=\"line\"><span class=\"comment\"># 删除授权</span></span><br><span class=\"line\">sh bin/mqadmin deleteAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq</span><br><span class=\"line\"><span class=\"comment\"># 删除授权，指定资源</span></span><br><span class=\"line\">sh bin/mqadmin deleteAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq -r Topic:*</span><br><span class=\"line\"><span class=\"comment\"># 查询授权列表</span></span><br><span class=\"line\">sh bin/mqadmin listAcl -n 127.0.0.1:9876 -c DefaultCluster</span><br><span class=\"line\"><span class=\"comment\"># 查询授权列表，带过滤条件</span></span><br><span class=\"line\">sh bin/mqadmin listAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq -r Topic:*</span><br><span class=\"line\"><span class=\"comment\"># 查询授权详情</span></span><br><span class=\"line\">sh bin/mqadmin getAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq</span><br></pre></td></tr></table></figure>\n<h2 id=\"Dashboard-配置\">Dashboard 配置</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时在 Dashboard 中配置好认证信息并重启，即可正常访问RocketMQ集群，并且支持在web端配置ACL认证信息。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># vim run/application.yaml # 按需替换配置</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">rocketmq:</span></span><br><span class=\"line\">  <span class=\"attr\">config:</span></span><br><span class=\"line\">    <span class=\"attr\">namesrvAddrs:</span>                <span class=\"comment\"># 填写NameServer地址列表</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"number\">10.250</span><span class=\"number\">.0</span><span class=\"number\">.175</span><span class=\"string\">:9876</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"number\">10.250</span><span class=\"number\">.0</span><span class=\"number\">.188</span><span class=\"string\">:9876</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"number\">10.250</span><span class=\"number\">.0</span><span class=\"number\">.131</span><span class=\"string\">:9876</span></span><br><span class=\"line\">    <span class=\"attr\">dataPath:</span> <span class=\"string\">/usr/local/soft/rocketmq/data/dashboard</span> <span class=\"comment\"># Dashboard文件目录，登录用户配置文件所在目录</span></span><br><span class=\"line\">    <span class=\"attr\">loginRequired:</span> <span class=\"literal\">true</span>  <span class=\"comment\"># 是否需要登录，此时需要在 dataPath 下创建 users.properties 文件，用于存放用户名和密码。如果该目录下不存在此文件，则默认使用resources/users.properties文件</span></span><br><span class=\"line\">    <span class=\"comment\"># 如果 broker 开启了 ACL，则需要配置 accessKey 和 secretKey</span></span><br><span class=\"line\">    <span class=\"attr\">accessKey:</span> <span class=\"string\">mqadmin</span></span><br><span class=\"line\">    <span class=\"attr\">secretKey:</span> <span class=\"number\">1234567</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Proxy-配置\">Proxy 配置</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Broker 开启 ACL 2.0 认证后，即使在代码中添加了ACL认证信息的情况下，<a href=\"https://github.com/apache/rocketmq-clients/tree/master/java/client/src/main/java/org/apache/rocketmq/client/java/example\">新版客户端(rocketmq-client-java)</a>通过<code>Proxy</code>发送或订阅消息依旧会失败，<a href=\"https://github.com/apache/rocketmq/tree/develop/example\">原客户端(rocketmq-client)</a>通过<code>Nameserver</code>发送或订阅消息正常，尚不知道该如何完美解决。</p>\n</li>\n<li class=\"lvl-2\">\n<p>按照这篇文章<a href=\"https://developer.aliyun.com/article/1569146\">Apache RocketMQ ACL 2.0 全新升级</a>的介绍，在所有 Proxy 的配置文件<code>rmq-proxy.json</code>中增加认证与授权配置依旧没有解决该问题。</p>\n</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;authenticationEnabled&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;authenticationProvider&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;org.apache.rocketmq.auth.authentication.provider.DefaultAuthenticationProvider&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;authenticationMetadataProvider&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;org.apache.rocketmq.proxy.auth.ProxyAuthenticationMetadataProvider&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;innerClientAuthenticationCredentials&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;&#123;\\&quot;accessKey\\&quot;:\\&quot;mqadmin\\&quot;, \\&quot;secretKey\\&quot;:\\&quot;1234567\\&quot;&#125;&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;authorizationEnabled&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;authorizationProvider&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;org.apache.rocketmq.auth.authorization.provider.DefaultAuthorizationProvider&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;authorizationMetadataProvider&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;org.apache.rocketmq.proxy.auth.ProxyAuthorizationMetadataProvider&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>异常信息如下：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Caused by: org.apache.rocketmq.client.java.exception.UnauthorizedException: [request-id=1b2af952-38d9-4201-bd10-055e442c6b59, response-code=40100] Authentication failed. Please verify the credentials and try again.</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>之后通过这篇文章 <a href=\"https://blog.zcw159357.com/article/1/2025-03-15-0048.html\">rocketmq部署踩坑(二) acl配置</a> 的介绍，需要在 <code>rmq-proxy.json</code> 中增加如下配置：</p>\n</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">&quot;enableAclRpcHookForClusterMode&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>配置完成后，重启 Proxy，生产者发送消息果然没问题了，消费者启动也不会报错，但是就是接收不到任何消息。</p>\n</li>\n<li class=\"lvl-2\">\n<p>之后通过这篇文章 <a href=\"https://blog.csdn.net/icebamboo2015/article/details/152118732\">关于RocketMq5.3.3开启ACL2.0通过proxy8081端口只能发消息，不能收消息问题简单处理</a> 的说明，将所有 <code>broker.conf</code> 中 <code>authorizationEnabled</code> 配置改为 <code>false</code>，重启 Broker，问题解决。</p>\n</li>\n</ul>\n<h2 id=\"后记\">后记</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>笔者感觉当前 RocketMQ 的 ACL 2.0 认证机制还存在一些bug，就连官网也没有提供的文档说明，暂时先玩玩吧。</p>\n</li>\n</ul>\n","content_text":"摘要 本文介绍 RocketMQ ACL 2.0 的使用方法。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。 RocketMQ 从 5.3.0 起引入安全性更高的 ACL 2.0，5.3.2 是最后一个还支持 ACL 1.0 的版本，5.3.3 移除了 ACL 1.0，官方建议所有使用 Apache RocketMQ ACL 的用户迁移到 ACL 2.0。 ACL 2.0 简介 在 RocketMQ官网 中没有找到关于 ACL 2.0 的介绍，但是有介绍 ACL 1.0 的使用方法: https://rocketmq.apache.org/zh/docs/bestPractice/03access。 在阿里云上找到一篇参考资料：Apache RocketMQ ACL 2.0 全新升级 配置步骤 本文在 RocketMQ 的安装及使用 中 集群 安装完成之后，开始配置 ACL 2.0。 在所有 Broker 的配置文件broker.conf中增加认证与授权配置: 1234567891011# broker.conf# 认证配置authenticationEnabled = trueauthenticationProvider = org.apache.rocketmq.auth.authentication.provider.DefaultAuthenticationProviderinitAuthenticationUser = &#123;&quot;username&quot;:&quot;mqadmin&quot;,&quot;password&quot;:&quot;1234567&quot;&#125;innerClientAuthenticationCredentials = &#123;&quot;accessKey&quot;:&quot;mqadmin&quot;,&quot;secretKey&quot;:&quot;1234567&quot;&#125;authenticationMetadataProvider = org.apache.rocketmq.auth.authentication.provider.LocalAuthenticationMetadataProvider# 授权配置authorizationEnabled = trueauthorizationProvider = org.apache.rocketmq.auth.authorization.provider.DefaultAuthorizationProviderauthorizationMetadataProvider = org.apache.rocketmq.auth.authorization.provider.LocalAuthorizationMetadataProvider 参数定义 参数名称 参数描述 authenticationEnabled 是否打开认证开关 用于判断认证是否打开。可选值：• true – 是• false – 否 authenticationProvider 认证方式提供者 用于提供请求访问时的认证方式。可选值：• org.apache.rocketmq.auth.authentication.provider.DefaultAuthenticationProvider – 默认的认证方式 initAuthenticationUser 系统初始化用户 用于系统初始化时自动创建的用户账号。示例：&#123;&quot;username&quot;:&quot;rocketmq&quot;,&quot;password&quot;:&quot;12345678&quot;&#125; innerClientAuthenticationCredentials 组件间认证用户 用于设置集群内组件之间的访问凭证。示例：&#123;&quot;accessKey&quot;:&quot;rocketmq&quot;,&quot;secretKey&quot;:&quot;12345678&quot;&#125; authenticationMetadataProvider 认证元数据提供者 用于提供认证相关的元数据（如用户）。可选值：• org.apache.rocketmq.auth.authentication.provider.LocalAuthenticationMetadataProvider – 本地认证元数据提供者• org.apache.rocketmq.proxy.auth.ProxyAuthenticationMetadataProvider – Proxy认证元数据提供者 authenticationStrategy 认证策略 用于指定请求访问时的认证策略。可选值：• org.apache.rocketmq.auth.authentication.strategy.StatelessAuthenticationStrategy – 每次请求认证策略• org.apache.rocketmq.auth.authentication.strategy.StatefulAuthenticationStrategy – 首次请求认证策略 重启启动所有 Broker 命令行管理用户 如果 RocketMQ 开启了 ACL，无论是 ACL 1.0 还是 ACL 2.0，都需要在 conf/tools.yml 配置正确的账号密码，否则无法执行 mqadmin 命令。 12accessKey: mqadminsecretKey: 1234567 用户管理 接口定义 接口名称 接口参数 createUser 创建用户 -n namesrv 地址-b broker 地址-c 集群名称注：-b 和 -c 参数二选一-u 用户名称-p 用户密码-t 用户类型（Super、Normal） updateUser 更新用户 -n namesrv 地址-b broker 地址-c 集群名称注：-b 和 -c 参数二选一-u 用户名称-p 用户密码-t 用户类型（Super、Normal） deleteUser 删除用户 -b broker 地址-c 集群名称注：-b 和 -c 参数二选一-u 用户名称 getUser 查询用户详情 -n namesrv 地址-b broker 地址-c 集群名称注：-b 和 -c 参数二选一-u 用户名称 listUser 查询用户列表 -n namesrv 地址-b broker 地址-c 集群名称注：-b 和 -c 参数二选一-u 用户名称-f 过滤条件（支持用户名称模糊查询，可选） 示例 1234567891011121314# 创建用户sh bin/mqadmin createUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq -p rocketmq# 创建用户，指定用户类型sh bin/mqadmin createUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq -p rocketmq -t Super# 更新用户sh bin/mqadmin updateUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq -p 12345678# 删除用户sh bin/mqadmin deleteUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq# 查询用户详情sh bin/mqadmin getUser -n 127.0.0.1:9876 -c DefaultCluster -u rocketmq# 查询用户列表sh bin/mqadmin listUser -n 127.0.0.1:9876 -c DefaultCluster# 查询用户列表，带过滤条件sh bin/mqadmin listUser -n 127.0.0.1:9876 -c DefaultCluster -f mq 权限管理 管理员(Super)拥有所以资源的访问权限，普通用户(Normal)则只有对应资源类型的访问权限。以下是为普通用户设置权限的命令。 命令名称 操作定义 命令参数及解释 createAcl 创建授权 -n 127.0.0.1:9876：NameServer 地址（多个以 ; 分隔）-b broker 地址-c DefaultCluster：集群名称注：-b 和 -c 参数二选一-s User:rocketmq：授权的用户（User:rocketmq 表示给用户 rocketmq 授权）-r Topic:*,Group:：资源类型与名称，* 表示所有 Topic 和 Group-a Pub,Sub：授权操作类型，Pub 表示发布权限，Sub 表示订阅权限-i 192.168.1.0/24：授权的 IP 地址范围-d Allow：授权类型，Allow 允许，Deny 拒绝 updateAcl 更新授权 -n 127.0.0.1:9876：NameServer 地址-b broker 地址-c DefaultCluster：集群名称注：-b 和 -c 参数二选一-s User:rocketmq：授权的用户-r Topic:*,Group:：资源类型与名称-a Pub,Sub：授权操作类型-i 192.168.1.0/24：IP 地址范围-d Deny：授权类型，更新为 Deny deleteAcl 删除授权 -n 127.0.0.1:9876：NameServer 地址-b broker 地址-c DefaultCluster：集群名称注：-b 和 -c 参数二选一-s User:rocketmq：授权的用户-r Topic:：指定删除某个资源（如 Topic）授权 listAcl 查询授权列表 -n 127.0.0.1:9876：NameServer 地址-b broker 地址-c DefaultCluster：集群名称注：-b 和 -c 参数二选一-s User:rocketmq：授权的用户-r Topic:：指定资源类型（如 Topic） getAcl 查询授权详情 -n 127.0.0.1:9876：NameServer 地址-b broker 地址-c DefaultCluster：集群名称注：-b 和 -c 参数二选一-s User:rocketmq：授权的用户 示例 1234567891011121314# 创建授权sh bin/mqadmin createAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq -r Topic:*,Group:* -a Pub,Sub -i 192.168.1.0/24 -d Allow# 更新授权sh bin/mqadmin updateAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq -r Topic:*,Group:* -a Pub,Sub -i 192.168.1.0/24 -d Deny# 删除授权sh bin/mqadmin deleteAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq# 删除授权，指定资源sh bin/mqadmin deleteAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq -r Topic:*# 查询授权列表sh bin/mqadmin listAcl -n 127.0.0.1:9876 -c DefaultCluster# 查询授权列表，带过滤条件sh bin/mqadmin listAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq -r Topic:*# 查询授权详情sh bin/mqadmin getAcl -n 127.0.0.1:9876 -c DefaultCluster -s User:rocketmq Dashboard 配置 此时在 Dashboard 中配置好认证信息并重启，即可正常访问RocketMQ集群，并且支持在web端配置ACL认证信息。 12345678910111213# vim run/application.yaml # 按需替换配置rocketmq: config: namesrvAddrs: # 填写NameServer地址列表 - 10.250.0.175:9876 - 10.250.0.188:9876 - 10.250.0.131:9876 dataPath: /usr/local/soft/rocketmq/data/dashboard # Dashboard文件目录，登录用户配置文件所在目录 loginRequired: true # 是否需要登录，此时需要在 dataPath 下创建 users.properties 文件，用于存放用户名和密码。如果该目录下不存在此文件，则默认使用resources/users.properties文件 # 如果 broker 开启了 ACL，则需要配置 accessKey 和 secretKey accessKey: mqadmin secretKey: 1234567 Proxy 配置 Broker 开启 ACL 2.0 认证后，即使在代码中添加了ACL认证信息的情况下，新版客户端(rocketmq-client-java)通过Proxy发送或订阅消息依旧会失败，原客户端(rocketmq-client)通过Nameserver发送或订阅消息正常，尚不知道该如何完美解决。 按照这篇文章Apache RocketMQ ACL 2.0 全新升级的介绍，在所有 Proxy 的配置文件rmq-proxy.json中增加认证与授权配置依旧没有解决该问题。 123456789&#123; &quot;authenticationEnabled&quot;: true, &quot;authenticationProvider&quot;: &quot;org.apache.rocketmq.auth.authentication.provider.DefaultAuthenticationProvider&quot;, &quot;authenticationMetadataProvider&quot;: &quot;org.apache.rocketmq.proxy.auth.ProxyAuthenticationMetadataProvider&quot;, &quot;innerClientAuthenticationCredentials&quot;: &quot;&#123;\\&quot;accessKey\\&quot;:\\&quot;mqadmin\\&quot;, \\&quot;secretKey\\&quot;:\\&quot;1234567\\&quot;&#125;&quot;, &quot;authorizationEnabled&quot;: true, &quot;authorizationProvider&quot;: &quot;org.apache.rocketmq.auth.authorization.provider.DefaultAuthorizationProvider&quot;, &quot;authorizationMetadataProvider&quot;: &quot;org.apache.rocketmq.proxy.auth.ProxyAuthorizationMetadataProvider&quot;&#125; 异常信息如下： 1Caused by: org.apache.rocketmq.client.java.exception.UnauthorizedException: [request-id=1b2af952-38d9-4201-bd10-055e442c6b59, response-code=40100] Authentication failed. Please verify the credentials and try again. 之后通过这篇文章 rocketmq部署踩坑(二) acl配置 的介绍，需要在 rmq-proxy.json 中增加如下配置： 1&quot;enableAclRpcHookForClusterMode&quot;: true 配置完成后，重启 Proxy，生产者发送消息果然没问题了，消费者启动也不会报错，但是就是接收不到任何消息。 之后通过这篇文章 关于RocketMq5.3.3开启ACL2.0通过proxy8081端口只能发消息，不能收消息问题简单处理 的说明，将所有 broker.conf 中 authorizationEnabled 配置改为 false，重启 Broker，问题解决。 后记 笔者感觉当前 RocketMQ 的 ACL 2.0 认证机制还存在一些bug，就连官网也没有提供的文档说明，暂时先玩玩吧。","summary":"摘要 本文介绍 RocketMQ ACL 2.0 的使用方法。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。 RocketMQ 从 5.3.0 起引入安全性更高的 ACL 2.0，5.3.2 是最后一个还支持 ACL 1.0 的版本，5.3.3 移除了 ACL 1.0，官方建议所有使用 Apache RocketMQ ACL 的用户迁移到 ACL 2.0。","date_published":"2025-10-31T13:40:05.000Z","tags":["技术","rocketmq","分布式","rocketmq"]},{"id":"https://blog.hanqunfeng.com/2025/10/29/rocketmq-08-acl1.0/","url":"https://blog.hanqunfeng.com/2025/10/29/rocketmq-08-acl1.0/","title":"RocketMQ ACL 1.0","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 RocketMQ ACL 1.0 的使用方法。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://rocketmq.apache.org/zh/\">RocketMQ官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文使用的 RocketMQ 版本为 5.3.2。</p>\n</li>\n<li class=\"lvl-2\">\n<p>RocketMQ 从 5.3.0 起引入安全性更高的 ACL 2.0，5.3.2 是最后一个还支持 ACL 1.0 的版本，5.3.3 移除了 ACL 1.0，官方建议所有使用 Apache RocketMQ ACL 的用户迁移到 ACL 2.0。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"ACL-1-0-简介\">ACL 1.0 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ACL控制在增强集群访问控制安全性的同时也会带来部署流程和运维管理的复杂度。</p>\n</li>\n<li class=\"lvl-2\">\n<p>一般仅建议在网络环境不安全、业务数据敏感、多部门租户混用的场景下使用。如果生产集群本身是私有集群不会被外部部门租户访问，可以不开启。</p>\n</li>\n</ul>\n<h2 id=\"ACL-1-0-使用方法\">ACL 1.0 使用方法</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文在 <a href=\"/2025/10/23/rocketmq-01-install/\" title=\"RocketMQ 的安装及使用\">RocketMQ 的安装及使用</a> 中 集群 安装完成之后，开始配置 ACL 1.0。</p>\n</li>\n<li class=\"lvl-2\">\n<p>首先需要在 Broker 节点开启 ACL 权限，在 <code>broker.conf</code> 文件中添加如下配置，并重启 Broker</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aclEnable=<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>权限配置文件为 <code>conf/plain_acl.yml</code>，这个文件不需要修改，后面会介绍如何通过命令行进行配置，默认的内容如下：</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 全局白名单，支持的格式：*;192.168.*.*;192.168.0.1</span></span><br><span class=\"line\"><span class=\"comment\"># 白名单内的 IP 都可以访问，无需配置帐号</span></span><br><span class=\"line\"><span class=\"attr\">globalWhiteRemoteAddresses:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"number\">10.10</span><span class=\"number\">.103</span><span class=\"string\">.*</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"string\">.*</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 全局白名单外的IP,需要账号访问</span></span><br><span class=\"line\"><span class=\"comment\"># 账号配置，数组形式</span></span><br><span class=\"line\"><span class=\"attr\">accounts:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">accessKey:</span> <span class=\"string\">RocketMQ</span> <span class=\"comment\"># 用户名</span></span><br><span class=\"line\">    <span class=\"attr\">secretKey:</span> <span class=\"number\">12345678</span> <span class=\"comment\"># 密码</span></span><br><span class=\"line\">    <span class=\"attr\">whiteRemoteAddress:</span> <span class=\"comment\"># 当前帐号的白名单</span></span><br><span class=\"line\">    <span class=\"attr\">admin:</span> <span class=\"literal\">false</span>        <span class=\"comment\"># 是否是管理员</span></span><br><span class=\"line\">    <span class=\"attr\">defaultTopicPerm:</span> <span class=\"string\">DENY</span> <span class=\"comment\"># 当前用户对未在 topicPerms 中显式声明的 Topic 的默认权限:DENY;PUB;SUB;PUB|SUB</span></span><br><span class=\"line\">    <span class=\"attr\">defaultGroupPerm:</span> <span class=\"string\">SUB</span>  <span class=\"comment\"># 当前用户对未在 groupPerms 中显式声明的 Consumer Group 的默认权限:DENY;PUB;SUB;PUB|SUB</span></span><br><span class=\"line\">    <span class=\"attr\">topicPerms:</span>            <span class=\"comment\"># 特定的 topic 权限</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">topicA=DENY</span>        <span class=\"comment\"># topicName=perm</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">topicB=PUB|SUB</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">topicC=SUB</span></span><br><span class=\"line\">    <span class=\"attr\">groupPerms:</span>            <span class=\"comment\"># 特定的 ConsumerGroup 权限</span></span><br><span class=\"line\">      <span class=\"comment\"># the group should convert to retry topic</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">groupA=DENY</span>        <span class=\"comment\"># groupName=perm</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">groupB=PUB|SUB</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">groupC=SUB</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">accessKey:</span> <span class=\"string\">rocketmq2</span></span><br><span class=\"line\">    <span class=\"attr\">secretKey:</span> <span class=\"number\">12345678</span></span><br><span class=\"line\">    <span class=\"attr\">whiteRemoteAddress:</span> <span class=\"number\">192.168</span><span class=\"number\">.1</span><span class=\"string\">.*</span></span><br><span class=\"line\">    <span class=\"comment\"># if it is admin, it could access all resources</span></span><br><span class=\"line\">    <span class=\"attr\">admin:</span> <span class=\"literal\">true</span>         <span class=\"comment\"># 是否是管理员,true 表示管理员,管理员可以访问所有资源</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>权限定义</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">权限值</th>\n<th style=\"text-align:left\">含义</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>DENY</strong></td>\n<td style=\"text-align:left\">拒绝</td>\n<td style=\"text-align:left\">禁止对该 Topic 的任何操作（无论是发送还是订阅）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>ANY</strong></td>\n<td style=\"text-align:left\">任意权限</td>\n<td style=\"text-align:left\">具有发布（PUB）和订阅（SUB）双重权限</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>PUB</strong></td>\n<td style=\"text-align:left\">发送权限</td>\n<td style=\"text-align:left\">允许生产者向该 Topic 发送消息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>SUB</strong></td>\n<td style=\"text-align:left\">订阅权限</td>\n<td style=\"text-align:left\">允许消费者订阅并消费该 Topic 的消息</td>\n</tr>\n</tbody>\n</table>\n<div class=\"tips\">\n<p><em><strong>defaultGroupPerm: SUB</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">表示：默认允许该用户以任意消费者组身份参与消费（不限制 group），但前提是该消费者对目标 Topic 也必须拥有 SUB 权限。</li>\n</ul>\n</div>\n<h3 id=\"命令行配置-ACL\">命令行配置 ACL</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果 RocketMQ 开启了 ACL，无论是 ACL 1.0 还是 ACL 2.0，都需要在 <code>conf/tools.yml</code> 配置正确的账号密码，否则无法执行 <code>mqadmin</code> 命令。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">accessKey:</span> <span class=\"string\">mqadmin</span></span><br><span class=\"line\"><span class=\"attr\">secretKey:</span> <span class=\"number\">1234567</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>以下命令执行后会自动修改 <code>conf/plain_acl.yml</code> 文件</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>添加白名单</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh bin/mqadmin updateGlobalWhiteAddr \\</span><br><span class=\"line\">    -n 127.0.0.1:9876 \\</span><br><span class=\"line\">    -c DefaultCluster \\</span><br><span class=\"line\">    -g 10.250.0.*,10.252.*.*,10.20.0.31</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">是否必填</th>\n<th style=\"text-align:left\">含义</th>\n<th style=\"text-align:left\">示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-b</code></td>\n<td style=\"text-align:left\">二选一必填</td>\n<td style=\"text-align:left\">指定要更新白名单的 <strong>Broker 地址</strong></td>\n<td style=\"text-align:left\"><code>127.0.0.1:10911</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-c</code></td>\n<td style=\"text-align:left\">二选一必填</td>\n<td style=\"text-align:left\">指定要更新白名单的 <strong>Cluster 名称</strong>，集群内所有 Broker 都会被更新</td>\n<td style=\"text-align:left\"><code>DefaultCluster</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-g</code></td>\n<td style=\"text-align:left\">✅ 必填</td>\n<td style=\"text-align:left\">要设置的全局白名单地址列表，支持通配符</td>\n<td style=\"text-align:left\"><code>&quot;10.10.103.*,192.168.0.*&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-n</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\">NameServer 地址</td>\n<td style=\"text-align:left\"><code>127.0.0.1:9876</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-p</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\">指定 ACL 配置文件路径（Broker 端对应的配置文件路径）</td>\n<td style=\"text-align:left\"><code>/home/rocketmq/conf/plain_acl.yml</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-h</code></td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">打印帮助信息</td>\n<td style=\"text-align:left\">—</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建或更新用户，accessKey 和 secretKey 的长度必须大于 6 位</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建管理员</span></span><br><span class=\"line\">sh bin/mqadmin updateAclConfig \\</span><br><span class=\"line\">    -n 127.0.0.1:9876 \\</span><br><span class=\"line\">    -c DefaultCluster \\</span><br><span class=\"line\">    -a mqadmin \\</span><br><span class=\"line\">    -s 1234567 \\</span><br><span class=\"line\">    -m <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建普通用户</span></span><br><span class=\"line\">sh bin/mqadmin updateAclConfig \\</span><br><span class=\"line\">  -c DefaultCluster \\</span><br><span class=\"line\">  -a rocketmq_user \\</span><br><span class=\"line\">  -s 12345678 \\</span><br><span class=\"line\">  -i <span class=\"string\">&quot;PUB|SUB&quot;</span> \\</span><br><span class=\"line\">  -u SUB \\</span><br><span class=\"line\">  -t <span class=\"string\">&quot;topicA=PUB|SUB,topicB=DENY&quot;</span> \\</span><br><span class=\"line\">  -g <span class=\"string\">&quot;groupA=SUB,groupB=DENY&quot;</span> \\</span><br><span class=\"line\">  -w <span class=\"string\">&quot;192.168.0.*&quot;</span> \\</span><br><span class=\"line\">  -n 127.0.0.1:9876</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">是否必填</th>\n<th style=\"text-align:left\">含义</th>\n<th style=\"text-align:left\">示例</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-a</code></td>\n<td style=\"text-align:left\">✅ 必填</td>\n<td style=\"text-align:left\">用户名（accessKey）</td>\n<td style=\"text-align:left\"><code>rocketmq_user</code></td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-s</code></td>\n<td style=\"text-align:left\">✅ 必填</td>\n<td style=\"text-align:left\">密码（secretKey）</td>\n<td style=\"text-align:left\"><code>12345678</code></td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-b</code></td>\n<td style=\"text-align:left\">二选一</td>\n<td style=\"text-align:left\">指定目标 Broker 地址</td>\n<td style=\"text-align:left\"><code>127.0.0.1:10911</code></td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-c</code></td>\n<td style=\"text-align:left\">二选一</td>\n<td style=\"text-align:left\">指定目标集群名称，集群中所有 Broker 都会被更新</td>\n<td style=\"text-align:left\"><code>DefaultCluster</code></td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-g</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\">指定 Group 权限列表</td>\n<td style=\"text-align:left\"><code>groupA=SUB,groupB=DENY</code></td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-t</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\">指定 Topic 权限列表</td>\n<td style=\"text-align:left\">`topicA=PUB</td>\n<td>SUB,topicB=DENY`</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-u</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\">设置默认 Group 权限</td>\n<td style=\"text-align:left\"><code>SUB</code></td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-i</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\">设置默认 Topic 权限</td>\n<td style=\"text-align:left\"><code>DENY</code></td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-w</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\">设置 IP 白名单</td>\n<td style=\"text-align:left\"><code>&quot;10.10.10.*,192.168.1.*&quot;</code></td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-m</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\">是否设置为管理员账号</td>\n<td style=\"text-align:left\"><code>true</code> 或 <code>false</code></td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-n</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\">指定 NameServer 地址</td>\n<td style=\"text-align:left\"><code>127.0.0.1:9876</code></td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-h</code></td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">打印帮助信息</td>\n<td style=\"text-align:left\">—</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>删除用户</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh bin/mqadmin deleteAccessConfig \\</span><br><span class=\"line\">    -n 127.0.0.1:9876 \\</span><br><span class=\"line\">    -c DefaultCluster \\</span><br><span class=\"line\">    -a mqadmin</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">是否必填</th>\n<th style=\"text-align:left\">含义</th>\n<th style=\"text-align:left\">示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-a</code></td>\n<td style=\"text-align:left\">✅ 必填</td>\n<td style=\"text-align:left\">要删除的用户名（accessKey）</td>\n<td style=\"text-align:left\"><code>rocketmq_user</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-b</code></td>\n<td style=\"text-align:left\">二选一</td>\n<td style=\"text-align:left\">指定目标 Broker 地址</td>\n<td style=\"text-align:left\"><code>127.0.0.1:10911</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-c</code></td>\n<td style=\"text-align:left\">二选一</td>\n<td style=\"text-align:left\">指定目标集群名称（删除整个集群上的该账号）</td>\n<td style=\"text-align:left\"><code>DefaultCluster</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-n</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\">指定 NameServer 地址</td>\n<td style=\"text-align:left\"><code>127.0.0.1:9876</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-h</code></td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">打印帮助信息</td>\n<td style=\"text-align:left\">—</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Dashboard-配置\">Dashboard 配置</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时在 Dashboard 中配置好认证信息并重启，即可正常访问RocketMQ集群，但是并不支持在web端配置ACL认证信息。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># vim run/application.yaml # 按需替换配置</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">rocketmq:</span></span><br><span class=\"line\">  <span class=\"attr\">config:</span></span><br><span class=\"line\">    <span class=\"attr\">namesrvAddrs:</span>                <span class=\"comment\"># 填写NameServer地址列表</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"number\">10.250</span><span class=\"number\">.0</span><span class=\"number\">.175</span><span class=\"string\">:9876</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"number\">10.250</span><span class=\"number\">.0</span><span class=\"number\">.188</span><span class=\"string\">:9876</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"number\">10.250</span><span class=\"number\">.0</span><span class=\"number\">.131</span><span class=\"string\">:9876</span></span><br><span class=\"line\">    <span class=\"attr\">dataPath:</span> <span class=\"string\">/usr/local/soft/rocketmq/data/dashboard</span> <span class=\"comment\"># Dashboard文件目录，登录用户配置文件所在目录</span></span><br><span class=\"line\">    <span class=\"attr\">loginRequired:</span> <span class=\"literal\">true</span>  <span class=\"comment\"># 是否需要登录，此时需要在 dataPath 下创建 users.properties 文件，用于存放用户名和密码。如果该目录下不存在此文件，则默认使用resources/users.properties文件</span></span><br><span class=\"line\">    <span class=\"comment\"># 如果 broker 开启了 ACL，则需要配置 accessKey 和 secretKey</span></span><br><span class=\"line\">    <span class=\"attr\">accessKey:</span> <span class=\"string\">mqadmin</span></span><br><span class=\"line\">    <span class=\"attr\">secretKey:</span> <span class=\"number\">1234567</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"Proxy-配置\">Proxy 配置</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Broker 开启 ACL 1.0 认证后，即使在代码中添加了ACL认证信息的情况下，<a href=\"https://github.com/apache/rocketmq-clients/tree/master/java/client/src/main/java/org/apache/rocketmq/client/java/example\">新版客户端(rocketmq-client-java)</a>通过<code>Proxy</code>发送或订阅消息依旧会失败，<a href=\"https://github.com/apache/rocketmq/tree/develop/example\">原客户端(rocketmq-client)</a>通过<code>Nameserver</code>发送或订阅消息正常，尚不知道该如何完美解决。</p>\n</li>\n</ul>\n<h3 id=\"目前有两种没什么意义的解决方法：\">目前有两种没什么意义的解决方法：</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol>\n<li class=\"lvl-5\">将 Proxy IP 添加到白名单，因为客户端连接Proxy后，所有的请求都是由Proxy转发，所以将Proxy IP添加到白名单即可免于认证，该方法无需重启即可生效</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh bin/mqadmin updateGlobalWhiteAddr \\</span><br><span class=\"line\">    -n 127.0.0.1:9876 \\</span><br><span class=\"line\">    -c DefaultCluster \\</span><br><span class=\"line\">    -g 10.250.0.*</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<ol start=\"2\">\n<li class=\"lvl-5\">为 Proxy 开启 <code>enableAclRpcHookForClusterMode</code></li>\n</ol>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">修改<code>conf/rmq-proxy.json</code>文件，添加<code>enableAclRpcHookForClusterMode</code>参数</li>\n</ul>\n  <figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">&quot;enableAclRpcHookForClusterMode&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">修改<code>conf/tools.yml</code>文件，配置帐号信息：</li>\n</ul>\n  <figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">accessKey:</span> <span class=\"string\">mqadmin</span></span><br><span class=\"line\"><span class=\"attr\">secretKey:</span> <span class=\"number\">1234567</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">重新启动Proxy即可</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>两种方法，客户端代码都不需要进行修改，甚至不需要添加ACL认证信息</p>\n</li>\n<li class=\"lvl-2\">\n<p>但这样做没啥意义，proxy也可以配置acl，但是没搞懂如何配置</p>\n</li>\n</ul>\n","content_text":"摘要 本文介绍 RocketMQ ACL 1.0 的使用方法。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。 RocketMQ 从 5.3.0 起引入安全性更高的 ACL 2.0，5.3.2 是最后一个还支持 ACL 1.0 的版本，5.3.3 移除了 ACL 1.0，官方建议所有使用 Apache RocketMQ ACL 的用户迁移到 ACL 2.0。 ACL 1.0 简介 ACL控制在增强集群访问控制安全性的同时也会带来部署流程和运维管理的复杂度。 一般仅建议在网络环境不安全、业务数据敏感、多部门租户混用的场景下使用。如果生产集群本身是私有集群不会被外部部门租户访问，可以不开启。 ACL 1.0 使用方法 本文在 RocketMQ 的安装及使用 中 集群 安装完成之后，开始配置 ACL 1.0。 首先需要在 Broker 节点开启 ACL 权限，在 broker.conf 文件中添加如下配置，并重启 Broker 1aclEnable=true 权限配置文件为 conf/plain_acl.yml，这个文件不需要修改，后面会介绍如何通过命令行进行配置，默认的内容如下： 123456789101112131415161718192021222324252627282930# 全局白名单，支持的格式：*;192.168.*.*;192.168.0.1# 白名单内的 IP 都可以访问，无需配置帐号globalWhiteRemoteAddresses: - 10.10.103.* - 192.168.0.*# 全局白名单外的IP,需要账号访问# 账号配置，数组形式accounts: - accessKey: RocketMQ # 用户名 secretKey: 12345678 # 密码 whiteRemoteAddress: # 当前帐号的白名单 admin: false # 是否是管理员 defaultTopicPerm: DENY # 当前用户对未在 topicPerms 中显式声明的 Topic 的默认权限:DENY;PUB;SUB;PUB|SUB defaultGroupPerm: SUB # 当前用户对未在 groupPerms 中显式声明的 Consumer Group 的默认权限:DENY;PUB;SUB;PUB|SUB topicPerms: # 特定的 topic 权限 - topicA=DENY # topicName=perm - topicB=PUB|SUB - topicC=SUB groupPerms: # 特定的 ConsumerGroup 权限 # the group should convert to retry topic - groupA=DENY # groupName=perm - groupB=PUB|SUB - groupC=SUB - accessKey: rocketmq2 secretKey: 12345678 whiteRemoteAddress: 192.168.1.* # if it is admin, it could access all resources admin: true # 是否是管理员,true 表示管理员,管理员可以访问所有资源 权限定义 权限值 含义 说明 DENY 拒绝 禁止对该 Topic 的任何操作（无论是发送还是订阅） ANY 任意权限 具有发布（PUB）和订阅（SUB）双重权限 PUB 发送权限 允许生产者向该 Topic 发送消息 SUB 订阅权限 允许消费者订阅并消费该 Topic 的消息 defaultGroupPerm: SUB 表示：默认允许该用户以任意消费者组身份参与消费（不限制 group），但前提是该消费者对目标 Topic 也必须拥有 SUB 权限。 命令行配置 ACL 如果 RocketMQ 开启了 ACL，无论是 ACL 1.0 还是 ACL 2.0，都需要在 conf/tools.yml 配置正确的账号密码，否则无法执行 mqadmin 命令。 12accessKey: mqadminsecretKey: 1234567 以下命令执行后会自动修改 conf/plain_acl.yml 文件 添加白名单 1234sh bin/mqadmin updateGlobalWhiteAddr \\ -n 127.0.0.1:9876 \\ -c DefaultCluster \\ -g 10.250.0.*,10.252.*.*,10.20.0.31 参数 是否必填 含义 示例 -b 二选一必填 指定要更新白名单的 Broker 地址 127.0.0.1:10911 -c 二选一必填 指定要更新白名单的 Cluster 名称，集群内所有 Broker 都会被更新 DefaultCluster -g ✅ 必填 要设置的全局白名单地址列表，支持通配符 &quot;10.10.103.*,192.168.0.*&quot; -n 可选 NameServer 地址 127.0.0.1:9876 -p 可选 指定 ACL 配置文件路径（Broker 端对应的配置文件路径） /home/rocketmq/conf/plain_acl.yml -h 否 打印帮助信息 — 创建或更新用户，accessKey 和 secretKey 的长度必须大于 6 位 1234567891011121314151617181920# 创建管理员sh bin/mqadmin updateAclConfig \\ -n 127.0.0.1:9876 \\ -c DefaultCluster \\ -a mqadmin \\ -s 1234567 \\ -m true# 创建普通用户sh bin/mqadmin updateAclConfig \\ -c DefaultCluster \\ -a rocketmq_user \\ -s 12345678 \\ -i &quot;PUB|SUB&quot; \\ -u SUB \\ -t &quot;topicA=PUB|SUB,topicB=DENY&quot; \\ -g &quot;groupA=SUB,groupB=DENY&quot; \\ -w &quot;192.168.0.*&quot; \\ -n 127.0.0.1:9876 参数 是否必填 含义 示例 -a ✅ 必填 用户名（accessKey） rocketmq_user -s ✅ 必填 密码（secretKey） 12345678 -b 二选一 指定目标 Broker 地址 127.0.0.1:10911 -c 二选一 指定目标集群名称，集群中所有 Broker 都会被更新 DefaultCluster -g 可选 指定 Group 权限列表 groupA=SUB,groupB=DENY -t 可选 指定 Topic 权限列表 `topicA=PUB SUB,topicB=DENY` -u 可选 设置默认 Group 权限 SUB -i 可选 设置默认 Topic 权限 DENY -w 可选 设置 IP 白名单 &quot;10.10.10.*,192.168.1.*&quot; -m 可选 是否设置为管理员账号 true 或 false -n 可选 指定 NameServer 地址 127.0.0.1:9876 -h 否 打印帮助信息 — 删除用户 1234sh bin/mqadmin deleteAccessConfig \\ -n 127.0.0.1:9876 \\ -c DefaultCluster \\ -a mqadmin 参数 是否必填 含义 示例 -a ✅ 必填 要删除的用户名（accessKey） rocketmq_user -b 二选一 指定目标 Broker 地址 127.0.0.1:10911 -c 二选一 指定目标集群名称（删除整个集群上的该账号） DefaultCluster -n 可选 指定 NameServer 地址 127.0.0.1:9876 -h 否 打印帮助信息 — Dashboard 配置 此时在 Dashboard 中配置好认证信息并重启，即可正常访问RocketMQ集群，但是并不支持在web端配置ACL认证信息。 1234567891011121314# vim run/application.yaml # 按需替换配置rocketmq: config: namesrvAddrs: # 填写NameServer地址列表 - 10.250.0.175:9876 - 10.250.0.188:9876 - 10.250.0.131:9876 dataPath: /usr/local/soft/rocketmq/data/dashboard # Dashboard文件目录，登录用户配置文件所在目录 loginRequired: true # 是否需要登录，此时需要在 dataPath 下创建 users.properties 文件，用于存放用户名和密码。如果该目录下不存在此文件，则默认使用resources/users.properties文件 # 如果 broker 开启了 ACL，则需要配置 accessKey 和 secretKey accessKey: mqadmin secretKey: 1234567 Proxy 配置 Broker 开启 ACL 1.0 认证后，即使在代码中添加了ACL认证信息的情况下，新版客户端(rocketmq-client-java)通过Proxy发送或订阅消息依旧会失败，原客户端(rocketmq-client)通过Nameserver发送或订阅消息正常，尚不知道该如何完美解决。 目前有两种没什么意义的解决方法： 将 Proxy IP 添加到白名单，因为客户端连接Proxy后，所有的请求都是由Proxy转发，所以将Proxy IP添加到白名单即可免于认证，该方法无需重启即可生效 1234sh bin/mqadmin updateGlobalWhiteAddr \\ -n 127.0.0.1:9876 \\ -c DefaultCluster \\ -g 10.250.0.* 为 Proxy 开启 enableAclRpcHookForClusterMode 修改conf/rmq-proxy.json文件，添加enableAclRpcHookForClusterMode参数 1&quot;enableAclRpcHookForClusterMode&quot;: true 修改conf/tools.yml文件，配置帐号信息： 12accessKey: mqadminsecretKey: 1234567 重新启动Proxy即可 两种方法，客户端代码都不需要进行修改，甚至不需要添加ACL认证信息 但这样做没啥意义，proxy也可以配置acl，但是没搞懂如何配置","summary":"摘要 本文介绍 RocketMQ ACL 1.0 的使用方法。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。 RocketMQ 从 5.3.0 起引入安全性更高的 ACL 2.0，5.3.2 是最后一个还支持 ACL 1.0 的版本，5.3.3 移除了 ACL 1.0，官方建议所有使用 Apache RocketMQ ACL 的用户迁移到 ACL 2.0。","date_published":"2025-10-29T13:40:05.000Z","tags":["技术","rocketmq","分布式","rocketmq"]},{"id":"https://blog.hanqunfeng.com/2025/10/28/rocketmq-07-admin-tool/","url":"https://blog.hanqunfeng.com/2025/10/28/rocketmq-07-admin-tool/","title":"RocketMQ Admin Tool","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 RocketMQ Admin Tool 的常用命令。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://rocketmq.apache.org/zh/\">RocketMQ官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文使用的 RocketMQ 版本为 5.3.2。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"RocketMQ-Admin-Tool-简介\">RocketMQ Admin Tool 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://rocketmq.apache.org/zh/docs/deploymentOperations/02admintool\">RocketMQ Admin Tool</a> 是 RocketMQ 的一个命令行工具，用于管理 RocketMQ 的集群。</p>\n</li>\n</ul>\n<h2 id=\"Topic-相关命令\">Topic 相关命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建或更新 Topic</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">全称</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">可选值 / 格式</th>\n<th style=\"text-align:left\">是否必填</th>\n<th style=\"text-align:left\">示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-t</code></td>\n<td style=\"text-align:left\"><code>--topic</code></td>\n<td style=\"text-align:left\">主题名称</td>\n<td style=\"text-align:left\">字符串</td>\n<td style=\"text-align:left\">✅ 必填</td>\n<td style=\"text-align:left\"><code>-t MyTopic</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-b</code></td>\n<td style=\"text-align:left\"><code>--brokerAddr</code></td>\n<td style=\"text-align:left\">指定创建 Topic 的 Broker 地址（与 <code>-c</code> 二选一）</td>\n<td style=\"text-align:left\"><code>ip:port</code></td>\n<td style=\"text-align:left\">✅ 必填（与 <code>-c</code> 二选一）</td>\n<td style=\"text-align:left\"><code>-b 192.168.1.10:10911</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-c</code></td>\n<td style=\"text-align:left\"><code>--clusterName</code></td>\n<td style=\"text-align:left\">指定创建 Topic 的集群名（与 <code>-b</code> 二选一）</td>\n<td style=\"text-align:left\">字符串</td>\n<td style=\"text-align:left\">✅ 必填（与 <code>-b</code> 二选一）</td>\n<td style=\"text-align:left\"><code>-c DefaultCluster</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-n</code></td>\n<td style=\"text-align:left\"><code>--namesrvAddr</code></td>\n<td style=\"text-align:left\">NameServer 地址列表</td>\n<td style=\"text-align:left\">多个地址用 <code>;</code> 分隔</td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\"><code>-n 192.168.1.1:9876;192.168.1.2:9876</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-r</code></td>\n<td style=\"text-align:left\"><code>--readQueueNums</code></td>\n<td style=\"text-align:left\">读队列数量，默认为8，始终保持 r == w</td>\n<td style=\"text-align:left\">整数</td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\"><code>-r 4</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-w</code></td>\n<td style=\"text-align:left\"><code>--writeQueueNums</code></td>\n<td style=\"text-align:left\">写队列数量，默认为8，始终保持 r == w</td>\n<td style=\"text-align:left\">整数</td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\"><code>-w 4</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-p</code></td>\n<td style=\"text-align:left\"><code>--perm</code></td>\n<td style=\"text-align:left\">Topic 权限，默认为6</td>\n<td style=\"text-align:left\">2：写（W）<br>4：读（R）<br>6：读写（RW）</td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\"><code>-p 6</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-o</code></td>\n<td style=\"text-align:left\"><code>--order</code></td>\n<td style=\"text-align:left\">是否顺序 Topic，兼容4.x版本，5.x版本使用 -a “+message.type=FIFO”</td>\n<td style=\"text-align:left\"><code>true</code> / <code>false</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\"><code>-o false</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-u</code></td>\n<td style=\"text-align:left\"><code>--unit</code></td>\n<td style=\"text-align:left\">是否为单元（Unit）Topic（用于多租户隔离）</td>\n<td style=\"text-align:left\"><code>true</code> / <code>false</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\"><code>-u false</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-s</code></td>\n<td style=\"text-align:left\"><code>--hasUnitSub</code></td>\n<td style=\"text-align:left\">是否有 Unit 订阅</td>\n<td style=\"text-align:left\"><code>true</code> / <code>false</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\"><code>-s false</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-a</code></td>\n<td style=\"text-align:left\"><code>--attributes</code></td>\n<td style=\"text-align:left\">额外属性设置，用 <code>+</code> 表示添加、<code>-</code> 表示删除</td>\n<td style=\"text-align:left\">例：<code>+a=b,+c=d,-e</code></td>\n<td style=\"text-align:left\">可选</td>\n<td style=\"text-align:left\"><code>-a &quot;+message.type=NORMAL&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-h</code></td>\n<td style=\"text-align:left\"><code>--help</code></td>\n<td style=\"text-align:left\">打印帮助信息</td>\n<td style=\"text-align:left\">无</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\"><code>-h</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建 Topic，此时 Topic 类型为 UNSPECIFIED，集群下所有 Broker 都会创建该 Topic</span></span><br><span class=\"line\">sh bin/mqadmin updateTopic -n 127.0.0.1:9876 -t newTopic -c DefaultCluster</span><br><span class=\"line\"><span class=\"comment\"># 仅在指定的 Broker 中创建 Topic，注意只能在 Master 节点上创建</span></span><br><span class=\"line\">sh bin/mqadmin updateTopic  -n 127.0.0.1:9876 -b 10.250.0.31:10911 -t newTopic</span><br><span class=\"line\"><span class=\"comment\"># 创建 Topic，并指定 Topic 类型为 NORMAL，支持的消息类型：UNSPECIFIED, TRANSACTION, FIFO, MIXED, DELAY, NORMAL</span></span><br><span class=\"line\">sh bin/mqadmin updateTopic -n 127.0.0.1:9876 -t newTopic -c DefaultCluster -a <span class=\"string\">&quot;+message.type=NORMAL&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 创建 Topic，并指定 Topic 类型为 FIFO，同时指定读写队列数量都为 4</span></span><br><span class=\"line\">sh bin/mqadmin updateTopic -n 127.0.0.1:9876 -t newTopic -c DefaultCluster -r 4 -w 4 -a <span class=\"string\">&quot;+message.type=FIFO&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 指定权限，默认为 6：读写</span></span><br><span class=\"line\">sh bin/mqadmin updateTopic -n 127.0.0.1:9876 -t newTopic -c DefaultCluster -p 6</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看与删除 Topic</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看所有 Topic，此时只打印 topic 列表</span></span><br><span class=\"line\">sh bin/mqadmin topicList -n 127.0.0.1:9876</span><br><span class=\"line\"><span class=\"comment\"># 查看所有 Topic，-c 参数表示同时打印 Cluster Name 和 Consumer Group</span></span><br><span class=\"line\">sh bin/mqadmin topicList -n 127.0.0.1:9876 -c</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除 Topic，删除指定集群下的指定Topic</span></span><br><span class=\"line\">sh bin/mqadmin deleteTopic -n 127.0.0.1:9876 -t newTopic -c DefaultCluster</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>其它 Topic 命令</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看 Topic 路由信息</span></span><br><span class=\"line\">sh bin/mqadmin topicRoute -n 127.0.0.1:9876 -t newTopic</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"string\">&quot;brokerDatas&quot;</span>:[</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;brokerAddrs&quot;</span>:&#123;0:<span class=\"string\">&quot;10.250.0.188:11011&quot;</span>,1:<span class=\"string\">&quot;10.250.0.31:10911&quot;</span></span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;brokerName&quot;</span>:<span class=\"string\">&quot;broker-b&quot;</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;cluster&quot;</span>:<span class=\"string\">&quot;DefaultCluster&quot;</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;enableActingMaster&quot;</span>:<span class=\"literal\">false</span></span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;brokerAddrs&quot;</span>:&#123;0:<span class=\"string\">&quot;10.250.0.31:11011&quot;</span>,1:<span class=\"string\">&quot;10.250.0.188:10911&quot;</span></span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;brokerName&quot;</span>:<span class=\"string\">&quot;broker-a&quot;</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;cluster&quot;</span>:<span class=\"string\">&quot;DefaultCluster&quot;</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;enableActingMaster&quot;</span>:<span class=\"literal\">false</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t],</span><br><span class=\"line\">\t<span class=\"string\">&quot;filterServerTable&quot;</span>:&#123;&#125;,</span><br><span class=\"line\">\t<span class=\"string\">&quot;queueDatas&quot;</span>:[</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;brokerName&quot;</span>:<span class=\"string\">&quot;broker-b&quot;</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;perm&quot;</span>:6,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;readQueueNums&quot;</span>:8,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;topicSysFlag&quot;</span>:0,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;writeQueueNums&quot;</span>:8</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;brokerName&quot;</span>:<span class=\"string\">&quot;broker-a&quot;</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;perm&quot;</span>:6,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;readQueueNums&quot;</span>:8,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;topicSysFlag&quot;</span>:0,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;writeQueueNums&quot;</span>:8</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看 Topic 消息队列offset</span></span><br><span class=\"line\">sh bin/mqadmin topicStatus -n 127.0.0.1:9876 -t newTopic</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\"><span class=\"comment\">#Broker Name                      #QID  #Min Offset           #Max Offset             #Last Updated</span></span><br><span class=\"line\">broker-a                          0     0                     3                       2025-10-27 03:08:43,112</span><br><span class=\"line\">broker-a                          1     0                     4                       2025-10-27 06:13:21,968</span><br><span class=\"line\">broker-a                          2     0                     2                       2025-10-27 06:13:34,685</span><br><span class=\"line\">broker-a                          3     0                     2                       2025-10-26 05:44:17,222</span><br><span class=\"line\">broker-a                          4     0                     1                       2025-10-26 05:44:45,513</span><br><span class=\"line\">broker-a                          5     0                     1                       2025-10-26 06:13:10,541</span><br><span class=\"line\">broker-a                          6     0                     2                       2025-10-26 02:58:34,393</span><br><span class=\"line\">broker-a                          7     0                     1                       2025-10-25 12:42:41,189</span><br><span class=\"line\">broker-b                          0     0                     1                       2025-10-25 14:01:24,836</span><br><span class=\"line\">broker-b                          1     0                     2                       2025-10-26 06:14:24,411</span><br><span class=\"line\">broker-b                          2     0                     0</span><br><span class=\"line\">broker-b                          3     0                     0</span><br><span class=\"line\">broker-b                          4     0                     0</span><br><span class=\"line\">broker-b                          5     0                     1                       2025-10-25 12:30:57,672</span><br><span class=\"line\">broker-b                          6     0                     1                       2025-10-26 06:19:47,051</span><br><span class=\"line\">broker-b                          7     0                     1                       2025-10-26 06:14:49,216</span><br></pre></td></tr></table></figure>\n<h2 id=\"集群相关命令\">集群相关命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看集群信息，集群、BrokerName、BrokerId、TPS等信息</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 集群信息</span></span><br><span class=\"line\">sh bin/mqadmin clusterList -n 127.0.0.1:9876 -c DefaultCluster</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\"><span class=\"comment\">#Cluster Name           #Broker Name            #BID  #Addr                  #Version              #InTPS(LOAD)                   #OutTPS(LOAD)  #Timer(Progress)        #PCWait(ms)  #Hour         #SPACE    #ACTIVATED</span></span><br><span class=\"line\">DefaultCluster          broker-a                0     10.250.0.31:11011      V5_3_2                 0.00(0,0ms)               2.60(0,0ms|0,0ms)  1-0(0.0w, 0.0, 0.0)               0  67.03         0.3300          <span class=\"literal\">true</span></span><br><span class=\"line\">DefaultCluster          broker-a                1     10.250.0.188:10911     V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  3-0(0.0w, 0.0, 0.0)               0  67.03         0.3200         <span class=\"literal\">false</span></span><br><span class=\"line\">DefaultCluster          broker-b                0     10.250.0.188:11011     V5_3_2                 0.00(0,0ms)               0.80(0,0ms|0,0ms)  1-0(0.0w, 0.0, 0.0)               0  67.17         0.3200          <span class=\"literal\">true</span></span><br><span class=\"line\">DefaultCluster          broker-b                1     10.250.0.31:10911      V5_3_2                 0.00(0,0ms)               0.00(0,0ms|0,0ms)  1-0(0.0w, 0.0, 0.0)               0  67.17         0.3300         <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"comment\">## Broker 统计信息</span></span><br><span class=\"line\"><span class=\"comment\">#BID: BrokerId，0 表示 Master，&gt;0 表示 Slave</span></span><br><span class=\"line\"><span class=\"comment\">#InTPS(LOAD): 生产者写入 TPS 与负载， 0.00(0,0ms): 每秒入站消息数(队列数，平均耗时)</span></span><br><span class=\"line\"><span class=\"comment\">#OutTPS(LOAD): 消费者拉取 TPS 与负载，2.60(0,0ms|0,0ms): 每秒出站消息数(队列数，平均耗时|平均延时)</span></span><br><span class=\"line\"><span class=\"comment\">#Timer(Progress): Broker 的消息处理进度，格式如 1-0(0.0w, 0.0, 0.0)：前面是定时轮次进度，括号内是写入等待等统计</span></span><br><span class=\"line\"><span class=\"comment\">#PCWait(ms): 表示 Broker 写入 PageCache 的平均等待时间，数值越低越好</span></span><br><span class=\"line\"><span class=\"comment\">#Hour: 表示 Broker 已运行的时长</span></span><br><span class=\"line\"><span class=\"comment\">#SPACE: 磁盘空间使用比例，小数形式，例如 0.3300 表示使用了 33.0%</span></span><br><span class=\"line\"><span class=\"comment\">#ACTIVATED: true 表示当前 Master 正在工作；false 表示从节点或备用 Master</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看集群统计信息</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh bin/mqadmin clusterList -n 127.0.0.1:9876 -c DefaultCluster -m</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\"><span class=\"comment\">#Cluster Name     #Broker Name                       #InTotalYest  #OutTotalYest  #InTotalToday #OutTotalToday</span></span><br><span class=\"line\">DefaultCluster    broker-a                                      0              0              0              0</span><br><span class=\"line\">DefaultCluster    broker-a                                      0              0              0              0</span><br><span class=\"line\">DefaultCluster    broker-b                                      0            369              0              0</span><br><span class=\"line\">DefaultCluster    broker-b                                      0              0              0              0</span><br><span class=\"line\"><span class=\"comment\">## Broker 统计信息</span></span><br><span class=\"line\"><span class=\"comment\">#InTotalYest：昨日入站消息总量，该 Broker 在昨天接收（生产者写入）的消息总数</span></span><br><span class=\"line\"><span class=\"comment\">#OutTotalYest：昨日出站消息总量，该 Broker 在昨天发送（消费者消费）的消息总数</span></span><br><span class=\"line\"><span class=\"comment\">#InTotalToday：今日入站消息总量，该 Broker 在今天接收（生产者写入）的消息总数</span></span><br><span class=\"line\"><span class=\"comment\">#OutTotalToday：今日出站消息总量，该 Broker 在今天发送（消费者消费）的消息总数</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"消息相关\">消息相关</h2>\n<h3 id=\"发送消息\">发送消息</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">全写</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:center\">是否必填</th>\n<th style=\"text-align:left\">示例值</th>\n<th style=\"text-align:left\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-t</code></td>\n<td style=\"text-align:left\"><code>--topic</code></td>\n<td style=\"text-align:left\">消息要发送的 Topic 名称</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:left\"><code>TestTopic</code></td>\n<td style=\"text-align:left\">必须指定目标 Topic</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-p</code></td>\n<td style=\"text-align:left\"><code>--body</code></td>\n<td style=\"text-align:left\">消息体内容（UTF-8 字符串）</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:left\"><code>&quot;Hello RocketMQ&quot;</code></td>\n<td style=\"text-align:left\">实际消息内容</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-n</code></td>\n<td style=\"text-align:left\"><code>--namesrvAddr</code></td>\n<td style=\"text-align:left\">NameServer 地址</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>127.0.0.1:9876</code></td>\n<td style=\"text-align:left\">不指定则用默认配置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-b</code></td>\n<td style=\"text-align:left\"><code>--broker</code></td>\n<td style=\"text-align:left\">指定发送到哪个 broker</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>broker-a</code></td>\n<td style=\"text-align:left\">一般用于测试 Broker 状态</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-i</code></td>\n<td style=\"text-align:left\"><code>--qid</code></td>\n<td style=\"text-align:left\">指定发送到的队列 ID</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>2</code></td>\n<td style=\"text-align:left\">一般不需要设置，RocketMQ 会自动选择</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-c</code></td>\n<td style=\"text-align:left\"><code>--tags</code></td>\n<td style=\"text-align:left\">消息的标签（tag）</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>testTag</code></td>\n<td style=\"text-align:left\">用于消息过滤</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-k</code></td>\n<td style=\"text-align:left\"><code>--key</code></td>\n<td style=\"text-align:left\">消息的业务键（key）</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>order123</code></td>\n<td style=\"text-align:left\">可用于追踪消息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-m</code></td>\n<td style=\"text-align:left\"><code>--msgTraceEnable</code></td>\n<td style=\"text-align:left\">是否开启消息轨迹</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>true</code></td>\n<td style=\"text-align:left\">默认 <code>false</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-h</code></td>\n<td style=\"text-align:left\"><code>--help</code></td>\n<td style=\"text-align:left\">打印帮助信息</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\">无</td>\n<td style=\"text-align:left\">显示命令参数说明</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 发送消息</span></span><br><span class=\"line\">sh bin/mqadmin sendMessage -n 127.0.0.1:9876 -t TestTopic -p <span class=\"string\">&quot;Hello RocketMQ&quot;</span></span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\"><span class=\"comment\">#Broker Name                      #QID  #Send Result            #MsgId</span></span><br><span class=\"line\">broker-b                          2     SEND_OK                 0AFA00AFCF171EB44E468CC7D5EE0000</span><br><span class=\"line\"><span class=\"comment\">## 输出解释</span></span><br><span class=\"line\"><span class=\"comment\">#Broker Name: Broker 名称</span></span><br><span class=\"line\"><span class=\"comment\">#QID: 队列 ID</span></span><br><span class=\"line\"><span class=\"comment\">#Send Result: 发送结果，SEND_OK 表示成功</span></span><br><span class=\"line\"><span class=\"comment\">#MsgId: 消息 ID</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定 tags、key</span></span><br><span class=\"line\">sh bin/mqadmin sendMessage -n 127.0.0.1:9876 -t TestTopic -p <span class=\"string\">&quot;Hello RocketMQ&quot;</span> -c testTag -k order123</span><br></pre></td></tr></table></figure>\n<h3 id=\"消费消息\">消费消息</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">全写</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:center\">是否必填</th>\n<th style=\"text-align:left\">示例值</th>\n<th style=\"text-align:left\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-t</code></td>\n<td style=\"text-align:left\"><code>--topic</code></td>\n<td style=\"text-align:left\">目标 Topic 名称</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:left\"><code>TestTopic</code></td>\n<td style=\"text-align:left\">必填</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-n</code></td>\n<td style=\"text-align:left\"><code>--namesrvAddr</code></td>\n<td style=\"text-align:left\">NameServer 地址</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>127.0.0.1:9876</code></td>\n<td style=\"text-align:left\">建议填写以避免默认配置不生效</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-g</code></td>\n<td style=\"text-align:left\"><code>--consumerGroup</code></td>\n<td style=\"text-align:left\">消费组名称</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>TestGroup</code></td>\n<td style=\"text-align:left\">可指定消费组（影响消费位点）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-b</code></td>\n<td style=\"text-align:left\"><code>--brokerName</code></td>\n<td style=\"text-align:left\">Broker 名称</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>broker-a</code></td>\n<td style=\"text-align:left\">指定从哪个 broker 拉取消息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-i</code></td>\n<td style=\"text-align:left\"><code>--queueId</code></td>\n<td style=\"text-align:left\">队列 ID</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>0</code></td>\n<td style=\"text-align:left\">默认从 0 号队列开始</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-o</code></td>\n<td style=\"text-align:left\"><code>--offset</code></td>\n<td style=\"text-align:left\">队列起始偏移量（offset）</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>0</code></td>\n<td style=\"text-align:left\">指定从哪个位置开始消费</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-c</code></td>\n<td style=\"text-align:left\"><code>--MessageNumber</code></td>\n<td style=\"text-align:left\">消费消息数量</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>10</code></td>\n<td style=\"text-align:left\">默认通常为 1</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-s</code></td>\n<td style=\"text-align:left\"><code>--beginTimestamp</code></td>\n<td style=\"text-align:left\">起始时间</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>2025-10-28#10:00:00:000</code></td>\n<td style=\"text-align:left\">格式或时间戳均可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-e</code></td>\n<td style=\"text-align:left\"><code>--endTimestamp</code></td>\n<td style=\"text-align:left\">结束时间</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>2025-10-28#12:00:00:000</code></td>\n<td style=\"text-align:left\">与 <code>-s</code> 一起使用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-h</code></td>\n<td style=\"text-align:left\"><code>--help</code></td>\n<td style=\"text-align:left\">打印帮助信息</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\">无</td>\n<td style=\"text-align:left\">显示命令参数说明</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 默认从队列 0 开始消费，拉取全部消息</span></span><br><span class=\"line\">sh bin/mqadmin consumeMessage -n 127.0.0.1:9876 -t TestTopic</span><br><span class=\"line\"><span class=\"comment\"># 拉取指定条数的消息，-c 指定拉取条数</span></span><br><span class=\"line\">sh bin/mqadmin consumeMessage -n 127.0.0.1:9876 -t TestTopic -c 10</span><br><span class=\"line\"><span class=\"comment\"># 指定偏移量，此时必须同时指定 brokerName、queueId、offset</span></span><br><span class=\"line\">sh bin/mqadmin consumeMessage -n 127.0.0.1:9876 -t TestTopic -b broker-b -i 2 -o 3</span><br><span class=\"line\"><span class=\"comment\"># 指定消费者组</span></span><br><span class=\"line\">sh bin/mqadmin consumeMessage -n 127.0.0.1:9876 -t TestTopic -g TestGroup</span><br><span class=\"line\"><span class=\"comment\"># 指定时间范围</span></span><br><span class=\"line\">sh bin/mqadmin consumeMessage -n 127.0.0.1:9876 -t TestTopic -s 2025-10-28#00:00:00:000 -e 2025-10-28#08:00:00:000</span><br></pre></td></tr></table></figure>\n<h4 id=\"消费结果\">消费结果</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Consume ok</span><br><span class=\"line\">MSGID: 0AFA00AFCF171EB44E468CC7D5EE0000</span><br><span class=\"line\">MessageExt [brokerName=broker-b, queueId=2, storeSize=228, queueOffset=0, sysFlag=0,</span><br><span class=\"line\">  bornTimestamp=1761638706671, bornHost=/10.250.0.175:41362,</span><br><span class=\"line\">  storeTimestamp=1761638706691, storeHost=/10.250.0.188:11011,</span><br><span class=\"line\">  msgId=0AFA00BC00002B0300000000000CA1E9, commitLogOffset=827881,</span><br><span class=\"line\">  bodyCRC=1774740973, reconsumeTimes=0, preparedTransactionOffset=0,</span><br><span class=\"line\">  toString()=Message&#123;topic=<span class=\"string\">&#x27;TestTopic&#x27;</span>, flag=0,</span><br><span class=\"line\">    properties=&#123;MSG_REGION=DefaultRegion, UNIQ_KEY=0AFA00AFCF171EB44E468CC7D5EE0000,</span><br><span class=\"line\">      CLUSTER=DefaultCluster, MIN_OFFSET=0, WAIT=<span class=\"literal\">true</span>, TRACE_ON=<span class=\"literal\">true</span>, MAX_OFFSET=1&#125;,</span><br><span class=\"line\">    body=[72, 101, 108, 108, 111, 32, 82, 111, 99, 107, 101, 116, 77, 81],</span><br><span class=\"line\">    transactionId=<span class=\"string\">&#x27;null&#x27;</span>&#125;]</span><br><span class=\"line\">BODY: Hello RocketMQ</span><br><span class=\"line\"></span><br><span class=\"line\">MessageQueue [topic=TestTopic, brokerName=broker-b, queueId=2] <span class=\"built_in\">print</span> msg finished. status=NO_NEW_MSG, offset=1</span><br><span class=\"line\">The older -1 message of the 2 queue will be provided</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>📘 字段解析表格</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">字段</th>\n<th style=\"text-align:left\">示例值</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>MSGID</strong></td>\n<td style=\"text-align:left\"><code>0AFA00AFCF171EB44E468CC7D5EE0000</code></td>\n<td style=\"text-align:left\">消息唯一标识（客户端生成）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>brokerName</strong></td>\n<td style=\"text-align:left\"><code>broker-b</code></td>\n<td style=\"text-align:left\">消息存储在哪个 Broker 上</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>queueId</strong></td>\n<td style=\"text-align:left\"><code>2</code></td>\n<td style=\"text-align:left\">存储的队列编号（TestTopic 有多个队列时的第 3 个）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>queueOffset</strong></td>\n<td style=\"text-align:left\"><code>0</code></td>\n<td style=\"text-align:left\">队列中的偏移量（从 0 开始）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>storeSize</strong></td>\n<td style=\"text-align:left\"><code>228</code></td>\n<td style=\"text-align:left\">消息在磁盘中的存储字节大小</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>sysFlag</strong></td>\n<td style=\"text-align:left\"><code>0</code></td>\n<td style=\"text-align:left\">消息系统标志位（内部用途）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>bornTimestamp</strong></td>\n<td style=\"text-align:left\"><code>1761638706671</code></td>\n<td style=\"text-align:left\">消息在生产者端创建的时间（毫秒）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>bornHost</strong></td>\n<td style=\"text-align:left\"><code>/10.250.0.175:41362</code></td>\n<td style=\"text-align:left\">生产者客户端的 IP 和端口</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>storeTimestamp</strong></td>\n<td style=\"text-align:left\"><code>1761638706691</code></td>\n<td style=\"text-align:left\">消息被 Broker 存储的时间（毫秒）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>storeHost</strong></td>\n<td style=\"text-align:left\"><code>/10.250.0.188:11011</code></td>\n<td style=\"text-align:left\">Broker 的存储节点地址</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>msgId</strong></td>\n<td style=\"text-align:left\"><code>0AFA00BC00002B0300000000000CA1E9</code></td>\n<td style=\"text-align:left\">消息在 Broker 存储系统生成的唯一 ID</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>commitLogOffset</strong></td>\n<td style=\"text-align:left\"><code>827881</code></td>\n<td style=\"text-align:left\">消息在 commitLog 文件中的偏移量</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>bodyCRC</strong></td>\n<td style=\"text-align:left\"><code>1774740973</code></td>\n<td style=\"text-align:left\">消息体的 CRC 校验码（用于校验数据一致性）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>reconsumeTimes</strong></td>\n<td style=\"text-align:left\"><code>0</code></td>\n<td style=\"text-align:left\">被重新消费的次数（0 表示第一次消费）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>preparedTransactionOffset</strong></td>\n<td style=\"text-align:left\"><code>0</code></td>\n<td style=\"text-align:left\">如果是事务消息，这里会记录预提交偏移量；普通消息为 0</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>topic</strong></td>\n<td style=\"text-align:left\"><code>TestTopic</code></td>\n<td style=\"text-align:left\">消息所属主题</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>properties</strong></td>\n<td style=\"text-align:left\"><code>&#123;MSG_REGION=DefaultRegion, UNIQ_KEY=..., ...&#125;</code></td>\n<td style=\"text-align:left\">消息属性，包括系统属性与用户属性</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>body</strong></td>\n<td style=\"text-align:left\"><code>[72, 101, 108, 108, 111, 32, 82, 111, 99, 107, 101, 116, 77, 81]</code></td>\n<td style=\"text-align:left\">消息体的字节数组</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>BODY（解码后）</strong></td>\n<td style=\"text-align:left\"><code>Hello RocketMQ</code></td>\n<td style=\"text-align:left\">实际消息内容（UTF-8 字符串）</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>⚙️ 消息状态说明</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">输出信息</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>Consume ok</code></td>\n<td style=\"text-align:left\">表示成功从 Broker 拉取消息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>status=NO_NEW_MSG</code></td>\n<td style=\"text-align:left\">当前队列（queueId=2）中已经没有比 offset=1 更新的消息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>offset=1</code></td>\n<td style=\"text-align:left\">当前队列消费到 offset=1（下次消费从此开始）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>The older -1 message of the 2 queue will be provided</code></td>\n<td style=\"text-align:left\">这是一句提示语，意思是：队列中没有更早的消息（offset=-1 表示无历史消息）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"查询消息\">查询消息</h3>\n<h4 id=\"根据消息-ID-查询消息-queryMsgById\">根据消息 ID 查询消息(queryMsgById)</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">全写</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:center\">是否必填</th>\n<th style=\"text-align:left\">示例值</th>\n<th style=\"text-align:left\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-i</code></td>\n<td style=\"text-align:left\"><code>--msgId</code></td>\n<td style=\"text-align:left\">要查询的消息 ID</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:left\"><code>0AFA00AFCF171EB44E468CC7D5EE0000</code></td>\n<td style=\"text-align:left\">必填，用于精确定位消息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-t</code></td>\n<td style=\"text-align:left\"><code>--topic</code></td>\n<td style=\"text-align:left\">目标 Topic 名称</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:left\"><code>TestTopic</code></td>\n<td style=\"text-align:left\">必填</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-n</code></td>\n<td style=\"text-align:left\"><code>--namesrvAddr</code></td>\n<td style=\"text-align:left\">NameServer 地址</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>127.0.0.1:9876</code></td>\n<td style=\"text-align:left\">建议明确指定</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-c</code></td>\n<td style=\"text-align:left\"><code>--cluster</code></td>\n<td style=\"text-align:left\">集群名称或 LMQ 父 Topic</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>DefaultCluster</code></td>\n<td style=\"text-align:left\">在多集群场景下使用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-g</code></td>\n<td style=\"text-align:left\"><code>--consumerGroup</code></td>\n<td style=\"text-align:left\">消费组名称</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>TestGroup</code></td>\n<td style=\"text-align:left\">当用于消费者关联查询时可指定</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-d</code></td>\n<td style=\"text-align:left\"><code>--clientId</code></td>\n<td style=\"text-align:left\">消费者客户端 ID</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>192.168.0.1@12345</code></td>\n<td style=\"text-align:left\">辅助定位消费实例</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-f</code></td>\n<td style=\"text-align:left\"><code>--bodyFormat</code></td>\n<td style=\"text-align:left\">消息体输出格式</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>UTF-8</code> / <code>HEX</code> / <code>BASE64</code></td>\n<td style=\"text-align:left\">默认 UTF-8</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-s</code></td>\n<td style=\"text-align:left\"><code>--sendMessage</code></td>\n<td style=\"text-align:left\">是否重新发送消息</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>true</code></td>\n<td style=\"text-align:left\">调试时可使用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-u</code></td>\n<td style=\"text-align:left\"><code>--unitName</code></td>\n<td style=\"text-align:left\">单元名（多单元部署时使用）</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>unit01</code></td>\n<td style=\"text-align:left\">一般场景可忽略</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-h</code></td>\n<td style=\"text-align:left\"><code>--help</code></td>\n<td style=\"text-align:left\">打印帮助信息</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\">无</td>\n<td style=\"text-align:left\">显示命令说明</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh bin/mqadmin queryMsgById -n 127.0.0.1:9876 -t TestTopic -i 0AFA00AFCF171EB44E468CC7D5EE0000 -f UTF-8</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">OffsetID:            0AFA00BC00002B0300000000000CA1E9</span><br><span class=\"line\">Topic:               TestTopic</span><br><span class=\"line\">Tags:                [null]</span><br><span class=\"line\">Keys:                [null]</span><br><span class=\"line\">Queue ID:            2</span><br><span class=\"line\">Queue Offset:        0</span><br><span class=\"line\">CommitLog Offset:    827881</span><br><span class=\"line\">Reconsume Times:     0</span><br><span class=\"line\">Born Timestamp:      2025-10-28 08:05:06,671</span><br><span class=\"line\">Store Timestamp:     2025-10-28 08:05:06,691</span><br><span class=\"line\">Born Host:           10.250.0.175:41362</span><br><span class=\"line\">Store Host:          10.250.0.188:11011</span><br><span class=\"line\">System Flag:         0</span><br><span class=\"line\">Properties:          &#123;MSG_REGION=DefaultRegion, UNIQ_KEY=0AFA00AFCF171EB44E468CC7D5EE0000, CLUSTER=DefaultCluster, WAIT=<span class=\"literal\">true</span>, TRACE_ON=<span class=\"literal\">true</span>&#125;</span><br><span class=\"line\">Message Body Path:   /tmp/rocketmq/msgbodys/0AFA00AFCF171EB44E468CC7D5EE0000</span><br><span class=\"line\">Message Body:        Hello RocketMQ</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>输出字段详解</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">字段名</th>\n<th style=\"text-align:left\">含义</th>\n<th style=\"text-align:left\">示例</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>OffsetID</strong></td>\n<td style=\"text-align:left\">消息在 CommitLog 中的偏移标识（内部定位使用）</td>\n<td style=\"text-align:left\"><code>0AFA00BC00002B0300000000000CA1E9</code></td>\n<td style=\"text-align:left\">可用于 broker 内部追踪定位消息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Topic</strong></td>\n<td style=\"text-align:left\">主题名称</td>\n<td style=\"text-align:left\"><code>TestTopic</code></td>\n<td style=\"text-align:left\">消息所属的主题</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Tags</strong></td>\n<td style=\"text-align:left\">消息标签</td>\n<td style=\"text-align:left\"><code>[null]</code></td>\n<td style=\"text-align:left\">若生产消息时未设置 tag，则为 null</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Keys</strong></td>\n<td style=\"text-align:left\">消息键</td>\n<td style=\"text-align:left\"><code>[null]</code></td>\n<td style=\"text-align:left\">通常可用于业务层索引查询</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Queue ID</strong></td>\n<td style=\"text-align:left\">消息所在的队列编号</td>\n<td style=\"text-align:left\"><code>2</code></td>\n<td style=\"text-align:left\">对应 topic 的第 3 个队列（从 0 开始）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Queue Offset</strong></td>\n<td style=\"text-align:left\">队列偏移量</td>\n<td style=\"text-align:left\"><code>0</code></td>\n<td style=\"text-align:left\">表示是该队列的第一条消息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>CommitLog Offset</strong></td>\n<td style=\"text-align:left\">消息在 commitlog 文件中的偏移量</td>\n<td style=\"text-align:left\"><code>827881</code></td>\n<td style=\"text-align:left\">broker 存储层位置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Reconsume Times</strong></td>\n<td style=\"text-align:left\">被重新消费的次数</td>\n<td style=\"text-align:left\"><code>0</code></td>\n<td style=\"text-align:left\">表示未重试消费过</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Born Timestamp</strong></td>\n<td style=\"text-align:left\">消息生成时间</td>\n<td style=\"text-align:left\"><code>2025-10-28 08:05:06,671</code></td>\n<td style=\"text-align:left\">生产者发送消息的时间</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Store Timestamp</strong></td>\n<td style=\"text-align:left\">消息存储时间</td>\n<td style=\"text-align:left\"><code>2025-10-28 08:05:06,691</code></td>\n<td style=\"text-align:left\">broker 写入消息的时间（通常相差几毫秒）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Born Host</strong></td>\n<td style=\"text-align:left\">生产者客户端 IP:端口</td>\n<td style=\"text-align:left\"><code>10.250.0.175:41362</code></td>\n<td style=\"text-align:left\">生产者所在机器</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Store Host</strong></td>\n<td style=\"text-align:left\">broker 存储该消息的地址</td>\n<td style=\"text-align:left\"><code>10.250.0.188:11011</code></td>\n<td style=\"text-align:left\">对应的 broker 服务端</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>System Flag</strong></td>\n<td style=\"text-align:left\">系统标志位</td>\n<td style=\"text-align:left\"><code>0</code></td>\n<td style=\"text-align:left\">内部使用（标识压缩/事务等）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Properties</strong></td>\n<td style=\"text-align:left\">消息属性</td>\n<td style=\"text-align:left\"><code>&#123;MSG_REGION=DefaultRegion, UNIQ_KEY=..., CLUSTER=DefaultCluster, WAIT=true, TRACE_ON=true&#125;</code></td>\n<td style=\"text-align:left\">包含 RocketMQ 自动附加的元数据</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Message Body Path</strong></td>\n<td style=\"text-align:left\">消息体在本地保存的文件路径</td>\n<td style=\"text-align:left\"><code>/tmp/rocketmq/msgbodys/0AFA00AFCF171EB44E468CC7D5EE0000</code></td>\n<td style=\"text-align:left\">RocketMQ CLI 将消息体内容（字节数组）写入文件以供查看</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Message Body</strong></td>\n<td style=\"text-align:left\">消息内容</td>\n<td style=\"text-align:left\"><code>Hello RocketMQ</code></td>\n<td style=\"text-align:left\">消息内容</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"根据消息-Key-查询消息-queryMsgByKey\">根据消息 Key 查询消息(queryMsgByKey)</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:center\">必填</th>\n<th style=\"text-align:left\">示例</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-t, --topic</code></td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:left\"><code>TestTopic</code></td>\n<td style=\"text-align:left\">要查询的主题名称</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-k, --msgKey</code></td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:left\"><code>order_10001</code></td>\n<td style=\"text-align:left\">发送消息时设置的业务 Key</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-n, --namesrvAddr</code></td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>127.0.0.1:9876</code></td>\n<td style=\"text-align:left\">NameServer 地址</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-c, --cluster</code></td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>DefaultCluster</code></td>\n<td style=\"text-align:left\">指定集群名称（可选）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-b, --beginTimestamp</code></td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>1730083200000</code></td>\n<td style=\"text-align:left\">查询起始时间戳（ms）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-e, --endTimestamp</code></td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>1730173200000</code></td>\n<td style=\"text-align:left\">查询结束时间戳（ms）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-m, --maxNum</code></td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>64</code></td>\n<td style=\"text-align:left\">返回的最大消息数，默认 64</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-h, --help</code></td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\">-</td>\n<td style=\"text-align:left\">打印帮助信息</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh bin/mqadmin queryMsgByKey -n 127.0.0.1:9876 -t TestTopic -k order123</span><br><span class=\"line\"><span class=\"comment\">## 查询结果</span></span><br><span class=\"line\"><span class=\"comment\">#Message ID                                        #QID                                  #Offset</span></span><br><span class=\"line\">0AFA00AFCF781EB44E468CC902A30000                      7                                        1</span><br></pre></td></tr></table></figure>\n<h2 id=\"消费者\">消费者</h2>\n<h4 id=\"创建或更新消费者订阅组-updateSubGroup\">创建或更新消费者订阅组(updateSubGroup)</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>消费者订阅组 就是 消费者组，其主要作用是调整消费者消费，例如：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">消费顺序（顺序/并发）</li>\n<li class=\"lvl-6\">广播模式</li>\n<li class=\"lvl-6\">消费使能</li>\n<li class=\"lvl-6\">消费重试策略</li>\n<li class=\"lvl-6\">延迟消费队列等</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">全写</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:center\">是否必填</th>\n<th style=\"text-align:left\">示例值</th>\n<th style=\"text-align:left\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-g</code></td>\n<td style=\"text-align:left\"><code>--groupName</code></td>\n<td style=\"text-align:left\">消费者组名称</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:left\"><code>TestConsumerGroup</code></td>\n<td style=\"text-align:left\">必填</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-n</code></td>\n<td style=\"text-align:left\"><code>--namesrvAddr</code></td>\n<td style=\"text-align:left\">NameServer 地址</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>127.0.0.1:9876</code></td>\n<td style=\"text-align:left\">建议明确指定</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-b</code></td>\n<td style=\"text-align:left\"><code>--brokerAddr</code></td>\n<td style=\"text-align:left\">指定 Broker 地址</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>10.250.0.188:10911</code></td>\n<td style=\"text-align:left\">仅对单 Broker 更新</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-c</code></td>\n<td style=\"text-align:left\"><code>--clusterName</code></td>\n<td style=\"text-align:left\">指定 Cluster 名称</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>DefaultCluster</code></td>\n<td style=\"text-align:left\">对整个集群更新</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-d</code></td>\n<td style=\"text-align:left\"><code>--consumeBroadcastEnable</code></td>\n<td style=\"text-align:left\">是否广播消费</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>true</code> / <code>false</code></td>\n<td style=\"text-align:left\">true 表示广播，false 表示集群模式</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-o</code></td>\n<td style=\"text-align:left\"><code>--consumeMessageOrderly</code></td>\n<td style=\"text-align:left\">是否顺序消费</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>true</code> / <code>false</code></td>\n<td style=\"text-align:left\">顺序消费只在同队列中生效</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-i</code></td>\n<td style=\"text-align:left\"><code>--brokerId</code></td>\n<td style=\"text-align:left\">从哪个 Broker 获取订阅信息</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>0</code></td>\n<td style=\"text-align:left\">内部用途，通常不用设置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-m</code></td>\n<td style=\"text-align:left\"><code>--consumeFromMinEnable</code></td>\n<td style=\"text-align:left\">是否从最小 offset 消费</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>true</code> / <code>false</code></td>\n<td style=\"text-align:left\">新组首次消费时生效</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-p</code></td>\n<td style=\"text-align:left\"><code>--groupRetryPolicy</code></td>\n<td style=\"text-align:left\">消费组重试策略 JSON</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>&#123;&quot;type&quot;:&quot;EXPONENTIAL&quot;,&quot;exponentialRetryPolicy&quot;:&#123;&quot;initial&quot;:5000,&quot;max&quot;:7200000,&quot;multiplier&quot;:2&#125;&#125;</code></td>\n<td style=\"text-align:left\">可以自定义重试间隔</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-q</code></td>\n<td style=\"text-align:left\"><code>--retryQueueNums</code></td>\n<td style=\"text-align:left\">重试队列数量</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>1</code> ~ <code>16</code></td>\n<td style=\"text-align:left\">默认为 1</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-r</code></td>\n<td style=\"text-align:left\"><code>--retryMaxTimes</code></td>\n<td style=\"text-align:left\">最大重试次数</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>16</code></td>\n<td style=\"text-align:left\">默认 16 次</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-s</code></td>\n<td style=\"text-align:left\"><code>--consumeEnable</code></td>\n<td style=\"text-align:left\">是否使能消费</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>true</code> / <code>false</code></td>\n<td style=\"text-align:left\">false 表示暂停消费</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-w</code></td>\n<td style=\"text-align:left\"><code>--whichBrokerWhenConsumeSlowly</code></td>\n<td style=\"text-align:left\">慢消费选择 Broker ID</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>0</code></td>\n<td style=\"text-align:left\">内部使用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-a</code></td>\n<td style=\"text-align:left\"><code>--notifyConsumerIdsChanged</code></td>\n<td style=\"text-align:left\">通知 ConsumerId 改变</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>true</code> / <code>false</code></td>\n<td style=\"text-align:left\">可触发消费者刷新订阅信息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>--attributes</code></td>\n<td style=\"text-align:left\"><code>--attributes</code></td>\n<td style=\"text-align:left\">其他自定义属性</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\"><code>attr1=val1,attr2=val2</code></td>\n<td style=\"text-align:left\">可设置自定义配置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-h</code></td>\n<td style=\"text-align:left\"><code>--help</code></td>\n<td style=\"text-align:left\">打印帮助</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:left\">-</td>\n<td style=\"text-align:left\">显示命令帮助</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建普通消费者组</span></span><br><span class=\"line\">sh bin/mqadmin updateSubGroup -c DefaultCluster -g NormalGroup -n 127.0.0.1:9876</span><br><span class=\"line\"><span class=\"comment\"># 创建顺序消费组</span></span><br><span class=\"line\">sh bin/mqadmin updateSubGroup -c DefaultCluster -g FIFOGroup -n 127.0.0.1:9876 -o <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建广播消费组</span></span><br><span class=\"line\">sh bin/mqadmin updateSubGroup -c DefaultCluster -g BroadcastGroup -n 127.0.0.1:9876 -d <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建自定义属性的消费者组，这里配置了重试策略</span></span><br><span class=\"line\">sh bin/mqadmin updateSubGroup -n 127.0.0.1:9876 -g TestConsumerGroup -c DefaultCluster -d <span class=\"literal\">true</span> -o <span class=\"literal\">true</span> -m <span class=\"literal\">true</span> -p <span class=\"string\">&#x27;&#123;&quot;type&quot;:&quot;EXPONENTIAL&quot;,&quot;exponentialRetryPolicy&quot;:&#123;&quot;initial&quot;:5000,&quot;max&quot;:7200000,&quot;multiplier&quot;:2&#125;&#125;&#x27;</span> -q 1 -r 16 -s <span class=\"literal\">true</span> -w 0 -a <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"删除消费者订阅组-deleteSubGroup\">删除消费者订阅组(deleteSubGroup)</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh bin/mqadmin deleteSubGroup -n 127.0.0.1:9876 -g TestConsumerGroup -c DefaultCluster</span><br></pre></td></tr></table></figure>\n<h2 id=\"重要说明\">重要说明</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果 RocketMQ 开启了 ACL，无论是 ACL 1.0 还是 ACL 2.0，都需要在 <code>conf/tools.yml</code> 配置正确的账号密码，否则无法执行 <code>mqadmin</code> 命令。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">accessKey:</span> <span class=\"string\">mqadmin</span></span><br><span class=\"line\"><span class=\"attr\">secretKey:</span> <span class=\"number\">1234567</span></span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍 RocketMQ Admin Tool 的常用命令。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。 RocketMQ Admin Tool 简介 RocketMQ Admin Tool 是 RocketMQ 的一个命令行工具，用于管理 RocketMQ 的集群。 Topic 相关命令 创建或更新 Topic 参数 全称 说明 可选值 / 格式 是否必填 示例 -t --topic 主题名称 字符串 ✅ 必填 -t MyTopic -b --brokerAddr 指定创建 Topic 的 Broker 地址（与 -c 二选一） ip:port ✅ 必填（与 -c 二选一） -b 192.168.1.10:10911 -c --clusterName 指定创建 Topic 的集群名（与 -b 二选一） 字符串 ✅ 必填（与 -b 二选一） -c DefaultCluster -n --namesrvAddr NameServer 地址列表 多个地址用 ; 分隔 可选 -n 192.168.1.1:9876;192.168.1.2:9876 -r --readQueueNums 读队列数量，默认为8，始终保持 r == w 整数 可选 -r 4 -w --writeQueueNums 写队列数量，默认为8，始终保持 r == w 整数 可选 -w 4 -p --perm Topic 权限，默认为6 2：写（W）4：读（R）6：读写（RW） 可选 -p 6 -o --order 是否顺序 Topic，兼容4.x版本，5.x版本使用 -a “+message.type=FIFO” true / false 可选 -o false -u --unit 是否为单元（Unit）Topic（用于多租户隔离） true / false 可选 -u false -s --hasUnitSub 是否有 Unit 订阅 true / false 可选 -s false -a --attributes 额外属性设置，用 + 表示添加、- 表示删除 例：+a=b,+c=d,-e 可选 -a &quot;+message.type=NORMAL&quot; -h --help 打印帮助信息 无 否 -h 示例 12345678910# 创建 Topic，此时 Topic 类型为 UNSPECIFIED，集群下所有 Broker 都会创建该 Topicsh bin/mqadmin updateTopic -n 127.0.0.1:9876 -t newTopic -c DefaultCluster# 仅在指定的 Broker 中创建 Topic，注意只能在 Master 节点上创建sh bin/mqadmin updateTopic -n 127.0.0.1:9876 -b 10.250.0.31:10911 -t newTopic# 创建 Topic，并指定 Topic 类型为 NORMAL，支持的消息类型：UNSPECIFIED, TRANSACTION, FIFO, MIXED, DELAY, NORMALsh bin/mqadmin updateTopic -n 127.0.0.1:9876 -t newTopic -c DefaultCluster -a &quot;+message.type=NORMAL&quot;# 创建 Topic，并指定 Topic 类型为 FIFO，同时指定读写队列数量都为 4sh bin/mqadmin updateTopic -n 127.0.0.1:9876 -t newTopic -c DefaultCluster -r 4 -w 4 -a &quot;+message.type=FIFO&quot;# 指定权限，默认为 6：读写sh bin/mqadmin updateTopic -n 127.0.0.1:9876 -t newTopic -c DefaultCluster -p 6 查看与删除 Topic 1234567# 查看所有 Topic，此时只打印 topic 列表sh bin/mqadmin topicList -n 127.0.0.1:9876# 查看所有 Topic，-c 参数表示同时打印 Cluster Name 和 Consumer Groupsh bin/mqadmin topicList -n 127.0.0.1:9876 -c# 删除 Topic，删除指定集群下的指定Topicsh bin/mqadmin deleteTopic -n 127.0.0.1:9876 -t newTopic -c DefaultCluster 其它 Topic 命令 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# 查看 Topic 路由信息sh bin/mqadmin topicRoute -n 127.0.0.1:9876 -t newTopic## 输出&#123; &quot;brokerDatas&quot;:[ &#123; &quot;brokerAddrs&quot;:&#123;0:&quot;10.250.0.188:11011&quot;,1:&quot;10.250.0.31:10911&quot; &#125;, &quot;brokerName&quot;:&quot;broker-b&quot;, &quot;cluster&quot;:&quot;DefaultCluster&quot;, &quot;enableActingMaster&quot;:false &#125;, &#123; &quot;brokerAddrs&quot;:&#123;0:&quot;10.250.0.31:11011&quot;,1:&quot;10.250.0.188:10911&quot; &#125;, &quot;brokerName&quot;:&quot;broker-a&quot;, &quot;cluster&quot;:&quot;DefaultCluster&quot;, &quot;enableActingMaster&quot;:false &#125; ], &quot;filterServerTable&quot;:&#123;&#125;, &quot;queueDatas&quot;:[ &#123; &quot;brokerName&quot;:&quot;broker-b&quot;, &quot;perm&quot;:6, &quot;readQueueNums&quot;:8, &quot;topicSysFlag&quot;:0, &quot;writeQueueNums&quot;:8 &#125;, &#123; &quot;brokerName&quot;:&quot;broker-a&quot;, &quot;perm&quot;:6, &quot;readQueueNums&quot;:8, &quot;topicSysFlag&quot;:0, &quot;writeQueueNums&quot;:8 &#125; ]&#125;# 查看 Topic 消息队列offsetsh bin/mqadmin topicStatus -n 127.0.0.1:9876 -t newTopic## 输出#Broker Name #QID #Min Offset #Max Offset #Last Updatedbroker-a 0 0 3 2025-10-27 03:08:43,112broker-a 1 0 4 2025-10-27 06:13:21,968broker-a 2 0 2 2025-10-27 06:13:34,685broker-a 3 0 2 2025-10-26 05:44:17,222broker-a 4 0 1 2025-10-26 05:44:45,513broker-a 5 0 1 2025-10-26 06:13:10,541broker-a 6 0 2 2025-10-26 02:58:34,393broker-a 7 0 1 2025-10-25 12:42:41,189broker-b 0 0 1 2025-10-25 14:01:24,836broker-b 1 0 2 2025-10-26 06:14:24,411broker-b 2 0 0broker-b 3 0 0broker-b 4 0 0broker-b 5 0 1 2025-10-25 12:30:57,672broker-b 6 0 1 2025-10-26 06:19:47,051broker-b 7 0 1 2025-10-26 06:14:49,216 集群相关命令 查看集群信息，集群、BrokerName、BrokerId、TPS等信息 123456789101112131415161718# 集群信息sh bin/mqadmin clusterList -n 127.0.0.1:9876 -c DefaultCluster## 输出#Cluster Name #Broker Name #BID #Addr #Version #InTPS(LOAD) #OutTPS(LOAD) #Timer(Progress) #PCWait(ms) #Hour #SPACE #ACTIVATEDDefaultCluster broker-a 0 10.250.0.31:11011 V5_3_2 0.00(0,0ms) 2.60(0,0ms|0,0ms) 1-0(0.0w, 0.0, 0.0) 0 67.03 0.3300 trueDefaultCluster broker-a 1 10.250.0.188:10911 V5_3_2 0.00(0,0ms) 0.00(0,0ms|0,0ms) 3-0(0.0w, 0.0, 0.0) 0 67.03 0.3200 falseDefaultCluster broker-b 0 10.250.0.188:11011 V5_3_2 0.00(0,0ms) 0.80(0,0ms|0,0ms) 1-0(0.0w, 0.0, 0.0) 0 67.17 0.3200 trueDefaultCluster broker-b 1 10.250.0.31:10911 V5_3_2 0.00(0,0ms) 0.00(0,0ms|0,0ms) 1-0(0.0w, 0.0, 0.0) 0 67.17 0.3300 false## Broker 统计信息#BID: BrokerId，0 表示 Master，&gt;0 表示 Slave#InTPS(LOAD): 生产者写入 TPS 与负载， 0.00(0,0ms): 每秒入站消息数(队列数，平均耗时)#OutTPS(LOAD): 消费者拉取 TPS 与负载，2.60(0,0ms|0,0ms): 每秒出站消息数(队列数，平均耗时|平均延时)#Timer(Progress): Broker 的消息处理进度，格式如 1-0(0.0w, 0.0, 0.0)：前面是定时轮次进度，括号内是写入等待等统计#PCWait(ms): 表示 Broker 写入 PageCache 的平均等待时间，数值越低越好#Hour: 表示 Broker 已运行的时长#SPACE: 磁盘空间使用比例，小数形式，例如 0.3300 表示使用了 33.0%#ACTIVATED: true 表示当前 Master 正在工作；false 表示从节点或备用 Master 查看集群统计信息 123456789101112sh bin/mqadmin clusterList -n 127.0.0.1:9876 -c DefaultCluster -m## 输出#Cluster Name #Broker Name #InTotalYest #OutTotalYest #InTotalToday #OutTotalTodayDefaultCluster broker-a 0 0 0 0DefaultCluster broker-a 0 0 0 0DefaultCluster broker-b 0 369 0 0DefaultCluster broker-b 0 0 0 0## Broker 统计信息#InTotalYest：昨日入站消息总量，该 Broker 在昨天接收（生产者写入）的消息总数#OutTotalYest：昨日出站消息总量，该 Broker 在昨天发送（消费者消费）的消息总数#InTotalToday：今日入站消息总量，该 Broker 在今天接收（生产者写入）的消息总数#OutTotalToday：今日出站消息总量，该 Broker 在今天发送（消费者消费）的消息总数 消息相关 发送消息 参数 全写 说明 是否必填 示例值 备注 -t --topic 消息要发送的 Topic 名称 ✅ TestTopic 必须指定目标 Topic -p --body 消息体内容（UTF-8 字符串） ✅ &quot;Hello RocketMQ&quot; 实际消息内容 -n --namesrvAddr NameServer 地址 ❌ 127.0.0.1:9876 不指定则用默认配置 -b --broker 指定发送到哪个 broker ❌ broker-a 一般用于测试 Broker 状态 -i --qid 指定发送到的队列 ID ❌ 2 一般不需要设置，RocketMQ 会自动选择 -c --tags 消息的标签（tag） ❌ testTag 用于消息过滤 -k --key 消息的业务键（key） ❌ order123 可用于追踪消息 -m --msgTraceEnable 是否开启消息轨迹 ❌ true 默认 false -h --help 打印帮助信息 ❌ 无 显示命令参数说明 示例 1234567891011121314# 发送消息sh bin/mqadmin sendMessage -n 127.0.0.1:9876 -t TestTopic -p &quot;Hello RocketMQ&quot;## 输出#Broker Name #QID #Send Result #MsgIdbroker-b 2 SEND_OK 0AFA00AFCF171EB44E468CC7D5EE0000## 输出解释#Broker Name: Broker 名称#QID: 队列 ID#Send Result: 发送结果，SEND_OK 表示成功#MsgId: 消息 ID# 指定 tags、keysh bin/mqadmin sendMessage -n 127.0.0.1:9876 -t TestTopic -p &quot;Hello RocketMQ&quot; -c testTag -k order123 消费消息 参数 全写 说明 是否必填 示例值 备注 -t --topic 目标 Topic 名称 ✅ TestTopic 必填 -n --namesrvAddr NameServer 地址 ❌ 127.0.0.1:9876 建议填写以避免默认配置不生效 -g --consumerGroup 消费组名称 ❌ TestGroup 可指定消费组（影响消费位点） -b --brokerName Broker 名称 ❌ broker-a 指定从哪个 broker 拉取消息 -i --queueId 队列 ID ❌ 0 默认从 0 号队列开始 -o --offset 队列起始偏移量（offset） ❌ 0 指定从哪个位置开始消费 -c --MessageNumber 消费消息数量 ❌ 10 默认通常为 1 -s --beginTimestamp 起始时间 ❌ 2025-10-28#10:00:00:000 格式或时间戳均可 -e --endTimestamp 结束时间 ❌ 2025-10-28#12:00:00:000 与 -s 一起使用 -h --help 打印帮助信息 ❌ 无 显示命令参数说明 示例 12345678910# 默认从队列 0 开始消费，拉取全部消息sh bin/mqadmin consumeMessage -n 127.0.0.1:9876 -t TestTopic# 拉取指定条数的消息，-c 指定拉取条数sh bin/mqadmin consumeMessage -n 127.0.0.1:9876 -t TestTopic -c 10# 指定偏移量，此时必须同时指定 brokerName、queueId、offsetsh bin/mqadmin consumeMessage -n 127.0.0.1:9876 -t TestTopic -b broker-b -i 2 -o 3# 指定消费者组sh bin/mqadmin consumeMessage -n 127.0.0.1:9876 -t TestTopic -g TestGroup# 指定时间范围sh bin/mqadmin consumeMessage -n 127.0.0.1:9876 -t TestTopic -s 2025-10-28#00:00:00:000 -e 2025-10-28#08:00:00:000 消费结果 12345678910111213141516Consume okMSGID: 0AFA00AFCF171EB44E468CC7D5EE0000MessageExt [brokerName=broker-b, queueId=2, storeSize=228, queueOffset=0, sysFlag=0, bornTimestamp=1761638706671, bornHost=/10.250.0.175:41362, storeTimestamp=1761638706691, storeHost=/10.250.0.188:11011, msgId=0AFA00BC00002B0300000000000CA1E9, commitLogOffset=827881, bodyCRC=1774740973, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message&#123;topic=&#x27;TestTopic&#x27;, flag=0, properties=&#123;MSG_REGION=DefaultRegion, UNIQ_KEY=0AFA00AFCF171EB44E468CC7D5EE0000, CLUSTER=DefaultCluster, MIN_OFFSET=0, WAIT=true, TRACE_ON=true, MAX_OFFSET=1&#125;, body=[72, 101, 108, 108, 111, 32, 82, 111, 99, 107, 101, 116, 77, 81], transactionId=&#x27;null&#x27;&#125;]BODY: Hello RocketMQMessageQueue [topic=TestTopic, brokerName=broker-b, queueId=2] print msg finished. status=NO_NEW_MSG, offset=1The older -1 message of the 2 queue will be provided 📘 字段解析表格 字段 示例值 说明 MSGID 0AFA00AFCF171EB44E468CC7D5EE0000 消息唯一标识（客户端生成） brokerName broker-b 消息存储在哪个 Broker 上 queueId 2 存储的队列编号（TestTopic 有多个队列时的第 3 个） queueOffset 0 队列中的偏移量（从 0 开始） storeSize 228 消息在磁盘中的存储字节大小 sysFlag 0 消息系统标志位（内部用途） bornTimestamp 1761638706671 消息在生产者端创建的时间（毫秒） bornHost /10.250.0.175:41362 生产者客户端的 IP 和端口 storeTimestamp 1761638706691 消息被 Broker 存储的时间（毫秒） storeHost /10.250.0.188:11011 Broker 的存储节点地址 msgId 0AFA00BC00002B0300000000000CA1E9 消息在 Broker 存储系统生成的唯一 ID commitLogOffset 827881 消息在 commitLog 文件中的偏移量 bodyCRC 1774740973 消息体的 CRC 校验码（用于校验数据一致性） reconsumeTimes 0 被重新消费的次数（0 表示第一次消费） preparedTransactionOffset 0 如果是事务消息，这里会记录预提交偏移量；普通消息为 0 topic TestTopic 消息所属主题 properties &#123;MSG_REGION=DefaultRegion, UNIQ_KEY=..., ...&#125; 消息属性，包括系统属性与用户属性 body [72, 101, 108, 108, 111, 32, 82, 111, 99, 107, 101, 116, 77, 81] 消息体的字节数组 BODY（解码后） Hello RocketMQ 实际消息内容（UTF-8 字符串） ⚙️ 消息状态说明 输出信息 含义 Consume ok 表示成功从 Broker 拉取消息 status=NO_NEW_MSG 当前队列（queueId=2）中已经没有比 offset=1 更新的消息 offset=1 当前队列消费到 offset=1（下次消费从此开始） The older -1 message of the 2 queue will be provided 这是一句提示语，意思是：队列中没有更早的消息（offset=-1 表示无历史消息） 查询消息 根据消息 ID 查询消息(queryMsgById) 参数 全写 说明 是否必填 示例值 备注 -i --msgId 要查询的消息 ID ✅ 0AFA00AFCF171EB44E468CC7D5EE0000 必填，用于精确定位消息 -t --topic 目标 Topic 名称 ✅ TestTopic 必填 -n --namesrvAddr NameServer 地址 ❌ 127.0.0.1:9876 建议明确指定 -c --cluster 集群名称或 LMQ 父 Topic ❌ DefaultCluster 在多集群场景下使用 -g --consumerGroup 消费组名称 ❌ TestGroup 当用于消费者关联查询时可指定 -d --clientId 消费者客户端 ID ❌ 192.168.0.1@12345 辅助定位消费实例 -f --bodyFormat 消息体输出格式 ❌ UTF-8 / HEX / BASE64 默认 UTF-8 -s --sendMessage 是否重新发送消息 ❌ true 调试时可使用 -u --unitName 单元名（多单元部署时使用） ❌ unit01 一般场景可忽略 -h --help 打印帮助信息 ❌ 无 显示命令说明 示例 123456789101112131415161718sh bin/mqadmin queryMsgById -n 127.0.0.1:9876 -t TestTopic -i 0AFA00AFCF171EB44E468CC7D5EE0000 -f UTF-8## 输出OffsetID: 0AFA00BC00002B0300000000000CA1E9Topic: TestTopicTags: [null]Keys: [null]Queue ID: 2Queue Offset: 0CommitLog Offset: 827881Reconsume Times: 0Born Timestamp: 2025-10-28 08:05:06,671Store Timestamp: 2025-10-28 08:05:06,691Born Host: 10.250.0.175:41362Store Host: 10.250.0.188:11011System Flag: 0Properties: &#123;MSG_REGION=DefaultRegion, UNIQ_KEY=0AFA00AFCF171EB44E468CC7D5EE0000, CLUSTER=DefaultCluster, WAIT=true, TRACE_ON=true&#125;Message Body Path: /tmp/rocketmq/msgbodys/0AFA00AFCF171EB44E468CC7D5EE0000Message Body: Hello RocketMQ 输出字段详解 字段名 含义 示例 说明 OffsetID 消息在 CommitLog 中的偏移标识（内部定位使用） 0AFA00BC00002B0300000000000CA1E9 可用于 broker 内部追踪定位消息 Topic 主题名称 TestTopic 消息所属的主题 Tags 消息标签 [null] 若生产消息时未设置 tag，则为 null Keys 消息键 [null] 通常可用于业务层索引查询 Queue ID 消息所在的队列编号 2 对应 topic 的第 3 个队列（从 0 开始） Queue Offset 队列偏移量 0 表示是该队列的第一条消息 CommitLog Offset 消息在 commitlog 文件中的偏移量 827881 broker 存储层位置 Reconsume Times 被重新消费的次数 0 表示未重试消费过 Born Timestamp 消息生成时间 2025-10-28 08:05:06,671 生产者发送消息的时间 Store Timestamp 消息存储时间 2025-10-28 08:05:06,691 broker 写入消息的时间（通常相差几毫秒） Born Host 生产者客户端 IP:端口 10.250.0.175:41362 生产者所在机器 Store Host broker 存储该消息的地址 10.250.0.188:11011 对应的 broker 服务端 System Flag 系统标志位 0 内部使用（标识压缩/事务等） Properties 消息属性 &#123;MSG_REGION=DefaultRegion, UNIQ_KEY=..., CLUSTER=DefaultCluster, WAIT=true, TRACE_ON=true&#125; 包含 RocketMQ 自动附加的元数据 Message Body Path 消息体在本地保存的文件路径 /tmp/rocketmq/msgbodys/0AFA00AFCF171EB44E468CC7D5EE0000 RocketMQ CLI 将消息体内容（字节数组）写入文件以供查看 Message Body 消息内容 Hello RocketMQ 消息内容 根据消息 Key 查询消息(queryMsgByKey) 参数 必填 示例 说明 -t, --topic ✅ TestTopic 要查询的主题名称 -k, --msgKey ✅ order_10001 发送消息时设置的业务 Key -n, --namesrvAddr ❌ 127.0.0.1:9876 NameServer 地址 -c, --cluster ❌ DefaultCluster 指定集群名称（可选） -b, --beginTimestamp ❌ 1730083200000 查询起始时间戳（ms） -e, --endTimestamp ❌ 1730173200000 查询结束时间戳（ms） -m, --maxNum ❌ 64 返回的最大消息数，默认 64 -h, --help ❌ - 打印帮助信息 示例 1234sh bin/mqadmin queryMsgByKey -n 127.0.0.1:9876 -t TestTopic -k order123## 查询结果#Message ID #QID #Offset0AFA00AFCF781EB44E468CC902A30000 7 1 消费者 创建或更新消费者订阅组(updateSubGroup) 消费者订阅组 就是 消费者组，其主要作用是调整消费者消费，例如： 消费顺序（顺序/并发） 广播模式 消费使能 消费重试策略 延迟消费队列等 参数 全写 说明 是否必填 示例值 备注 -g --groupName 消费者组名称 ✅ TestConsumerGroup 必填 -n --namesrvAddr NameServer 地址 ❌ 127.0.0.1:9876 建议明确指定 -b --brokerAddr 指定 Broker 地址 ❌ 10.250.0.188:10911 仅对单 Broker 更新 -c --clusterName 指定 Cluster 名称 ❌ DefaultCluster 对整个集群更新 -d --consumeBroadcastEnable 是否广播消费 ❌ true / false true 表示广播，false 表示集群模式 -o --consumeMessageOrderly 是否顺序消费 ❌ true / false 顺序消费只在同队列中生效 -i --brokerId 从哪个 Broker 获取订阅信息 ❌ 0 内部用途，通常不用设置 -m --consumeFromMinEnable 是否从最小 offset 消费 ❌ true / false 新组首次消费时生效 -p --groupRetryPolicy 消费组重试策略 JSON ❌ &#123;&quot;type&quot;:&quot;EXPONENTIAL&quot;,&quot;exponentialRetryPolicy&quot;:&#123;&quot;initial&quot;:5000,&quot;max&quot;:7200000,&quot;multiplier&quot;:2&#125;&#125; 可以自定义重试间隔 -q --retryQueueNums 重试队列数量 ❌ 1 ~ 16 默认为 1 -r --retryMaxTimes 最大重试次数 ❌ 16 默认 16 次 -s --consumeEnable 是否使能消费 ❌ true / false false 表示暂停消费 -w --whichBrokerWhenConsumeSlowly 慢消费选择 Broker ID ❌ 0 内部使用 -a --notifyConsumerIdsChanged 通知 ConsumerId 改变 ❌ true / false 可触发消费者刷新订阅信息 --attributes --attributes 其他自定义属性 ❌ attr1=val1,attr2=val2 可设置自定义配置 -h --help 打印帮助 ❌ - 显示命令帮助 示例 12345678910# 创建普通消费者组sh bin/mqadmin updateSubGroup -c DefaultCluster -g NormalGroup -n 127.0.0.1:9876# 创建顺序消费组sh bin/mqadmin updateSubGroup -c DefaultCluster -g FIFOGroup -n 127.0.0.1:9876 -o true# 创建广播消费组sh bin/mqadmin updateSubGroup -c DefaultCluster -g BroadcastGroup -n 127.0.0.1:9876 -d true# 创建自定义属性的消费者组，这里配置了重试策略sh bin/mqadmin updateSubGroup -n 127.0.0.1:9876 -g TestConsumerGroup -c DefaultCluster -d true -o true -m true -p &#x27;&#123;&quot;type&quot;:&quot;EXPONENTIAL&quot;,&quot;exponentialRetryPolicy&quot;:&#123;&quot;initial&quot;:5000,&quot;max&quot;:7200000,&quot;multiplier&quot;:2&#125;&#125;&#x27; -q 1 -r 16 -s true -w 0 -a true 删除消费者订阅组(deleteSubGroup) 1sh bin/mqadmin deleteSubGroup -n 127.0.0.1:9876 -g TestConsumerGroup -c DefaultCluster 重要说明 如果 RocketMQ 开启了 ACL，无论是 ACL 1.0 还是 ACL 2.0，都需要在 conf/tools.yml 配置正确的账号密码，否则无法执行 mqadmin 命令。 12accessKey: mqadminsecretKey: 1234567","summary":"摘要 本文介绍 RocketMQ Admin Tool 的常用命令。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。","date_published":"2025-10-28T13:40:05.000Z","tags":["技术","rocketmq","分布式","rocketmq"]},{"id":"https://blog.hanqunfeng.com/2025/10/28/rocketmq-06-proxy-config/","url":"https://blog.hanqunfeng.com/2025/10/28/rocketmq-06-proxy-config/","title":"RocketMQ Proxy 的配置项","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 RocketMQ Proxy 的配置项。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://rocketmq.apache.org/zh/\">RocketMQ官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本文使用的 RocketMQ 版本为 5.3.2。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"配置项项目源码简介\">配置项项目源码简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当前版本尚不支持通过命令行查看 Proxy 的配置项，但是在启动Proxy的日志中可以看到当前生效的配置项。</p>\n</li>\n<li class=\"lvl-2\">\n<p>另外在源码 <code>rocketmq-all-5.3.2-source-release/proxy</code> 的启动类 <code>org.apache.rocketmq.proxy.ProxyStartup</code>中 可以看到其启动时会初始化如下配置项的类</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">org.apache.rocketmq.proxy.config.ProxyConfig</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置项说明\">配置项说明</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Proxy 配置参数说明与优化建议，这里要注意，Proxy的配置文件是 JSON 格式</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">分类</th>\n<th style=\"text-align:left\">参数名</th>\n<th style=\"text-align:left\">默认值</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">优化建议</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>基础信息</strong></td>\n<td style=\"text-align:left\"><code>rocketMQClusterName</code></td>\n<td style=\"text-align:left\"><code>DefaultCluster</code></td>\n<td style=\"text-align:left\">Broker 集群名称（Proxy 用于关联 RocketMQ 集群）</td>\n<td style=\"text-align:left\">若有多个集群，应唯一命名</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>proxyClusterName</code></td>\n<td style=\"text-align:left\"><code>DefaultCluster</code></td>\n<td style=\"text-align:left\">Proxy 所属集群名称（与 brokerClusterName 可不同）</td>\n<td style=\"text-align:left\">✅建议独立命名，区分 Proxy 集群</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>proxyName</code></td>\n<td style=\"text-align:left\">主机名（例：<code>ip-10-250-0-175...</code>）</td>\n<td style=\"text-align:left\">Proxy 实例名称，用于唯一标识</td>\n<td style=\"text-align:left\">✅建议设置唯一名称</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>localServeAddr</code></td>\n<td style=\"text-align:left\">本地 IP</td>\n<td style=\"text-align:left\">Proxy 本地服务地址（Remoting 通信使用）</td>\n<td style=\"text-align:left\">✅建议显式指定 IP</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Namesrv</strong></td>\n<td style=\"text-align:left\"><code>namesrvAddr</code></td>\n<td style=\"text-align:left\">多个地址（分号分隔）</td>\n<td style=\"text-align:left\">NameServer 地址，Proxy 通过它同步路由</td>\n<td style=\"text-align:left\">✅推荐配置为可访问的内网地址</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>namesrvDomain</code></td>\n<td style=\"text-align:left\">空</td>\n<td style=\"text-align:left\">NameServer 域名（可用于动态解析）</td>\n<td style=\"text-align:left\">可选，DNS 方式时使用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>namesrvDomainSubgroup</code></td>\n<td style=\"text-align:left\">空</td>\n<td style=\"text-align:left\">子域分组（多集群域名发现用）</td>\n<td style=\"text-align:left\">一般可忽略</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>TLS 配置</strong></td>\n<td style=\"text-align:left\"><code>tlsTestModeEnable</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">测试模式下跳过验证（仅用于本地测试）</td>\n<td style=\"text-align:left\">❗生产应设为 false</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>tlsKeyPath</code></td>\n<td style=\"text-align:left\"><code>/conf/tls/rocketmq.key</code></td>\n<td style=\"text-align:left\">TLS 私钥路径</td>\n<td style=\"text-align:left\">✅根据证书路径调整</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>tlsCertPath</code></td>\n<td style=\"text-align:left\"><code>/conf/tls/rocketmq.crt</code></td>\n<td style=\"text-align:left\">TLS 证书路径</td>\n<td style=\"text-align:left\">✅根据证书路径调整</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>gRPC 基础</strong></td>\n<td style=\"text-align:left\"><code>proxyMode</code></td>\n<td style=\"text-align:left\"><code>CLUSTER</code></td>\n<td style=\"text-align:left\">Proxy 模式：CLUSTER / LOCAL / REMOTING</td>\n<td style=\"text-align:left\">✅生产推荐 CLUSTER</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>grpcServerPort</code></td>\n<td style=\"text-align:left\">8081</td>\n<td style=\"text-align:left\">gRPC 服务端监听端口</td>\n<td style=\"text-align:left\">若冲突可修改</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>grpcShutdownTimeSeconds</code></td>\n<td style=\"text-align:left\">30</td>\n<td style=\"text-align:left\">优雅关闭等待时间</td>\n<td style=\"text-align:left\">可适当调大</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>enableGrpcEpoll</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">启用 Linux epoll I/O 模型</td>\n<td style=\"text-align:left\">✅Linux 建议开启</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>grpcMaxInboundMessageSize</code></td>\n<td style=\"text-align:left\">136314880 (~130MB)</td>\n<td style=\"text-align:left\">最大入站消息大小</td>\n<td style=\"text-align:left\">根据消息大小调整</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>消息限制</strong></td>\n<td style=\"text-align:left\"><code>maxMessageSize</code></td>\n<td style=\"text-align:left\">4194304 (4MB)</td>\n<td style=\"text-align:left\">最大消息体大小</td>\n<td style=\"text-align:left\">✅应与 Broker 一致</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>enableMessageBodyEmptyCheck</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">校验消息体是否为空</td>\n<td style=\"text-align:left\">保持默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>maxUserPropertySize</code></td>\n<td style=\"text-align:left\">16384 (16KB)</td>\n<td style=\"text-align:left\">用户属性最大长度</td>\n<td style=\"text-align:left\">根据业务复杂度调整</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>userPropertyMaxNum</code></td>\n<td style=\"text-align:left\">128</td>\n<td style=\"text-align:left\">单条消息最大属性数量</td>\n<td style=\"text-align:left\">可适当调低防止性能损耗</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>maxMessageGroupSize</code></td>\n<td style=\"text-align:left\">64</td>\n<td style=\"text-align:left\">最大消息组大小（批量 pop 使用）</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>消息可见性与延迟</strong></td>\n<td style=\"text-align:left\"><code>defaultInvisibleTimeMills</code></td>\n<td style=\"text-align:left\">60000 (60s)</td>\n<td style=\"text-align:left\">pop 消息默认不可见时间</td>\n<td style=\"text-align:left\">✅高并发时可调低</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>maxInvisibleTimeMills</code></td>\n<td style=\"text-align:left\">43200000 (12h)</td>\n<td style=\"text-align:left\">最大不可见时长</td>\n<td style=\"text-align:left\">✅可根据业务降低</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>maxDelayTimeMills</code></td>\n<td style=\"text-align:left\">86400000 (1d)</td>\n<td style=\"text-align:left\">最大延迟时间</td>\n<td style=\"text-align:left\">与 Broker 保持一致</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>useDelayLevel</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否使用延迟等级模式</td>\n<td style=\"text-align:left\">若 Broker 启用等级延迟则开启</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>messageDelayLevel</code></td>\n<td style=\"text-align:left\"><code>&quot;1s 5s 10s ... 2h&quot;</code></td>\n<td style=\"text-align:left\">延迟等级配置表</td>\n<td style=\"text-align:left\">✅需与 broker.conf 对齐</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>线程池（gRPC 模块）</strong></td>\n<td style=\"text-align:left\"><code>grpcBossLoopNum</code></td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">Netty boss 线程</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>grpcWorkerLoopNum</code></td>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">gRPC worker 线程</td>\n<td style=\"text-align:left\">✅CPU&gt;4 时可调高至核数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>grpcThreadPoolNums</code></td>\n<td style=\"text-align:left\">20</td>\n<td style=\"text-align:left\">gRPC 业务线程数</td>\n<td style=\"text-align:left\">✅建议 ≈ CPU 核数×2</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>grpcThreadPoolQueueCapacity</code></td>\n<td style=\"text-align:left\">100000</td>\n<td style=\"text-align:left\">队列容量</td>\n<td style=\"text-align:left\">⚠️建议 ≤20000，防 OOM</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>线程池（内部模块）</strong></td>\n<td style=\"text-align:left\"><code>producerProcessorThreadPoolNums</code></td>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">生产者处理线程</td>\n<td style=\"text-align:left\">✅可根据QPS调整</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>consumerProcessorThreadPoolNums</code></td>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">消费者处理线程</td>\n<td style=\"text-align:left\">同上</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>topicRouteServiceThreadPoolNums</code></td>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">路由服务线程</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>renewThreadPoolNums</code></td>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">自动续期线程</td>\n<td style=\"text-align:left\">高并发时可调大</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>缓存配置</strong></td>\n<td style=\"text-align:left\"><code>topicRouteServiceCacheExpiredSeconds</code></td>\n<td style=\"text-align:left\">300</td>\n<td style=\"text-align:left\">路由缓存有效期</td>\n<td style=\"text-align:left\">✅可适当调大</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>topicConfigCacheExpiredSeconds</code></td>\n<td style=\"text-align:left\">300</td>\n<td style=\"text-align:left\">Topic 配置缓存有效期</td>\n<td style=\"text-align:left\">同上</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>subscriptionGroupConfigCacheExpiredSeconds</code></td>\n<td style=\"text-align:left\">300</td>\n<td style=\"text-align:left\">订阅组缓存有效期</td>\n<td style=\"text-align:left\">同上</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>aclCacheExpiredSeconds</code></td>\n<td style=\"text-align:left\">300</td>\n<td style=\"text-align:left\">ACL 缓存有效期</td>\n<td style=\"text-align:left\">✅同上</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>事务与心跳</strong></td>\n<td style=\"text-align:left\"><code>transactionHeartbeatThreadPoolNums</code></td>\n<td style=\"text-align:left\">20</td>\n<td style=\"text-align:left\">事务心跳线程数</td>\n<td style=\"text-align:left\">✅根据事务量调整</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>transactionHeartbeatPeriodSecond</code></td>\n<td style=\"text-align:left\">20</td>\n<td style=\"text-align:left\">事务心跳周期</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>transactionDataExpireMillis</code></td>\n<td style=\"text-align:left\">30000</td>\n<td style=\"text-align:left\">事务数据过期时间</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>指标与监控</strong></td>\n<td style=\"text-align:left\"><code>metricsExporterType</code></td>\n<td style=\"text-align:left\">DISABLE</td>\n<td style=\"text-align:left\">指标导出方式：DISABLE / PROM / GRPC / LOG</td>\n<td style=\"text-align:left\">✅建议启用 PROM</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>metricsPromExporterPort</code></td>\n<td style=\"text-align:left\">5557</td>\n<td style=\"text-align:left\">Prometheus 导出端口</td>\n<td style=\"text-align:left\">✅建议暴露监控</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>metricsInDelta</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">是否按增量导出指标</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Remoting 模式</strong></td>\n<td style=\"text-align:left\"><code>enableRemotingLocalProxyGrpc</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">启用本地 Proxy gRPC 转发</td>\n<td style=\"text-align:left\">默认即可</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>remotingListenPort</code></td>\n<td style=\"text-align:left\">8080</td>\n<td style=\"text-align:left\">Remoting 通信端口</td>\n<td style=\"text-align:left\">若冲突修改</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>sendLatencyEnable</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">启用发送延迟探测（LoadBalance 优化）</td>\n<td style=\"text-align:left\">✅建议开启</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>startDetectorEnable</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">启用启动探测功能</td>\n<td style=\"text-align:left\">可选，测试阶段使用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>可观测性</strong></td>\n<td style=\"text-align:left\"><code>traceOn</code></td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">启用链路追踪</td>\n<td style=\"text-align:left\">✅建议开启</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>enablePrintJstack</code></td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">打印线程堆栈（用于诊断）</td>\n<td style=\"text-align:left\">✅可延长周期减少日志</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>综合优化建议</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">方向</th>\n<th style=\"text-align:left\">建议</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>性能调优</strong></td>\n<td style=\"text-align:left\">启用 <code>enableGrpcEpoll=true</code>；合理配置线程池（如减少队列长度）；设置合适的 <code>grpcThreadPoolNums</code>。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>可靠性</strong></td>\n<td style=\"text-align:left\">开启 <code>traceOn</code> 与 <code>sendLatencyEnable</code> 监控；使用 Prometheus 指标导出。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>安全性</strong></td>\n<td style=\"text-align:left\">禁用 <code>tlsTestModeEnable</code>，使用真实 TLS 证书。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>资源管理</strong></td>\n<td style=\"text-align:left\">限制缓存数量（如 topic/user/acl）和线程队列容量，防止内存膨胀。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>可维护性</strong></td>\n<td style=\"text-align:left\">使用独立的 <code>proxyClusterName</code>，并在配置文件 <code>rmq-proxy.json</code> 中明确各项端口和路径。</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 RocketMQ Proxy 的配置项。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。 配置项项目源码简介 当前版本尚不支持通过命令行查看 Proxy 的配置项，但是在启动Proxy的日志中可以看到当前生效的配置项。 另外在源码 rocketmq-all-5.3.2-source-release/proxy 的启动类 org.apache.rocketmq.proxy.ProxyStartup中 可以看到其启动时会初始化如下配置项的类 1org.apache.rocketmq.proxy.config.ProxyConfig 配置项说明 Proxy 配置参数说明与优化建议，这里要注意，Proxy的配置文件是 JSON 格式 分类 参数名 默认值 说明 优化建议 基础信息 rocketMQClusterName DefaultCluster Broker 集群名称（Proxy 用于关联 RocketMQ 集群） 若有多个集群，应唯一命名 proxyClusterName DefaultCluster Proxy 所属集群名称（与 brokerClusterName 可不同） ✅建议独立命名，区分 Proxy 集群 proxyName 主机名（例：ip-10-250-0-175...） Proxy 实例名称，用于唯一标识 ✅建议设置唯一名称 localServeAddr 本地 IP Proxy 本地服务地址（Remoting 通信使用） ✅建议显式指定 IP Namesrv namesrvAddr 多个地址（分号分隔） NameServer 地址，Proxy 通过它同步路由 ✅推荐配置为可访问的内网地址 namesrvDomain 空 NameServer 域名（可用于动态解析） 可选，DNS 方式时使用 namesrvDomainSubgroup 空 子域分组（多集群域名发现用） 一般可忽略 TLS 配置 tlsTestModeEnable true 测试模式下跳过验证（仅用于本地测试） ❗生产应设为 false tlsKeyPath /conf/tls/rocketmq.key TLS 私钥路径 ✅根据证书路径调整 tlsCertPath /conf/tls/rocketmq.crt TLS 证书路径 ✅根据证书路径调整 gRPC 基础 proxyMode CLUSTER Proxy 模式：CLUSTER / LOCAL / REMOTING ✅生产推荐 CLUSTER grpcServerPort 8081 gRPC 服务端监听端口 若冲突可修改 grpcShutdownTimeSeconds 30 优雅关闭等待时间 可适当调大 enableGrpcEpoll false 启用 Linux epoll I/O 模型 ✅Linux 建议开启 grpcMaxInboundMessageSize 136314880 (~130MB) 最大入站消息大小 根据消息大小调整 消息限制 maxMessageSize 4194304 (4MB) 最大消息体大小 ✅应与 Broker 一致 enableMessageBodyEmptyCheck true 校验消息体是否为空 保持默认即可 maxUserPropertySize 16384 (16KB) 用户属性最大长度 根据业务复杂度调整 userPropertyMaxNum 128 单条消息最大属性数量 可适当调低防止性能损耗 maxMessageGroupSize 64 最大消息组大小（批量 pop 使用） 默认即可 消息可见性与延迟 defaultInvisibleTimeMills 60000 (60s) pop 消息默认不可见时间 ✅高并发时可调低 maxInvisibleTimeMills 43200000 (12h) 最大不可见时长 ✅可根据业务降低 maxDelayTimeMills 86400000 (1d) 最大延迟时间 与 Broker 保持一致 useDelayLevel false 是否使用延迟等级模式 若 Broker 启用等级延迟则开启 messageDelayLevel &quot;1s 5s 10s ... 2h&quot; 延迟等级配置表 ✅需与 broker.conf 对齐 线程池（gRPC 模块） grpcBossLoopNum 1 Netty boss 线程 默认即可 grpcWorkerLoopNum 4 gRPC worker 线程 ✅CPU&gt;4 时可调高至核数 grpcThreadPoolNums 20 gRPC 业务线程数 ✅建议 ≈ CPU 核数×2 grpcThreadPoolQueueCapacity 100000 队列容量 ⚠️建议 ≤20000，防 OOM 线程池（内部模块） producerProcessorThreadPoolNums 2 生产者处理线程 ✅可根据QPS调整 consumerProcessorThreadPoolNums 2 消费者处理线程 同上 topicRouteServiceThreadPoolNums 2 路由服务线程 默认即可 renewThreadPoolNums 2 自动续期线程 高并发时可调大 缓存配置 topicRouteServiceCacheExpiredSeconds 300 路由缓存有效期 ✅可适当调大 topicConfigCacheExpiredSeconds 300 Topic 配置缓存有效期 同上 subscriptionGroupConfigCacheExpiredSeconds 300 订阅组缓存有效期 同上 aclCacheExpiredSeconds 300 ACL 缓存有效期 ✅同上 事务与心跳 transactionHeartbeatThreadPoolNums 20 事务心跳线程数 ✅根据事务量调整 transactionHeartbeatPeriodSecond 20 事务心跳周期 默认即可 transactionDataExpireMillis 30000 事务数据过期时间 默认即可 指标与监控 metricsExporterType DISABLE 指标导出方式：DISABLE / PROM / GRPC / LOG ✅建议启用 PROM metricsPromExporterPort 5557 Prometheus 导出端口 ✅建议暴露监控 metricsInDelta false 是否按增量导出指标 默认即可 Remoting 模式 enableRemotingLocalProxyGrpc true 启用本地 Proxy gRPC 转发 默认即可 remotingListenPort 8080 Remoting 通信端口 若冲突修改 sendLatencyEnable false 启用发送延迟探测（LoadBalance 优化） ✅建议开启 startDetectorEnable false 启用启动探测功能 可选，测试阶段使用 可观测性 traceOn false 启用链路追踪 ✅建议开启 enablePrintJstack true 打印线程堆栈（用于诊断） ✅可延长周期减少日志 综合优化建议 方向 建议 性能调优 启用 enableGrpcEpoll=true；合理配置线程池（如减少队列长度）；设置合适的 grpcThreadPoolNums。 可靠性 开启 traceOn 与 sendLatencyEnable 监控；使用 Prometheus 指标导出。 安全性 禁用 tlsTestModeEnable，使用真实 TLS 证书。 资源管理 限制缓存数量（如 topic/user/acl）和线程队列容量，防止内存膨胀。 可维护性 使用独立的 proxyClusterName，并在配置文件 rmq-proxy.json 中明确各项端口和路径。","summary":"摘要 本文介绍 RocketMQ Proxy 的配置项。 RocketMQ官网 本文使用的 RocketMQ 版本为 5.3.2。","date_published":"2025-10-28T13:33:05.000Z","tags":["技术","rocketmq","分布式","rocketmq"]}]}