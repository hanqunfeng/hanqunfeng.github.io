{"version":"https://jsonfeed.org/version/1","name":"飘逸峰的博客","home_page_url":"https://blog.hanqunfeng.com","feed_url":"https://blog.hanqunfeng.com/feed.json","author":{"name":"飘逸峰"},"items":[{"id":"https://blog.hanqunfeng.com/2025/07/20/k8s-hpa/","url":"https://blog.hanqunfeng.com/2025/07/20/k8s-hpa/","title":"K8S 之 Horizontal Pod Autoscaler（HPA）","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 K8S 中的 Horizontal Pod Autoscaler（HPA），本文以 CentOS 8 为例。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/\">K8S官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/docs/concepts/workloads/autoscaling/\">Autoscaling k8s简介</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/docs/tasks/run-application/horizontal-pod-autoscale/\">Horizontal Pod Autoscaler（HPA）</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Horizontal-Pod-Autoscaler（HPA）-简介\">Horizontal Pod Autoscaler（HPA） 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Horizontal Pod Autoscaler（HPA）基于资源 CPU 利用率自动调整 deployment、replication controller 或者 replica 中 pod 的数量，这有助于您的应用程序进行扩展以满足增长的需求，或在不需要资源时进行缩减，从而释放出节点用于其他应用程序。当您设置目标 CPU 利用率百分比时，HPA 扩展或缩减应用程序来尝试满足该目标。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Kubernetes 本身已经包含了 HPA 的 controller，所以不需要额外的安装或部署。</p>\n</li>\n<li class=\"lvl-2\">\n<p>HPA 需要获取 metrics 信息，metrics 信息需要从 Metrics Server 中获取，所以需要先安装 Metrics Server。</p>\n</li>\n<li class=\"lvl-2\">\n<p>HPA 会周期性(默认15秒)查询目标资源的使用情况，然后和 HPA 中定义的值做比较，并根据比较结果相应的调整 pod 数量。</p>\n</li>\n<li class=\"lvl-2\">\n<p>创建pod时，必须为其设定cpu资源，用于与目标值进行比较，目前最新的v2版本的HPA除了支持CPU的对比，还可以设定其它指标，具体参考<a href=\"https://kubernetes.io/zh-cn/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/\">HorizontalPodAutoscaler 演练</a>中的“基于多项度量指标和自定义度量指标自动扩缩”。</p>\n</li>\n<li class=\"lvl-2\">\n<p>博主之前写过一篇在aws的eks中使用hpa的文章 <a href=\"/2023/07/17/aws-eks17-hpa/\" title=\"AWS-EKS-17--Horizontal Pod Autoscaler（HPA）\">AWS-EKS-17--Horizontal Pod Autoscaler（HPA）</a>，和在自己搭建 k8s集群 中使用 hpa 基本一致，所以本文不再对重复内容进行赘述，建议读者先阅读 <a href=\"/2023/07/17/aws-eks17-hpa/\" title=\"AWS-EKS-17--Horizontal Pod Autoscaler（HPA）\">AWS-EKS-17--Horizontal Pod Autoscaler（HPA）</a>。</p>\n</li>\n</ul>\n<h2 id=\"安装-Metrics-Server\">安装 Metrics Server</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Kubernetes 的 HPA 是依赖 Metrics API 的，默认并不内置。需要通过 metrics-server 来收集和提供节点/Pod 的资源用量数据（CPU、内存等）。</p>\n</li>\n<li class=\"lvl-2\">\n<p>安装 <a href=\"https://github.com/kubernetes-sigs/metrics-server\">metrics-server</a></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -L -o metrics-server.yaml https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml</span><br><span class=\"line\">$ kubectl apply -f metrics-server.yaml</span><br><span class=\"line\">serviceaccount/metrics-server created</span><br><span class=\"line\">clusterrole.rbac.authorization.k8s.io/system:aggregated-metrics-reader created</span><br><span class=\"line\">clusterrole.rbac.authorization.k8s.io/system:metrics-server created</span><br><span class=\"line\">rolebinding.rbac.authorization.k8s.io/metrics-server-auth-reader created</span><br><span class=\"line\">clusterrolebinding.rbac.authorization.k8s.io/metrics-server:system:auth-delegator created</span><br><span class=\"line\">clusterrolebinding.rbac.authorization.k8s.io/system:metrics-server created</span><br><span class=\"line\">service/metrics-server created</span><br><span class=\"line\">deployment.apps/metrics-server created</span><br><span class=\"line\">apiservice.apiregistration.k8s.io/v1beta1.metrics.k8s.io created</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>部署后发现pod没有运行成功</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$  k get all -n kube-system -l k8s-app=metrics-server</span><br><span class=\"line\">NAME                                  READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">pod/metrics-server-867d48dc9c-fgdjq   0/1     Running   0          16s</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                     TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE</span><br><span class=\"line\">service/metrics-server   ClusterIP   10.96.91.221   &lt;none&gt;        443/TCP   16s</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                             READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class=\"line\">deployment.apps/metrics-server   0/1     1            0           16s</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                                        DESIRED   CURRENT   READY   AGE</span><br><span class=\"line\">replicaset.apps/metrics-server-867d48dc9c   1         1         0       16s</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>检查日志</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ k logs deployment.apps/metrics-server -n kube-system</span><br><span class=\"line\"><span class=\"comment\">## 输出类似于</span></span><br><span class=\"line\">E0703 23:02:38.120831       1 scraper.go:149] <span class=\"string\">&quot;Failed to scrape node&quot;</span> err=<span class=\"string\">&quot;Get \\&quot;https://10.211.55.15:10250/metrics/resource\\&quot;: tls: failed to verify certificate: x509: cannot validate certificate for 10.211.55.15 because it doesn&#x27;t contain any IP SANs&quot;</span> node=<span class=\"string\">&quot;k8s-worker1&quot;</span></span><br><span class=\"line\">E0703 23:02:38.127774       1 scraper.go:149] <span class=\"string\">&quot;Failed to scrape node&quot;</span> err=<span class=\"string\">&quot;Get \\&quot;https://10.211.55.16:10250/metrics/resource\\&quot;: tls: failed to verify certificate: x509: cannot validate certificate for 10.211.55.16 because it doesn&#x27;t contain any IP SANs&quot;</span> node=<span class=\"string\">&quot;k8s-worker2&quot;</span></span><br><span class=\"line\">E0703 23:02:38.140583       1 scraper.go:149] <span class=\"string\">&quot;Failed to scrape node&quot;</span> err=<span class=\"string\">&quot;Get \\&quot;https://10.211.55.11:10250/metrics/resource\\&quot;: tls: failed to verify certificate: x509: cannot validate certificate for 10.211.55.11 because it doesn&#x27;t contain any IP SANs&quot;</span> node=<span class=\"string\">&quot;k8s-master&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>意思是 metrics-server 在通过 https://<node-ip>:10250 请求 kubelet 的时候，发现 kubelet 的证书不包含该 IP 的 Subject Alternative Name (SAN)，因此 TLS 校验失败。</p>\n</li>\n<li class=\"lvl-2\">\n<p>解决方案: 添加 --kubelet-insecure-tls 参数，跳过 kubelet 的 TLS 证书校验(metrics-server 本身权限有限，风险可控，kubelet 自签证书维护成本高)</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl edit deployment metrics-server -n kube-system</span><br><span class=\"line\"><span class=\"comment\">## 在 args 中添加 --kubelet-insecure-tls</span></span><br><span class=\"line\">  spec:</span><br><span class=\"line\">    containers:</span><br><span class=\"line\">    - args:</span><br><span class=\"line\">      - --cert-dir=/tmp</span><br><span class=\"line\">      - --secure-port=10250</span><br><span class=\"line\">      - --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname</span><br><span class=\"line\">      - --kubelet-use-node-status-port</span><br><span class=\"line\">      - --metric-resolution=15s</span><br><span class=\"line\">      - --kubelet-insecure-tls   <span class=\"comment\"># 添加此行</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>wq</code>保存后，等一会再次查看所有资源均已正常</p>\n</li>\n<li class=\"lvl-2\">\n<p>查看所有 node 的资源</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ k top nodes</span><br><span class=\"line\">NAME          CPU(cores)   CPU(%)   MEMORY(bytes)   MEMORY(%)</span><br><span class=\"line\">k8s-master    216m         10%      1712Mi          44%</span><br><span class=\"line\">k8s-worker1   79m          3%       1025Mi          26%</span><br><span class=\"line\">k8s-worker2   82m          4%       982Mi           25%</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>NAME</strong></td>\n<td>节点名称，Kubernetes 集群的节点名字。</td>\n</tr>\n<tr>\n<td><strong>CPU(cores)</strong></td>\n<td>当前节点 CPU 的瞬时使用量，单位是核心数（Core），比如 <code>216m</code> = 0.216 核心。<code>m</code> = <strong>millicores</strong>，1000m = 1核。</td>\n</tr>\n<tr>\n<td><strong>CPU(%)</strong></td>\n<td>当前 CPU 使用率，相对于该节点 CPU 总核数的百分比。比如 <code>10%</code> 表示节点 CPU 的 10% 被使用。</td>\n</tr>\n<tr>\n<td><strong>MEMORY(bytes)</strong></td>\n<td>节点当前使用的内存，单位是字节（例如 <code>1712Mi</code> = 1712 Mebibytes ≈ 1.7 GB）。</td>\n</tr>\n<tr>\n<td><strong>MEMORY(%)</strong></td>\n<td>节点内存使用率，占总内存的百分比。比如 <code>44%</code> 表示该节点内存使用了 44%。</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看所有 pod 的资源</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ k top pods -A</span><br><span class=\"line\">NAMESPACE     NAME                                       CPU(cores)   MEMORY(bytes)</span><br><span class=\"line\">default       nginx-5869d7778c-5682r                     0m           9Mi</span><br><span class=\"line\">default       nginx-5869d7778c-thw8f                     0m           4Mi</span><br><span class=\"line\">kube-system   calico-kube-controllers-7bfdc5b57c-q5xwp   6m           35Mi</span><br><span class=\"line\">kube-system   calico-node-7pbbq                          42m          281Mi</span><br><span class=\"line\">kube-system   calico-node-v4hzr                          47m          260Mi</span><br><span class=\"line\">kube-system   calico-node-w47qq                          40m          263Mi</span><br><span class=\"line\">kube-system   coredns-674b8bbfcf-2tvld                   2m           23Mi</span><br><span class=\"line\">kube-system   coredns-674b8bbfcf-h6kx7                   2m           22Mi</span><br><span class=\"line\">kube-system   etcd-k8s-master                            27m          85Mi</span><br><span class=\"line\">kube-system   kube-apiserver-k8s-master                  49m          404Mi</span><br><span class=\"line\">kube-system   kube-controller-manager-k8s-master         28m          100Mi</span><br><span class=\"line\">kube-system   kube-proxy-nkbns                           1m           41Mi</span><br><span class=\"line\">kube-system   kube-proxy-plqw8                           1m           25Mi</span><br><span class=\"line\">kube-system   kube-proxy-sbgh6                           1m           34Mi</span><br><span class=\"line\">kube-system   kube-scheduler-k8s-master                  8m           38Mi</span><br><span class=\"line\">kube-system   metrics-server-56fb9549f4-rtt7n            4m           21Mi</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建-HPA\">创建 HPA</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>前面的文章中多次使用 nginx 镜像创建了 deployment，但是都没有配置过资源，为了测试 hpa，需要为其指定资源</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 直接修改 deployment，保存后立刻生效</span></span><br><span class=\"line\">kubectl edit deployment nginx</span><br><span class=\"line\"><span class=\"comment\"># 增加资源限制</span></span><br><span class=\"line\">spec:</span><br><span class=\"line\">  replicas: 1   <span class=\"comment\"># 修改副本数位 1</span></span><br><span class=\"line\">  template:</span><br><span class=\"line\">    metadata:</span><br><span class=\"line\">      labels:</span><br><span class=\"line\">        app: nginx</span><br><span class=\"line\">    spec:</span><br><span class=\"line\">      containers:</span><br><span class=\"line\">      - name: nginx</span><br><span class=\"line\">        image: nginx</span><br><span class=\"line\">        resources:</span><br><span class=\"line\">          limits:</span><br><span class=\"line\">            cpu: 500m</span><br><span class=\"line\">            memory: 500Mi</span><br><span class=\"line\">          requests:</span><br><span class=\"line\">            cpu: 200m</span><br><span class=\"line\">            memory: 200Mi</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>命令行创建 HPA</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建了一个叫“hpa-nginx”的 HPA，默认与 deployment 的名称相同，可以用 --name=&#x27;hpa-nginx&#x27; 指定hpa的名称</span></span><br><span class=\"line\"><span class=\"comment\"># replicas 变动范围是最小 3，最大 10</span></span><br><span class=\"line\"><span class=\"comment\"># 目标cpu利用率为 50%，上面我们设定 CPU request 值为 100m，所以当平均cpu值为 100m 时就会触发 autoscale</span></span><br><span class=\"line\"><span class=\"comment\"># 这里说平均cpu，是指所有pod的cpu利用率的平均值</span></span><br><span class=\"line\">$ k autoscale deployment nginx --name=<span class=\"string\">&quot;hpa-nginx&quot;</span> --cpu-percent=50 --min=3 --max=10</span><br><span class=\"line\">horizontalpodautoscaler.autoscaling/hpa-nginx autoscaled</span><br><span class=\"line\"><span class=\"comment\"># 观察，大约 15秒后，hpa-nginx 发现 replicas 值为1，30秒的时候自动扩容到3个，因为我们设置的hpa的replicas最小值为3，并且采集到了cpu使用率</span></span><br><span class=\"line\">$ k get hpa -w</span><br><span class=\"line\">NAME        REFERENCE          TARGETS              MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class=\"line\">hpa-nginx   Deployment/nginx   cpu: &lt;unknown&gt;/50%   3         10        0          0s</span><br><span class=\"line\">hpa-nginx   Deployment/nginx   cpu: &lt;unknown&gt;/50%   3         10        1          15s</span><br><span class=\"line\">hpa-nginx   Deployment/nginx   cpu: 0%/50%          3         10        3          30s</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ymal文件创建 HPA</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">autoscaling/v2</span>    <span class=\"comment\"># api版本，这里设置为 v2</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">HorizontalPodAutoscaler</span> <span class=\"comment\"># 资源类型</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">hpa-nginx</span>             <span class=\"comment\"># hpa资源名称</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">default</span>          <span class=\"comment\"># 命名空间</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">maxReplicas:</span> <span class=\"number\">10</span>             <span class=\"comment\"># 最大副本数</span></span><br><span class=\"line\">  <span class=\"attr\">minReplicas:</span> <span class=\"number\">1</span>              <span class=\"comment\"># 最小副本数</span></span><br><span class=\"line\">  <span class=\"attr\">metrics:</span>                    <span class=\"comment\"># 指标设定</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">Resource</span>            <span class=\"comment\"># 资源类型，可以配置为 Resource/Object/Pods</span></span><br><span class=\"line\">    <span class=\"attr\">resource:</span>                 <span class=\"comment\"># 资源对象</span></span><br><span class=\"line\">      <span class=\"attr\">name:</span> <span class=\"string\">cpu</span>               <span class=\"comment\"># 资源名称 cpu/memory</span></span><br><span class=\"line\">      <span class=\"attr\">target:</span>                 <span class=\"comment\"># 目标对象</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">Utilization</span>     <span class=\"comment\"># 目标类型，可以配置为 Utilization/AverageValue/Value</span></span><br><span class=\"line\">        <span class=\"attr\">averageUtilization:</span> <span class=\"number\">50</span> <span class=\"comment\"># 目标值，这里是平均使用率的百分比</span></span><br><span class=\"line\">  <span class=\"attr\">scaleTargetRef:</span>             <span class=\"comment\"># 指定要自动伸缩的资源对象</span></span><br><span class=\"line\">    <span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\">    <span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span>          <span class=\"comment\"># 资源类型为 Deployment</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">nginx</span>               <span class=\"comment\"># 资源名称为 nginx</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"HPA-支持的监控指标类型\">HPA 支持的监控指标类型</h2>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>字段名</th>\n<th>说明</th>\n<th>常见用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Resource</strong></td>\n<td><code>resource</code></td>\n<td>基于 Pod 资源使用情况（CPU、内存），最常用</td>\n<td>按 CPU 利用率自动扩缩容</td>\n</tr>\n<tr>\n<td><strong>Pods</strong></td>\n<td><code>pods</code></td>\n<td>基于每个 Pod 的自定义度量指标的平均值，需要第三方监控系统提供，比如 Prometheus</td>\n<td>按业务指标（如请求数、队列长度）扩缩容</td>\n</tr>\n<tr>\n<td><strong>Object</strong></td>\n<td><code>object</code></td>\n<td>基于单个 Kubernetes 对象（如 Service、Ingress）的指标，，比如 Prometheus</td>\n<td>按某个对象的指标扩缩容，例如队列长度</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Resource-资源指标（CPU-内存）\">Resource 资源指标（CPU/内存）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Utilization: 利用率百分比</p>\n</li>\n<li class=\"lvl-2\">\n<p>Utilization 不关心 limits，只看 requests。</p>\n</li>\n<li class=\"lvl-2\">\n<p>如果 resources.requests 没有设置，HPA Utilization 会报错（除非 AverageValue）。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">metrics:</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">Resource</span></span><br><span class=\"line\">  <span class=\"attr\">resource:</span>                   <span class=\"comment\"># 资源 指标</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">cpu</span>                 <span class=\"comment\"># cpu</span></span><br><span class=\"line\">    <span class=\"attr\">target:</span></span><br><span class=\"line\">      <span class=\"attr\">type:</span> <span class=\"string\">Utilization</span>       <span class=\"comment\"># 利用率百分比</span></span><br><span class=\"line\">      <span class=\"attr\">averageUtilization:</span> <span class=\"number\">50</span>  <span class=\"comment\"># 50%</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>当前有 3 个 Pod：</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Pod</th>\n<th>CPU 实际使用</th>\n<th>CPU requests</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>pod-1</td>\n<td>150m</td>\n<td>200m</td>\n</tr>\n<tr>\n<td>pod-2</td>\n<td>100m</td>\n<td>200m</td>\n</tr>\n<tr>\n<td>pod-3</td>\n<td>50m</td>\n<td>200m</td>\n</tr>\n<tr>\n<td>合计</td>\n<td>400m</td>\n<td>600m</td>\n</tr>\n<tr>\n<td><strong>平均</strong></td>\n<td><strong>400m ÷ 600m × 100% ≈ 66.7%</strong></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>由于 66.7% &gt; 50%，会扩容；如果小于 50%，HPA 会缩容。</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>AverageValue: 指定资源使用平均值</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">metrics:</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">Resource</span></span><br><span class=\"line\">  <span class=\"attr\">resource:</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">memory</span>                <span class=\"comment\"># 监控资源类型为 memory（内存）</span></span><br><span class=\"line\">    <span class=\"attr\">target:</span></span><br><span class=\"line\">      <span class=\"attr\">type:</span> <span class=\"string\">AverageValue</span>        <span class=\"comment\"># 指标类型为 AverageValue，表示每个 Pod 平均使用多少</span></span><br><span class=\"line\">      <span class=\"attr\">averageValue:</span> <span class=\"string\">400Mi</span>       <span class=\"comment\"># 目标值：平均每个 Pod 使用 400Mi 内存</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>假设当前部署了 3 个副本，内存使用情况如下：</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Pod</th>\n<th>当前内存使用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>pod-1</td>\n<td>450Mi</td>\n</tr>\n<tr>\n<td>pod-2</td>\n<td>400Mi</td>\n</tr>\n<tr>\n<td>pod-3</td>\n<td>300Mi</td>\n</tr>\n<tr>\n<td><strong>平均</strong></td>\n<td><strong>(450+400+300)/3 = 383.3Mi</strong></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>因为 383.3Mi &lt; 400Mi，不触发扩容。如果将来平均使用超过 400Mi，HPA 就会扩容，反之缩容。</p>\n</blockquote>\n<h2 id=\"HPA-扩缩容速度配置\">HPA 扩缩容速度配置</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>HPA 的扩缩容速度是可以控制的，通过 behavior 字段来自定义扩缩容的速度和策略。</p>\n</li>\n<li class=\"lvl-2\">\n<p>以下是默认策略</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">behavior:</span></span><br><span class=\"line\">  <span class=\"attr\">scaleUp:</span>                                  <span class=\"comment\"># ⬆️ 扩容策略</span></span><br><span class=\"line\">    <span class=\"attr\">tolerance:</span> <span class=\"number\">0.1</span>                          <span class=\"comment\"># 容忍阈值，默认0.1(10%)，表示每次扩容时，pod使用率超过1.1倍目标值时才会进行扩容</span></span><br><span class=\"line\">    <span class=\"attr\">stabilizationWindowSeconds:</span> <span class=\"number\">0</span>           <span class=\"comment\"># 默认0，即增加或减少pod数量后保持不变的时间，单位为秒</span></span><br><span class=\"line\">    <span class=\"attr\">policies:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">Percent</span>                         <span class=\"comment\"># 扩容速度按百分比限制</span></span><br><span class=\"line\">      <span class=\"attr\">value:</span> <span class=\"number\">100</span>                            <span class=\"comment\"># 每 15 秒最多扩容 100% 的副本数</span></span><br><span class=\"line\">      <span class=\"attr\">periodSeconds:</span> <span class=\"number\">15</span>                     <span class=\"comment\"># 每 15 秒计算一次是否可以扩容，默认 15 秒</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">Pods</span>                            <span class=\"comment\"># 按固定 Pod 数量限制扩容速度</span></span><br><span class=\"line\">      <span class=\"attr\">value:</span> <span class=\"number\">4</span>                              <span class=\"comment\"># 每 15 秒最多扩容 4 个 Pod</span></span><br><span class=\"line\">      <span class=\"attr\">periodSeconds:</span> <span class=\"number\">15</span>                     <span class=\"comment\"># 同样 15 秒计算一次，默认 15 秒</span></span><br><span class=\"line\">    <span class=\"attr\">selectPolicy:</span> <span class=\"string\">Max</span>                       <span class=\"comment\"># 多个 policy 同时存在时，取 Percent 和 Pods 的最大值。Min 取最小值</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">scaleDown:</span>                                <span class=\"comment\"># ⬇️ 缩容策略</span></span><br><span class=\"line\">    <span class=\"attr\">stabilizationWindowSeconds:</span> <span class=\"number\">300</span>         <span class=\"comment\"># 默认 300，即增加或减少pod数量后保持不变的时间，单位为秒，防止快速缩容（平滑策略）</span></span><br><span class=\"line\">    <span class=\"attr\">policies:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">Percent</span>                         <span class=\"comment\"># 缩容速度按百分比限制</span></span><br><span class=\"line\">      <span class=\"attr\">value:</span> <span class=\"number\">100</span>                            <span class=\"comment\"># 每 15 秒最多缩容 100% 的副本数</span></span><br><span class=\"line\">      <span class=\"attr\">periodSeconds:</span> <span class=\"number\">15</span>                     <span class=\"comment\"># 每 15 秒评估一次是否可以缩容</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>完整的 HPA 配置文件示例(一般情况下，我们无需修改扩缩容速度的配置，默认策略满足大部分场景)</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">autoscaling/v2</span>                    <span class=\"comment\"># api版本，使用 v2 版本支持 behavior 扩缩容策略</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">HorizontalPodAutoscaler</span>                 <span class=\"comment\"># 资源类型为 HPA</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">hpa-nginx</span>                             <span class=\"comment\"># HPA 资源的名称</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">default</span>                          <span class=\"comment\"># 命名空间，设置为 default</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">maxReplicas:</span> <span class=\"number\">10</span>                             <span class=\"comment\"># HPA 自动扩容的最大副本数</span></span><br><span class=\"line\">  <span class=\"attr\">minReplicas:</span> <span class=\"number\">1</span>                              <span class=\"comment\"># HPA 自动缩容的最小副本数</span></span><br><span class=\"line\">  <span class=\"attr\">metrics:</span>                                    <span class=\"comment\"># 自动伸缩的指标配置</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">Resource</span>                            <span class=\"comment\"># 指标类型为 Resource（资源型）</span></span><br><span class=\"line\">    <span class=\"attr\">resource:</span>                                 <span class=\"comment\"># 资源指标对象</span></span><br><span class=\"line\">      <span class=\"attr\">name:</span> <span class=\"string\">cpu</span>                               <span class=\"comment\"># 资源名称为 cpu，也可以设置为 memory</span></span><br><span class=\"line\">      <span class=\"attr\">target:</span>                                 <span class=\"comment\"># 目标指标对象</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">Utilization</span>                     <span class=\"comment\"># 指标类型为 Utilization（利用率百分比）</span></span><br><span class=\"line\">        <span class=\"attr\">averageUtilization:</span> <span class=\"number\">50</span>                <span class=\"comment\"># CPU 平均使用率达到 50% 时进行扩缩容</span></span><br><span class=\"line\">  <span class=\"attr\">scaleTargetRef:</span>                             <span class=\"comment\"># HPA 绑定的目标资源对象</span></span><br><span class=\"line\">    <span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\">    <span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span>                          <span class=\"comment\"># 目标类型为 Deployment</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">nginx</span>                               <span class=\"comment\"># 目标 Deployment 名称为 nginx</span></span><br><span class=\"line\">  <span class=\"attr\">behavior:</span>                                   <span class=\"comment\"># ⬇️ 扩缩容行为控制</span></span><br><span class=\"line\">    <span class=\"attr\">scaleUp:</span>                                  <span class=\"comment\"># 扩容策略</span></span><br><span class=\"line\">      <span class=\"attr\">stabilizationWindowSeconds:</span> <span class=\"number\">30</span>          <span class=\"comment\"># 扩容平滑窗口为 30 秒，防止短时间抖动频繁扩容</span></span><br><span class=\"line\">      <span class=\"attr\">policies:</span>                               <span class=\"comment\"># 扩容速度限制策略</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">Percent</span>                         <span class=\"comment\"># 按百分比计算</span></span><br><span class=\"line\">        <span class=\"attr\">value:</span> <span class=\"number\">100</span>                            <span class=\"comment\"># 每 15 秒内最多扩容 100%</span></span><br><span class=\"line\">        <span class=\"attr\">periodSeconds:</span> <span class=\"number\">15</span>                     <span class=\"comment\"># 每 15 秒评估一次扩容速率</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">Pods</span>                            <span class=\"comment\"># 按固定 Pod 数量计算</span></span><br><span class=\"line\">        <span class=\"attr\">value:</span> <span class=\"number\">4</span>                              <span class=\"comment\"># 每 15 秒最多扩容 4 个 Pod</span></span><br><span class=\"line\">        <span class=\"attr\">periodSeconds:</span> <span class=\"number\">15</span>                     <span class=\"comment\"># 每 15 秒评估一次扩容速率</span></span><br><span class=\"line\">      <span class=\"attr\">selectPolicy:</span> <span class=\"string\">Max</span>                       <span class=\"comment\"># 如果多个 policy 同时满足，取最大值（更激进的扩容）</span></span><br><span class=\"line\">    <span class=\"attr\">scaleDown:</span>                                <span class=\"comment\"># 缩容策略</span></span><br><span class=\"line\">      <span class=\"attr\">stabilizationWindowSeconds:</span> <span class=\"number\">300</span>         <span class=\"comment\"># 缩容平滑窗口为 300 秒（5 分钟），避免短时流量降低快速缩容</span></span><br><span class=\"line\">      <span class=\"attr\">policies:</span>                               <span class=\"comment\"># 缩容速度限制策略</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">Percent</span>                         <span class=\"comment\"># 按百分比缩容</span></span><br><span class=\"line\">        <span class=\"attr\">value:</span> <span class=\"number\">30</span>                             <span class=\"comment\"># 每 60 秒最多缩容 30%</span></span><br><span class=\"line\">        <span class=\"attr\">periodSeconds:</span> <span class=\"number\">60</span>                     <span class=\"comment\"># 每 60 秒评估一次缩容速率</span></span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍 K8S 中的 Horizontal Pod Autoscaler（HPA），本文以 CentOS 8 为例。 K8S官网 Autoscaling k8s简介 Horizontal Pod Autoscaler（HPA） Horizontal Pod Autoscaler（HPA） 简介 Horizontal Pod Autoscaler（HPA）基于资源 CPU 利用率自动调整 deployment、replication controller 或者 replica 中 pod 的数量，这有助于您的应用程序进行扩展以满足增长的需求，或在不需要资源时进行缩减，从而释放出节点用于其他应用程序。当您设置目标 CPU 利用率百分比时，HPA 扩展或缩减应用程序来尝试满足该目标。 Kubernetes 本身已经包含了 HPA 的 controller，所以不需要额外的安装或部署。 HPA 需要获取 metrics 信息，metrics 信息需要从 Metrics Server 中获取，所以需要先安装 Metrics Server。 HPA 会周期性(默认15秒)查询目标资源的使用情况，然后和 HPA 中定义的值做比较，并根据比较结果相应的调整 pod 数量。 创建pod时，必须为其设定cpu资源，用于与目标值进行比较，目前最新的v2版本的HPA除了支持CPU的对比，还可以设定其它指标，具体参考HorizontalPodAutoscaler 演练中的“基于多项度量指标和自定义度量指标自动扩缩”。 博主之前写过一篇在aws的eks中使用hpa的文章 AWS-EKS-17--Horizontal Pod Autoscaler（HPA），和在自己搭建 k8s集群 中使用 hpa 基本一致，所以本文不再对重复内容进行赘述，建议读者先阅读 AWS-EKS-17--Horizontal Pod Autoscaler（HPA）。 安装 Metrics Server Kubernetes 的 HPA 是依赖 Metrics API 的，默认并不内置。需要通过 metrics-server 来收集和提供节点/Pod 的资源用量数据（CPU、内存等）。 安装 metrics-server 1234567891011$ curl -L -o metrics-server.yaml https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml$ kubectl apply -f metrics-server.yamlserviceaccount/metrics-server createdclusterrole.rbac.authorization.k8s.io/system:aggregated-metrics-reader createdclusterrole.rbac.authorization.k8s.io/system:metrics-server createdrolebinding.rbac.authorization.k8s.io/metrics-server-auth-reader createdclusterrolebinding.rbac.authorization.k8s.io/metrics-server:system:auth-delegator createdclusterrolebinding.rbac.authorization.k8s.io/system:metrics-server createdservice/metrics-server createddeployment.apps/metrics-server createdapiservice.apiregistration.k8s.io/v1beta1.metrics.k8s.io created 部署后发现pod没有运行成功 123456789101112$ k get all -n kube-system -l k8s-app=metrics-serverNAME READY STATUS RESTARTS AGEpod/metrics-server-867d48dc9c-fgdjq 0/1 Running 0 16sNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEservice/metrics-server ClusterIP 10.96.91.221 &lt;none&gt; 443/TCP 16sNAME READY UP-TO-DATE AVAILABLE AGEdeployment.apps/metrics-server 0/1 1 0 16sNAME DESIRED CURRENT READY AGEreplicaset.apps/metrics-server-867d48dc9c 1 1 0 16s 检查日志 12345$ k logs deployment.apps/metrics-server -n kube-system## 输出类似于E0703 23:02:38.120831 1 scraper.go:149] &quot;Failed to scrape node&quot; err=&quot;Get \\&quot;https://10.211.55.15:10250/metrics/resource\\&quot;: tls: failed to verify certificate: x509: cannot validate certificate for 10.211.55.15 because it doesn&#x27;t contain any IP SANs&quot; node=&quot;k8s-worker1&quot;E0703 23:02:38.127774 1 scraper.go:149] &quot;Failed to scrape node&quot; err=&quot;Get \\&quot;https://10.211.55.16:10250/metrics/resource\\&quot;: tls: failed to verify certificate: x509: cannot validate certificate for 10.211.55.16 because it doesn&#x27;t contain any IP SANs&quot; node=&quot;k8s-worker2&quot;E0703 23:02:38.140583 1 scraper.go:149] &quot;Failed to scrape node&quot; err=&quot;Get \\&quot;https://10.211.55.11:10250/metrics/resource\\&quot;: tls: failed to verify certificate: x509: cannot validate certificate for 10.211.55.11 because it doesn&#x27;t contain any IP SANs&quot; node=&quot;k8s-master&quot; 意思是 metrics-server 在通过 https://:10250 请求 kubelet 的时候，发现 kubelet 的证书不包含该 IP 的 Subject Alternative Name (SAN)，因此 TLS 校验失败。 解决方案: 添加 --kubelet-insecure-tls 参数，跳过 kubelet 的 TLS 证书校验(metrics-server 本身权限有限，风险可控，kubelet 自签证书维护成本高) 1234567891011kubectl edit deployment metrics-server -n kube-system## 在 args 中添加 --kubelet-insecure-tls spec: containers: - args: - --cert-dir=/tmp - --secure-port=10250 - --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname - --kubelet-use-node-status-port - --metric-resolution=15s - --kubelet-insecure-tls # 添加此行 wq保存后，等一会再次查看所有资源均已正常 查看所有 node 的资源 12345$ k top nodesNAME CPU(cores) CPU(%) MEMORY(bytes) MEMORY(%)k8s-master 216m 10% 1712Mi 44%k8s-worker1 79m 3% 1025Mi 26%k8s-worker2 82m 4% 982Mi 25% 字段 说明 NAME 节点名称，Kubernetes 集群的节点名字。 CPU(cores) 当前节点 CPU 的瞬时使用量，单位是核心数（Core），比如 216m = 0.216 核心。m = millicores，1000m = 1核。 CPU(%) 当前 CPU 使用率，相对于该节点 CPU 总核数的百分比。比如 10% 表示节点 CPU 的 10% 被使用。 MEMORY(bytes) 节点当前使用的内存，单位是字节（例如 1712Mi = 1712 Mebibytes ≈ 1.7 GB）。 MEMORY(%) 节点内存使用率，占总内存的百分比。比如 44% 表示该节点内存使用了 44%。 查看所有 pod 的资源 123456789101112131415161718$ k top pods -ANAMESPACE NAME CPU(cores) MEMORY(bytes)default nginx-5869d7778c-5682r 0m 9Midefault nginx-5869d7778c-thw8f 0m 4Mikube-system calico-kube-controllers-7bfdc5b57c-q5xwp 6m 35Mikube-system calico-node-7pbbq 42m 281Mikube-system calico-node-v4hzr 47m 260Mikube-system calico-node-w47qq 40m 263Mikube-system coredns-674b8bbfcf-2tvld 2m 23Mikube-system coredns-674b8bbfcf-h6kx7 2m 22Mikube-system etcd-k8s-master 27m 85Mikube-system kube-apiserver-k8s-master 49m 404Mikube-system kube-controller-manager-k8s-master 28m 100Mikube-system kube-proxy-nkbns 1m 41Mikube-system kube-proxy-plqw8 1m 25Mikube-system kube-proxy-sbgh6 1m 34Mikube-system kube-scheduler-k8s-master 8m 38Mikube-system metrics-server-56fb9549f4-rtt7n 4m 21Mi 创建 HPA 前面的文章中多次使用 nginx 镜像创建了 deployment，但是都没有配置过资源，为了测试 hpa，需要为其指定资源 1234567891011121314151617181920# 直接修改 deployment，保存后立刻生效kubectl edit deployment nginx# 增加资源限制spec: replicas: 1 # 修改副本数位 1 template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx resources: limits: cpu: 500m memory: 500Mi requests: cpu: 200m memory: 200Mi 命令行创建 HPA 123456789101112# 创建了一个叫“hpa-nginx”的 HPA，默认与 deployment 的名称相同，可以用 --name=&#x27;hpa-nginx&#x27; 指定hpa的名称# replicas 变动范围是最小 3，最大 10# 目标cpu利用率为 50%，上面我们设定 CPU request 值为 100m，所以当平均cpu值为 100m 时就会触发 autoscale# 这里说平均cpu，是指所有pod的cpu利用率的平均值$ k autoscale deployment nginx --name=&quot;hpa-nginx&quot; --cpu-percent=50 --min=3 --max=10horizontalpodautoscaler.autoscaling/hpa-nginx autoscaled# 观察，大约 15秒后，hpa-nginx 发现 replicas 值为1，30秒的时候自动扩容到3个，因为我们设置的hpa的replicas最小值为3，并且采集到了cpu使用率$ k get hpa -wNAME REFERENCE TARGETS MINPODS MAXPODS REPLICAS AGEhpa-nginx Deployment/nginx cpu: &lt;unknown&gt;/50% 3 10 0 0shpa-nginx Deployment/nginx cpu: &lt;unknown&gt;/50% 3 10 1 15shpa-nginx Deployment/nginx cpu: 0%/50% 3 10 3 30s ymal文件创建 HPA 12345678910111213141516171819apiVersion: autoscaling/v2 # api版本，这里设置为 v2kind: HorizontalPodAutoscaler # 资源类型metadata: name: hpa-nginx # hpa资源名称 namespace: default # 命名空间spec: maxReplicas: 10 # 最大副本数 minReplicas: 1 # 最小副本数 metrics: # 指标设定 - type: Resource # 资源类型，可以配置为 Resource/Object/Pods resource: # 资源对象 name: cpu # 资源名称 cpu/memory target: # 目标对象 type: Utilization # 目标类型，可以配置为 Utilization/AverageValue/Value averageUtilization: 50 # 目标值，这里是平均使用率的百分比 scaleTargetRef: # 指定要自动伸缩的资源对象 apiVersion: apps/v1 kind: Deployment # 资源类型为 Deployment name: nginx # 资源名称为 nginx HPA 支持的监控指标类型 类型 字段名 说明 常见用途 Resource resource 基于 Pod 资源使用情况（CPU、内存），最常用 按 CPU 利用率自动扩缩容 Pods pods 基于每个 Pod 的自定义度量指标的平均值，需要第三方监控系统提供，比如 Prometheus 按业务指标（如请求数、队列长度）扩缩容 Object object 基于单个 Kubernetes 对象（如 Service、Ingress）的指标，，比如 Prometheus 按某个对象的指标扩缩容，例如队列长度 Resource 资源指标（CPU/内存） Utilization: 利用率百分比 Utilization 不关心 limits，只看 requests。 如果 resources.requests 没有设置，HPA Utilization 会报错（除非 AverageValue）。 1234567metrics:- type: Resource resource: # 资源 指标 name: cpu # cpu target: type: Utilization # 利用率百分比 averageUtilization: 50 # 50% 当前有 3 个 Pod： Pod CPU 实际使用 CPU requests pod-1 150m 200m pod-2 100m 200m pod-3 50m 200m 合计 400m 600m 平均 400m ÷ 600m × 100% ≈ 66.7% 由于 66.7% &gt; 50%，会扩容；如果小于 50%，HPA 会缩容。 AverageValue: 指定资源使用平均值 1234567metrics:- type: Resource resource: name: memory # 监控资源类型为 memory（内存） target: type: AverageValue # 指标类型为 AverageValue，表示每个 Pod 平均使用多少 averageValue: 400Mi # 目标值：平均每个 Pod 使用 400Mi 内存 假设当前部署了 3 个副本，内存使用情况如下： Pod 当前内存使用 pod-1 450Mi pod-2 400Mi pod-3 300Mi 平均 (450+400+300)/3 = 383.3Mi 因为 383.3Mi &lt; 400Mi，不触发扩容。如果将来平均使用超过 400Mi，HPA 就会扩容，反之缩容。 HPA 扩缩容速度配置 HPA 的扩缩容速度是可以控制的，通过 behavior 字段来自定义扩缩容的速度和策略。 以下是默认策略 12345678910111213141516171819behavior: scaleUp: # ⬆️ 扩容策略 tolerance: 0.1 # 容忍阈值，默认0.1(10%)，表示每次扩容时，pod使用率超过1.1倍目标值时才会进行扩容 stabilizationWindowSeconds: 0 # 默认0，即增加或减少pod数量后保持不变的时间，单位为秒 policies: - type: Percent # 扩容速度按百分比限制 value: 100 # 每 15 秒最多扩容 100% 的副本数 periodSeconds: 15 # 每 15 秒计算一次是否可以扩容，默认 15 秒 - type: Pods # 按固定 Pod 数量限制扩容速度 value: 4 # 每 15 秒最多扩容 4 个 Pod periodSeconds: 15 # 同样 15 秒计算一次，默认 15 秒 selectPolicy: Max # 多个 policy 同时存在时，取 Percent 和 Pods 的最大值。Min 取最小值 scaleDown: # ⬇️ 缩容策略 stabilizationWindowSeconds: 300 # 默认 300，即增加或减少pod数量后保持不变的时间，单位为秒，防止快速缩容（平滑策略） policies: - type: Percent # 缩容速度按百分比限制 value: 100 # 每 15 秒最多缩容 100% 的副本数 periodSeconds: 15 # 每 15 秒评估一次是否可以缩容 完整的 HPA 配置文件示例(一般情况下，我们无需修改扩缩容速度的配置，默认策略满足大部分场景) 123456789101112131415161718192021222324252627282930313233343536apiVersion: autoscaling/v2 # api版本，使用 v2 版本支持 behavior 扩缩容策略kind: HorizontalPodAutoscaler # 资源类型为 HPAmetadata: name: hpa-nginx # HPA 资源的名称 namespace: default # 命名空间，设置为 defaultspec: maxReplicas: 10 # HPA 自动扩容的最大副本数 minReplicas: 1 # HPA 自动缩容的最小副本数 metrics: # 自动伸缩的指标配置 - type: Resource # 指标类型为 Resource（资源型） resource: # 资源指标对象 name: cpu # 资源名称为 cpu，也可以设置为 memory target: # 目标指标对象 type: Utilization # 指标类型为 Utilization（利用率百分比） averageUtilization: 50 # CPU 平均使用率达到 50% 时进行扩缩容 scaleTargetRef: # HPA 绑定的目标资源对象 apiVersion: apps/v1 kind: Deployment # 目标类型为 Deployment name: nginx # 目标 Deployment 名称为 nginx behavior: # ⬇️ 扩缩容行为控制 scaleUp: # 扩容策略 stabilizationWindowSeconds: 30 # 扩容平滑窗口为 30 秒，防止短时间抖动频繁扩容 policies: # 扩容速度限制策略 - type: Percent # 按百分比计算 value: 100 # 每 15 秒内最多扩容 100% periodSeconds: 15 # 每 15 秒评估一次扩容速率 - type: Pods # 按固定 Pod 数量计算 value: 4 # 每 15 秒最多扩容 4 个 Pod periodSeconds: 15 # 每 15 秒评估一次扩容速率 selectPolicy: Max # 如果多个 policy 同时满足，取最大值（更激进的扩容） scaleDown: # 缩容策略 stabilizationWindowSeconds: 300 # 缩容平滑窗口为 300 秒（5 分钟），避免短时流量降低快速缩容 policies: # 缩容速度限制策略 - type: Percent # 按百分比缩容 value: 30 # 每 60 秒最多缩容 30% periodSeconds: 60 # 每 60 秒评估一次缩容速率","summary":"摘要 本文介绍 K8S 中的 Horizontal Pod Autoscaler（HPA），本文以 CentOS 8 为例。 K8S官网 Autoscaling k8s简介 Horizontal Pod Autoscaler（HPA）","date_published":"2025-07-20T13:30:05.000Z","tags":["技术","k8s","K8S"]},{"id":"https://blog.hanqunfeng.com/2025/07/19/k8s-ingress-nginx/","url":"https://blog.hanqunfeng.com/2025/07/19/k8s-ingress-nginx/","title":"K8S 之 Ingress Nginx","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 K8S 安装及使用 Ingress Nginx，本文以 CentOS 8 为例。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/\">K8S官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.github.io/ingress-nginx/\">ingress-nginx 官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/\">ingress-nginx k8s简介</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress-controllers/\">k8s支持的 ingress controller</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Ingress-简介\">Ingress 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Ingress 提供从集群外部到集群内服务的 HTTP 和 HTTPS 路由(7层)。 流量路由由 Ingress 资源所定义的规则来控制。</p>\n</li>\n<li class=\"lvl-2\">\n<p>实际上 Ingress-Nginx 内置了 nginx，由 nginx 其负责接收请求并转发给后端服务。</p>\n</li>\n<li class=\"lvl-2\">\n<p>下面是 Ingress 的一个简单示例，可将所有流量都发送到同一 Service<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/jVrIUP.png\" alt=\"\"></p>\n</li>\n</ul>\n<h2 id=\"安装-Ingress-Nginx\">安装 Ingress-Nginx</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>安装时要注意 ingress-nginx 的版本和 Kubernetes 的版本兼容性，参考 Github:<a href=\"https://github.com/kubernetes/ingress-nginx\">ingress-nginx</a>。</p>\n</li>\n<li class=\"lvl-2\">\n<p>获取对应版本的yaml文件</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载最新的 v1.13.0 版本，其支持 Kubernetes 1.33 版本</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> INGRESS_NGINX_VERSION=v1.13.0</span><br><span class=\"line\">curl -L -o ingress-nginx-controller.yaml https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-<span class=\"variable\">$&#123;INGRESS_NGINX_VERSION&#125;</span>/deploy/static/provider/cloud/deploy.yaml</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>安装 ingress-nginx</p>\n</li>\n</ul>\n<blockquote>\n<p>这里要注意，ingress-nginx 的 <code>service/ingress-nginx-controller</code> 默认使用 LoadBalancer 类型，所以需要先使 k8s 集群支持 LoadBalancer 类型，可以参考 <a href=\"/2025/07/18/k8s-service/\" title=\"K8S 之 Service\">K8S 之 Service</a> 中 LoadBalancer 部分。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl apply -f ingress-nginx-controller.yaml</span><br><span class=\"line\">namespace/ingress-nginx created</span><br><span class=\"line\">serviceaccount/ingress-nginx created</span><br><span class=\"line\">serviceaccount/ingress-nginx-admission created</span><br><span class=\"line\">role.rbac.authorization.k8s.io/ingress-nginx created</span><br><span class=\"line\">role.rbac.authorization.k8s.io/ingress-nginx-admission created</span><br><span class=\"line\">clusterrole.rbac.authorization.k8s.io/ingress-nginx created</span><br><span class=\"line\">clusterrole.rbac.authorization.k8s.io/ingress-nginx-admission created</span><br><span class=\"line\">rolebinding.rbac.authorization.k8s.io/ingress-nginx created</span><br><span class=\"line\">rolebinding.rbac.authorization.k8s.io/ingress-nginx-admission created</span><br><span class=\"line\">clusterrolebinding.rbac.authorization.k8s.io/ingress-nginx created</span><br><span class=\"line\">clusterrolebinding.rbac.authorization.k8s.io/ingress-nginx-admission created</span><br><span class=\"line\">configmap/ingress-nginx-controller created</span><br><span class=\"line\">service/ingress-nginx-controller created</span><br><span class=\"line\">service/ingress-nginx-controller-admission created</span><br><span class=\"line\">deployment.apps/ingress-nginx-controller created</span><br><span class=\"line\">job.batch/ingress-nginx-admission-create created</span><br><span class=\"line\">job.batch/ingress-nginx-admission-patch created</span><br><span class=\"line\">ingressclass.networking.k8s.io/nginx created</span><br><span class=\"line\">validatingwebhookconfiguration.admissionregistration.k8s.io/ingress-nginx-admission created</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看ingress-nginx资源</span></span><br><span class=\"line\">$ k get all -n ingress-nginx</span><br><span class=\"line\">NAME                                           READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">pod/ingress-nginx-controller-95f6586c6-nznwq   1/1     Running   0          2m46s</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                                         TYPE           CLUSTER-IP      EXTERNAL-IP     PORT(S)                      AGE</span><br><span class=\"line\">service/ingress-nginx-controller             LoadBalancer   10.96.112.234   10.211.55.201   80:30168/TCP,443:30600/TCP   2m46s</span><br><span class=\"line\">service/ingress-nginx-controller-admission   ClusterIP      10.96.245.155   &lt;none&gt;          443/TCP                      2m46s</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                                       READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class=\"line\">deployment.apps/ingress-nginx-controller   1/1     1            1           2m46s</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                                                 DESIRED   CURRENT   READY   AGE</span><br><span class=\"line\">replicaset.apps/ingress-nginx-controller-95f6586c6   1         1         1       2m46s</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看 IngressClass 资源</span></span><br><span class=\"line\">$ k get ingressclasses.networking.k8s.io</span><br><span class=\"line\">NAME    CONTROLLER             PARAMETERS   AGE</span><br><span class=\"line\">nginx   k8s.io/ingress-nginx   &lt;none&gt;       14m</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建-Ingress-资源\">创建 Ingress 资源</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ingress-demo.yaml</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">networking.k8s.io/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Ingress</span>                   <span class=\"comment\"># Ingress 资源</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">web-ingress</span>             <span class=\"comment\"># Ingress 名称</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">default</span>            <span class=\"comment\"># Ingress 所在的命名空间</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">ingressClassName:</span> <span class=\"string\">nginx</span>       <span class=\"comment\"># Ingress 使用的 IngressClass</span></span><br><span class=\"line\">  <span class=\"attr\">rules:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">host:</span> <span class=\"string\">nginx.hanqunfeng.com</span>  <span class=\"comment\"># 转发域名，支持通配符 *.hanqunfeng.com</span></span><br><span class=\"line\">    <span class=\"attr\">http:</span></span><br><span class=\"line\">      <span class=\"attr\">paths:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">pathType:</span> <span class=\"string\">Prefix</span>        <span class=\"comment\"># 路径匹配规则, 前缀匹配</span></span><br><span class=\"line\">        <span class=\"attr\">path:</span> <span class=\"string\">/</span>                 <span class=\"comment\"># 路径</span></span><br><span class=\"line\">        <span class=\"attr\">backend:</span>                <span class=\"comment\"># 后端服务</span></span><br><span class=\"line\">          <span class=\"attr\">service:</span>              <span class=\"comment\"># 声明后端是一个 service</span></span><br><span class=\"line\">            <span class=\"attr\">name:</span> <span class=\"string\">nginx</span>         <span class=\"comment\"># service名称，提前创建好 service，类型可以是ClusterIP、NodePort、LoadBalancer任意，推荐ClusterIP，因为使用 ingress 的话，就没必要创建其它类型的 service 了</span></span><br><span class=\"line\">            <span class=\"attr\">port:</span>               <span class=\"comment\"># 端口</span></span><br><span class=\"line\">              <span class=\"attr\">number:</span> <span class=\"number\">80</span>        <span class=\"comment\"># service的端口</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看 ingress 资源</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ k get ing -n ns1</span><br><span class=\"line\">NAME          CLASS   HOSTS                  ADDRESS         PORTS   AGE</span><br><span class=\"line\">web-ingress   nginx   nginx.hanqunfeng.com   10.211.55.201   80      80s</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>访问 web-ingress</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将域名 nginx.hanqunfeng.com 解析到 10.211.55.201，如果是内部域名可以通过 hosts 文件添加解析</span></span><br><span class=\"line\"><span class=\"comment\"># 只能通过 nginx.hanqunfeng.com 访问，不能通过 10.211.55.201 访问</span></span><br><span class=\"line\">curl http://nginx.hanqunfeng.com</span><br></pre></td></tr></table></figure>\n<h2 id=\"让-Ingress-支持-HTTPS-访问\">让 Ingress 支持 HTTPS 访问</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建证书，可以在阿里云上申请一个免费的证书</p>\n</li>\n<li class=\"lvl-2\">\n<p>创建 secret</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create secret tls nginx-tls \\</span><br><span class=\"line\">    --key=nginx.hanqunfeng.com.key \\</span><br><span class=\"line\">    --cert=nginx.hanqunfeng.com.pem \\</span><br><span class=\"line\">    -n default</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>也可以通过yaml创建</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Secret</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx-tls</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">default</span></span><br><span class=\"line\"><span class=\"attr\">data:</span></span><br><span class=\"line\">  <span class=\"attr\">tls.crt:</span> <span class=\"string\">base64</span> <span class=\"string\">编码的证书，而非文件路径</span></span><br><span class=\"line\">  <span class=\"attr\">tls.key:</span> <span class=\"string\">base64</span> <span class=\"string\">编码的私钥，而非文件路径</span></span><br><span class=\"line\"><span class=\"attr\">type:</span> <span class=\"string\">kubernetes.io/tls</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>你的 Ingress 资源需要增加 tls 字段，引用一个 Secret 存储的 TLS 证书。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">networking.k8s.io/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Ingress</span>                   <span class=\"comment\"># Ingress 资源</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">web-ingress</span>             <span class=\"comment\"># Ingress 名称</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">default</span>            <span class=\"comment\"># Ingress 所在的命名空间</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">ingressClassName:</span> <span class=\"string\">nginx</span>       <span class=\"comment\"># Ingress 使用的 IngressClass</span></span><br><span class=\"line\">  <span class=\"attr\">tls:</span>                          <span class=\"comment\"># 配置 TLS</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">hosts:</span>                      <span class=\"comment\"># 域名列表</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">nginx.hanqunfeng.com</span>      <span class=\"comment\"># 域名</span></span><br><span class=\"line\">    <span class=\"attr\">secretName:</span> <span class=\"string\">nginx-tls</span>       <span class=\"comment\"># 存放证书的 Secret</span></span><br><span class=\"line\">  <span class=\"attr\">rules:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">host:</span> <span class=\"string\">nginx.hanqunfeng.com</span>  <span class=\"comment\">#转发域名</span></span><br><span class=\"line\">    <span class=\"attr\">http:</span></span><br><span class=\"line\">      <span class=\"attr\">paths:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">pathType:</span> <span class=\"string\">Prefix</span>        <span class=\"comment\"># 路径匹配规则, 前缀匹配</span></span><br><span class=\"line\">        <span class=\"attr\">path:</span> <span class=\"string\">/</span>                 <span class=\"comment\"># 路径</span></span><br><span class=\"line\">        <span class=\"attr\">backend:</span>                <span class=\"comment\"># 后端服务</span></span><br><span class=\"line\">          <span class=\"attr\">service:</span>              <span class=\"comment\"># service</span></span><br><span class=\"line\">            <span class=\"attr\">name:</span> <span class=\"string\">nginx</span>         <span class=\"comment\"># service名称</span></span><br><span class=\"line\">            <span class=\"attr\">port:</span>               <span class=\"comment\"># 端口</span></span><br><span class=\"line\">              <span class=\"attr\">number:</span> <span class=\"number\">80</span>        <span class=\"comment\"># service的端口</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 重新运行ingress</span></span><br><span class=\"line\">k apply -f nginx-ingress.yaml</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看ingress，此时多了一个 443 端口</span></span><br><span class=\"line\">$ k get ing</span><br><span class=\"line\">NAME          CLASS   HOSTS                  ADDRESS         PORTS     AGE</span><br><span class=\"line\">web-ingress   nginx   nginx.hanqunfeng.com   10.211.55.201   80, 443   51s</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 访问https，但此时 80 端口访问不了，需要配置 80 端口重定向到 443</span></span><br><span class=\"line\">curl https://nginx.hanqunfeng.com</span><br></pre></td></tr></table></figure>\n<h2 id=\"80端口重定向到443\">80端口重定向到443</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>nginx ingress controller</code>，它内置支持重定向，你可以在 Ingress 上添加 annotation</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">annotations:</span></span><br><span class=\"line\">    <span class=\"attr\">nginx.ingress.kubernetes.io/force-ssl-redirect:</span> <span class=\"string\">&quot;true&quot;</span>  <span class=\"comment\"># 80 重定向到 443</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>完整的yaml</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">networking.k8s.io/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Ingress</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">web-ingress</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">default</span></span><br><span class=\"line\">  <span class=\"attr\">annotations:</span></span><br><span class=\"line\">    <span class=\"attr\">nginx.ingress.kubernetes.io/force-ssl-redirect:</span> <span class=\"string\">&quot;true&quot;</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">ingressClassName:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">  <span class=\"attr\">tls:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">hosts:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">nginx.hanqunfeng.com</span></span><br><span class=\"line\">    <span class=\"attr\">secretName:</span> <span class=\"string\">nginx-tls</span></span><br><span class=\"line\">  <span class=\"attr\">rules:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">host:</span> <span class=\"string\">nginx.hanqunfeng.com</span></span><br><span class=\"line\">    <span class=\"attr\">http:</span></span><br><span class=\"line\">      <span class=\"attr\">paths:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">pathType:</span> <span class=\"string\">Prefix</span></span><br><span class=\"line\">        <span class=\"attr\">path:</span> <span class=\"string\">/</span></span><br><span class=\"line\">        <span class=\"attr\">backend:</span></span><br><span class=\"line\">          <span class=\"attr\">service:</span></span><br><span class=\"line\">            <span class=\"attr\">name:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">            <span class=\"attr\">port:</span></span><br><span class=\"line\">              <span class=\"attr\">number:</span> <span class=\"number\">80</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>访问测试</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 重新运行ingress</span></span><br><span class=\"line\">k apply -f nginx-ingress.yaml</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 默认情况下 curl 不会自动跳转，使用浏览器访问会自动重定向，308 表示永久重定向</span></span><br><span class=\"line\">$ curl http://nginx.hanqunfeng.com</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;<span class=\"built_in\">head</span>&gt;&lt;title&gt;308 Permanent Redirect&lt;/title&gt;&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;center&gt;&lt;h1&gt;308 Permanent Redirect&lt;/h1&gt;&lt;/center&gt;</span><br><span class=\"line\">&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加 -L 参数，curl 会自动跳转</span></span><br><span class=\"line\">$ curl -L http://nginx.hanqunfeng.com</span><br><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;<span class=\"built_in\">head</span>&gt;</span><br><span class=\"line\">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">html &#123; color-scheme: light dark; &#125;</span><br><span class=\"line\">body &#123; width: 35em; margin: 0 auto;</span><br><span class=\"line\">font-family: Tahoma, Verdana, Arial, sans-serif; &#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class=\"line\">&lt;p&gt;If you see this page, the nginx web server is successfully installed and</span><br><span class=\"line\">working. Further configuration is required.&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;p&gt;For online documentation and support please refer to</span><br><span class=\"line\">&lt;a href=<span class=\"string\">&quot;http://nginx.org/&quot;</span>&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</span><br><span class=\"line\">Commercial support is available at</span><br><span class=\"line\">&lt;a href=<span class=\"string\">&quot;http://nginx.com/&quot;</span>&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;p&gt;&lt;em&gt;Thank you <span class=\"keyword\">for</span> using nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"后记\">后记</h2>\n<h3 id=\"ssl-证书过期怎么办？\">ssl 证书过期怎么办？</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># apply 会直接更新 Secret，而不是删除重建</span></span><br><span class=\"line\">kubectl create secret tls nginx-tls \\</span><br><span class=\"line\">    --key=新的.key \\</span><br><span class=\"line\">    --cert=新的.pem \\</span><br><span class=\"line\">    -n default --dry-run=client -o yaml | kubectl apply -f -</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Ingress Controller（如 nginx-ingress）通常会自动监听 Secret 变化，大概 30 秒 ~ 1 分钟内自动热加载新证书，无需重启 Pod。</p>\n</li>\n</ul>\n<h3 id=\"pathType-可以设置哪些值？\">pathType 可以设置哪些值？</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 Kubernetes Ingress 的 pathType 字段中，一共可以设置以下三种值</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>pathType 值</strong></th>\n<th><strong>含义</strong></th>\n<th><strong>匹配规则说明</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Exact</strong></td>\n<td>精确匹配</td>\n<td>路径必须<strong>完全匹配</strong></td>\n</tr>\n<tr>\n<td><strong>Prefix</strong></td>\n<td>前缀匹配</td>\n<td>以指定路径为<strong>前缀</strong>即可匹配</td>\n</tr>\n<tr>\n<td><strong>ImplementationSpecific</strong></td>\n<td>由 Ingress Controller 自己决定</td>\n<td>nginx 常常表现为前缀匹配</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Exact 精确匹配，且区分大小写</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 只匹配 http://example.com/foo</span></span><br><span class=\"line\"><span class=\"comment\"># 不会匹配 /foo/abc 或 /foo/</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">pathType:</span> <span class=\"string\">Exact</span></span><br><span class=\"line\">  <span class=\"attr\">path:</span> <span class=\"string\">/foo</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Prefix 前缀匹配，且区分大小写</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 匹配所有以 /foo 开头的路径：</span></span><br><span class=\"line\"><span class=\"comment\">#   /foo</span></span><br><span class=\"line\"><span class=\"comment\">#   /foo/   # 会忽略尾部的 /</span></span><br><span class=\"line\"><span class=\"comment\">#   /foo/abc</span></span><br><span class=\"line\"><span class=\"comment\">#   /foo/bar/test</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">pathType:</span> <span class=\"string\">Prefix</span></span><br><span class=\"line\">  <span class=\"attr\">path:</span> <span class=\"string\">/foo</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ImplementationSpecific 控制器自定义（不推荐）</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 匹配规则由 Ingress Controller 决定；</span></span><br><span class=\"line\"><span class=\"comment\"># 在 nginx-ingress 中通常行为类似于 Prefix，但不保证兼容性；</span></span><br><span class=\"line\"><span class=\"comment\"># Kubernetes 官方不推荐生产使用，建议显式使用 Prefix 或 Exact。</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">pathType:</span> <span class=\"string\">ImplementationSpecific</span></span><br><span class=\"line\">  <span class=\"attr\">path:</span> <span class=\"string\">/foo</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"设置缺省的-ingressclass\">设置缺省的 ingressclass</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>我们可以设置一个缺省的 ingressclass 为默认值，这样，当创建ingress时，如果未指定ingressclass，则使用缺省值</p>\n</li>\n<li class=\"lvl-2\">\n<p>可以通过 kubectl patch 为 ingressclass 直接打上默认标识(通过 k edit ingressclass ingressclass-name 为其添加注解也可以)</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看 ingressclasses</span></span><br><span class=\"line\">$ k get ingressclasses</span><br><span class=\"line\">NAME    CONTROLLER             PARAMETERS   AGE</span><br><span class=\"line\">nginx   k8s.io/ingress-nginx   &lt;none&gt;       3h3m</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置 nginx 为默认 ingressclass，就是为其加上如下注解</span></span><br><span class=\"line\">$ kubectl patch ingressclass nginx -p <span class=\"string\">&#x27;&#123;&quot;metadata&quot;: &#123;&quot;annotations&quot;:&#123;&quot;ingressclass.kubernetes.io/is-default-class&quot;:&quot;true&quot;&#125;&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"ingerss-nginx-应用示例\">ingerss-nginx 应用示例</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>同一域名不同路径<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/s1XbqM.png\" alt=\"\"></p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">networking.k8s.io/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Ingress</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">simple-fanout-example</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span>                       <span class=\"comment\"># 未指定 ingressClassName ,则使用 上文中设置的默认 ingressClassName</span></span><br><span class=\"line\">  <span class=\"attr\">rules:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">host:</span> <span class=\"string\">foo.bar.com</span></span><br><span class=\"line\">    <span class=\"attr\">http:</span></span><br><span class=\"line\">      <span class=\"attr\">paths:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">path:</span> <span class=\"string\">/foo</span></span><br><span class=\"line\">        <span class=\"attr\">pathType:</span> <span class=\"string\">Prefix</span></span><br><span class=\"line\">        <span class=\"attr\">backend:</span></span><br><span class=\"line\">          <span class=\"attr\">service:</span></span><br><span class=\"line\">            <span class=\"attr\">name:</span> <span class=\"string\">service1</span></span><br><span class=\"line\">            <span class=\"attr\">port:</span></span><br><span class=\"line\">              <span class=\"attr\">number:</span> <span class=\"number\">4200</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">path:</span> <span class=\"string\">/bar</span></span><br><span class=\"line\">        <span class=\"attr\">pathType:</span> <span class=\"string\">Prefix</span></span><br><span class=\"line\">        <span class=\"attr\">backend:</span></span><br><span class=\"line\">          <span class=\"attr\">service:</span></span><br><span class=\"line\">            <span class=\"attr\">name:</span> <span class=\"string\">service2</span></span><br><span class=\"line\">            <span class=\"attr\">port:</span></span><br><span class=\"line\">              <span class=\"attr\">number:</span> <span class=\"number\">8080</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>不同域名的服务<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/sBhmbR.png\" alt=\"\"></p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">networking.k8s.io/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Ingress</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">name-virtual-host-ingress</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">rules:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">host:</span> <span class=\"string\">foo.bar.com</span></span><br><span class=\"line\">    <span class=\"attr\">http:</span></span><br><span class=\"line\">      <span class=\"attr\">paths:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">pathType:</span> <span class=\"string\">Prefix</span></span><br><span class=\"line\">        <span class=\"attr\">path:</span> <span class=\"string\">&quot;/&quot;</span></span><br><span class=\"line\">        <span class=\"attr\">backend:</span></span><br><span class=\"line\">          <span class=\"attr\">service:</span></span><br><span class=\"line\">            <span class=\"attr\">name:</span> <span class=\"string\">service1</span></span><br><span class=\"line\">            <span class=\"attr\">port:</span></span><br><span class=\"line\">              <span class=\"attr\">number:</span> <span class=\"number\">80</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">host:</span> <span class=\"string\">bar.foo.com</span></span><br><span class=\"line\">    <span class=\"attr\">http:</span></span><br><span class=\"line\">      <span class=\"attr\">paths:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">pathType:</span> <span class=\"string\">Prefix</span></span><br><span class=\"line\">        <span class=\"attr\">path:</span> <span class=\"string\">&quot;/&quot;</span></span><br><span class=\"line\">        <span class=\"attr\">backend:</span></span><br><span class=\"line\">          <span class=\"attr\">service:</span></span><br><span class=\"line\">            <span class=\"attr\">name:</span> <span class=\"string\">service2</span></span><br><span class=\"line\">            <span class=\"attr\">port:</span></span><br><span class=\"line\">              <span class=\"attr\">number:</span> <span class=\"number\">80</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>通过如下命令对 ingress 进行修改，修改保存(:wq)后会立刻生效</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl edit ingress web-ingress</span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍 K8S 安装及使用 Ingress Nginx，本文以 CentOS 8 为例。 K8S官网 ingress-nginx 官网 ingress-nginx k8s简介 k8s支持的 ingress controller Ingress 简介 Ingress 提供从集群外部到集群内服务的 HTTP 和 HTTPS 路由(7层)。 流量路由由 Ingress 资源所定义的规则来控制。 实际上 Ingress-Nginx 内置了 nginx，由 nginx 其负责接收请求并转发给后端服务。 下面是 Ingress 的一个简单示例，可将所有流量都发送到同一 Service 安装 Ingress-Nginx 安装时要注意 ingress-nginx 的版本和 Kubernetes 的版本兼容性，参考 Github:ingress-nginx。 获取对应版本的yaml文件 123# 下载最新的 v1.13.0 版本，其支持 Kubernetes 1.33 版本export INGRESS_NGINX_VERSION=v1.13.0curl -L -o ingress-nginx-controller.yaml https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-$&#123;INGRESS_NGINX_VERSION&#125;/deploy/static/provider/cloud/deploy.yaml 安装 ingress-nginx 这里要注意，ingress-nginx 的 service/ingress-nginx-controller 默认使用 LoadBalancer 类型，所以需要先使 k8s 集群支持 LoadBalancer 类型，可以参考 K8S 之 Service 中 LoadBalancer 部分。 12345678910111213141516171819202122232425262728293031323334353637383940$ kubectl apply -f ingress-nginx-controller.yamlnamespace/ingress-nginx createdserviceaccount/ingress-nginx createdserviceaccount/ingress-nginx-admission createdrole.rbac.authorization.k8s.io/ingress-nginx createdrole.rbac.authorization.k8s.io/ingress-nginx-admission createdclusterrole.rbac.authorization.k8s.io/ingress-nginx createdclusterrole.rbac.authorization.k8s.io/ingress-nginx-admission createdrolebinding.rbac.authorization.k8s.io/ingress-nginx createdrolebinding.rbac.authorization.k8s.io/ingress-nginx-admission createdclusterrolebinding.rbac.authorization.k8s.io/ingress-nginx createdclusterrolebinding.rbac.authorization.k8s.io/ingress-nginx-admission createdconfigmap/ingress-nginx-controller createdservice/ingress-nginx-controller createdservice/ingress-nginx-controller-admission createddeployment.apps/ingress-nginx-controller createdjob.batch/ingress-nginx-admission-create createdjob.batch/ingress-nginx-admission-patch createdingressclass.networking.k8s.io/nginx createdvalidatingwebhookconfiguration.admissionregistration.k8s.io/ingress-nginx-admission created# 查看ingress-nginx资源$ k get all -n ingress-nginxNAME READY STATUS RESTARTS AGEpod/ingress-nginx-controller-95f6586c6-nznwq 1/1 Running 0 2m46sNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEservice/ingress-nginx-controller LoadBalancer 10.96.112.234 10.211.55.201 80:30168/TCP,443:30600/TCP 2m46sservice/ingress-nginx-controller-admission ClusterIP 10.96.245.155 &lt;none&gt; 443/TCP 2m46sNAME READY UP-TO-DATE AVAILABLE AGEdeployment.apps/ingress-nginx-controller 1/1 1 1 2m46sNAME DESIRED CURRENT READY AGEreplicaset.apps/ingress-nginx-controller-95f6586c6 1 1 1 2m46s# 查看 IngressClass 资源$ k get ingressclasses.networking.k8s.ioNAME CONTROLLER PARAMETERS AGEnginx k8s.io/ingress-nginx &lt;none&gt; 14m 创建 Ingress 资源 ingress-demo.yaml 123456789101112131415161718apiVersion: networking.k8s.io/v1kind: Ingress # Ingress 资源metadata: name: web-ingress # Ingress 名称 namespace: default # Ingress 所在的命名空间spec: ingressClassName: nginx # Ingress 使用的 IngressClass rules: - host: nginx.hanqunfeng.com # 转发域名，支持通配符 *.hanqunfeng.com http: paths: - pathType: Prefix # 路径匹配规则, 前缀匹配 path: / # 路径 backend: # 后端服务 service: # 声明后端是一个 service name: nginx # service名称，提前创建好 service，类型可以是ClusterIP、NodePort、LoadBalancer任意，推荐ClusterIP，因为使用 ingress 的话，就没必要创建其它类型的 service 了 port: # 端口 number: 80 # service的端口 查看 ingress 资源 123$ k get ing -n ns1NAME CLASS HOSTS ADDRESS PORTS AGEweb-ingress nginx nginx.hanqunfeng.com 10.211.55.201 80 80s 访问 web-ingress 123# 将域名 nginx.hanqunfeng.com 解析到 10.211.55.201，如果是内部域名可以通过 hosts 文件添加解析# 只能通过 nginx.hanqunfeng.com 访问，不能通过 10.211.55.201 访问curl http://nginx.hanqunfeng.com 让 Ingress 支持 HTTPS 访问 创建证书，可以在阿里云上申请一个免费的证书 创建 secret 1234kubectl create secret tls nginx-tls \\ --key=nginx.hanqunfeng.com.key \\ --cert=nginx.hanqunfeng.com.pem \\ -n default 也可以通过yaml创建 123456789apiVersion: v1kind: Secretmetadata: name: nginx-tls namespace: defaultdata: tls.crt: base64 编码的证书，而非文件路径 tls.key: base64 编码的私钥，而非文件路径type: kubernetes.io/tls 你的 Ingress 资源需要增加 tls 字段，引用一个 Secret 存储的 TLS 证书。 12345678910111213141516171819202122apiVersion: networking.k8s.io/v1kind: Ingress # Ingress 资源metadata: name: web-ingress # Ingress 名称 namespace: default # Ingress 所在的命名空间spec: ingressClassName: nginx # Ingress 使用的 IngressClass tls: # 配置 TLS - hosts: # 域名列表 - nginx.hanqunfeng.com # 域名 secretName: nginx-tls # 存放证书的 Secret rules: - host: nginx.hanqunfeng.com #转发域名 http: paths: - pathType: Prefix # 路径匹配规则, 前缀匹配 path: / # 路径 backend: # 后端服务 service: # service name: nginx # service名称 port: # 端口 number: 80 # service的端口 12345678910# 重新运行ingressk apply -f nginx-ingress.yaml# 查看ingress，此时多了一个 443 端口$ k get ingNAME CLASS HOSTS ADDRESS PORTS AGEweb-ingress nginx nginx.hanqunfeng.com 10.211.55.201 80, 443 51s# 访问https，但此时 80 端口访问不了，需要配置 80 端口重定向到 443curl https://nginx.hanqunfeng.com 80端口重定向到443 nginx ingress controller，它内置支持重定向，你可以在 Ingress 上添加 annotation 123metadata: annotations: nginx.ingress.kubernetes.io/force-ssl-redirect: &quot;true&quot; # 80 重定向到 443 完整的yaml 123456789101112131415161718192021222324apiVersion: networking.k8s.io/v1kind: Ingressmetadata: name: web-ingress namespace: default annotations: nginx.ingress.kubernetes.io/force-ssl-redirect: &quot;true&quot;spec: ingressClassName: nginx tls: - hosts: - nginx.hanqunfeng.com secretName: nginx-tls rules: - host: nginx.hanqunfeng.com http: paths: - pathType: Prefix path: / backend: service: name: nginx port: number: 80 访问测试 1234567891011121314151617181920212223242526272829303132333435363738# 重新运行ingressk apply -f nginx-ingress.yaml# 默认情况下 curl 不会自动跳转，使用浏览器访问会自动重定向，308 表示永久重定向$ curl http://nginx.hanqunfeng.com&lt;html&gt;&lt;head&gt;&lt;title&gt;308 Permanent Redirect&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;&lt;h1&gt;308 Permanent Redirect&lt;/h1&gt;&lt;/center&gt;&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;# 添加 -L 参数，curl 会自动跳转$ curl -L http://nginx.hanqunfeng.com&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;style&gt;html &#123; color-scheme: light dark; &#125;body &#123; width: 35em; margin: 0 auto;font-family: Tahoma, Verdana, Arial, sans-serif; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&lt;p&gt;If you see this page, the nginx web server is successfully installed andworking. Further configuration is required.&lt;/p&gt;&lt;p&gt;For online documentation and support please refer to&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;Commercial support is available at&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 后记 ssl 证书过期怎么办？ 12345# apply 会直接更新 Secret，而不是删除重建kubectl create secret tls nginx-tls \\ --key=新的.key \\ --cert=新的.pem \\ -n default --dry-run=client -o yaml | kubectl apply -f - Ingress Controller（如 nginx-ingress）通常会自动监听 Secret 变化，大概 30 秒 ~ 1 分钟内自动热加载新证书，无需重启 Pod。 pathType 可以设置哪些值？ 在 Kubernetes Ingress 的 pathType 字段中，一共可以设置以下三种值 pathType 值 含义 匹配规则说明 Exact 精确匹配 路径必须完全匹配 Prefix 前缀匹配 以指定路径为前缀即可匹配 ImplementationSpecific 由 Ingress Controller 自己决定 nginx 常常表现为前缀匹配 Exact 精确匹配，且区分大小写 1234# 只匹配 http://example.com/foo# 不会匹配 /foo/abc 或 /foo/- pathType: Exact path: /foo Prefix 前缀匹配，且区分大小写 1234567# 匹配所有以 /foo 开头的路径：# /foo# /foo/ # 会忽略尾部的 /# /foo/abc# /foo/bar/test- pathType: Prefix path: /foo ImplementationSpecific 控制器自定义（不推荐） 12345# 匹配规则由 Ingress Controller 决定；# 在 nginx-ingress 中通常行为类似于 Prefix，但不保证兼容性；# Kubernetes 官方不推荐生产使用，建议显式使用 Prefix 或 Exact。- pathType: ImplementationSpecific path: /foo 设置缺省的 ingressclass 我们可以设置一个缺省的 ingressclass 为默认值，这样，当创建ingress时，如果未指定ingressclass，则使用缺省值 可以通过 kubectl patch 为 ingressclass 直接打上默认标识(通过 k edit ingressclass ingressclass-name 为其添加注解也可以) 1234567# 查看 ingressclasses$ k get ingressclassesNAME CONTROLLER PARAMETERS AGEnginx k8s.io/ingress-nginx &lt;none&gt; 3h3m# 设置 nginx 为默认 ingressclass，就是为其加上如下注解$ kubectl patch ingressclass nginx -p &#x27;&#123;&quot;metadata&quot;: &#123;&quot;annotations&quot;:&#123;&quot;ingressclass.kubernetes.io/is-default-class&quot;:&quot;true&quot;&#125;&#125;&#125;&#x27; ingerss-nginx 应用示例 同一域名不同路径 1234567891011121314151617181920212223apiVersion: networking.k8s.io/v1kind: Ingressmetadata: name: simple-fanout-examplespec: # 未指定 ingressClassName ,则使用 上文中设置的默认 ingressClassName rules: - host: foo.bar.com http: paths: - path: /foo pathType: Prefix backend: service: name: service1 port: number: 4200 - path: /bar pathType: Prefix backend: service: name: service2 port: number: 8080 不同域名的服务 1234567891011121314151617181920212223242526apiVersion: networking.k8s.io/v1kind: Ingressmetadata: name: name-virtual-host-ingressspec: rules: - host: foo.bar.com http: paths: - pathType: Prefix path: &quot;/&quot; backend: service: name: service1 port: number: 80 - host: bar.foo.com http: paths: - pathType: Prefix path: &quot;/&quot; backend: service: name: service2 port: number: 80 通过如下命令对 ingress 进行修改，修改保存(:wq)后会立刻生效 1kubectl edit ingress web-ingress","summary":"摘要 本文介绍 K8S 安装及使用 Ingress Nginx，本文以 CentOS 8 为例。 K8S官网 ingress-nginx 官网 ingress-nginx k8s简介 k8s支持的 ingress controller","date_published":"2025-07-19T13:30:05.000Z","tags":["技术","k8s","K8S"]},{"id":"https://blog.hanqunfeng.com/2025/07/18/k8s-service/","url":"https://blog.hanqunfeng.com/2025/07/18/k8s-service/","title":"K8S 之 Service","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 K8S 的 Service ，本文以 CentOS 8 为例。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/\">K8S官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/kubernetes/kubernetes\">k8s Github</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/\">k8s Service 介绍</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Service-介绍\">Service 介绍</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Service是一个抽象层，它定义了一组Pod的逻辑集，并为这些Pod支持外部流量暴露、负载均衡和服务发现。</p>\n</li>\n<li class=\"lvl-2\">\n<p>尽管每个Pod 都有一个唯一的IP地址，但是如果没有Service，这些IP不会暴露在群集外部。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Service允许您的应用程序接收流量。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Service也可以用在ServiceSpec标记type的方式暴露，type类型如下：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">ClusterIP（默认）：在集群的内部IP上公开Service。这种类型使得Service只能从集群内访问。</li>\n<li class=\"lvl-4\">NodePort：使用NAT在集群中每个选定Node的相同端口上公开Service。使用 <NodeIP>:<NodePort> 从集群外部访问Service。是ClusterIP的超集。</li>\n<li class=\"lvl-4\">LoadBalancer：在当前云中创建一个外部负载均衡器(如果支持的话)，并为Service分配一个固定的外部IP。是NodePort的超集。</li>\n<li class=\"lvl-4\">ExternalName：通过返回带有该名称的CNAME记录，使用任意名称（由spec中的externalName指定）公开Service。不使用代理。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"创建Service\">创建Service</h2>\n<h3 id=\"ClusterIP\">ClusterIP</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>只能在集群内部访问</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 先创建deployment，此时会为每个pod添加一个label app=nginx</span></span><br><span class=\"line\">kubectl create deployment nginx --image=nginx --replicas=2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建service，，将deployment的pod暴露出来，暴露类型为ClusterIP</span></span><br><span class=\"line\">kubectl expose deployment nginx --<span class=\"built_in\">type</span>=ClusterIP --port=80</span><br><span class=\"line\">$ kubectl get svc nginx</span><br><span class=\"line\">NAME    TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)   AGE</span><br><span class=\"line\">nginx   ClusterIP   10.96.14.90   &lt;none&gt;        80/TCP    60s</span><br></pre></td></tr></table></figure>\n<h3 id=\"NodePort\">NodePort</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>暴露宿主机的端口，供外部访问</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建service，将deployment的pod暴露出来，暴露类型为NodePort</span></span><br><span class=\"line\">kubectl expose deployment nginx --<span class=\"built_in\">type</span>=NodePort --port=80</span><br><span class=\"line\"><span class=\"comment\"># 查看service，此时可以看到service的端口和节点的端口，与 ClusterIP 的区别就是是否暴露在节点上的端口</span></span><br><span class=\"line\">$ kubectl get svc nginx</span><br><span class=\"line\">NAME    TYPE       CLUSTER-IP   EXTERNAL-IP   PORT(S)        AGE</span><br><span class=\"line\">nginx   NodePort   10.96.7.8    &lt;none&gt;        80:32691/TCP   31s</span><br></pre></td></tr></table></figure>\n<h3 id=\"yaml文件创建service\">yaml文件创建service</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>yaml文件格式</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span>      <span class=\"comment\"># api版本</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span>       <span class=\"comment\"># 资源类型</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span>           <span class=\"comment\"># 元数据</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx</span>       <span class=\"comment\"># service名称</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span>               <span class=\"comment\"># 配置</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span>            <span class=\"comment\"># 端口</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">80</span>        <span class=\"comment\"># 集群内访问端口，service的端口，一般配置为与 targetPort 一致，但是非必须</span></span><br><span class=\"line\">    <span class=\"attr\">protocol:</span> <span class=\"string\">TCP</span>   <span class=\"comment\"># 协议</span></span><br><span class=\"line\">    <span class=\"attr\">targetPort:</span> <span class=\"number\">80</span>  <span class=\"comment\"># 容器端口, pod的端口，这个必须与实际容器端口一致</span></span><br><span class=\"line\">    <span class=\"attr\">nodePort:</span> <span class=\"number\">30080</span> <span class=\"comment\"># node暴露的端口，service类型为 NodePort 时使用，默认范围在 30000-32767 之间</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span>         <span class=\"comment\"># 选择器</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">nginx</span>      <span class=\"comment\"># pod的标签，即匹配pod的标签 app=nginx</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">NodePort</span>    <span class=\"comment\"># service类型</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里有个问题需要注意，service 默认是通过<code>标签</code>来匹配pod的，所以创建service的时候，一定要保证pod的标签是存在的，否则service无法匹配pod，另外虽然我们通过命令行创建service时是通过<code>kubectl expose deployment nginx --type=NodePort --port=80</code>创建的，但也并不表示service只会匹配这个deployment创建的pod，而是会匹配所有具有指定标签的pod（app=nginx）。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取service的 selector</span></span><br><span class=\"line\">$ k get svc -owide</span><br><span class=\"line\">NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)        AGE    SELECTOR</span><br><span class=\"line\">kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP        4d5h   &lt;none&gt;</span><br><span class=\"line\">nginx        NodePort    10.96.9.77   &lt;none&gt;        80:30080/TCP   8s     app=nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 这里有个名称为 kubernetes 的 service，其作用是为了方便集群内部的 Pod 调用 API Server 的统一入口</span></span><br><span class=\"line\"><span class=\"comment\"># 无论 API Server 实际运行在哪个节点哪个 IP，集群内部只要访问如下地址就能访问 API Server。</span></span><br><span class=\"line\"><span class=\"comment\"># https://kubernetes.default.svc</span></span><br><span class=\"line\"><span class=\"comment\"># 或者</span></span><br><span class=\"line\"><span class=\"comment\"># https://10.96.0.1</span></span><br><span class=\"line\"><span class=\"comment\"># 这个 Service 是 系统自带的，不建议删除或修改。</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"ExternalName\">ExternalName</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>可以将其它 namespace 的 service 别名到 当前 namespace，这样访问 service 时就不需要加上命名空间名称了</p>\n</li>\n<li class=\"lvl-2\">\n<p>ExternalName Service 是纯 DNS CNAME 映射，我们不经可以映射集群内容服务，也可以映射集群外部服务。</p>\n</li>\n<li class=\"lvl-2\">\n<p>原先的 service 访问方式：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在不同命名空间下创建service</span></span><br><span class=\"line\"><span class=\"comment\"># 创建两个命名空间以及下面的资源</span></span><br><span class=\"line\"><span class=\"comment\">## ns1</span></span><br><span class=\"line\">kubectl create namespace ns1</span><br><span class=\"line\">kubectl create deployment alpine-demo -n ns1 --image=alpine/curl --replicas=1 -- /bin/sh -c <span class=\"string\">&quot;sleep infinity&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## ns2</span></span><br><span class=\"line\">kubectl create namespace ns2</span><br><span class=\"line\">kubectl create deployment nginx-demo -n ns2 --image=nginx --replicas=1</span><br><span class=\"line\">kubectl expose deployment nginx-demo -n ns2 --<span class=\"built_in\">type</span>=ClusterIP --port=80 --name=nginx-service</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 进入 ns1 中的 pod 访问 ns2 中的 nginx-service</span></span><br><span class=\"line\">kubectl <span class=\"built_in\">exec</span> -it -n ns1 alpine-demo-66895487c8-sk4t4 -- /bin/sh</span><br><span class=\"line\">curl nginx-service.ns2.svc.cluster.local</span><br><span class=\"line\">curl nginx-service.ns2</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ExternalName 访问</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在 ns1 中创建 externalName 类型的 service，--external-name 指定 ns2 中的 nginx-service</span></span><br><span class=\"line\">kubectl create service externalname nginx-service -n ns1 --external-name=nginx-service.ns2.svc.cluster.local</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>也可以通过 yaml 创建</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx-service</span>                               <span class=\"comment\"># service 名称</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">ns1</span>                                    <span class=\"comment\"># 指定命名空间 为 ns1</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">externalName:</span> <span class=\"string\">nginx-service.ns2.svc.cluster.local</span> <span class=\"comment\"># 指定外部服务名，比如 www.baidu.com</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">ExternalName</span>                                <span class=\"comment\"># 指定为 ExternalName 类型</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span>                                         <span class=\"comment\"># 不需要配置 selector</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">nginx-service</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看 service</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ k get svc -n ns1</span><br><span class=\"line\">NAME            TYPE           CLUSTER-IP   EXTERNAL-IP                           PORT(S)   AGE</span><br><span class=\"line\">nginx-service   ExternalName   &lt;none&gt;       nginx-service.ns2.svc.cluster.local   &lt;none&gt;    16s</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时再次进入 ns1 中的 pod 访问 ns2 中的 nginx-service 服务</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl <span class=\"built_in\">exec</span> -it -n ns1 alpine-demo-66895487c8-sk4t4 -- /bin/sh</span><br><span class=\"line\"><span class=\"comment\"># 此时就不需要加上 ns2 的 namespace 了</span></span><br><span class=\"line\">curl nginx-service</span><br></pre></td></tr></table></figure>\n<h3 id=\"LoadBalancer\">LoadBalancer</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>LoadBalancer 是 Kubernetes Service 的一种类型，用于自动申请一个云厂商的负载均衡器（如 AWS ELB、GCP LB、阿里云 SLB），将外部流量转发到 Kubernetes 集群内部的 Pod 上。</p>\n</li>\n<li class=\"lvl-2\">\n<p>在私有云上，需要借助第三方负载均衡器来实现，比如 <a href=\"https://metallb.io\">MetalLB</a>，<a href=\"https://github.com/metallb/metallb\">github</a></p>\n</li>\n</ul>\n<h4 id=\"安装-MetallB\">安装 MetallB</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果您在IPVS模式下使用kube代理，从Kubernetes v1.14.2开始，您必须启用严格的ARP模式。请注意，如果您使用kube-router作为服务代理，则不需要这个，因为它默认启用了严格的ARP。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看将要产生的变更，如果有变更则返回非零状态码</span></span><br><span class=\"line\">kubectl get configmap kube-proxy -n kube-system -o yaml | \\</span><br><span class=\"line\">sed -e <span class=\"string\">&quot;s/strictARP: false/strictARP: true/&quot;</span> | \\</span><br><span class=\"line\">kubectl diff -f - -n kube-system</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 实际应用变更，只有发生错误时才返回非零状态码</span></span><br><span class=\"line\">kubectl get configmap kube-proxy -n kube-system -o yaml | \\</span><br><span class=\"line\">sed -e <span class=\"string\">&quot;s/strictARP: false/strictARP: true/&quot;</span> | \\</span><br><span class=\"line\">kubectl apply -f - -n kube-system</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>安装MetalLB</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> METLB_VERSION=v0.15.2</span><br><span class=\"line\">curl -L -o metallb.yaml https://raw.githubusercontent.com/metallb/metallb/<span class=\"variable\">$&#123;METLB_VERSION&#125;</span>/config/manifests/metallb-native.yaml</span><br><span class=\"line\">kubectl apply -f metallb.yaml</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看MetalLB资源</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ k get all -n metallb-system -owide</span><br><span class=\"line\">NAME                              READY   STATUS    RESTARTS      AGE     IP               NODE          NOMINATED NODE   READINESS GATES</span><br><span class=\"line\">pod/controller-58fdf44d87-bsp4z   1/1     Running   0             4m13s   10.244.194.104   k8s-worker1   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">pod/speaker-sjvq5                 1/1     Running   0             4m13s   10.211.55.15     k8s-worker1   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">pod/speaker-srpp4                 1/1     Running   0             4m13s   10.211.55.16     k8s-worker2   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">pod/speaker-tbnls                 1/1     Running   2 (98s ago)   4m13s   10.211.55.11     k8s-master    &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                              TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)   AGE     SELECTOR</span><br><span class=\"line\">service/metallb-webhook-service   ClusterIP   10.96.233.8   &lt;none&gt;        443/TCP   4m14s   component=controller</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                     DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR            AGE     CONTAINERS   IMAGES                            SELECTOR</span><br><span class=\"line\">daemonset.apps/speaker   3         3         3       3            3           kubernetes.io/os=linux   4m13s   speaker      quay.io/metallb/speaker:v0.15.2   app=metallb,component=speaker</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                         READY   UP-TO-DATE   AVAILABLE   AGE     CONTAINERS   IMAGES                               SELECTOR</span><br><span class=\"line\">deployment.apps/controller   1/1     1            1           4m14s   controller   quay.io/metallb/controller:v0.15.2   app=metallb,component=controller</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                                    DESIRED   CURRENT   READY   AGE     CONTAINERS   IMAGES                               SELECTOR</span><br><span class=\"line\">replicaset.apps/controller-58fdf44d87   1         1         1       4m13s   controller   quay.io/metallb/controller:v0.15.2   app=metallb,component=controller,pod-template-hash=58fdf44d87</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>配置地址池:metallb-pool.yaml</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">metallb.io/v1beta1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">IPAddressPool</span>                 <span class=\"comment\"># 地址池类型</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">metallb-pool</span>                <span class=\"comment\"># 地址池名称</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">metallb-system</span>         <span class=\"comment\"># 命名空间</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">addresses:</span>                        <span class=\"comment\"># 配置地址池</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"number\">10.211</span><span class=\"number\">.55</span><span class=\"number\">.200</span><span class=\"number\">-10.211</span><span class=\"number\">.55</span><span class=\"number\">.250</span>     <span class=\"comment\"># 与 节点 相同的网段，负载均衡器可以分配的IP范围</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl apply -f metallb-pool.yaml</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>配置地址池的二级公告:metallb-advertisement.yaml</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">metallb.io/v1beta1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">L2Advertisement</span>               <span class=\"comment\"># 地址池二级公告类型</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">metallb-advertisement</span>       <span class=\"comment\"># 公告名称</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">metallb-system</span>         <span class=\"comment\"># 命名空间</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">ipAddressPools:</span>                   <span class=\"comment\"># 地址池名称列表，只有被公告的地址池才会被使用</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">metallb-pool</span>                    <span class=\"comment\"># 地址池名称</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl apply -f metallb-advertisement.yaml</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建-LoadBalancer-类型的-service\">创建 LoadBalancer 类型的 service</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>metallb-service.yaml</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span>                  <span class=\"comment\"># 指定使用的 API 版本，这里是 apps/v1，适用于 Deployment 资源</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span>                     <span class=\"comment\"># Kubernetes 资源类型，这里是部署（Deployment）</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">nginx</span>                       <span class=\"comment\"># 标签，用于标识资源，可与 selector 匹配</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx</span>                        <span class=\"comment\"># 资源名称，必须唯一（在同一命名空间下）</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">ns1</span>                     <span class=\"comment\"># 命名空间，默认为 default</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span>                                <span class=\"comment\"># 配置项</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">3</span>                        <span class=\"comment\"># 副本数，表示希望运行多少个 Pod 实例</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span>                          <span class=\"comment\"># 选择器，指定要管理的 Pod</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span>                     <span class=\"comment\"># 标签选择器</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">nginx</span>                     <span class=\"comment\"># 选择器，指定 Deployment 管理哪些 Pod（标签必须与 template 中匹配）</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span>                          <span class=\"comment\"># 模板，定义 Pod 的内容，具体可以参考 Pod 的配置</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">nginx</span>                   <span class=\"comment\"># Pod 的标签，必须与 selector 中的 matchLabels 一致</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">image:</span> <span class=\"string\">nginx</span>                 <span class=\"comment\"># 容器使用的镜像，这里是官方的 nginx 镜像</span></span><br><span class=\"line\">        <span class=\"attr\">name:</span> <span class=\"string\">nginx</span>                  <span class=\"comment\"># 容器的名称</span></span><br><span class=\"line\"><span class=\"string\">---</span>                                  <span class=\"comment\"># 分割线</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span>                       <span class=\"comment\"># api版本</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span>                        <span class=\"comment\"># 资源类型</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span>                            <span class=\"comment\"># 元数据</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx</span>                        <span class=\"comment\"># service名称</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">ns1</span>                     <span class=\"comment\"># 命名空间</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span>                                <span class=\"comment\"># 配置</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span>                             <span class=\"comment\"># 端口</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">80</span>                         <span class=\"comment\"># 集群内访问端口，service的端口，一般配置为与 targetPort 一致，但是非必须</span></span><br><span class=\"line\">    <span class=\"attr\">protocol:</span> <span class=\"string\">TCP</span>                    <span class=\"comment\"># 协议</span></span><br><span class=\"line\">    <span class=\"attr\">targetPort:</span> <span class=\"number\">80</span>                   <span class=\"comment\"># 容器端口, pod的端口，这个必须与实际容器端口一致</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span>                          <span class=\"comment\"># 选择器</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">nginx</span>                       <span class=\"comment\"># pod的标签，即匹配pod的标签 app=nginx</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">LoadBalancer</span>                 <span class=\"comment\"># service类型</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ k apply -f metallb-service.yaml</span><br><span class=\"line\">deployment.apps/nginx created</span><br><span class=\"line\">service/nginx created</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看service</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 可以看到 service 的类型为 LoadBalancer，并分配了 EXTERNAL-IP，这里还开放了nodePort 30613</span></span><br><span class=\"line\">$ kubectl get svc -n ns1</span><br><span class=\"line\">NAME         TYPE           CLUSTER-IP      EXTERNAL-IP     PORT(S)        AGE</span><br><span class=\"line\">nginx        LoadBalancer   10.96.210.244   10.211.55.200   80:30613/TCP   52s</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>访问service</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 通过 service 的 port 访问，这里是 80</span></span><br><span class=\"line\">curl 10.211.55.200</span><br><span class=\"line\"><span class=\"comment\"># 同样可以基于 nodeIP+nodePort 访问</span></span><br><span class=\"line\">curl 10.211.55.11:30613</span><br></pre></td></tr></table></figure>\n<h2 id=\"访问service，轮询pod\">访问service，轮询pod</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## 在集群内</span></span><br><span class=\"line\"><span class=\"comment\"># 在相同的 namespace 中，可以通过 serviceName 直接访问</span></span><br><span class=\"line\">curl nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 也可以通过 CLUSTER-IP 访问</span></span><br><span class=\"line\">curl 10.96.9.77</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在不同的 namespace 中，可以通过 &lt;serviceName&gt;.&lt;namespace&gt; 或者 &lt;serviceName&gt;.&lt;namespace&gt;.svc.cluster.local 访问，比如本示例为</span></span><br><span class=\"line\">curl nginx.default</span><br><span class=\"line\">curl nginx.default.svc.cluster.local</span><br><span class=\"line\"><span class=\"comment\"># 这是因为在创建 service前，我们是不知道 service 的 IP 地址的，所以在其它pod中就可以预先使用 &lt;serviceName&gt;.&lt;namespace&gt; 占位，k8s会自动将其解析为 service 的 CLUSTER-IP</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 在集群外</span></span><br><span class=\"line\"><span class=\"comment\"># 通过 NODE-IP:NODE-PORT 访问</span></span><br><span class=\"line\">curl 10.211.55.16:30080</span><br></pre></td></tr></table></figure>\n<h2 id=\"管理service\">管理service</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看service</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看service</span></span><br><span class=\"line\">kubectl get svc</span><br><span class=\"line\"><span class=\"comment\"># 查看指定namespace下的service</span></span><br><span class=\"line\">kubectl get svc -n kube-system</span><br><span class=\"line\"><span class=\"comment\"># 查看全部service</span></span><br><span class=\"line\">kubectl get svc -A</span><br><span class=\"line\"><span class=\"comment\"># 查看service详情</span></span><br><span class=\"line\">kubectl get svc nginx -o yaml</span><br><span class=\"line\">kubectl describe svc nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看日志</span></span><br><span class=\"line\">k logs svc/nginx</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>编辑service，保存（:wq）后生效，不需要额外 apply 或 restart</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl edit svc nginx</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>删除service</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl delete svc nginx</span><br></pre></td></tr></table></figure>\n","content_text":"摘要 本文介绍 K8S 的 Service ，本文以 CentOS 8 为例。 K8S官网 k8s Github k8s Service 介绍 Service 介绍 Service是一个抽象层，它定义了一组Pod的逻辑集，并为这些Pod支持外部流量暴露、负载均衡和服务发现。 尽管每个Pod 都有一个唯一的IP地址，但是如果没有Service，这些IP不会暴露在群集外部。 Service允许您的应用程序接收流量。 Service也可以用在ServiceSpec标记type的方式暴露，type类型如下： ClusterIP（默认）：在集群的内部IP上公开Service。这种类型使得Service只能从集群内访问。 NodePort：使用NAT在集群中每个选定Node的相同端口上公开Service。使用 : 从集群外部访问Service。是ClusterIP的超集。 LoadBalancer：在当前云中创建一个外部负载均衡器(如果支持的话)，并为Service分配一个固定的外部IP。是NodePort的超集。 ExternalName：通过返回带有该名称的CNAME记录，使用任意名称（由spec中的externalName指定）公开Service。不使用代理。 创建Service ClusterIP 只能在集群内部访问 12345678# 先创建deployment，此时会为每个pod添加一个label app=nginxkubectl create deployment nginx --image=nginx --replicas=2# 创建service，，将deployment的pod暴露出来，暴露类型为ClusterIPkubectl expose deployment nginx --type=ClusterIP --port=80$ kubectl get svc nginxNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEnginx ClusterIP 10.96.14.90 &lt;none&gt; 80/TCP 60s NodePort 暴露宿主机的端口，供外部访问 123456# 创建service，将deployment的pod暴露出来，暴露类型为NodePortkubectl expose deployment nginx --type=NodePort --port=80# 查看service，此时可以看到service的端口和节点的端口，与 ClusterIP 的区别就是是否暴露在节点上的端口$ kubectl get svc nginxNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEnginx NodePort 10.96.7.8 &lt;none&gt; 80:32691/TCP 31s yaml文件创建service yaml文件格式 12345678910111213apiVersion: v1 # api版本kind: Service # 资源类型metadata: # 元数据 name: nginx # service名称spec: # 配置 ports: # 端口 - port: 80 # 集群内访问端口，service的端口，一般配置为与 targetPort 一致，但是非必须 protocol: TCP # 协议 targetPort: 80 # 容器端口, pod的端口，这个必须与实际容器端口一致 nodePort: 30080 # node暴露的端口，service类型为 NodePort 时使用，默认范围在 30000-32767 之间 selector: # 选择器 app: nginx # pod的标签，即匹配pod的标签 app=nginx type: NodePort # service类型 这里有个问题需要注意，service 默认是通过标签来匹配pod的，所以创建service的时候，一定要保证pod的标签是存在的，否则service无法匹配pod，另外虽然我们通过命令行创建service时是通过kubectl expose deployment nginx --type=NodePort --port=80创建的，但也并不表示service只会匹配这个deployment创建的pod，而是会匹配所有具有指定标签的pod（app=nginx）。 123456789101112# 获取service的 selector$ k get svc -owideNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE SELECTORkubernetes ClusterIP 10.96.0.1 &lt;none&gt; 443/TCP 4d5h &lt;none&gt;nginx NodePort 10.96.9.77 &lt;none&gt; 80:30080/TCP 8s app=nginx# 这里有个名称为 kubernetes 的 service，其作用是为了方便集群内部的 Pod 调用 API Server 的统一入口# 无论 API Server 实际运行在哪个节点哪个 IP，集群内部只要访问如下地址就能访问 API Server。# https://kubernetes.default.svc# 或者# https://10.96.0.1# 这个 Service 是 系统自带的，不建议删除或修改。 ExternalName 可以将其它 namespace 的 service 别名到 当前 namespace，这样访问 service 时就不需要加上命名空间名称了 ExternalName Service 是纯 DNS CNAME 映射，我们不经可以映射集群内容服务，也可以映射集群外部服务。 原先的 service 访问方式： 123456789101112131415# 在不同命名空间下创建service# 创建两个命名空间以及下面的资源## ns1kubectl create namespace ns1kubectl create deployment alpine-demo -n ns1 --image=alpine/curl --replicas=1 -- /bin/sh -c &quot;sleep infinity&quot;## ns2kubectl create namespace ns2kubectl create deployment nginx-demo -n ns2 --image=nginx --replicas=1kubectl expose deployment nginx-demo -n ns2 --type=ClusterIP --port=80 --name=nginx-service# 进入 ns1 中的 pod 访问 ns2 中的 nginx-servicekubectl exec -it -n ns1 alpine-demo-66895487c8-sk4t4 -- /bin/shcurl nginx-service.ns2.svc.cluster.localcurl nginx-service.ns2 ExternalName 访问 12# 在 ns1 中创建 externalName 类型的 service，--external-name 指定 ns2 中的 nginx-servicekubectl create service externalname nginx-service -n ns1 --external-name=nginx-service.ns2.svc.cluster.local 也可以通过 yaml 创建 12345678910apiVersion: v1kind: Servicemetadata: name: nginx-service # service 名称 namespace: ns1 # 指定命名空间 为 ns1spec: externalName: nginx-service.ns2.svc.cluster.local # 指定外部服务名，比如 www.baidu.com type: ExternalName # 指定为 ExternalName 类型 selector: # 不需要配置 selector app: nginx-service 查看 service 123$ k get svc -n ns1NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEnginx-service ExternalName &lt;none&gt; nginx-service.ns2.svc.cluster.local &lt;none&gt; 16s 此时再次进入 ns1 中的 pod 访问 ns2 中的 nginx-service 服务 123kubectl exec -it -n ns1 alpine-demo-66895487c8-sk4t4 -- /bin/sh# 此时就不需要加上 ns2 的 namespace 了curl nginx-service LoadBalancer LoadBalancer 是 Kubernetes Service 的一种类型，用于自动申请一个云厂商的负载均衡器（如 AWS ELB、GCP LB、阿里云 SLB），将外部流量转发到 Kubernetes 集群内部的 Pod 上。 在私有云上，需要借助第三方负载均衡器来实现，比如 MetalLB，github 安装 MetallB 如果您在IPVS模式下使用kube代理，从Kubernetes v1.14.2开始，您必须启用严格的ARP模式。请注意，如果您使用kube-router作为服务代理，则不需要这个，因为它默认启用了严格的ARP。 123456789# 查看将要产生的变更，如果有变更则返回非零状态码kubectl get configmap kube-proxy -n kube-system -o yaml | \\sed -e &quot;s/strictARP: false/strictARP: true/&quot; | \\kubectl diff -f - -n kube-system# 实际应用变更，只有发生错误时才返回非零状态码kubectl get configmap kube-proxy -n kube-system -o yaml | \\sed -e &quot;s/strictARP: false/strictARP: true/&quot; | \\kubectl apply -f - -n kube-system 安装MetalLB 123export METLB_VERSION=v0.15.2curl -L -o metallb.yaml https://raw.githubusercontent.com/metallb/metallb/$&#123;METLB_VERSION&#125;/config/manifests/metallb-native.yamlkubectl apply -f metallb.yaml 查看MetalLB资源 123456789101112131415161718$ k get all -n metallb-system -owideNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATESpod/controller-58fdf44d87-bsp4z 1/1 Running 0 4m13s 10.244.194.104 k8s-worker1 &lt;none&gt; &lt;none&gt;pod/speaker-sjvq5 1/1 Running 0 4m13s 10.211.55.15 k8s-worker1 &lt;none&gt; &lt;none&gt;pod/speaker-srpp4 1/1 Running 0 4m13s 10.211.55.16 k8s-worker2 &lt;none&gt; &lt;none&gt;pod/speaker-tbnls 1/1 Running 2 (98s ago) 4m13s 10.211.55.11 k8s-master &lt;none&gt; &lt;none&gt;NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE SELECTORservice/metallb-webhook-service ClusterIP 10.96.233.8 &lt;none&gt; 443/TCP 4m14s component=controllerNAME DESIRED CURRENT READY UP-TO-DATE AVAILABLE NODE SELECTOR AGE CONTAINERS IMAGES SELECTORdaemonset.apps/speaker 3 3 3 3 3 kubernetes.io/os=linux 4m13s speaker quay.io/metallb/speaker:v0.15.2 app=metallb,component=speakerNAME READY UP-TO-DATE AVAILABLE AGE CONTAINERS IMAGES SELECTORdeployment.apps/controller 1/1 1 1 4m14s controller quay.io/metallb/controller:v0.15.2 app=metallb,component=controllerNAME DESIRED CURRENT READY AGE CONTAINERS IMAGES SELECTORreplicaset.apps/controller-58fdf44d87 1 1 1 4m13s controller quay.io/metallb/controller:v0.15.2 app=metallb,component=controller,pod-template-hash=58fdf44d87 配置地址池:metallb-pool.yaml 12345678apiVersion: metallb.io/v1beta1kind: IPAddressPool # 地址池类型metadata: name: metallb-pool # 地址池名称 namespace: metallb-system # 命名空间spec: addresses: # 配置地址池 - 10.211.55.200-10.211.55.250 # 与 节点 相同的网段，负载均衡器可以分配的IP范围 1kubectl apply -f metallb-pool.yaml 配置地址池的二级公告:metallb-advertisement.yaml 12345678apiVersion: metallb.io/v1beta1kind: L2Advertisement # 地址池二级公告类型metadata: name: metallb-advertisement # 公告名称 namespace: metallb-system # 命名空间spec: ipAddressPools: # 地址池名称列表，只有被公告的地址池才会被使用 - metallb-pool # 地址池名称 1kubectl apply -f metallb-advertisement.yaml 创建 LoadBalancer 类型的 service metallb-service.yaml 12345678910111213141516171819202122232425262728293031323334apiVersion: apps/v1 # 指定使用的 API 版本，这里是 apps/v1，适用于 Deployment 资源kind: Deployment # Kubernetes 资源类型，这里是部署（Deployment）metadata: labels: app: nginx # 标签，用于标识资源，可与 selector 匹配 name: nginx # 资源名称，必须唯一（在同一命名空间下） namespace: ns1 # 命名空间，默认为 defaultspec: # 配置项 replicas: 3 # 副本数，表示希望运行多少个 Pod 实例 selector: # 选择器，指定要管理的 Pod matchLabels: # 标签选择器 app: nginx # 选择器，指定 Deployment 管理哪些 Pod（标签必须与 template 中匹配） template: # 模板，定义 Pod 的内容，具体可以参考 Pod 的配置 metadata: labels: app: nginx # Pod 的标签，必须与 selector 中的 matchLabels 一致 spec: containers: - image: nginx # 容器使用的镜像，这里是官方的 nginx 镜像 name: nginx # 容器的名称--- # 分割线apiVersion: v1 # api版本kind: Service # 资源类型metadata: # 元数据 name: nginx # service名称 namespace: ns1 # 命名空间spec: # 配置 ports: # 端口 - port: 80 # 集群内访问端口，service的端口，一般配置为与 targetPort 一致，但是非必须 protocol: TCP # 协议 targetPort: 80 # 容器端口, pod的端口，这个必须与实际容器端口一致 selector: # 选择器 app: nginx # pod的标签，即匹配pod的标签 app=nginx type: LoadBalancer # service类型 123$ k apply -f metallb-service.yamldeployment.apps/nginx createdservice/nginx created 查看service 1234# 可以看到 service 的类型为 LoadBalancer，并分配了 EXTERNAL-IP，这里还开放了nodePort 30613$ kubectl get svc -n ns1NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEnginx LoadBalancer 10.96.210.244 10.211.55.200 80:30613/TCP 52s 访问service 1234# 通过 service 的 port 访问，这里是 80curl 10.211.55.200# 同样可以基于 nodeIP+nodePort 访问curl 10.211.55.11:30613 访问service，轮询pod 12345678910111213141516## 在集群内# 在相同的 namespace 中，可以通过 serviceName 直接访问curl nginx# 也可以通过 CLUSTER-IP 访问curl 10.96.9.77# 在不同的 namespace 中，可以通过 &lt;serviceName&gt;.&lt;namespace&gt; 或者 &lt;serviceName&gt;.&lt;namespace&gt;.svc.cluster.local 访问，比如本示例为curl nginx.defaultcurl nginx.default.svc.cluster.local# 这是因为在创建 service前，我们是不知道 service 的 IP 地址的，所以在其它pod中就可以预先使用 &lt;serviceName&gt;.&lt;namespace&gt; 占位，k8s会自动将其解析为 service 的 CLUSTER-IP## 在集群外# 通过 NODE-IP:NODE-PORT 访问curl 10.211.55.16:30080 管理service 查看service 123456789101112# 查看servicekubectl get svc# 查看指定namespace下的servicekubectl get svc -n kube-system# 查看全部servicekubectl get svc -A# 查看service详情kubectl get svc nginx -o yamlkubectl describe svc nginx# 查看日志k logs svc/nginx 编辑service，保存（:wq）后生效，不需要额外 apply 或 restart 1kubectl edit svc nginx 删除service 1kubectl delete svc nginx","summary":"摘要 本文介绍 K8S 的 Service ，本文以 CentOS 8 为例。 K8S官网 k8s Github k8s Service 介绍","date_published":"2025-07-18T14:30:05.000Z","tags":["技术","k8s","K8S"]},{"id":"https://blog.hanqunfeng.com/2025/07/17/acme/","url":"https://blog.hanqunfeng.com/2025/07/17/acme/","title":"acme.sh 自动申请并续签 SSL 证书的工具","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍自动申请并续签 SSL 证书的工具: <a href=\"http://acme.sh\">acme.sh</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/acmesh-official/acme.sh\">acme.sh Github</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"acme-sh-介绍\"><a href=\"http://acme.sh\">acme.sh</a> 介绍</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"http://acme.sh\">acme.sh</a> 实现了 acme 协议，可以从 ZeroSSL，Let’s Encrypt 等 CA 生成免费的证书。</p>\n</li>\n<li class=\"lvl-2\">\n<p>适用场景：shell脚本方式，几乎无依赖，极简，适合不想安装Python环境的人。</p>\n</li>\n<li class=\"lvl-2\">\n<p>特点：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">纯 Shell 脚本，单文件运行</li>\n<li class=\"lvl-4\">支持 100+ DNS API 自动续签（如 Cloudflare、阿里云、腾讯云等）</li>\n<li class=\"lvl-4\">支持通配符证书</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"acme-sh-安装\"><a href=\"http://acme.sh\">acme.sh</a> 安装</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>需要先安装 crontab</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装 crontab</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> dnf install cronie -y</span><br><span class=\"line\"><span class=\"comment\"># 启动 crond</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl <span class=\"built_in\">enable</span> --now crond</span><br><span class=\"line\"><span class=\"comment\"># 查看 crond 状态</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl status crond</span><br><span class=\"line\"><span class=\"comment\"># 查看 crontab 是否正常</span></span><br><span class=\"line\">crontab -l</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>安装 <a href=\"http://acme.sh\">acme.sh</a></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装成功后会自动安装到 ~/.acme.sh/ 目录下，证书也会生成在该目录下</span></span><br><span class=\"line\">curl https://get.acme.sh | sh -s email=qunfeng_han@aliyun.com</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;alias acme.sh=~/.acme.sh/acme.sh&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bashrc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装成功后会自动在 crontab 中添加了定时任务，每天检查一次证书是否到达下次更新日期，如果到期则自动更新</span></span><br><span class=\"line\"><span class=\"comment\"># 证书有效期默认为 90 天，还剩 30 天时会触发自动更新</span></span><br><span class=\"line\">crontab -l</span><br><span class=\"line\"><span class=\"comment\"># 输出类似于 以下内容</span></span><br><span class=\"line\">48 1 * * * <span class=\"string\">&quot;/root/.acme.sh&quot;</span>/acme.sh --cron --home <span class=\"string\">&quot;/root/.acme.sh&quot;</span> &gt; /dev/null</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看帮助</span></span><br><span class=\"line\">acme.sh -h</span><br><span class=\"line\"><span class=\"comment\"># 查看版本</span></span><br><span class=\"line\">acme.sh -v</span><br></pre></td></tr></table></figure>\n<h2 id=\"升级-acme-sh\">升级 <a href=\"http://acme.sh\">acme.sh</a></h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 升级 acme.sh 到最新版</span></span><br><span class=\"line\">acme.sh --upgrade</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 开启自动升级</span></span><br><span class=\"line\">acme.sh --upgrade --auto-upgrade</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 可以随时关闭自动更新</span></span><br><span class=\"line\">acme.sh --upgrade --auto-upgrade  0</span><br></pre></td></tr></table></figure>\n<h2 id=\"卸载-acme-sh\">卸载 <a href=\"http://acme.sh\">acme.sh</a></h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">acme.sh --uninstall</span><br><span class=\"line\"><span class=\"built_in\">rm</span> -rf ~/.acme.sh</span><br></pre></td></tr></table></figure>\n<h2 id=\"生成证书\">生成证书</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"http://acme.sh\">acme.sh</a> 实现了 acme 协议支持的所有验证协议。</p>\n</li>\n<li class=\"lvl-2\">\n<p>证书创建后会保存在 ~/.acme.sh/目录下，比如我的域名是 <code>acme.hanqunfeng.com</code>，则证书保存在 <code>~/.acme.sh/acme.hanqunfeng.com_ecc/</code>目录下</p>\n</li>\n<li class=\"lvl-2\">\n<p>创建证书时一般有两种方式验证: HTTP 和 DNS 验证。</p>\n</li>\n</ul>\n<h3 id=\"HTTP-验证\">HTTP 验证</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>只支持单个子域名的证书生成，不支持通配符域名</p>\n</li>\n<li class=\"lvl-2\">\n<p>需要提前将域名解析到本机的IP地址</p>\n</li>\n</ul>\n<h4 id=\"直接签发\">直接签发</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>只需要指定域名，并指定域名所在的网站根目录. <a href=\"http://acme.sh\">acme.sh</a> 会全自动的生成验证文件，并放到网站的根目录，验证完成后会聪明的删除验证文件，整个过程没有任何副作用。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -d 指定域名，可以添加多个，--webroot 指定网站根目录</span></span><br><span class=\"line\">acme.sh --issue -d acme.hanqunfeng.com -d www.hanqunfeng.com --webroot /home/wwwroot/mydomain.com/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># --server 指定 acme.sh 使用的 CA 服务商为 Let&#x27;s Encrypt，默认使用 ZeroSSL</span></span><br><span class=\"line\">acme.sh --issue -d acme.hanqunfeng.com -d www.hanqunfeng.com --webroot /home/wwwroot/mydomain.com/ --server letsencrypt</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用-Nginx-Apache-模式\">使用 Nginx/Apache 模式</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果你用的 Nginx/Apache 服务器，或者反代，<a href=\"http://acme.sh\">acme.sh</a> 还可以智能的从 Nginx/Apache 的配置中自动完成验证，你不需要指定网站根目录</p>\n</li>\n<li class=\"lvl-2\">\n<p>nginx 或 httpd 命令要在系统Path中</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -d 域名，可以添加多个, --nginx 告诉 acme.sh 使用 Nginx 模式</span></span><br><span class=\"line\">acme.sh --issue --nginx -d acme.hanqunfeng.com -d www.hanqunfeng.com</span><br><span class=\"line\"><span class=\"comment\"># -d 域名，可以添加多个, --apache 告诉 acme.sh 使用 Apache 模式</span></span><br><span class=\"line\">acme.sh --issue --apache -d acme.hanqunfeng.com -d www.hanqunfeng.com</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用独立服务模式\">使用独立服务模式</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果服务器上没有运行任何 Web 服务，80 端口是空闲的，那么 <a href=\"http://acme.sh\">acme.sh</a> 还能假装自己是一个 WebServer，临时监听 80 端口，完成验证</p>\n</li>\n<li class=\"lvl-2\">\n<p>需要先安装 socat 命令，socat 常用于临时开启 TCP/UDP 监听端口</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> dnf install socat -y</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>生成证书，要求80端口空闲，否则会失败</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># --standalone 独立服务模式</span></span><br><span class=\"line\">acme.sh --issue --standalone -d acme.hanqunfeng.com -d www.hanqunfeng.com</span><br></pre></td></tr></table></figure>\n<h3 id=\"DNS-验证\">DNS 验证</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果你没有服务器，没有公网 IP，只需要 DNS 的解析记录即可完成验证。</p>\n</li>\n<li class=\"lvl-2\">\n<p>支持通配符域名</p>\n</li>\n</ul>\n<h4 id=\"手动验证\">手动验证</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这需要你手动在域名上添加一条 TXT 解析记录，验证域名所有权。</p>\n</li>\n<li class=\"lvl-2\">\n<p>注意，如果使用手动验证，<a href=\"http://acme.sh\">acme.sh</a> 将无法自动更新证书，每次都需要手动添加解析来验证域名所有权。如果有自动更新证书的需求，请使用自动验证（DNS API）。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 需要加上 --yes-I-know-dns-manual-mode-enough-go-ahead-please 选项</span></span><br><span class=\"line\">acme.sh --issue --dns -d acme.hanqunfeng.com -d www.hanqunfeng.com --yes-I-know-dns-manual-mode-enough-go-ahead-please</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>然后，<a href=\"http://acme.sh\">acme.sh</a> 会生成相应的解析记录显示出来，你只需要在你的域名管理面板中添加这条 TXT 记录即可。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Add the following txt record:</span><br><span class=\"line\">Domain:_acme-challenge.acme.hanqunfeng.com</span><br><span class=\"line\">Txt value:mUWNg9kuQ9hwOkqYFQ_DFMQ4Eu0CEaxxxxxxxxxxx</span><br><span class=\"line\"></span><br><span class=\"line\">Add the following txt record:</span><br><span class=\"line\">Domain:_acme-challenge.www.hanqunfeng.com</span><br><span class=\"line\">Txt value:vLwDR48eHcmcScOwHrDjaFZo-yw_f9xxxxxxxxxxx</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>等待解析完成之后，执行以下命令重新生成证书：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 注意这里现在用的是 --renew 参数</span></span><br><span class=\"line\">acme.sh --renew -d acme.hanqunfeng.com -d www.hanqunfeng.com</span><br></pre></td></tr></table></figure>\n<h4 id=\"自动验证（DNS-API）\">自动验证（DNS API）</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>DNS 方式的真正强大之处在于可以使用域名解析商提供的 API 自动添加 TXT 记录，且在完成验证后删除对应的记录。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"http://acme.sh\">acme.sh</a> 目前支持<a href=\"https://github.com/acmesh-official/acme.sh/wiki/dnsapi\">超过一百家的 DNS API</a>。</p>\n</li>\n<li class=\"lvl-2\">\n<p>以阿里云为例，登录阿里云帐号，获取 AccessKey 和 SecretKey，并设置环境变量：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 只需要命令行执行一次，运行生成证书命令时会保存在 ~/.acme.sh/account.conf 中，并在需要时自动获取，无需手动再设置</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> Ali_Key=<span class=\"string\">&quot;&lt;key&gt;&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> Ali_Secret=<span class=\"string\">&quot;&lt;secret&gt;&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>生成证书</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># --dns dns_ali 指定阿里云的DNS API</span></span><br><span class=\"line\">acme.sh --issue -d acme.hanqunfeng.com -d *.hanqunfeng.com --dns dns_ali</span><br></pre></td></tr></table></figure>\n<h2 id=\"生成证书的其它说明\">生成证书的其它说明</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"http://acme.sh\">acme.sh</a> 脚本默认 CA 服务商是 ZeroSSL，<a href=\"https://github.com/acmesh-official/acme.sh/wiki/Server\">acme.sh 支持的CA 服务商及其使用方法</a>，可以在命令行中通过 --server 指定</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 这里使用 Let&#x27;s Encrypt 的 CA 服务商</span></span><br><span class=\"line\">acme.sh --issue -d acme.hanqunfeng.com -d *.hanqunfeng.com --dns dns_ali --server letsencrypt</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>也可以设置全局默认的 CA 服务商，这样就不需要每次都指定 --server</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">acme.sh --set-default-ca --server letsencrypt</span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>小贴士</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\"><a href=\"http://acme.sh\">acme.sh</a> 官网说 默认的 CA 服务商 ZeroSSL 不是很稳定，有时可能会导致获取证书的时候一直出现：<code>Pending，The CA is processing your order，please just wait.</code>， 此时只需要把 CA 服务器改成 Let’s Encrypt 即可，虽然更改以后还是有概率出现 pending，但基本 2-3 次即可成功。</li>\n<li class=\"lvl-2\">但是 Let’s Encrypt 获取的证书，不支持比较旧的设备，比如 Android 5.0 以下的设备，如果有这方面的需要还是推荐使用 ZeroSSL。</li>\n<li class=\"lvl-2\">常见根证书表</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>根证书（CN）</th>\n<th>Android 5.0</th>\n<th>常见签发方</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>ISRG Root X1</strong></td>\n<td>❌ 不兼容</td>\n<td>Let’s Encrypt</td>\n</tr>\n<tr>\n<td><strong>DST Root CA X3</strong></td>\n<td>✅ 兼容（2021年过期）</td>\n<td>Let’s Encrypt 老版本</td>\n</tr>\n<tr>\n<td><strong>GlobalSign Root R1</strong></td>\n<td>✅ 兼容</td>\n<td>GlobalSign</td>\n</tr>\n<tr>\n<td><strong>USERTrust RSA Certification Authority</strong></td>\n<td>✅ 兼容</td>\n<td>ZeroSSL, Sectigo</td>\n</tr>\n<tr>\n<td><strong>Starfield Root CA - G2</strong></td>\n<td>❌ 不兼容</td>\n<td>GoDaddy 新版</td>\n</tr>\n<tr>\n<td><strong>Starfield Root CA - G1</strong></td>\n<td>✅ 兼容</td>\n<td>GoDaddy 老版</td>\n</tr>\n<tr>\n<td><strong>GTS Root R1/R3</strong></td>\n<td>❌ 不兼容</td>\n<td>Google Trust Services</td>\n</tr>\n<tr>\n<td><strong>Amazon Root CA 1</strong></td>\n<td>❌ 不兼容</td>\n<td>Amazon Trust</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">\n<p>可以用在线工具直接查看证书链：<a href=\"https://www.ssllabs.com/ssltest/\">https://www.ssllabs.com/ssltest/</a> ，它会显示完整证书链和各种设备的兼容性</p>\n</li>\n</ul>\n</div>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看已经生成的证书</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ acme.sh --list</span><br><span class=\"line\">Main_Domain          KeyLength  SAN_Domains  CA           Created               Renew</span><br><span class=\"line\">acme.hanqunfeng.com  <span class=\"string\">&quot;ec-256&quot;</span>   no           ZeroSSL.com  2025-07-17T03:31:30Z  2025-09-14T03:31:30Z</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果生成证书时失败，可以通过添加 --debug 参数查看详细错误信息</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">acme.sh --issue -d acme.hanqunfeng.com -d *.hanqunfeng.com --dns dns_ali --server letsencrypt --debug</span><br><span class=\"line\"><span class=\"comment\"># --debug 2 输出更为详细的信息</span></span><br><span class=\"line\">acme.sh --issue -d acme.hanqunfeng.com -d *.hanqunfeng.com --dns dns_ali --server letsencrypt --debug 2</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>目前证书每 60 天自动更新，你无需任何操作。但是你也可以强制续签证书：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 注意这里要将 --issue 改为 --renew，--issue 只有第一次生成正式时才会使用。同时加上 --force，未到更新时间强制重新生成证书。</span></span><br><span class=\"line\">acme.sh --renew -d acme.hanqunfeng.com -d *.hanqunfeng.com --dns dns_ali --server letsencrypt --force</span><br></pre></td></tr></table></figure>\n<h2 id=\"生成证书后自动部署和更新\">生成证书后自动部署和更新</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>上面无论是 http 还是 dns 模式，生成证书后，都会在 ~/.acme.sh/acme.hanqunfeng.com_ecc/ 目录下生成以下文件：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── acme.hanqunfeng.com.cer</span><br><span class=\"line\">├── acme.hanqunfeng.com.conf</span><br><span class=\"line\">├── acme.hanqunfeng.com.csr</span><br><span class=\"line\">├── acme.hanqunfeng.com.csr.conf</span><br><span class=\"line\">├── acme.hanqunfeng.com.key</span><br><span class=\"line\">├── ca.cer</span><br><span class=\"line\">└── fullchain.cer</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>我们可以手动将证书拷贝到真正使用证书的目录下，如果我们使用nginx或者apache，可以让 <a href=\"http://acme.sh\">acme.sh</a> 帮我们自动将证书拷贝到正确的目录下，并重启服务使证书生效，我们只需要通过如下命令进行设置即可，只需要运行一次命令，后续会通过 crontab 进行自动更新证书并完成部署。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Nginx</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">acme.sh --install-cert \\</span><br><span class=\"line\">-d acme.hanqunfeng.com \\                               <span class=\"comment\"># 生成证书时指定的域名</span></span><br><span class=\"line\">--key-file /path/to/keyfile/in/nginx/key.pem \\    <span class=\"comment\"># nginx 中配置的 key 文件路径</span></span><br><span class=\"line\">--fullchain-file /path/to/fullchain/nginx/cert.pem \\  <span class=\"comment\"># nginx 中配置的证书文件路径</span></span><br><span class=\"line\">--reloadcmd <span class=\"string\">&quot;systemctl reload nginx&quot;</span>                   <span class=\"comment\"># nginx 重载命令，也可以使用 nginx -s reload</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>文件对应关系</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><a href=\"http://acme.sh\">acme.sh</a> 文件</th>\n<th>含义</th>\n<th>你配置的目标文件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>acme.hanqunfeng.com.key</code></td>\n<td><strong>私钥 (Private Key)</strong></td>\n<td><code>/path/to/keyfile/in/nginx/key.pem</code></td>\n</tr>\n<tr>\n<td><code>fullchain.cer</code></td>\n<td><strong>证书 + 中间证书链 (Fullchain)</strong></td>\n<td><code>/path/to/fullchain/nginx/cert.pem</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Apache</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">acme.sh --install-cert \\</span><br><span class=\"line\">-d acme.hanqunfeng.com \\</span><br><span class=\"line\">--cert-file      /path/to/certfile/in/apache/cert.pem  \\ <span class=\"comment\"># apache 证书文件</span></span><br><span class=\"line\">--key-file       /path/to/keyfile/in/apache/key.pem  \\   <span class=\"comment\"># apache 密钥文件</span></span><br><span class=\"line\">--fullchain-file /path/to/fullchain/certfile/apache/fullchain.pem \\ <span class=\"comment\"># apache 全链文件</span></span><br><span class=\"line\">--reloadcmd     <span class=\"string\">&quot;systemctl reload httpd&quot;</span>  <span class=\"comment\"># apache 重载命令</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>文件对应关系</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><a href=\"http://acme.sh\">acme.sh</a> 文件</th>\n<th>含义</th>\n<th>你配置的目标文件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>acme.hanqunfeng.com.key</code></td>\n<td><strong>私钥 (Private Key)</strong></td>\n<td><code>/path/to/keyfile/in/apache/key.pem</code></td>\n</tr>\n<tr>\n<td><code>acme.hanqunfeng.com.cer</code></td>\n<td><strong>仅域名证书 (Certificate)</strong></td>\n<td><code>/path/to/certfile/in/apache/cert.pem</code></td>\n</tr>\n<tr>\n<td><code>fullchain.cer</code></td>\n<td><strong>证书 + 中间证书链 (Fullchain)</strong></td>\n<td><code>/path/to/fullchain/certfile/apache/fullchain.pem</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"停止自动更新并删除证书\">停止自动更新并删除证书</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 停止自动更新</span></span><br><span class=\"line\">acme.sh --remove -d acme.hanqunfeng.com --ecc</span><br><span class=\"line\"><span class=\"comment\"># 删除证书</span></span><br><span class=\"line\"><span class=\"built_in\">rm</span> -rf ~/.acme.sh/acme.hanqunfeng.com_ecc</span><br></pre></td></tr></table></figure>\n<h2 id=\"其它ssl自动续签工具\">其它ssl自动续签工具</h2>\n<table>\n<thead>\n<tr>\n<th>工具</th>\n<th>推荐场景</th>\n<th>官网地址</th>\n<th>依赖</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Certbot</td>\n<td>传统服务器、Nginx/Apache</td>\n<td><a href=\"https://certbot.eff.org/\">https://certbot.eff.org/</a></td>\n<td>Python</td>\n</tr>\n<tr>\n<td>Lego</td>\n<td>静态二进制、K8s</td>\n<td><a href=\"https://github.com/go-acme/lego\">https://github.com/go-acme/lego</a></td>\n<td>无依赖</td>\n</tr>\n<tr>\n<td>cert-manager</td>\n<td>K8s 集群</td>\n<td><a href=\"https://cert-manager.io/\">https://cert-manager.io/</a></td>\n<td>K8s CRD</td>\n</tr>\n<tr>\n<td>Caddy</td>\n<td>简单站点自动HTTPS</td>\n<td><a href=\"https://caddyserver.com/\">https://caddyserver.com/</a></td>\n<td>无需单独工具</td>\n</tr>\n<tr>\n<td>Traefik</td>\n<td>微服务网关</td>\n<td><a href=\"https://traefik.io/\">https://traefik.io/</a></td>\n<td>Docker/K8s</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍自动申请并续签 SSL 证书的工具: acme.sh acme.sh Github acme.sh 介绍 acme.sh 实现了 acme 协议，可以从 ZeroSSL，Let’s Encrypt 等 CA 生成免费的证书。 适用场景：shell脚本方式，几乎无依赖，极简，适合不想安装Python环境的人。 特点： 纯 Shell 脚本，单文件运行 支持 100+ DNS API 自动续签（如 Cloudflare、阿里云、腾讯云等） 支持通配符证书 acme.sh 安装 需要先安装 crontab 12345678# 安装 crontabsudo dnf install cronie -y# 启动 crondsudo systemctl enable --now crond# 查看 crond 状态sudo systemctl status crond# 查看 crontab 是否正常crontab -l 安装 acme.sh 123456789101112131415# 安装成功后会自动安装到 ~/.acme.sh/ 目录下，证书也会生成在该目录下curl https://get.acme.sh | sh -s email=qunfeng_han@aliyun.comecho &#x27;alias acme.sh=~/.acme.sh/acme.sh&#x27; &gt;&gt; ~/.bashrcsource ~/.bashrc# 安装成功后会自动在 crontab 中添加了定时任务，每天检查一次证书是否到达下次更新日期，如果到期则自动更新# 证书有效期默认为 90 天，还剩 30 天时会触发自动更新crontab -l# 输出类似于 以下内容48 1 * * * &quot;/root/.acme.sh&quot;/acme.sh --cron --home &quot;/root/.acme.sh&quot; &gt; /dev/null# 查看帮助acme.sh -h# 查看版本acme.sh -v 升级 acme.sh 12345678# 升级 acme.sh 到最新版acme.sh --upgrade# 开启自动升级acme.sh --upgrade --auto-upgrade# 可以随时关闭自动更新acme.sh --upgrade --auto-upgrade 0 卸载 acme.sh 12acme.sh --uninstallrm -rf ~/.acme.sh 生成证书 acme.sh 实现了 acme 协议支持的所有验证协议。 证书创建后会保存在 ~/.acme.sh/目录下，比如我的域名是 acme.hanqunfeng.com，则证书保存在 ~/.acme.sh/acme.hanqunfeng.com_ecc/目录下 创建证书时一般有两种方式验证: HTTP 和 DNS 验证。 HTTP 验证 只支持单个子域名的证书生成，不支持通配符域名 需要提前将域名解析到本机的IP地址 直接签发 只需要指定域名，并指定域名所在的网站根目录. acme.sh 会全自动的生成验证文件，并放到网站的根目录，验证完成后会聪明的删除验证文件，整个过程没有任何副作用。 12345# -d 指定域名，可以添加多个，--webroot 指定网站根目录acme.sh --issue -d acme.hanqunfeng.com -d www.hanqunfeng.com --webroot /home/wwwroot/mydomain.com/# --server 指定 acme.sh 使用的 CA 服务商为 Let&#x27;s Encrypt，默认使用 ZeroSSLacme.sh --issue -d acme.hanqunfeng.com -d www.hanqunfeng.com --webroot /home/wwwroot/mydomain.com/ --server letsencrypt 使用 Nginx/Apache 模式 如果你用的 Nginx/Apache 服务器，或者反代，acme.sh 还可以智能的从 Nginx/Apache 的配置中自动完成验证，你不需要指定网站根目录 nginx 或 httpd 命令要在系统Path中 1234# -d 域名，可以添加多个, --nginx 告诉 acme.sh 使用 Nginx 模式acme.sh --issue --nginx -d acme.hanqunfeng.com -d www.hanqunfeng.com# -d 域名，可以添加多个, --apache 告诉 acme.sh 使用 Apache 模式acme.sh --issue --apache -d acme.hanqunfeng.com -d www.hanqunfeng.com 使用独立服务模式 如果服务器上没有运行任何 Web 服务，80 端口是空闲的，那么 acme.sh 还能假装自己是一个 WebServer，临时监听 80 端口，完成验证 需要先安装 socat 命令，socat 常用于临时开启 TCP/UDP 监听端口 1sudo dnf install socat -y 生成证书，要求80端口空闲，否则会失败 12# --standalone 独立服务模式acme.sh --issue --standalone -d acme.hanqunfeng.com -d www.hanqunfeng.com DNS 验证 如果你没有服务器，没有公网 IP，只需要 DNS 的解析记录即可完成验证。 支持通配符域名 手动验证 这需要你手动在域名上添加一条 TXT 解析记录，验证域名所有权。 注意，如果使用手动验证，acme.sh 将无法自动更新证书，每次都需要手动添加解析来验证域名所有权。如果有自动更新证书的需求，请使用自动验证（DNS API）。 12# 需要加上 --yes-I-know-dns-manual-mode-enough-go-ahead-please 选项acme.sh --issue --dns -d acme.hanqunfeng.com -d www.hanqunfeng.com --yes-I-know-dns-manual-mode-enough-go-ahead-please 然后，acme.sh 会生成相应的解析记录显示出来，你只需要在你的域名管理面板中添加这条 TXT 记录即可。 1234567Add the following txt record:Domain:_acme-challenge.acme.hanqunfeng.comTxt value:mUWNg9kuQ9hwOkqYFQ_DFMQ4Eu0CEaxxxxxxxxxxxAdd the following txt record:Domain:_acme-challenge.www.hanqunfeng.comTxt value:vLwDR48eHcmcScOwHrDjaFZo-yw_f9xxxxxxxxxxx 等待解析完成之后，执行以下命令重新生成证书： 12# 注意这里现在用的是 --renew 参数acme.sh --renew -d acme.hanqunfeng.com -d www.hanqunfeng.com 自动验证（DNS API） DNS 方式的真正强大之处在于可以使用域名解析商提供的 API 自动添加 TXT 记录，且在完成验证后删除对应的记录。 acme.sh 目前支持超过一百家的 DNS API。 以阿里云为例，登录阿里云帐号，获取 AccessKey 和 SecretKey，并设置环境变量： 123# 只需要命令行执行一次，运行生成证书命令时会保存在 ~/.acme.sh/account.conf 中，并在需要时自动获取，无需手动再设置export Ali_Key=&quot;&lt;key&gt;&quot;export Ali_Secret=&quot;&lt;secret&gt;&quot; 生成证书 12# --dns dns_ali 指定阿里云的DNS APIacme.sh --issue -d acme.hanqunfeng.com -d *.hanqunfeng.com --dns dns_ali 生成证书的其它说明 acme.sh 脚本默认 CA 服务商是 ZeroSSL，acme.sh 支持的CA 服务商及其使用方法，可以在命令行中通过 --server 指定 12# 这里使用 Let&#x27;s Encrypt 的 CA 服务商acme.sh --issue -d acme.hanqunfeng.com -d *.hanqunfeng.com --dns dns_ali --server letsencrypt 也可以设置全局默认的 CA 服务商，这样就不需要每次都指定 --server 1acme.sh --set-default-ca --server letsencrypt 小贴士 acme.sh 官网说 默认的 CA 服务商 ZeroSSL 不是很稳定，有时可能会导致获取证书的时候一直出现：Pending，The CA is processing your order，please just wait.， 此时只需要把 CA 服务器改成 Let’s Encrypt 即可，虽然更改以后还是有概率出现 pending，但基本 2-3 次即可成功。 但是 Let’s Encrypt 获取的证书，不支持比较旧的设备，比如 Android 5.0 以下的设备，如果有这方面的需要还是推荐使用 ZeroSSL。 常见根证书表 根证书（CN） Android 5.0 常见签发方 ISRG Root X1 ❌ 不兼容 Let’s Encrypt DST Root CA X3 ✅ 兼容（2021年过期） Let’s Encrypt 老版本 GlobalSign Root R1 ✅ 兼容 GlobalSign USERTrust RSA Certification Authority ✅ 兼容 ZeroSSL, Sectigo Starfield Root CA - G2 ❌ 不兼容 GoDaddy 新版 Starfield Root CA - G1 ✅ 兼容 GoDaddy 老版 GTS Root R1/R3 ❌ 不兼容 Google Trust Services Amazon Root CA 1 ❌ 不兼容 Amazon Trust 可以用在线工具直接查看证书链：https://www.ssllabs.com/ssltest/ ，它会显示完整证书链和各种设备的兼容性 查看已经生成的证书 123$ acme.sh --listMain_Domain KeyLength SAN_Domains CA Created Renewacme.hanqunfeng.com &quot;ec-256&quot; no ZeroSSL.com 2025-07-17T03:31:30Z 2025-09-14T03:31:30Z 如果生成证书时失败，可以通过添加 --debug 参数查看详细错误信息 123acme.sh --issue -d acme.hanqunfeng.com -d *.hanqunfeng.com --dns dns_ali --server letsencrypt --debug# --debug 2 输出更为详细的信息acme.sh --issue -d acme.hanqunfeng.com -d *.hanqunfeng.com --dns dns_ali --server letsencrypt --debug 2 目前证书每 60 天自动更新，你无需任何操作。但是你也可以强制续签证书： 12# 注意这里要将 --issue 改为 --renew，--issue 只有第一次生成正式时才会使用。同时加上 --force，未到更新时间强制重新生成证书。acme.sh --renew -d acme.hanqunfeng.com -d *.hanqunfeng.com --dns dns_ali --server letsencrypt --force 生成证书后自动部署和更新 上面无论是 http 还是 dns 模式，生成证书后，都会在 ~/.acme.sh/acme.hanqunfeng.com_ecc/ 目录下生成以下文件： 1234567├── acme.hanqunfeng.com.cer├── acme.hanqunfeng.com.conf├── acme.hanqunfeng.com.csr├── acme.hanqunfeng.com.csr.conf├── acme.hanqunfeng.com.key├── ca.cer└── fullchain.cer 我们可以手动将证书拷贝到真正使用证书的目录下，如果我们使用nginx或者apache，可以让 acme.sh 帮我们自动将证书拷贝到正确的目录下，并重启服务使证书生效，我们只需要通过如下命令进行设置即可，只需要运行一次命令，后续会通过 crontab 进行自动更新证书并完成部署。 Nginx 12345acme.sh --install-cert \\-d acme.hanqunfeng.com \\ # 生成证书时指定的域名--key-file /path/to/keyfile/in/nginx/key.pem \\ # nginx 中配置的 key 文件路径--fullchain-file /path/to/fullchain/nginx/cert.pem \\ # nginx 中配置的证书文件路径--reloadcmd &quot;systemctl reload nginx&quot; # nginx 重载命令，也可以使用 nginx -s reload 文件对应关系 acme.sh 文件 含义 你配置的目标文件 acme.hanqunfeng.com.key 私钥 (Private Key) /path/to/keyfile/in/nginx/key.pem fullchain.cer 证书 + 中间证书链 (Fullchain) /path/to/fullchain/nginx/cert.pem Apache 123456acme.sh --install-cert \\-d acme.hanqunfeng.com \\--cert-file /path/to/certfile/in/apache/cert.pem \\ # apache 证书文件--key-file /path/to/keyfile/in/apache/key.pem \\ # apache 密钥文件--fullchain-file /path/to/fullchain/certfile/apache/fullchain.pem \\ # apache 全链文件--reloadcmd &quot;systemctl reload httpd&quot; # apache 重载命令 文件对应关系 acme.sh 文件 含义 你配置的目标文件 acme.hanqunfeng.com.key 私钥 (Private Key) /path/to/keyfile/in/apache/key.pem acme.hanqunfeng.com.cer 仅域名证书 (Certificate) /path/to/certfile/in/apache/cert.pem fullchain.cer 证书 + 中间证书链 (Fullchain) /path/to/fullchain/certfile/apache/fullchain.pem 停止自动更新并删除证书 1234# 停止自动更新acme.sh --remove -d acme.hanqunfeng.com --ecc# 删除证书rm -rf ~/.acme.sh/acme.hanqunfeng.com_ecc 其它ssl自动续签工具 工具 推荐场景 官网地址 依赖 Certbot 传统服务器、Nginx/Apache https://certbot.eff.org/ Python Lego 静态二进制、K8s https://github.com/go-acme/lego 无依赖 cert-manager K8s 集群 https://cert-manager.io/ K8s CRD Caddy 简单站点自动HTTPS https://caddyserver.com/ 无需单独工具 Traefik 微服务网关 https://traefik.io/ Docker/K8s","summary":"摘要 本文介绍自动申请并续签 SSL 证书的工具: acme.sh acme.sh Github","date_published":"2025-07-17T14:30:05.000Z","tags":["技术","acme","ssl","certificate","ssl","acme"]},{"id":"https://blog.hanqunfeng.com/2025/07/16/k8s-toomanyrequests/","url":"https://blog.hanqunfeng.com/2025/07/16/k8s-toomanyrequests/","title":"K8S 镜像拉取 之 toomanyrequests 的解决方法","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 K8S 镜像拉取 的 <code>toomanyrequests</code> 的解决方法 ，本文以 CentOS 8 为例。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/\">K8S官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/kubernetes/kubernetes\">k8s Github</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"toomanyrequests-介绍\">toomanyrequests 介绍</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当我们通过k8s创建pod时需要从 dockerhub 上拉取镜像，但是 dockerhub 的api请求是有限制的，未认证用户限制为100/6h，如果超过这个限制就会返回<code>429 Too Many Requests响应</code>。<a href=\"https://docs.docker.com/docker-hub/usage/\">Docker Hub的使用和限制</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>我们可以进行用户认证，这样可以将限制提高到2000/6h。如果还需要进一步提高请求限制，可以申请dockerhub的pro plan。</p>\n</li>\n</ul>\n<h2 id=\"dockerhub-认证\">dockerhub 认证</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建 Docker Registry Secret</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 指定 namespace， 默认命名空间是 default</span></span><br><span class=\"line\">kubectl create secret docker-registry \\</span><br><span class=\"line\">  dockerhub-secret \\                            <span class=\"comment\"># 创建 secret 名称</span></span><br><span class=\"line\">  --namespace=你的命名空间 \\                      <span class=\"comment\"># 创建 secret 所在的命名空间</span></span><br><span class=\"line\">  --docker-server=https://index.docker.io/v1/ \\ <span class=\"comment\"># 指定 docker registry 地址，默认就是这个，其它仓库或私服请更改为对应的url</span></span><br><span class=\"line\">  --docker-username=你的用户名 \\                  <span class=\"comment\"># 仓库 的用户名</span></span><br><span class=\"line\">  --docker-password=你的密码或访问令牌 \\           <span class=\"comment\"># 仓库 的密码或访问令牌</span></span><br><span class=\"line\">  --docker-email=你的邮箱                        <span class=\"comment\"># 仓库 的邮箱</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看 secret</span></span><br><span class=\"line\">kubectl get secret dockerhub-secret -o yaml -n &lt;namespace&gt;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>可以在创建 pod 或 deployment 时指定凭证</p>\n</li>\n</ul>\n<blockquote>\n<p>pod</p>\n</blockquote>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">myapp</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">myapp</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">username/repository:tag</span></span><br><span class=\"line\">  <span class=\"attr\">imagePullSecrets:</span>                         <span class=\"comment\"># 添加凭证</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">dockerhub-secret</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>deployment</p>\n</blockquote>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">myapp-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">3</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">myapp</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">myapp</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">myapp</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">username/repository:tag</span></span><br><span class=\"line\">      <span class=\"attr\">imagePullSecrets:</span>                       <span class=\"comment\"># 添加凭证</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">dockerhub-secret</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>将 Secret 添加到 ServiceAccount，这样 Pod 创建的时候，会自动将 Secret 挂载到 Pod 中</p>\n</li>\n</ul>\n<blockquote>\n<p>每个 namespace 下 都有一个 名称为 default 的 ServiceAccount</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看 pod 的 ServiceAccount</span></span><br><span class=\"line\">$ k describe pod pi-n65gn | grep <span class=\"string\">&quot;Service Account&quot;</span></span><br><span class=\"line\">Service Account:  default</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定 namespace 下的 Pod 使用这个凭证</span></span><br><span class=\"line\">kubectl patch serviceaccount default -p <span class=\"string\">&#x27;&#123;&quot;imagePullSecrets&quot;: [&#123;&quot;name&quot;: &quot;dockerhub-secret&quot;&#125;]&#125;&#x27;</span> -n &lt;namespace&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加多个凭证，这会覆盖之前的设置，多个 secret 按顺序生效，k8s 会逐个尝试去拉取镜像</span></span><br><span class=\"line\">kubectl patch serviceaccount default -p <span class=\"string\">&#x27;&#123;&quot;imagePullSecrets&quot;: [&#123;&quot;name&quot;: &quot;dockerhub-secret&quot;&#125;, &#123;&quot;name&quot;: &quot;harbor-secret&quot;&#125;, &#123;&quot;name&quot;: &quot;aliyun-secret&quot;&#125;]&#125;&#x27;</span> -n &lt;namespace&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 追加一个凭证，不会覆盖原有的设置</span></span><br><span class=\"line\">kubectl patch serviceaccount default --<span class=\"built_in\">type</span>=<span class=\"string\">&#x27;json&#x27;</span> -p=<span class=\"string\">&#x27;[&#123;&quot;op&quot;: &quot;add&quot;, &quot;path&quot;: &quot;/imagePullSecrets/-&quot;, &quot;value&quot;: &#123;&quot;name&quot;: &quot;new-secret&quot;&#125;&#125;]&#x27;</span> -n &lt;namespace&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看当前 imagePullSecrets 的索引，以下命令会输出凭证的名称，索引从 0 开始</span></span><br><span class=\"line\">kubectl get sa default -o jsonpath=<span class=\"string\">&#x27;&#123;.imagePullSecrets[*].name&#125;&#x27;</span> -n &lt;namespace&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除一个凭证: 删除 index 为 1 的凭证</span></span><br><span class=\"line\">kubectl patch serviceaccount default --<span class=\"built_in\">type</span>=json -p=<span class=\"string\">&#x27;[&#123;&quot;op&quot;: &quot;remove&quot;, &quot;path&quot;: &quot;/imagePullSecrets/1&quot;&#125;]&#x27;</span> -n &lt;namespace&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清空所有凭证</span></span><br><span class=\"line\">kubectl patch sa default -p <span class=\"string\">&#x27;&#123;&quot;imagePullSecrets&quot;: []&#125;&#x27;</span> -n &lt;namespace&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 为所有 namespace 下的 Pod 添加凭证</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> ns <span class=\"keyword\">in</span> $(kubectl get ns -o jsonpath=<span class=\"string\">&#x27;&#123;.items[*].metadata.name&#125;&#x27;</span>); <span class=\"keyword\">do</span></span><br><span class=\"line\">  kubectl patch serviceaccount default -n <span class=\"variable\">$ns</span> \\</span><br><span class=\"line\">    --<span class=\"built_in\">type</span>=merge \\</span><br><span class=\"line\">    -p <span class=\"string\">&#x27;&#123;&quot;imagePullSecrets&quot;: [&#123;&quot;name&quot;: &quot;dockerhub-secret&quot;&#125;]&#125;&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看 ServiceAccount</span></span><br><span class=\"line\">$ kubectl get serviceaccount default -o yaml -n &lt;namespace&gt;</span><br><span class=\"line\">apiVersion: v1</span><br><span class=\"line\">imagePullSecrets:</span><br><span class=\"line\">- name: dockerhub-secret</span><br><span class=\"line\">kind: ServiceAccount</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  creationTimestamp: <span class=\"string\">&quot;2025-06-29T14:41:35Z&quot;</span></span><br><span class=\"line\">  name: default</span><br><span class=\"line\">  namespace: default</span><br><span class=\"line\">  resourceVersion: <span class=\"string\">&quot;361001&quot;</span></span><br><span class=\"line\">  uid: cb3a0f99-5804-4f21-816a-70533cc3d29d</span><br></pre></td></tr></table></figure>\n<h2 id=\"提高下载频率的其他建议\">提高下载频率的其他建议</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1.使用镜像缓存:</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">设置集群内镜像缓存（如 Harbor, Nexus Registry）</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 修改集群的镜像仓库配置（vim）</span></span><br><span class=\"line\">kubectl edit configmap -n kube-system</span><br><span class=\"line\"><span class=\"comment\"># 找到 imageRepository: 替换为你的仓库地址</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">使用 Docker Hub 镜像加速器（如果在中国大陆）\n<ul class=\"lvl-4\">\n<li class=\"lvl-6\">如果 k8s 使用的是 docker，则在<code>/etc/docker/daemon.json</code>添加镜像加速器配置</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">mkdir</span> -p /etc/docker</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class=\"string\">&#x27;EOF&#x27;</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;registry-mirrors&quot;</span>: [</span><br><span class=\"line\">    <span class=\"string\">&quot;https://docker.1ms.run&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;https://docker.xuanyuan.me&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;https://docker.m.daocloud.io&quot;</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EOF</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl daemon-reload</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-4\">\n<li class=\"lvl-6\">如果 k8s 使用的是 containerd，则在<code>/etc/containerd/config.toml</code>添加镜像加速器配置</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> vi /etc/containerd/config.toml</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 找到 registry.mirrors 字段，添加加速器，比如：</span></span><br><span class=\"line\">[plugins.<span class=\"string\">&quot;io.containerd.grpc.v1.cri&quot;</span>.registry.mirrors]</span><br><span class=\"line\">  [plugins.<span class=\"string\">&quot;io.containerd.grpc.v1.cri&quot;</span>.registry.mirrors.<span class=\"string\">&quot;docker.io&quot;</span>]</span><br><span class=\"line\">    endpoint = [<span class=\"string\">&quot;https://docker.1ms.run&quot;</span>, <span class=\"string\">&quot;https://docker.xuanyuan.me&quot;</span>, <span class=\"string\">&quot;https://docker.m.daocloud.io&quot;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 修改后重启 containerd</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl restart containerd</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>2.升级 Docker Hub 订阅:</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">免费账户：200 pulls/6小时（匿名用户100 pulls/6小时）</li>\n<li class=\"lvl-4\">Pro/Team 账户：无限制拉取</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>3.使用多个账户:</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">为不同节点配置不同的 Docker Hub 凭证</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>4.减少不必要的拉取:</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">使用 imagePullPolicy: IfNotPresent</li>\n<li class=\"lvl-4\">尽量使用固定版本标签而非 latest</li>\n</ul>\n</li>\n</ul>\n","content_text":"摘要 本文介绍 K8S 镜像拉取 的 toomanyrequests 的解决方法 ，本文以 CentOS 8 为例。 K8S官网 k8s Github toomanyrequests 介绍 当我们通过k8s创建pod时需要从 dockerhub 上拉取镜像，但是 dockerhub 的api请求是有限制的，未认证用户限制为100/6h，如果超过这个限制就会返回429 Too Many Requests响应。Docker Hub的使用和限制 我们可以进行用户认证，这样可以将限制提高到2000/6h。如果还需要进一步提高请求限制，可以申请dockerhub的pro plan。 dockerhub 认证 创建 Docker Registry Secret 1234567891011# 指定 namespace， 默认命名空间是 defaultkubectl create secret docker-registry \\ dockerhub-secret \\ # 创建 secret 名称 --namespace=你的命名空间 \\ # 创建 secret 所在的命名空间 --docker-server=https://index.docker.io/v1/ \\ # 指定 docker registry 地址，默认就是这个，其它仓库或私服请更改为对应的url --docker-username=你的用户名 \\ # 仓库 的用户名 --docker-password=你的密码或访问令牌 \\ # 仓库 的密码或访问令牌 --docker-email=你的邮箱 # 仓库 的邮箱# 查看 secretkubectl get secret dockerhub-secret -o yaml -n &lt;namespace&gt; 可以在创建 pod 或 deployment 时指定凭证 pod 12345678910apiVersion: v1kind: Podmetadata: name: myappspec: containers: - name: myapp image: username/repository:tag imagePullSecrets: # 添加凭证 - name: dockerhub-secret deployment 12345678910111213141516171819apiVersion: apps/v1kind: Deploymentmetadata: name: myapp-deploymentspec: replicas: 3 selector: matchLabels: app: myapp template: metadata: labels: app: myapp spec: containers: - name: myapp image: username/repository:tag imagePullSecrets: # 添加凭证 - name: dockerhub-secret 将 Secret 添加到 ServiceAccount，这样 Pod 创建的时候，会自动将 Secret 挂载到 Pod 中 每个 namespace 下 都有一个 名称为 default 的 ServiceAccount 123456789101112131415161718192021222324252627282930313233343536373839404142# 查看 pod 的 ServiceAccount$ k describe pod pi-n65gn | grep &quot;Service Account&quot;Service Account: default# 指定 namespace 下的 Pod 使用这个凭证kubectl patch serviceaccount default -p &#x27;&#123;&quot;imagePullSecrets&quot;: [&#123;&quot;name&quot;: &quot;dockerhub-secret&quot;&#125;]&#125;&#x27; -n &lt;namespace&gt;# 添加多个凭证，这会覆盖之前的设置，多个 secret 按顺序生效，k8s 会逐个尝试去拉取镜像kubectl patch serviceaccount default -p &#x27;&#123;&quot;imagePullSecrets&quot;: [&#123;&quot;name&quot;: &quot;dockerhub-secret&quot;&#125;, &#123;&quot;name&quot;: &quot;harbor-secret&quot;&#125;, &#123;&quot;name&quot;: &quot;aliyun-secret&quot;&#125;]&#125;&#x27; -n &lt;namespace&gt;# 追加一个凭证，不会覆盖原有的设置kubectl patch serviceaccount default --type=&#x27;json&#x27; -p=&#x27;[&#123;&quot;op&quot;: &quot;add&quot;, &quot;path&quot;: &quot;/imagePullSecrets/-&quot;, &quot;value&quot;: &#123;&quot;name&quot;: &quot;new-secret&quot;&#125;&#125;]&#x27; -n &lt;namespace&gt;# 查看当前 imagePullSecrets 的索引，以下命令会输出凭证的名称，索引从 0 开始kubectl get sa default -o jsonpath=&#x27;&#123;.imagePullSecrets[*].name&#125;&#x27; -n &lt;namespace&gt;# 删除一个凭证: 删除 index 为 1 的凭证kubectl patch serviceaccount default --type=json -p=&#x27;[&#123;&quot;op&quot;: &quot;remove&quot;, &quot;path&quot;: &quot;/imagePullSecrets/1&quot;&#125;]&#x27; -n &lt;namespace&gt;# 清空所有凭证kubectl patch sa default -p &#x27;&#123;&quot;imagePullSecrets&quot;: []&#125;&#x27; -n &lt;namespace&gt;# 为所有 namespace 下的 Pod 添加凭证for ns in $(kubectl get ns -o jsonpath=&#x27;&#123;.items[*].metadata.name&#125;&#x27;); do kubectl patch serviceaccount default -n $ns \\ --type=merge \\ -p &#x27;&#123;&quot;imagePullSecrets&quot;: [&#123;&quot;name&quot;: &quot;dockerhub-secret&quot;&#125;]&#125;&#x27;done# 查看 ServiceAccount$ kubectl get serviceaccount default -o yaml -n &lt;namespace&gt;apiVersion: v1imagePullSecrets:- name: dockerhub-secretkind: ServiceAccountmetadata: creationTimestamp: &quot;2025-06-29T14:41:35Z&quot; name: default namespace: default resourceVersion: &quot;361001&quot; uid: cb3a0f99-5804-4f21-816a-70533cc3d29d 提高下载频率的其他建议 1.使用镜像缓存: 设置集群内镜像缓存（如 Harbor, Nexus Registry） 123# 修改集群的镜像仓库配置（vim）kubectl edit configmap -n kube-system# 找到 imageRepository: 替换为你的仓库地址 使用 Docker Hub 镜像加速器（如果在中国大陆） 如果 k8s 使用的是 docker，则在/etc/docker/daemon.json添加镜像加速器配置 123456789101112sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123; &quot;registry-mirrors&quot;: [ &quot;https://docker.1ms.run&quot;, &quot;https://docker.xuanyuan.me&quot;, &quot;https://docker.m.daocloud.io&quot; ]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker 如果 k8s 使用的是 containerd，则在/etc/containerd/config.toml添加镜像加速器配置 123456789sudo vi /etc/containerd/config.toml# 找到 registry.mirrors 字段，添加加速器，比如：[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors] [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors.&quot;docker.io&quot;] endpoint = [&quot;https://docker.1ms.run&quot;, &quot;https://docker.xuanyuan.me&quot;, &quot;https://docker.m.daocloud.io&quot;]# 修改后重启 containerdsudo systemctl restart containerd 2.升级 Docker Hub 订阅: 免费账户：200 pulls/6小时（匿名用户100 pulls/6小时） Pro/Team 账户：无限制拉取 3.使用多个账户: 为不同节点配置不同的 Docker Hub 凭证 4.减少不必要的拉取: 使用 imagePullPolicy: IfNotPresent 尽量使用固定版本标签而非 latest","summary":"摘要 本文介绍 K8S 镜像拉取 的 toomanyrequests 的解决方法 ，本文以 CentOS 8 为例。 K8S官网 k8s Github","date_published":"2025-07-16T15:30:05.000Z","tags":["技术","k8s","K8S"]},{"id":"https://blog.hanqunfeng.com/2025/07/16/k8s-job-cornjob/","url":"https://blog.hanqunfeng.com/2025/07/16/k8s-job-cornjob/","title":"K8S 之 Job/CronJob","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 K8S 的 Job/CronJob ，本文以 CentOS 8 为例。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/\">K8S官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/kubernetes/kubernetes\">k8s Github</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/\">k8s Job 介绍</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/cron-jobs/\">k8s CronJob 介绍</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Job-介绍\">Job 介绍</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Job 表示一次性任务，运行完成后就会停止。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Job 会创建一个或者多个 Pod，并将继续重试 Pod 的执行，直到指定数量的 Pod 成功终止。</p>\n</li>\n<li class=\"lvl-2\">\n<p>随着 Pod 成功结束，Job 跟踪记录成功完成的 Pod 个数。 当数量达到指定的成功个数阈值时，任务（即 Job）结束。</p>\n</li>\n<li class=\"lvl-2\">\n<p>删除 Job 的操作会清除所创建的全部 Pod。 挂起 Job 的操作会删除 Job 的所有活跃 Pod，直到 Job 被再次恢复执行。</p>\n</li>\n</ul>\n<h3 id=\"Job-创建\">Job 创建</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>yaml 文件: job.yaml</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">batch/v1</span>                      <span class=\"comment\"># API 版本，这里使用 batch/v1，适用于 Job 资源</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Job</span>                                 <span class=\"comment\"># 资源类型，Job 用于一次性任务，完成后自动退出</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">pi</span>                                <span class=\"comment\"># Job 的名称，这里命名为 pi</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">ttlSecondsAfterFinished:</span> <span class=\"number\">100</span>            <span class=\"comment\"># Job 完成后，自动删除job的延迟时间，单位为秒。默认不删除</span></span><br><span class=\"line\">  <span class=\"attr\">parallelism:</span> <span class=\"number\">1</span>                          <span class=\"comment\"># Job 的并发数，默认为1，即一次只能启动一个 Pod</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span>                               <span class=\"comment\"># Pod 模板，定义 Job 创建的 Pod 的规范</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span>                         <span class=\"comment\"># Pod 内的容器列表</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">pi</span>                          <span class=\"comment\"># 容器名称，用户自定义的名字</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">perl:5.34.0</span>                <span class=\"comment\"># 使用的镜像，这里是 Perl 5.34.0 官方镜像</span></span><br><span class=\"line\">        <span class=\"attr\">command:</span> [<span class=\"string\">&quot;perl&quot;</span>,  <span class=\"string\">&quot;-Mbignum=bpi&quot;</span>, <span class=\"string\">&quot;-wle&quot;</span>, <span class=\"string\">&quot;print bpi(2000)&quot;</span>]  <span class=\"comment\"># 容器启动时执行的命令，计算并输出圆周率的 2000 位小数</span></span><br><span class=\"line\">      <span class=\"attr\">restartPolicy:</span> <span class=\"string\">Never</span>                <span class=\"comment\"># 重启策略，设置为 Never，表示 Pod 失败时不会自动重启</span></span><br><span class=\"line\">  <span class=\"attr\">backoffLimit:</span> <span class=\"number\">4</span>                         <span class=\"comment\"># Job 重试次数上限，若失败超过 4 次，则不再重试，Job 状态将标记为 Failed。默认为 6</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动Job</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl apply -f job.yaml</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看 Job</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看 Job</span></span><br><span class=\"line\">kubectl get <span class=\"built_in\">jobs</span></span><br><span class=\"line\"><span class=\"comment\"># 查看日志，此时会看到输出 圆周率值</span></span><br><span class=\"line\">kubectl logs <span class=\"built_in\">jobs</span>/pi</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>删除 Job</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl delete <span class=\"built_in\">jobs</span>/pi</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># yaml 删除</span></span><br><span class=\"line\">kubectl delete -f job.yaml</span><br></pre></td></tr></table></figure>\n<h2 id=\"CronJob-介绍\">CronJob 介绍</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>CronJob 通过重复调度启动一次性的 Job。</p>\n</li>\n<li class=\"lvl-2\">\n<p>CronJob 用于执行排期操作，例如备份、生成报告等。</p>\n</li>\n<li class=\"lvl-2\">\n<p>一个 CronJob 对象就像 Unix 系统上的 crontab（cron table）文件中的一行。 它用 Cron 格式进行编写， 并周期性地在给定的调度时间执行 Job。</p>\n</li>\n</ul>\n<h3 id=\"CronJob-示例：\">CronJob 示例：</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apiVersion: batch/v1</span><br><span class=\"line\">kind: CronJob                               <span class=\"comment\"># 创建CronJob</span></span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  name: hello</span><br><span class=\"line\">spec:</span><br><span class=\"line\">  schedule: <span class=\"string\">&quot;* * * * *&quot;</span>                     <span class=\"comment\"># 每分钟执行一次，不支持时区设置</span></span><br><span class=\"line\">  successfulJobsHistoryLimit: 3             <span class=\"comment\"># 指定要保留多少成功完成的 Job。默认值为 3</span></span><br><span class=\"line\">  failedJobsHistoryLimit: 1                 <span class=\"comment\"># 指定要保留多少失败完成的 Job。默认值为 1</span></span><br><span class=\"line\">  concurrencyPolicy: Allow                  <span class=\"comment\"># 默认值为 Allow：允许多个 Job 同时运行</span></span><br><span class=\"line\">                                            <span class=\"comment\"># Forbid：不允许多个 Job 同时运行。如果新 Job 的执行时间到了而老 Job 没有执行完，CronJob 会忽略新 Job 的执行。 另请注意，当老 Job 执行完成时，仍然会考虑 .spec.startingDeadlineSeconds，可能会导致新的 Job 执行。</span></span><br><span class=\"line\">                                            <span class=\"comment\"># Replace：如果新 Job 的执行时间到了而老 Job 没有执行完，CronJob 会用新 Job 替换当前正在运行的 Job。</span></span><br><span class=\"line\">  jobTemplate:</span><br><span class=\"line\">    spec:</span><br><span class=\"line\">      template:</span><br><span class=\"line\">        spec:</span><br><span class=\"line\">          containers:</span><br><span class=\"line\">          - name: hello</span><br><span class=\"line\">            image: busybox:1.28</span><br><span class=\"line\">            imagePullPolicy: IfNotPresent</span><br><span class=\"line\">            <span class=\"built_in\">command</span>:</span><br><span class=\"line\">            - /bin/sh</span><br><span class=\"line\">            - -c</span><br><span class=\"line\">            - <span class=\"built_in\">date</span>; <span class=\"built_in\">echo</span> Hello from the Kubernetes cluster</span><br><span class=\"line\">          restartPolicy: OnFailure</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>.spec.schedule</code> 字段是必需的。该字段的值遵循 Cron 语法：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ┌───────────── 分钟 (0 - 59)</span></span><br><span class=\"line\"><span class=\"comment\"># │ ┌───────────── 小时 (0 - 23)</span></span><br><span class=\"line\"><span class=\"comment\"># │ │ ┌───────────── 月的某天 (1 - 31)</span></span><br><span class=\"line\"><span class=\"comment\"># │ │ │ ┌───────────── 月份 (1 - 12)</span></span><br><span class=\"line\"><span class=\"comment\"># │ │ │ │ ┌───────────── 周的某天 (0 - 6)（周日到周六）</span></span><br><span class=\"line\"><span class=\"comment\"># │ │ │ │ │                          或者是 sun，mon，tue，web，thu，fri，sat</span></span><br><span class=\"line\"><span class=\"comment\"># │ │ │ │ │</span></span><br><span class=\"line\"><span class=\"comment\"># │ │ │ │ │</span></span><br><span class=\"line\"><span class=\"comment\"># * * * * *</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 时间表中的问号 (?) 和星号 * 含义相同，它们用来表示给定字段的任何可用值。</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>除了标准语法，还可以使用一些类似 @monthly 的宏</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>输入</strong></th>\n<th><strong>描述</strong></th>\n<th><strong>等价 Cron 表达式</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>@yearly</code> 或 <code>@annually</code></td>\n<td>每年 1 月 1 日的午夜运行一次</td>\n<td><code>0 0 1 1 *</code></td>\n</tr>\n<tr>\n<td><code>@monthly</code></td>\n<td>每月第一天的午夜运行一次</td>\n<td><code>0 0 1 * *</code></td>\n</tr>\n<tr>\n<td><code>@weekly</code></td>\n<td>每周的周日午夜运行一次</td>\n<td><code>0 0 * * 0</code></td>\n</tr>\n<tr>\n<td><code>@daily</code> 或 <code>@midnight</code></td>\n<td>每天午夜运行一次</td>\n<td><code>0 0 * * *</code></td>\n</tr>\n<tr>\n<td><code>@hourly</code></td>\n<td>每小时的开始运行一次</td>\n<td><code>0 * * * *</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>管理cronjob</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建cronjob</span></span><br><span class=\"line\">kubectl create -f cronjob.yaml</span><br><span class=\"line\"><span class=\"comment\"># 查看cronjob</span></span><br><span class=\"line\">kubectl get cronjob hello -o yaml</span><br><span class=\"line\"><span class=\"comment\"># 删除cronjob</span></span><br><span class=\"line\">kubectl delete cronjob hello</span><br><span class=\"line\">k delete -f cronjob.yaml</span><br></pre></td></tr></table></figure>\n<h2 id=\"以下是-Kubernetes-中-Job-和-CronJob-的对比表\">以下是 Kubernetes 中 Job 和 CronJob 的对比表</h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Job</th>\n<th>CronJob</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>用途</strong></td>\n<td>一次性任务，完成即结束</td>\n<td>定时周期性任务，按照时间计划定时运行</td>\n</tr>\n<tr>\n<td><strong>调度方式</strong></td>\n<td>手动创建或由控制器触发</td>\n<td>按照 Cron 表达式自动周期性调度</td>\n</tr>\n<tr>\n<td><strong>常用场景</strong></td>\n<td>数据批处理、数据库迁移、一次性任务</td>\n<td>每天备份、定时报告生成、周期性检查</td>\n</tr>\n<tr>\n<td><strong>配置关键字段</strong></td>\n<td><code>spec.template</code></td>\n<td><code>spec.schedule</code>（Cron 表达式） + <code>spec.jobTemplate</code></td>\n</tr>\n<tr>\n<td><strong>启动频率</strong></td>\n<td>创建后立刻启动一次</td>\n<td>根据 <code>schedule</code> 定期启动</td>\n</tr>\n<tr>\n<td><strong>并发控制</strong></td>\n<td>不支持并发策略</td>\n<td>支持 <code>concurrencyPolicy</code>（Allow、Forbid、Replace）</td>\n</tr>\n<tr>\n<td><strong>保留历史任务</strong></td>\n<td>无保留，任务完成后直接终结</td>\n<td>可配置保留成功或失败任务数：<code>successfulJobsHistoryLimit</code>、<code>failedJobsHistoryLimit</code></td>\n</tr>\n<tr>\n<td><strong>失败重试机制</strong></td>\n<td>支持 <code>backoffLimit</code>、<code>restartPolicy</code></td>\n<td>同样支持，作用于每次周期性运行产生的 Job 上</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 K8S 的 Job/CronJob ，本文以 CentOS 8 为例。 K8S官网 k8s Github k8s Job 介绍 k8s CronJob 介绍 Job 介绍 Job 表示一次性任务，运行完成后就会停止。 Job 会创建一个或者多个 Pod，并将继续重试 Pod 的执行，直到指定数量的 Pod 成功终止。 随着 Pod 成功结束，Job 跟踪记录成功完成的 Pod 个数。 当数量达到指定的成功个数阈值时，任务（即 Job）结束。 删除 Job 的操作会清除所创建的全部 Pod。 挂起 Job 的操作会删除 Job 的所有活跃 Pod，直到 Job 被再次恢复执行。 Job 创建 yaml 文件: job.yaml 123456789101112131415apiVersion: batch/v1 # API 版本，这里使用 batch/v1，适用于 Job 资源kind: Job # 资源类型，Job 用于一次性任务，完成后自动退出metadata: name: pi # Job 的名称，这里命名为 pispec: ttlSecondsAfterFinished: 100 # Job 完成后，自动删除job的延迟时间，单位为秒。默认不删除 parallelism: 1 # Job 的并发数，默认为1，即一次只能启动一个 Pod template: # Pod 模板，定义 Job 创建的 Pod 的规范 spec: containers: # Pod 内的容器列表 - name: pi # 容器名称，用户自定义的名字 image: perl:5.34.0 # 使用的镜像，这里是 Perl 5.34.0 官方镜像 command: [&quot;perl&quot;, &quot;-Mbignum=bpi&quot;, &quot;-wle&quot;, &quot;print bpi(2000)&quot;] # 容器启动时执行的命令，计算并输出圆周率的 2000 位小数 restartPolicy: Never # 重启策略，设置为 Never，表示 Pod 失败时不会自动重启 backoffLimit: 4 # Job 重试次数上限，若失败超过 4 次，则不再重试，Job 状态将标记为 Failed。默认为 6 启动Job 1kubectl apply -f job.yaml 查看 Job 1234# 查看 Jobkubectl get jobs# 查看日志，此时会看到输出 圆周率值kubectl logs jobs/pi 删除 Job 1234kubectl delete jobs/pi# yaml 删除kubectl delete -f job.yaml CronJob 介绍 CronJob 通过重复调度启动一次性的 Job。 CronJob 用于执行排期操作，例如备份、生成报告等。 一个 CronJob 对象就像 Unix 系统上的 crontab（cron table）文件中的一行。 它用 Cron 格式进行编写， 并周期性地在给定的调度时间执行 Job。 CronJob 示例： 123456789101112131415161718192021222324apiVersion: batch/v1kind: CronJob # 创建CronJobmetadata: name: hellospec: schedule: &quot;* * * * *&quot; # 每分钟执行一次，不支持时区设置 successfulJobsHistoryLimit: 3 # 指定要保留多少成功完成的 Job。默认值为 3 failedJobsHistoryLimit: 1 # 指定要保留多少失败完成的 Job。默认值为 1 concurrencyPolicy: Allow # 默认值为 Allow：允许多个 Job 同时运行 # Forbid：不允许多个 Job 同时运行。如果新 Job 的执行时间到了而老 Job 没有执行完，CronJob 会忽略新 Job 的执行。 另请注意，当老 Job 执行完成时，仍然会考虑 .spec.startingDeadlineSeconds，可能会导致新的 Job 执行。 # Replace：如果新 Job 的执行时间到了而老 Job 没有执行完，CronJob 会用新 Job 替换当前正在运行的 Job。 jobTemplate: spec: template: spec: containers: - name: hello image: busybox:1.28 imagePullPolicy: IfNotPresent command: - /bin/sh - -c - date; echo Hello from the Kubernetes cluster restartPolicy: OnFailure .spec.schedule 字段是必需的。该字段的值遵循 Cron 语法： 1234567891011# ┌───────────── 分钟 (0 - 59)# │ ┌───────────── 小时 (0 - 23)# │ │ ┌───────────── 月的某天 (1 - 31)# │ │ │ ┌───────────── 月份 (1 - 12)# │ │ │ │ ┌───────────── 周的某天 (0 - 6)（周日到周六）# │ │ │ │ │ 或者是 sun，mon，tue，web，thu，fri，sat# │ │ │ │ │# │ │ │ │ │# * * * * *# 时间表中的问号 (?) 和星号 * 含义相同，它们用来表示给定字段的任何可用值。 除了标准语法，还可以使用一些类似 @monthly 的宏 输入 描述 等价 Cron 表达式 @yearly 或 @annually 每年 1 月 1 日的午夜运行一次 0 0 1 1 * @monthly 每月第一天的午夜运行一次 0 0 1 * * @weekly 每周的周日午夜运行一次 0 0 * * 0 @daily 或 @midnight 每天午夜运行一次 0 0 * * * @hourly 每小时的开始运行一次 0 * * * * 管理cronjob 1234567# 创建cronjobkubectl create -f cronjob.yaml# 查看cronjobkubectl get cronjob hello -o yaml# 删除cronjobkubectl delete cronjob hellok delete -f cronjob.yaml 以下是 Kubernetes 中 Job 和 CronJob 的对比表 特性 Job CronJob 用途 一次性任务，完成即结束 定时周期性任务，按照时间计划定时运行 调度方式 手动创建或由控制器触发 按照 Cron 表达式自动周期性调度 常用场景 数据批处理、数据库迁移、一次性任务 每天备份、定时报告生成、周期性检查 配置关键字段 spec.template spec.schedule（Cron 表达式） + spec.jobTemplate 启动频率 创建后立刻启动一次 根据 schedule 定期启动 并发控制 不支持并发策略 支持 concurrencyPolicy（Allow、Forbid、Replace） 保留历史任务 无保留，任务完成后直接终结 可配置保留成功或失败任务数：successfulJobsHistoryLimit、failedJobsHistoryLimit 失败重试机制 支持 backoffLimit、restartPolicy 同样支持，作用于每次周期性运行产生的 Job 上","summary":"摘要 本文介绍 K8S 的 Job/CronJob ，本文以 CentOS 8 为例。 K8S官网 k8s Github k8s Job 介绍 k8s CronJob 介绍","date_published":"2025-07-16T14:30:05.000Z","tags":["技术","k8s","K8S"]},{"id":"https://blog.hanqunfeng.com/2025/07/15/k8s-daemonset/","url":"https://blog.hanqunfeng.com/2025/07/15/k8s-daemonset/","title":"K8S 之 DaemonSet","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 K8S 的 DaemonSet ，本文以 CentOS 8 为例。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/\">K8S官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/kubernetes/kubernetes\">k8s Github</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/\">k8s DaemonSet 介绍</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"DaemonSet-介绍\">DaemonSet 介绍</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>DaemonSet 定义了提供节点本地设施的 Pod。这些设施可能对于集群的运行至关重要，例如网络辅助工具，或者作为 add-on 的一部分。</p>\n</li>\n<li class=\"lvl-2\">\n<p>DaemonSet 确保全部（或者某些）节点上运行一个 Pod 的副本。 当有节点加入集群时， 也会为他们新增一个 Pod 。 当有节点从集群移除时，这些 Pod 也会被回收。删除 DaemonSet 将会删除它创建的所有 Pod。</p>\n</li>\n<li class=\"lvl-2\">\n<p>DaemonSet 的一些典型用法：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">在每个节点上运行集群守护进程</li>\n<li class=\"lvl-4\">在每个节点上运行日志收集守护进程</li>\n<li class=\"lvl-4\">在每个节点上运行监控守护进程</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>DaemonSet 与 Deployment 的主要区别是：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">无法自定义副本数量</li>\n<li class=\"lvl-4\">每个node上都会运行且只允许运行一个 Pod</li>\n<li class=\"lvl-4\">当有新Node加入集群时，会自动在其上部署并运行Pod副本，当Node从集群移除时，这些Pod也会被回收</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"DaemonSet-管理\">DaemonSet 管理</h2>\n<h3 id=\"DaemonSet-创建\">DaemonSet 创建</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>DaemonSet 只能 通过 <code>yaml</code> 创建，不支持 <code>create</code> 创建</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 通过 yaml 文件创建</span></span><br><span class=\"line\">kubectl apply -f daemonset.yaml</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>一个简单的 <code>daemonset.yaml</code> 文件说明</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span>                  <span class=\"comment\"># 指定使用的 API 版本，这里是 apps/v1，适用于 DaemonSet 资源</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">DaemonSet</span>                     <span class=\"comment\"># Kubernetes 资源类型，这里是部署（DaemonSet）</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">nginx</span>                       <span class=\"comment\"># 标签，用于标识资源，可与 selector 匹配</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx</span>                        <span class=\"comment\"># 资源名称，必须唯一（在同一命名空间下）</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span>                                <span class=\"comment\"># 配置项</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span>                          <span class=\"comment\"># 选择器，指定要管理的 Pod</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span>                     <span class=\"comment\"># 标签选择器</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">nginx</span>                     <span class=\"comment\"># 选择器，指定 DaemonSet 管理哪些 Pod（标签必须与 template 中匹配）</span></span><br><span class=\"line\">  <span class=\"attr\">updateStrategy:</span>                    <span class=\"comment\"># 更新策略</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">RollingUpdate</span>              <span class=\"comment\"># RollingUpdate：这是默认的更新策略。使用 RollingUpdate 更新策略时，在更新 DaemonSet 模板后， 老的 DaemonSet Pod 将被终止，并且将以受控方式自动创建新的 DaemonSet Pod。 更新期间，最多只能有 DaemonSet 的一个 Pod 运行于每个节点上。</span></span><br><span class=\"line\">                                     <span class=\"comment\"># OnDelete：使用 OnDelete 更新策略时，在更新 DaemonSet 模板后，只有当你手动删除老的 DaemonSet Pod 之后，新的 DaemonSet Pod 才会被自动创建。</span></span><br><span class=\"line\">    <span class=\"attr\">rollingUpdate:</span>                   <span class=\"comment\"># 滚动升级的配置</span></span><br><span class=\"line\">      <span class=\"attr\">maxUnavailable:</span> <span class=\"number\">1</span>              <span class=\"comment\"># 最大不可用 Pod 的数量，这里是 1，默认值为 1</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span>                          <span class=\"comment\"># 模板，定义 Pod 的内容，具体可以参考 Pod 的配置</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">nginx</span>                   <span class=\"comment\"># Pod 的标签，必须与 selector 中的 matchLabels 一致</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">image:</span> <span class=\"string\">nginx</span>                 <span class=\"comment\"># 容器使用的镜像，这里是官方的 nginx 镜像</span></span><br><span class=\"line\">        <span class=\"attr\">name:</span> <span class=\"string\">nginx</span>                  <span class=\"comment\"># 容器的名称</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"查看-DaemonSet\">查看 DaemonSet</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看 DaemonSet ，默认显示 default 命名空间下的 DaemonSet</span></span><br><span class=\"line\">kubectl get daemonsets</span><br><span class=\"line\">kubectl get ds <span class=\"comment\"># 简称</span></span><br><span class=\"line\"><span class=\"comment\"># 查看 kube-system 命名空间下的 DaemonSet</span></span><br><span class=\"line\">kubectl get ds -n kube-system</span><br><span class=\"line\"><span class=\"comment\"># 查看所有命名空间下的 DaemonSet</span></span><br><span class=\"line\">kubectl get ds -A</span><br><span class=\"line\"><span class=\"comment\"># -o wide: 显示 deploy 的详细信息</span></span><br><span class=\"line\">kubectl get ds -o wide</span><br><span class=\"line\"><span class=\"comment\"># 显示 DaemonSet 的标签</span></span><br><span class=\"line\">kubectl get ds --show-labels</span><br><span class=\"line\"><span class=\"comment\"># 按 DaemonSet 的标签进程查询</span></span><br><span class=\"line\">kubectl get ds -l &lt;label_name&gt;=&lt;label_value&gt;</span><br><span class=\"line\"><span class=\"comment\"># 持续查看 DaemonSet 的状态，当 DaemonSet 状态发生改变时，会实时显示</span></span><br><span class=\"line\">kubectl get ds -w</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看 pod、ds 的详细信息</span></span><br><span class=\"line\">$ k get pod,ds -owide</span><br><span class=\"line\">NAME              READY   STATUS    RESTARTS   AGE    IP              NODE          NOMINATED NODE   READINESS GATES</span><br><span class=\"line\">pod/nginx-6g8j8   1/1     Running   0          9m3s   10.244.126.18   k8s-worker2   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">pod/nginx-tnvhn   1/1     Running   0          9m3s   10.244.194.89   k8s-worker1   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                   DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE    CONTAINERS   IMAGES   SELECTOR</span><br><span class=\"line\">daemonset.apps/nginx   2         2         2       2            2           &lt;none&gt;          9m3s   nginx        nginx    app=nginx</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"允许-master-节点运行-pod\">允许 master 节点运行 pod</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>上面看到pod只在worker1和worker2上运行,而没有在master节点上运行</p>\n</li>\n<li class=\"lvl-2\">\n<p>默认情况下，Kubernetes 不允许在 master 节点上运行 Pod，这是因为master节点有污点</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl describe node k8s-master | grep Taints</span><br><span class=\"line\">Taints:             node-role.kubernetes.io/control-plane:NoSchedule</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>为了能让pod运行在具有污点的节点上，我们需要为pod指定容忍度(tolerations)，实际上 DaemonSet 控制器会自动将一组容忍度添加到 DaemonSet Pod</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>容忍度键名</th>\n<th>效果</th>\n<th>操作</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>node.kubernetes.io/not-ready</code></td>\n<td><code>NoExecute</code></td>\n<td>Exists</td>\n<td>DaemonSet Pod 可以被调度到不健康或未就绪的节点上，且不会被驱逐。</td>\n</tr>\n<tr>\n<td><code>node.kubernetes.io/unreachable</code></td>\n<td><code>NoExecute</code></td>\n<td>Exists</td>\n<td>DaemonSet Pod 可以被调度到不可达的节点上，且不会被驱逐。</td>\n</tr>\n<tr>\n<td><code>node.kubernetes.io/disk-pressure</code></td>\n<td><code>NoSchedule</code></td>\n<td>Exists</td>\n<td>DaemonSet Pod 可以被调度到存在磁盘压力的节点上。</td>\n</tr>\n<tr>\n<td><code>node.kubernetes.io/memory-pressure</code></td>\n<td><code>NoSchedule</code></td>\n<td>Exists</td>\n<td>DaemonSet Pod 可以被调度到存在内存压力的节点上。</td>\n</tr>\n<tr>\n<td><code>node.kubernetes.io/pid-pressure</code></td>\n<td><code>NoSchedule</code></td>\n<td>Exists</td>\n<td>DaemonSet Pod 可以被调度到存在进程数压力的节点上。</td>\n</tr>\n<tr>\n<td><code>node.kubernetes.io/unschedulable</code></td>\n<td><code>NoSchedule</code></td>\n<td>Exists</td>\n<td>DaemonSet Pod 可以被调度到标记为不可调度的节点上。</td>\n</tr>\n<tr>\n<td><code>node.kubernetes.io/network-unavailable</code></td>\n<td><code>NoSchedule</code></td>\n<td>Exists</td>\n<td>针对 <code>spec.hostNetwork: true</code> 的 Pod，可以被调度到网络不可用的节点上。</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>增加可以运行在 master 节点的容忍度</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">DaemonSet</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">tolerations:</span>                                   <span class=\"comment\"># 增加容忍度</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">key:</span> <span class=\"string\">&quot;node-role.kubernetes.io/control-plane&quot;</span> <span class=\"comment\"># 容忍控制平面节点</span></span><br><span class=\"line\">        <span class=\"attr\">operator:</span> <span class=\"string\">&quot;Exists&quot;</span>                           <span class=\"comment\"># 操作符</span></span><br><span class=\"line\">        <span class=\"attr\">effect:</span> <span class=\"string\">&quot;NoSchedule&quot;</span>                         <span class=\"comment\"># 污点标签</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">image:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">        <span class=\"attr\">name:</span> <span class=\"string\">nginx</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>增加容忍度后重新运行</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl apply -f daemonset.yaml</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看</span></span><br><span class=\"line\">$ k get pod,ds -o wide</span><br><span class=\"line\">NAME              READY   STATUS    RESTARTS   AGE   IP               NODE          NOMINATED NODE   READINESS GATES</span><br><span class=\"line\">pod/nginx-4gxwh   1/1     Running   0          79m   10.244.235.205   k8s-master    &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">pod/nginx-gx7tf   1/1     Running   0          78m   10.244.126.21    k8s-worker2   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">pod/nginx-sl8cc   1/1     Running   0          78m   10.244.194.92    k8s-worker1   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                   DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE     CONTAINERS   IMAGES   SELECTOR</span><br><span class=\"line\">daemonset.apps/nginx   3         3         3       3            3           &lt;none&gt;          3h42m   nginx        nginx    app=nginx</span><br></pre></td></tr></table></figure>\n<h3 id=\"访问pod中的nginx服务\">访问pod中的nginx服务</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时我们还没有创建 <code>Service</code>(后面章节会介绍)，所以只能通过 Pod 的 IP 访问</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 任意pod的IP，端口80</span></span><br><span class=\"line\">curl http://10.244.194.92</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看-DaemonSet-详情\">查看 DaemonSet 详情</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当 DaemonSet 运行错误时，可以通过该命令查看 DaemonSet 的详情，找到错误原因</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl describe ds &lt;ds-name&gt;</span><br><span class=\"line\">kubectl describe ds &lt;ds-name&gt; -n &lt;namespace-name&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除-DaemonSet\">删除 DaemonSet</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl delete ds &lt;ds-name&gt;</span><br><span class=\"line\">kubectl delete ds &lt;ds-name&gt; -n &lt;namespace-name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 通过 yaml 文件删除</span></span><br><span class=\"line\">kubectl delete -f &lt;yaml-file&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看-DaemonSet-日志\">查看 DaemonSet 日志</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl logs ds/&lt;ds-name&gt;</span><br><span class=\"line\">kubectl logs ds/&lt;ds-name&gt; -n &lt;namespace-name&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"滚动升级与回滚-DaemonSet\">滚动升级与回滚 DaemonSet</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>对 <code>RollingUpdate</code> 类型的 <code>DaemonSet</code> 的 <code>.spec.template</code> 的任何更新都将触发滚动更新。</p>\n</li>\n<li class=\"lvl-2\">\n<p>我们修改过 <code>DaemonSet</code> 的 <code>.spec.template</code>，并保存后，重新运行 <code>kubectl apply -f &lt;yaml-file&gt;</code>即可触发滚动升级。</p>\n</li>\n<li class=\"lvl-2\">\n<p>如果只是更新容器的镜像，也可以通过如下命令触发滚动升级</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># kubectl set image ds/&lt;ds-name&gt; &lt;container-name&gt;=&lt;image&gt;:&lt;tag&gt; --record=true</span></span><br><span class=\"line\">kubectl <span class=\"built_in\">set</span> image ds nginx nginx=nginx:1.9.1 --record=<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看滚动升级状态</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># kubectl rollout status ds/&lt;ds-name&gt;</span></span><br><span class=\"line\">kubectl rollout status ds nginx</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看历史版本</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 前面的序号表示版本号</span></span><br><span class=\"line\">kubectl rollout <span class=\"built_in\">history</span> ds nginx</span><br><span class=\"line\"><span class=\"comment\"># 查看指定版本的详情</span></span><br><span class=\"line\">kubectl rollout <span class=\"built_in\">history</span> ds nginx --revision=1</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>回滚</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 回退到前一个版本</span></span><br><span class=\"line\">kubectl rollout undo ds nginx</span><br><span class=\"line\"><span class=\"comment\"># 回到指定版本，这里 --to-revision=1 表示回到版本1</span></span><br><span class=\"line\">kubectl rollout undo ds nginx --to-revision=1</span><br></pre></td></tr></table></figure>\n<h2 id=\"Deployment-和-DaemonSet-的对比总结\">Deployment 和 DaemonSet 的对比总结</h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th><strong>Deployment</strong></th>\n<th><strong>DaemonSet</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>用途</strong></td>\n<td>管理一组可水平扩展的 Pod，按需副本数运行</td>\n<td>在每个（或特定）节点上运行 <strong>一个副本</strong> 的 Pod</td>\n</tr>\n<tr>\n<td><strong>常见场景</strong></td>\n<td>无状态服务、Web 服务、API、后端服务</td>\n<td>日志采集（如 fluentd）、监控（如 node-exporter）、系统守护进程</td>\n</tr>\n<tr>\n<td><strong>副本控制</strong></td>\n<td>可通过 <code>spec.replicas</code> 灵活控制副本数</td>\n<td>每个匹配的节点自动运行一个 Pod，无需设置 <code>replicas</code></td>\n</tr>\n<tr>\n<td><strong>节点分布</strong></td>\n<td>Pod 分布随机，调度器选择可用节点</td>\n<td>Pod 分布固定，<strong>每个匹配节点必跑一个 Pod</strong></td>\n</tr>\n<tr>\n<td><strong>更新策略</strong></td>\n<td><code>RollingUpdate</code>（默认）、<code>Recreate</code>，支持回滚</td>\n<td><code>RollingUpdate</code>（默认从 Kubernetes 1.6 起支持）</td>\n</tr>\n<tr>\n<td><strong>伸缩方式</strong></td>\n<td><code>kubectl scale deployment</code> 可以水平扩缩容</td>\n<td><strong>不支持手动伸缩</strong>，跟随节点变化自动伸缩</td>\n</tr>\n<tr>\n<td><strong>Pod 更新行为</strong></td>\n<td>按策略滚动更新全部副本</td>\n<td>每个节点上的 Pod 逐个滚动更新</td>\n</tr>\n<tr>\n<td><strong>调度策略</strong></td>\n<td>通过调度器分配节点，可搭配 <code>affinity</code> 使用</td>\n<td>默认调度所有节点，可用 <code>nodeSelector</code>、<code>affinity</code>、<code>taints</code> 控制</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 K8S 的 DaemonSet ，本文以 CentOS 8 为例。 K8S官网 k8s Github k8s DaemonSet 介绍 DaemonSet 介绍 DaemonSet 定义了提供节点本地设施的 Pod。这些设施可能对于集群的运行至关重要，例如网络辅助工具，或者作为 add-on 的一部分。 DaemonSet 确保全部（或者某些）节点上运行一个 Pod 的副本。 当有节点加入集群时， 也会为他们新增一个 Pod 。 当有节点从集群移除时，这些 Pod 也会被回收。删除 DaemonSet 将会删除它创建的所有 Pod。 DaemonSet 的一些典型用法： 在每个节点上运行集群守护进程 在每个节点上运行日志收集守护进程 在每个节点上运行监控守护进程 DaemonSet 与 Deployment 的主要区别是： 无法自定义副本数量 每个node上都会运行且只允许运行一个 Pod 当有新Node加入集群时，会自动在其上部署并运行Pod副本，当Node从集群移除时，这些Pod也会被回收 DaemonSet 管理 DaemonSet 创建 DaemonSet 只能 通过 yaml 创建，不支持 create 创建 12# 通过 yaml 文件创建kubectl apply -f daemonset.yaml 一个简单的 daemonset.yaml 文件说明 1234567891011121314151617181920212223apiVersion: apps/v1 # 指定使用的 API 版本，这里是 apps/v1，适用于 DaemonSet 资源kind: DaemonSet # Kubernetes 资源类型，这里是部署（DaemonSet）metadata: labels: app: nginx # 标签，用于标识资源，可与 selector 匹配 name: nginx # 资源名称，必须唯一（在同一命名空间下）spec: # 配置项 selector: # 选择器，指定要管理的 Pod matchLabels: # 标签选择器 app: nginx # 选择器，指定 DaemonSet 管理哪些 Pod（标签必须与 template 中匹配） updateStrategy: # 更新策略 type: RollingUpdate # RollingUpdate：这是默认的更新策略。使用 RollingUpdate 更新策略时，在更新 DaemonSet 模板后， 老的 DaemonSet Pod 将被终止，并且将以受控方式自动创建新的 DaemonSet Pod。 更新期间，最多只能有 DaemonSet 的一个 Pod 运行于每个节点上。 # OnDelete：使用 OnDelete 更新策略时，在更新 DaemonSet 模板后，只有当你手动删除老的 DaemonSet Pod 之后，新的 DaemonSet Pod 才会被自动创建。 rollingUpdate: # 滚动升级的配置 maxUnavailable: 1 # 最大不可用 Pod 的数量，这里是 1，默认值为 1 template: # 模板，定义 Pod 的内容，具体可以参考 Pod 的配置 metadata: labels: app: nginx # Pod 的标签，必须与 selector 中的 matchLabels 一致 spec: containers: - image: nginx # 容器使用的镜像，这里是官方的 nginx 镜像 name: nginx # 容器的名称 查看 DaemonSet 12345678910111213141516171819202122232425# 查看 DaemonSet ，默认显示 default 命名空间下的 DaemonSetkubectl get daemonsetskubectl get ds # 简称# 查看 kube-system 命名空间下的 DaemonSetkubectl get ds -n kube-system# 查看所有命名空间下的 DaemonSetkubectl get ds -A# -o wide: 显示 deploy 的详细信息kubectl get ds -o wide# 显示 DaemonSet 的标签kubectl get ds --show-labels# 按 DaemonSet 的标签进程查询kubectl get ds -l &lt;label_name&gt;=&lt;label_value&gt;# 持续查看 DaemonSet 的状态，当 DaemonSet 状态发生改变时，会实时显示kubectl get ds -w# 查看 pod、ds 的详细信息$ k get pod,ds -owideNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATESpod/nginx-6g8j8 1/1 Running 0 9m3s 10.244.126.18 k8s-worker2 &lt;none&gt; &lt;none&gt;pod/nginx-tnvhn 1/1 Running 0 9m3s 10.244.194.89 k8s-worker1 &lt;none&gt; &lt;none&gt;NAME DESIRED CURRENT READY UP-TO-DATE AVAILABLE NODE SELECTOR AGE CONTAINERS IMAGES SELECTORdaemonset.apps/nginx 2 2 2 2 2 &lt;none&gt; 9m3s nginx nginx app=nginx 允许 master 节点运行 pod 上面看到pod只在worker1和worker2上运行,而没有在master节点上运行 默认情况下，Kubernetes 不允许在 master 节点上运行 Pod，这是因为master节点有污点 12$ kubectl describe node k8s-master | grep TaintsTaints: node-role.kubernetes.io/control-plane:NoSchedule 为了能让pod运行在具有污点的节点上，我们需要为pod指定容忍度(tolerations)，实际上 DaemonSet 控制器会自动将一组容忍度添加到 DaemonSet Pod 容忍度键名 效果 操作 描述 node.kubernetes.io/not-ready NoExecute Exists DaemonSet Pod 可以被调度到不健康或未就绪的节点上，且不会被驱逐。 node.kubernetes.io/unreachable NoExecute Exists DaemonSet Pod 可以被调度到不可达的节点上，且不会被驱逐。 node.kubernetes.io/disk-pressure NoSchedule Exists DaemonSet Pod 可以被调度到存在磁盘压力的节点上。 node.kubernetes.io/memory-pressure NoSchedule Exists DaemonSet Pod 可以被调度到存在内存压力的节点上。 node.kubernetes.io/pid-pressure NoSchedule Exists DaemonSet Pod 可以被调度到存在进程数压力的节点上。 node.kubernetes.io/unschedulable NoSchedule Exists DaemonSet Pod 可以被调度到标记为不可调度的节点上。 node.kubernetes.io/network-unavailable NoSchedule Exists 针对 spec.hostNetwork: true 的 Pod，可以被调度到网络不可用的节点上。 增加可以运行在 master 节点的容忍度 12345678910111213141516171819202122apiVersion: apps/v1kind: DaemonSetmetadata: labels: app: nginx name: nginxspec: selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: tolerations: # 增加容忍度 - key: &quot;node-role.kubernetes.io/control-plane&quot; # 容忍控制平面节点 operator: &quot;Exists&quot; # 操作符 effect: &quot;NoSchedule&quot; # 污点标签 containers: - image: nginx name: nginx 增加容忍度后重新运行 1234567891011kubectl apply -f daemonset.yaml# 查看$ k get pod,ds -o wideNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATESpod/nginx-4gxwh 1/1 Running 0 79m 10.244.235.205 k8s-master &lt;none&gt; &lt;none&gt;pod/nginx-gx7tf 1/1 Running 0 78m 10.244.126.21 k8s-worker2 &lt;none&gt; &lt;none&gt;pod/nginx-sl8cc 1/1 Running 0 78m 10.244.194.92 k8s-worker1 &lt;none&gt; &lt;none&gt;NAME DESIRED CURRENT READY UP-TO-DATE AVAILABLE NODE SELECTOR AGE CONTAINERS IMAGES SELECTORdaemonset.apps/nginx 3 3 3 3 3 &lt;none&gt; 3h42m nginx nginx app=nginx 访问pod中的nginx服务 此时我们还没有创建 Service(后面章节会介绍)，所以只能通过 Pod 的 IP 访问 12# 任意pod的IP，端口80curl http://10.244.194.92 查看 DaemonSet 详情 当 DaemonSet 运行错误时，可以通过该命令查看 DaemonSet 的详情，找到错误原因 12kubectl describe ds &lt;ds-name&gt;kubectl describe ds &lt;ds-name&gt; -n &lt;namespace-name&gt; 删除 DaemonSet 12345kubectl delete ds &lt;ds-name&gt;kubectl delete ds &lt;ds-name&gt; -n &lt;namespace-name&gt;# 通过 yaml 文件删除kubectl delete -f &lt;yaml-file&gt; 查看 DaemonSet 日志 12kubectl logs ds/&lt;ds-name&gt;kubectl logs ds/&lt;ds-name&gt; -n &lt;namespace-name&gt; 滚动升级与回滚 DaemonSet 对 RollingUpdate 类型的 DaemonSet 的 .spec.template 的任何更新都将触发滚动更新。 我们修改过 DaemonSet 的 .spec.template，并保存后，重新运行 kubectl apply -f &lt;yaml-file&gt;即可触发滚动升级。 如果只是更新容器的镜像，也可以通过如下命令触发滚动升级 12# kubectl set image ds/&lt;ds-name&gt; &lt;container-name&gt;=&lt;image&gt;:&lt;tag&gt; --record=truekubectl set image ds nginx nginx=nginx:1.9.1 --record=true 查看滚动升级状态 12# kubectl rollout status ds/&lt;ds-name&gt;kubectl rollout status ds nginx 查看历史版本 1234# 前面的序号表示版本号kubectl rollout history ds nginx# 查看指定版本的详情kubectl rollout history ds nginx --revision=1 回滚 1234# 回退到前一个版本kubectl rollout undo ds nginx# 回到指定版本，这里 --to-revision=1 表示回到版本1kubectl rollout undo ds nginx --to-revision=1 Deployment 和 DaemonSet 的对比总结 特性 Deployment DaemonSet 用途 管理一组可水平扩展的 Pod，按需副本数运行 在每个（或特定）节点上运行 一个副本 的 Pod 常见场景 无状态服务、Web 服务、API、后端服务 日志采集（如 fluentd）、监控（如 node-exporter）、系统守护进程 副本控制 可通过 spec.replicas 灵活控制副本数 每个匹配的节点自动运行一个 Pod，无需设置 replicas 节点分布 Pod 分布随机，调度器选择可用节点 Pod 分布固定，每个匹配节点必跑一个 Pod 更新策略 RollingUpdate（默认）、Recreate，支持回滚 RollingUpdate（默认从 Kubernetes 1.6 起支持） 伸缩方式 kubectl scale deployment 可以水平扩缩容 不支持手动伸缩，跟随节点变化自动伸缩 Pod 更新行为 按策略滚动更新全部副本 每个节点上的 Pod 逐个滚动更新 调度策略 通过调度器分配节点，可搭配 affinity 使用 默认调度所有节点，可用 nodeSelector、affinity、taints 控制","summary":"摘要 本文介绍 K8S 的 DaemonSet ，本文以 CentOS 8 为例。 K8S官网 k8s Github k8s DaemonSet 介绍","date_published":"2025-07-15T14:30:05.000Z","tags":["技术","k8s","K8S"]},{"id":"https://blog.hanqunfeng.com/2025/07/14/k8s-deployment/","url":"https://blog.hanqunfeng.com/2025/07/14/k8s-deployment/","title":"K8S 之 Deployment","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 K8S 的 Deployment，本文以 CentOS 8 为例。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/\">K8S官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/kubernetes/kubernetes\">k8s Github</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/\">k8s Deployment 介绍</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Deployment-介绍\">Deployment 介绍</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在使用k8s创建容器时，我们一般不会直接创建pod，而是创建 deployment，daemonSet，StatefulSet等等。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Deployment 用于管理运行一个应用负载的一组 Pod，通常适用于不保持状态的负载。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Deployment 是最常用的无状态服务控制器，由Deployment、ReplicaSet、Pod组成、支持集群扩容缩容、滚动、更新、自动维护Pod可用性及副本数量等功能，<a href=\"https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/\">ReplicaSet</a>和Pod由Deployment自动管理，用户无需干预，也就是说，创建一个Deployment后，K8S会自动创建ReplicaSet，并创建指定数量的Pod。<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/Tcj2Px.png\" alt=\"\" width=\"1200\" height=\"600\"></p>\n</li>\n</ul>\n<h2 id=\"Deployment-管理\">Deployment 管理</h2>\n<h3 id=\"Deployment-创建\">Deployment 创建</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>create</code> 创建</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建 deployment</span></span><br><span class=\"line\">kubectl create deployment nginx --image=nginx</span><br><span class=\"line\"><span class=\"comment\"># 多副本，--replicas=3 创建3个副本</span></span><br><span class=\"line\">kubectl create deployment nginx --image=nginx --replicas=3</span><br><span class=\"line\"><span class=\"comment\"># -o 生成 yaml 文件, --dry-run: 不真的执行创建</span></span><br><span class=\"line\">kubectl create deployment nginx --image=nginx --replicas=3 --dry-run=client -o yaml &gt; deployment.yaml</span><br><span class=\"line\"><span class=\"comment\"># 通过 yaml 文件创建</span></span><br><span class=\"line\">kubectl apply -f deployment.yaml</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>一个简单的 <code>deployment.yaml</code> 文件说明</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span>                  <span class=\"comment\"># 指定使用的 API 版本，这里是 apps/v1，适用于 Deployment 资源</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span>                     <span class=\"comment\"># Kubernetes 资源类型，这里是部署（Deployment）</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">nginx</span>                       <span class=\"comment\"># 标签，用于标识资源，可与 selector 匹配</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx</span>                        <span class=\"comment\"># 资源名称，必须唯一（在同一命名空间下）</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span>                                <span class=\"comment\"># 配置项</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">3</span>                        <span class=\"comment\"># 副本数，表示希望运行多少个 Pod 实例</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span>                          <span class=\"comment\"># 选择器，指定要管理的 Pod</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span>                     <span class=\"comment\"># 标签选择器</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">nginx</span>                     <span class=\"comment\"># 选择器，指定 Deployment 管理哪些 Pod（标签必须与 template 中匹配）</span></span><br><span class=\"line\">  <span class=\"attr\">strategy:</span>                          <span class=\"comment\"># 用新Pod替换现有Pod的部署策略，可省略，默认就是滚动更新</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">RollingUpdate</span>              <span class=\"comment\"># 滚动更新策略</span></span><br><span class=\"line\">    <span class=\"attr\">rollingUpdate:</span>                   <span class=\"comment\"># 滚动更新方式，type: RollingUpdate 时有效</span></span><br><span class=\"line\">      <span class=\"attr\">maxSurge:</span> <span class=\"number\">30</span><span class=\"string\">%</span>                  <span class=\"comment\"># 最大额外可以存在的副本数，可以为百分比，也可以为整数，默认为 25%</span></span><br><span class=\"line\">      <span class=\"attr\">maxUnavailable:</span> <span class=\"number\">30</span><span class=\"string\">%</span>            <span class=\"comment\"># 最大不可用状态的 Pod 的最大值，可以为百分比，也可以为整数，默认为 25%</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span>                          <span class=\"comment\"># 模板，定义 Pod 的内容，具体可以参考 Pod 的配置</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">nginx</span>                   <span class=\"comment\"># Pod 的标签，必须与 selector 中的 matchLabels 一致</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">image:</span> <span class=\"string\">nginx</span>                 <span class=\"comment\"># 容器使用的镜像，这里是官方的 nginx 镜像</span></span><br><span class=\"line\">        <span class=\"attr\">name:</span> <span class=\"string\">nginx</span>                  <span class=\"comment\"># 容器的名称</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 需要新了解的配置项就是spec下面几个选项：</span></span><br><span class=\"line\"><span class=\"comment\"># replicas：指定副本数量，其实就是当前rs创建出来的pod的数量，默认为1</span></span><br><span class=\"line\"><span class=\"comment\"># selector：选择器，它的作用是建立pod控制器和pod之间的关联关系，采用的Label Selector机制，在pod模板上定义label，在控制器上定义选择器，就可以表明当前控制器能管理哪些pod了</span></span><br><span class=\"line\"><span class=\"comment\"># template：模板，就是当前控制器创建pod所使用的模板，里面其实就是前一章学过的pod的定义</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>获取 deployment 的 yaml 文件配置项帮助</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 比如，这里查看用新Pod替换现有Pod的部署策略</span></span><br><span class=\"line\">$ kubectl explain deployment.spec.strategy</span><br><span class=\"line\"><span class=\"comment\">## 输出结果</span></span><br><span class=\"line\">DESCRIPTION:</span><br><span class=\"line\">    The deployment strategy to use to replace existing pods with new ones.</span><br><span class=\"line\">    DeploymentStrategy describes how to replace existing pods with new ones.</span><br><span class=\"line\"></span><br><span class=\"line\">FIELDS:</span><br><span class=\"line\">  rollingUpdate\t&lt;RollingUpdateDeployment&gt;</span><br><span class=\"line\">    Rolling update config params. Present only <span class=\"keyword\">if</span> DeploymentStrategyType =</span><br><span class=\"line\">    RollingUpdate.</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">type</span>\t&lt;string&gt;</span><br><span class=\"line\">  enum: Recreate, RollingUpdate</span><br><span class=\"line\">    Type of deployment. Can be <span class=\"string\">&quot;Recreate&quot;</span> or <span class=\"string\">&quot;RollingUpdate&quot;</span>. Default is</span><br><span class=\"line\">        RollingUpdate.</span><br><span class=\"line\"></span><br><span class=\"line\">        Possible enum values:</span><br><span class=\"line\">        <span class=\"comment\"># 在创建新pod之前，先删除所有现有的pod</span></span><br><span class=\"line\">        - `<span class=\"string\">&quot;Recreate&quot;</span>` Kill all existing pods before creating new ones.</span><br><span class=\"line\">        <span class=\"comment\"># 使用滚动更新方式用新的 ReplicaSet 替换旧的 ReplicaSet更新，即逐步缩减旧的ReplicaSet并扩大新的ReplicaSet</span></span><br><span class=\"line\">        - `<span class=\"string\">&quot;RollingUpdate&quot;</span>` Replace the old ReplicaSets by new one using rolling update i.e gradually scale down the old ReplicaSets and scale up the new one.</span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>小贴士</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">yaml 文件中，出现了 <code>metadata.labels</code>,<code>spec.selector.matchLabels</code> 以及 <code>template.metadata.labels</code>，三者是什么关系？</li>\n</ul>\n<ol>\n<li class=\"lvl-3\">metadata.labels（Deployment 的标签）</li>\n</ol>\n<blockquote>\n<p>给 Deployment 本身 打的标签, 和 Pod 没有直接管理关系<br>\n常用于资源分组、查找（比如：kubectl get deploy -l app=nginx）</p>\n</blockquote>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">nginx</span>   <span class=\"comment\"># 属于这个 Deployment 的“标签”，只是标识它自己</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>spec.selector.matchLabels（选择器）</p>\n</li>\n</ol>\n<blockquote>\n<p>指定 Deployment 要管理哪些 Pod<br>\n必须精确匹配 Pod 的标签<br>\n决定 Deployment 会不会“接管”某些 Pod</p>\n</blockquote>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">nginx</span></span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li class=\"lvl-3\">\n<p>template.metadata.labels（模板中的 Pod 标签）</p>\n</li>\n</ol>\n<blockquote>\n<p>Pod 模板中定义的标签<br>\nDeployment 按这个模板创建 Pod<br>\n必须与 matchLabels 完全一致，否则会报错</p>\n</blockquote>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">template:</span></span><br><span class=\"line\">  <span class=\"attr\">metadata:</span></span><br><span class=\"line\">    <span class=\"attr\">labels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">nginx</span>   <span class=\"comment\"># Pod 的标签，必须与 selector 匹配！</span></span><br></pre></td></tr></table></figure>\n<p>🔁 关系图示意：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"string\">│</span></span><br><span class=\"line\"><span class=\"string\">├─</span> <span class=\"string\">metadata.labels</span>                <span class=\"string\">←</span> <span class=\"string\">Deployment</span> <span class=\"string\">本身的标签（非关键）</span></span><br><span class=\"line\"><span class=\"string\">│</span></span><br><span class=\"line\"><span class=\"string\">├─</span> <span class=\"string\">spec.selector.matchLabels</span> <span class=\"string\">─┐</span></span><br><span class=\"line\"><span class=\"string\">│</span>                             <span class=\"string\">│</span></span><br><span class=\"line\"><span class=\"string\">└─</span> <span class=\"string\">spec.template.metadata.labels</span> <span class=\"string\">←</span> <span class=\"string\">必须匹配</span> <span class=\"string\">selector，才能让</span> <span class=\"string\">Pod</span> <span class=\"string\">被</span> <span class=\"string\">Deployment</span> <span class=\"string\">管理</span></span><br></pre></td></tr></table></figure>\n</div>\n<h3 id=\"Deployment-扩缩容\">Deployment 扩缩容</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 扩容到5个，原先有3个，这里会再创建2个</span></span><br><span class=\"line\">kubectl scale deployment nginx --replicas=5</span><br><span class=\"line\"><span class=\"comment\"># 缩容到3个，原先有5个，这里会删除2个</span></span><br><span class=\"line\">kubectl scale deployment nginx --replicas=3</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看-Deployment\">查看 Deployment</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看 Deployment ，默认显示 default 命名空间下的 deployments</span></span><br><span class=\"line\">kubectl get deployments</span><br><span class=\"line\">kubectl get deploy <span class=\"comment\"># 简称</span></span><br><span class=\"line\"><span class=\"comment\"># 查看 kube-system 命名空间下的 Deployment</span></span><br><span class=\"line\">kubectl get deploy -n kube-system</span><br><span class=\"line\"><span class=\"comment\"># 查看所有命名空间下的 Deployment</span></span><br><span class=\"line\">kubectl get deploy -A</span><br><span class=\"line\"><span class=\"comment\"># -o wide: 显示 deploy 的详细信息</span></span><br><span class=\"line\">kubectl get deployments -o wide</span><br><span class=\"line\"><span class=\"comment\"># 显示 Deployment 的标签</span></span><br><span class=\"line\">kubectl get deploy --show-labels</span><br><span class=\"line\"><span class=\"comment\"># 按 Deployment 的标签进程查询</span></span><br><span class=\"line\">kubectl get deploy -l &lt;label_name&gt;=&lt;label_value&gt;</span><br><span class=\"line\"><span class=\"comment\"># 持续查看 Deployment 的状态，当 Deployment 状态发生改变时，会实时显示</span></span><br><span class=\"line\">kubectl get deploy -w</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看 pod、deploy、replicaset</span></span><br><span class=\"line\">$ k get pod,deploy,rs -owide</span><br><span class=\"line\">NAME                         READY   STATUS    RESTARTS   AGE    IP              NODE          NOMINATED NODE   READINESS GATES</span><br><span class=\"line\">pod/nginx-5869d7778c-4sqwf   1/1     Running   0          105s   10.244.126.11   k8s-worker2   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">pod/nginx-5869d7778c-kn6pg   1/1     Running   0          105s   10.244.126.12   k8s-worker2   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">pod/nginx-5869d7778c-zkwkd   1/1     Running   0          18m    10.244.194.82   k8s-worker1   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                    READY   UP-TO-DATE   AVAILABLE   AGE   CONTAINERS   IMAGES   SELECTOR</span><br><span class=\"line\">deployment.apps/nginx   3/3     3            3           18m   nginx        nginx    app=nginx</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                               DESIRED   CURRENT   READY   AGE   CONTAINERS   IMAGES   SELECTOR</span><br><span class=\"line\">replicaset.apps/nginx-5869d7778c   3         3         3       18m   nginx        nginx    app=nginx,pod-template-hash=5869d7778c</span><br></pre></td></tr></table></figure>\n<h3 id=\"访问pod中的nginx服务\">访问pod中的nginx服务</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时我们还没有创建 <code>Service</code>(后面章节会介绍)，所以只能通过 Pod 的 IP 访问</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 任意pod的IP，端口80</span></span><br><span class=\"line\">curl http://10.244.194.82</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看-Deployment-详情\">查看 Deployment 详情</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当 Deployment 运行错误时，可以通过该命令查看 Deployment 的详情，找到错误原因</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl describe deploy &lt;deploy-name&gt;</span><br><span class=\"line\">kubectl describe deploy &lt;deploy-name&gt; -n &lt;namespace-name&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除-Deployment\">删除 Deployment</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl delete deploy &lt;deploy-name&gt;</span><br><span class=\"line\">kubectl delete deploy &lt;deploy-name&gt; -n &lt;namespace-name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 通过 yaml 文件删除</span></span><br><span class=\"line\">kubectl delete -f &lt;yaml-file&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看-Deployment-日志\">查看 Deployment 日志</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl logs deploy/&lt;deploy-name&gt;</span><br><span class=\"line\">kubectl logs deploy/&lt;deploy-name&gt; -n &lt;namespace-name&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"滚动升级与回滚-Deployment\">滚动升级与回滚 Deployment</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>对 <code>RollingUpdate</code> 类型的 <code>Deployment</code> 的 <code>.spec.template</code> 的任何更新都将触发滚动更新。</p>\n</li>\n<li class=\"lvl-2\">\n<p>我们修改过 <code>Deployment</code> 的 <code>.spec.template</code>，并保存后，重新运行 <code>kubectl apply -f &lt;yaml-file&gt;</code>即可触发滚动升级。</p>\n</li>\n<li class=\"lvl-2\">\n<p>如果只是更新容器的镜像，也可以通过如下命令触发滚动升级</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># set image: 这里表示要改变的是镜像， --record=true 表示记录此次操作</span></span><br><span class=\"line\"><span class=\"comment\"># kubectl set image deploy &lt;deploy-name&gt; &lt;container-name&gt;=&lt;image-name&gt;:&lt;tag&gt;</span></span><br><span class=\"line\">kubectl <span class=\"built_in\">set</span> image deploy nginx nginx=nginx:1.9.1 --record=<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看历史版本</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 前面的序号表示版本号</span></span><br><span class=\"line\">$ kubectl rollout <span class=\"built_in\">history</span> deploy nginx</span><br><span class=\"line\">deployment.apps/nginx</span><br><span class=\"line\">REVISION  CHANGE-CAUSE</span><br><span class=\"line\">1         &lt;none&gt;</span><br><span class=\"line\">2         kubectl <span class=\"built_in\">set</span> image deploy nginx nginx=nginx:1.9.1 --record=<span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看指定版本的详情</span></span><br><span class=\"line\">kubectl rollout <span class=\"built_in\">history</span> deploy nginx --revision=1</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看更新状态</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl rollout status deploy nginx</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>回滚</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 回退到前一个版本</span></span><br><span class=\"line\">kubectl rollout undo deploy nginx</span><br><span class=\"line\"><span class=\"comment\"># 回到指定版本，这里 --to-revision=1 表示回到版本1</span></span><br><span class=\"line\">kubectl rollout undo deploy nginx --to-revision=1</span><br></pre></td></tr></table></figure>\n","content_text":"摘要 本文介绍 K8S 的 Deployment，本文以 CentOS 8 为例。 K8S官网 k8s Github k8s Deployment 介绍 Deployment 介绍 在使用k8s创建容器时，我们一般不会直接创建pod，而是创建 deployment，daemonSet，StatefulSet等等。 Deployment 用于管理运行一个应用负载的一组 Pod，通常适用于不保持状态的负载。 Deployment 是最常用的无状态服务控制器，由Deployment、ReplicaSet、Pod组成、支持集群扩容缩容、滚动、更新、自动维护Pod可用性及副本数量等功能，ReplicaSet和Pod由Deployment自动管理，用户无需干预，也就是说，创建一个Deployment后，K8S会自动创建ReplicaSet，并创建指定数量的Pod。 Deployment 管理 Deployment 创建 create 创建 12345678# 创建 deploymentkubectl create deployment nginx --image=nginx# 多副本，--replicas=3 创建3个副本kubectl create deployment nginx --image=nginx --replicas=3# -o 生成 yaml 文件, --dry-run: 不真的执行创建kubectl create deployment nginx --image=nginx --replicas=3 --dry-run=client -o yaml &gt; deployment.yaml# 通过 yaml 文件创建kubectl apply -f deployment.yaml 一个简单的 deployment.yaml 文件说明 1234567891011121314151617181920212223242526272829apiVersion: apps/v1 # 指定使用的 API 版本，这里是 apps/v1，适用于 Deployment 资源kind: Deployment # Kubernetes 资源类型，这里是部署（Deployment）metadata: labels: app: nginx # 标签，用于标识资源，可与 selector 匹配 name: nginx # 资源名称，必须唯一（在同一命名空间下）spec: # 配置项 replicas: 3 # 副本数，表示希望运行多少个 Pod 实例 selector: # 选择器，指定要管理的 Pod matchLabels: # 标签选择器 app: nginx # 选择器，指定 Deployment 管理哪些 Pod（标签必须与 template 中匹配） strategy: # 用新Pod替换现有Pod的部署策略，可省略，默认就是滚动更新 type: RollingUpdate # 滚动更新策略 rollingUpdate: # 滚动更新方式，type: RollingUpdate 时有效 maxSurge: 30% # 最大额外可以存在的副本数，可以为百分比，也可以为整数，默认为 25% maxUnavailable: 30% # 最大不可用状态的 Pod 的最大值，可以为百分比，也可以为整数，默认为 25% template: # 模板，定义 Pod 的内容，具体可以参考 Pod 的配置 metadata: labels: app: nginx # Pod 的标签，必须与 selector 中的 matchLabels 一致 spec: containers: - image: nginx # 容器使用的镜像，这里是官方的 nginx 镜像 name: nginx # 容器的名称# 需要新了解的配置项就是spec下面几个选项：# replicas：指定副本数量，其实就是当前rs创建出来的pod的数量，默认为1# selector：选择器，它的作用是建立pod控制器和pod之间的关联关系，采用的Label Selector机制，在pod模板上定义label，在控制器上定义选择器，就可以表明当前控制器能管理哪些pod了# template：模板，就是当前控制器创建pod所使用的模板，里面其实就是前一章学过的pod的定义 获取 deployment 的 yaml 文件配置项帮助 12345678910111213141516171819202122# 比如，这里查看用新Pod替换现有Pod的部署策略$ kubectl explain deployment.spec.strategy## 输出结果DESCRIPTION: The deployment strategy to use to replace existing pods with new ones. DeploymentStrategy describes how to replace existing pods with new ones.FIELDS: rollingUpdate &lt;RollingUpdateDeployment&gt; Rolling update config params. Present only if DeploymentStrategyType = RollingUpdate. type &lt;string&gt; enum: Recreate, RollingUpdate Type of deployment. Can be &quot;Recreate&quot; or &quot;RollingUpdate&quot;. Default is RollingUpdate. Possible enum values: # 在创建新pod之前，先删除所有现有的pod - `&quot;Recreate&quot;` Kill all existing pods before creating new ones. # 使用滚动更新方式用新的 ReplicaSet 替换旧的 ReplicaSet更新，即逐步缩减旧的ReplicaSet并扩大新的ReplicaSet - `&quot;RollingUpdate&quot;` Replace the old ReplicaSets by new one using rolling update i.e gradually scale down the old ReplicaSets and scale up the new one. 小贴士 yaml 文件中，出现了 metadata.labels,spec.selector.matchLabels 以及 template.metadata.labels，三者是什么关系？ metadata.labels（Deployment 的标签） 给 Deployment 本身 打的标签, 和 Pod 没有直接管理关系 常用于资源分组、查找（比如：kubectl get deploy -l app=nginx） 123metadata: labels: app: nginx # 属于这个 Deployment 的“标签”，只是标识它自己 spec.selector.matchLabels（选择器） 指定 Deployment 要管理哪些 Pod 必须精确匹配 Pod 的标签 决定 Deployment 会不会“接管”某些 Pod 1234spec: selector: matchLabels: app: nginx template.metadata.labels（模板中的 Pod 标签） Pod 模板中定义的标签 Deployment 按这个模板创建 Pod 必须与 matchLabels 完全一致，否则会报错 1234template: metadata: labels: app: nginx # Pod 的标签，必须与 selector 匹配！ 🔁 关系图示意： 1234567Deployment│├─ metadata.labels ← Deployment 本身的标签（非关键）│├─ spec.selector.matchLabels ─┐│ │└─ spec.template.metadata.labels ← 必须匹配 selector，才能让 Pod 被 Deployment 管理 Deployment 扩缩容 1234# 扩容到5个，原先有3个，这里会再创建2个kubectl scale deployment nginx --replicas=5# 缩容到3个，原先有5个，这里会删除2个kubectl scale deployment nginx --replicas=3 查看 Deployment 12345678910111213141516171819202122232425262728# 查看 Deployment ，默认显示 default 命名空间下的 deploymentskubectl get deploymentskubectl get deploy # 简称# 查看 kube-system 命名空间下的 Deploymentkubectl get deploy -n kube-system# 查看所有命名空间下的 Deploymentkubectl get deploy -A# -o wide: 显示 deploy 的详细信息kubectl get deployments -o wide# 显示 Deployment 的标签kubectl get deploy --show-labels# 按 Deployment 的标签进程查询kubectl get deploy -l &lt;label_name&gt;=&lt;label_value&gt;# 持续查看 Deployment 的状态，当 Deployment 状态发生改变时，会实时显示kubectl get deploy -w# 查看 pod、deploy、replicaset$ k get pod,deploy,rs -owideNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATESpod/nginx-5869d7778c-4sqwf 1/1 Running 0 105s 10.244.126.11 k8s-worker2 &lt;none&gt; &lt;none&gt;pod/nginx-5869d7778c-kn6pg 1/1 Running 0 105s 10.244.126.12 k8s-worker2 &lt;none&gt; &lt;none&gt;pod/nginx-5869d7778c-zkwkd 1/1 Running 0 18m 10.244.194.82 k8s-worker1 &lt;none&gt; &lt;none&gt;NAME READY UP-TO-DATE AVAILABLE AGE CONTAINERS IMAGES SELECTORdeployment.apps/nginx 3/3 3 3 18m nginx nginx app=nginxNAME DESIRED CURRENT READY AGE CONTAINERS IMAGES SELECTORreplicaset.apps/nginx-5869d7778c 3 3 3 18m nginx nginx app=nginx,pod-template-hash=5869d7778c 访问pod中的nginx服务 此时我们还没有创建 Service(后面章节会介绍)，所以只能通过 Pod 的 IP 访问 12# 任意pod的IP，端口80curl http://10.244.194.82 查看 Deployment 详情 当 Deployment 运行错误时，可以通过该命令查看 Deployment 的详情，找到错误原因 12kubectl describe deploy &lt;deploy-name&gt;kubectl describe deploy &lt;deploy-name&gt; -n &lt;namespace-name&gt; 删除 Deployment 12345kubectl delete deploy &lt;deploy-name&gt;kubectl delete deploy &lt;deploy-name&gt; -n &lt;namespace-name&gt;# 通过 yaml 文件删除kubectl delete -f &lt;yaml-file&gt; 查看 Deployment 日志 12kubectl logs deploy/&lt;deploy-name&gt;kubectl logs deploy/&lt;deploy-name&gt; -n &lt;namespace-name&gt; 滚动升级与回滚 Deployment 对 RollingUpdate 类型的 Deployment 的 .spec.template 的任何更新都将触发滚动更新。 我们修改过 Deployment 的 .spec.template，并保存后，重新运行 kubectl apply -f &lt;yaml-file&gt;即可触发滚动升级。 如果只是更新容器的镜像，也可以通过如下命令触发滚动升级 123# set image: 这里表示要改变的是镜像， --record=true 表示记录此次操作# kubectl set image deploy &lt;deploy-name&gt; &lt;container-name&gt;=&lt;image-name&gt;:&lt;tag&gt;kubectl set image deploy nginx nginx=nginx:1.9.1 --record=true 查看历史版本 123456789# 前面的序号表示版本号$ kubectl rollout history deploy nginxdeployment.apps/nginxREVISION CHANGE-CAUSE1 &lt;none&gt;2 kubectl set image deploy nginx nginx=nginx:1.9.1 --record=true# 查看指定版本的详情kubectl rollout history deploy nginx --revision=1 查看更新状态 1kubectl rollout status deploy nginx 回滚 1234# 回退到前一个版本kubectl rollout undo deploy nginx# 回到指定版本，这里 --to-revision=1 表示回到版本1kubectl rollout undo deploy nginx --to-revision=1","summary":"摘要 本文介绍 K8S 的 Deployment，本文以 CentOS 8 为例。 K8S官网 k8s Github k8s Deployment 介绍","date_published":"2025-07-14T14:30:05.000Z","tags":["技术","k8s","K8S"]},{"id":"https://blog.hanqunfeng.com/2025/07/04/k8s-pod/","url":"https://blog.hanqunfeng.com/2025/07/04/k8s-pod/","title":"K8S 之 Pod","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 K8S 的 Pod，本文以 CentOS 8 为例。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/\">K8S官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/kubernetes/kubernetes\">k8s Github</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/\">k8s Pod 介绍</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Pod-介绍\">Pod 介绍</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Pod 是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Pod（就像在豌豆荚中）是一组（一个或多个） 容器，这些容器共享存储、网络、以及怎样运行这些容器的规约。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Pod 中的内容总是并置（colocated）的并且一同调度，在共享的上下文中运行。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Kubernetes 集群中的 Pod 主要有两种用法：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">运行单个容器的 Pod: &quot;每个 Pod 一个容器&quot;模型是最常见的 Kubernetes 用例，在这种情况下，可以将 Pod 看作单个容器的包装器，并且 Kubernetes 直接管理 Pod，而不是容器。</li>\n<li class=\"lvl-4\">运行多个协同工作的容器的 Pod: Pod 可以封装由紧密耦合且需要共享资源的多个并置容器组成的应用，这些位于同一位置的容器构成一个内聚单元。<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/nLmg0X.png\" alt=\"\"></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Pod-管理\">Pod 管理</h2>\n<h3 id=\"Pod-创建\">Pod 创建</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>run</code> 创建</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl run nginx --image=nginx</span><br><span class=\"line\"><span class=\"comment\"># 输出 yaml</span></span><br><span class=\"line\">kubectl run nginx --image=nginx --dry-run=client -o yaml &gt; pod.yaml</span><br><span class=\"line\"><span class=\"comment\"># 通过 yaml 文件创建</span></span><br><span class=\"line\">kubectl apply -f pod.yaml</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>pod 中至少包含两个容器，一个是业务容器，比如这里的 nginx，另一个是 <code>pause</code> 容器，负责共享容器的网络，进程，存储等资源。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 通过 crictl ps 是看不到 pause 容器的，我们可以使用 ctr 命令查看，ctr 是 containerd 的命令行工具</span></span><br><span class=\"line\">ctr --namespace=k8s.io c <span class=\"built_in\">ls</span></span><br><span class=\"line\"><span class=\"comment\"># 查看容器所属的pod</span></span><br><span class=\"line\">ctr --namespace=k8s.io c info &lt;container-id&gt; | grep <span class=\"string\">&#x27;pod.name&#x27;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"pod-yaml-文件说明\"><code>pod.yaml</code> 文件说明</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>因为 Pod 不支持扩缩容，所以日常使用时一般不会直接创建 Pod，而是创建 <code>Deployment</code>, <code>DaemonSet</code>等这些工作负载资源，这些后面会介绍到。</p>\n</li>\n<li class=\"lvl-2\">\n<p>但我们这里还是要重点介绍一下 Pod 的 yaml 文件格式，因为它是后面所有资源创建的基础。</p>\n</li>\n<li class=\"lvl-2\">\n<p>一个最基础的 Pod 配置如下：</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span>                   <span class=\"comment\"># 必填。指定使用的 API 版本，Pod 是核心资源，使用 v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span>                        <span class=\"comment\"># 必填。资源类型：Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span>                        <span class=\"comment\"># 必填。元数据，包含 Pod 的名称、命名空间、标签、注解等信息</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx</span>                    <span class=\"comment\"># 必填。Pod 的名称，命名空间中唯一</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span>                            <span class=\"comment\"># 必填。资源的特性描述（规约），定义Pod具体行为的部分</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span>                    <span class=\"comment\"># 必填。容器列表</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">image:</span> <span class=\"string\">nginx</span>                 <span class=\"comment\"># 必填。容器使用的镜像</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">nginx</span>                  <span class=\"comment\"># 必填。容器名称，在同一个 Pod 内必须唯一</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Pod是用来配置容器的，我们在学习docker时知道，容器有非常多的配置项，比如端口、网络、存储等，而 pod 的配置项更丰富。</p>\n</li>\n<li class=\"lvl-2\">\n<p>一个Pod的配置主要包含两大部分：<code>metadata</code> 和 <code>spec</code>，每一项中包含的配置项非常多，这里只对常用的配置项进行说明，若要查看每个配置项的说明可以通过如下命令获取：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># pod开头，配置项以 . 连接，例如：</span></span><br><span class=\"line\">kubectl explain pod.metadata</span><br><span class=\"line\">kubectl explain pod.metadata.labels</span><br><span class=\"line\">kubectl explain pod.spec</span><br><span class=\"line\">kubectl explain pod.spec.containers</span><br><span class=\"line\">kubectl explain pod.spec.containers.ports</span><br></pre></td></tr></table></figure>\n<h4 id=\"metadata\">metadata</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>metadata 是 Pod 的元数据，比如 Pod 的名称、命名空间、标签、注解等。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">metadata:</span>                 <span class=\"comment\"># 元数据部分</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">myapp-pod</span>         <span class=\"comment\"># Pod 的名称</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">default</span>      <span class=\"comment\"># Pod 所在的命名空间，默认是 default</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span>                 <span class=\"comment\"># 标签，用于选择器、管理、分组</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">myapp</span></span><br><span class=\"line\">    <span class=\"attr\">tier:</span> <span class=\"string\">frontend</span></span><br><span class=\"line\">  <span class=\"attr\">annotations:</span>            <span class=\"comment\"># 注解，用于添加非结构化元信息</span></span><br><span class=\"line\">    <span class=\"attr\">description:</span> <span class=\"string\">&quot;A sample pod for demonstration&quot;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"spec\">spec</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>spec 描述了 Pod 的配置信息，包括 Pod 的容器、存储、网络、资源限制、调度策略等</p>\n</li>\n</ul>\n<h5 id=\"spec-containers\">spec.containers</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>containers 描述了 Pod 中容器的配置信息，包括镜像、启动命令、环境变量、资源限制、卷挂载等</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spec:</span>                      <span class=\"comment\">#必选，Pod中容器的详细定义</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span>              <span class=\"comment\">#必选，Pod中容器列表</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">string</span>           <span class=\"comment\">#必选，容器名称</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">string</span>          <span class=\"comment\">#必选，容器的镜像名称</span></span><br><span class=\"line\">    <span class=\"attr\">imagePullPolicy:</span> [ <span class=\"string\">Always|Never|IfNotPresent</span> ]   <span class=\"comment\">#获取镜像的策略，当镜像标签为 latest 时默认值为 Always，否则为 IfNotPresent</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">string</span>]      <span class=\"comment\">#容器的启动命令列表，如不指定，使用打包时使用的启动命令</span></span><br><span class=\"line\">    <span class=\"attr\">args:</span> [<span class=\"string\">string</span>]         <span class=\"comment\">#容器的启动命令参数列表</span></span><br><span class=\"line\">    <span class=\"attr\">workingDir:</span> <span class=\"string\">string</span>     <span class=\"comment\">#容器的工作目录，如果为指定，则默认为镜像中的配置</span></span><br><span class=\"line\">    <span class=\"attr\">volumeMounts:</span>          <span class=\"comment\">#挂载到容器内部的存储卷配置</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">string</span>         <span class=\"comment\">#引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名</span></span><br><span class=\"line\">      <span class=\"attr\">mountPath:</span> <span class=\"string\">string</span>    <span class=\"comment\">#存储卷在容器内mount的绝对路径，应少于512字符</span></span><br><span class=\"line\">      <span class=\"attr\">readOnly:</span> <span class=\"string\">boolean</span>    <span class=\"comment\">#是否为只读模式</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span>                 <span class=\"comment\">#需要暴露的端口库号列表</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">string</span>         <span class=\"comment\">#端口的名称</span></span><br><span class=\"line\">      <span class=\"attr\">containerPort:</span> <span class=\"number\">80</span>    <span class=\"comment\">#容器需要监听的端口号</span></span><br><span class=\"line\">      <span class=\"attr\">hostPort:</span> <span class=\"string\">int</span>        <span class=\"comment\">#容器所在主机需要监听的端口号，默认与Container相同</span></span><br><span class=\"line\">      <span class=\"attr\">protocol:</span> <span class=\"string\">string</span>     <span class=\"comment\">#端口协议，支持TCP和UDP，默认TCP</span></span><br><span class=\"line\">    <span class=\"attr\">env:</span>                   <span class=\"comment\">#容器运行前需设置的环境变量列表</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">string</span>         <span class=\"comment\">#环境变量名称</span></span><br><span class=\"line\">      <span class=\"attr\">value:</span> <span class=\"string\">string</span>        <span class=\"comment\">#环境变量的值</span></span><br><span class=\"line\">    <span class=\"attr\">resources:</span>             <span class=\"comment\">#资源限制和请求的设置</span></span><br><span class=\"line\">      <span class=\"attr\">limits:</span>              <span class=\"comment\">#资源限制的设置(上限)</span></span><br><span class=\"line\">        <span class=\"attr\">cpu:</span> <span class=\"string\">string</span>        <span class=\"comment\">#Cpu的限制，单位为core数，将用于docker run --cpu-shares参数</span></span><br><span class=\"line\">        <span class=\"attr\">memory:</span> <span class=\"string\">string</span>     <span class=\"comment\">#内存限制，单位可以为Mib/Gib，将用于docker run --memory参数</span></span><br><span class=\"line\">      <span class=\"attr\">requests:</span>            <span class=\"comment\">#资源请求的设置(下限)</span></span><br><span class=\"line\">        <span class=\"attr\">cpu:</span> <span class=\"string\">string</span>        <span class=\"comment\">#Cpu请求，容器启动的初始可用数量</span></span><br><span class=\"line\">        <span class=\"attr\">memory:</span> <span class=\"string\">string</span>     <span class=\"comment\">#内存请求,容器启动的初始可用数量</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spec:</span>                         <span class=\"comment\"># Pod 的具体规范</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span>                 <span class=\"comment\"># Pod 中的容器数组，可以有多个容器</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">myapp-container</span>   <span class=\"comment\"># 容器名称</span></span><br><span class=\"line\">      <span class=\"attr\">image:</span> <span class=\"string\">nginx:1.25</span>       <span class=\"comment\"># 使用的镜像</span></span><br><span class=\"line\">      <span class=\"attr\">ports:</span>                  <span class=\"comment\"># 容器开放的端口</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">80</span>   <span class=\"comment\"># 容器内部端口，只是声明性的字段，不具有决定作用</span></span><br><span class=\"line\">      <span class=\"attr\">env:</span>                    <span class=\"comment\"># 环境变量配置</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">ENVIRONMENT</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">production</span></span><br><span class=\"line\">      <span class=\"attr\">resources:</span>              <span class=\"comment\"># 资源限制和请求</span></span><br><span class=\"line\">        <span class=\"attr\">limits:</span></span><br><span class=\"line\">          <span class=\"attr\">memory:</span> <span class=\"string\">&quot;512Mi&quot;</span>     <span class=\"comment\"># 最大内存限制</span></span><br><span class=\"line\">          <span class=\"attr\">cpu:</span> <span class=\"string\">&quot;1&quot;</span>            <span class=\"comment\"># 最大 CPU 核心数，这里是 1 核</span></span><br><span class=\"line\">          <span class=\"comment\"># cpu: 1000m        # 1000m = 1 核</span></span><br><span class=\"line\">        <span class=\"attr\">requests:</span></span><br><span class=\"line\">          <span class=\"attr\">memory:</span> <span class=\"string\">&quot;256Mi&quot;</span>     <span class=\"comment\"># 初始分配内存</span></span><br><span class=\"line\">          <span class=\"attr\">cpu:</span> <span class=\"string\">&quot;0.5&quot;</span>          <span class=\"comment\"># 初始分配 CPU, 这里0.5 表示 0.5 核</span></span><br><span class=\"line\">          <span class=\"comment\"># cpu: 500m           # 500 毫核，也就是 0.5 核</span></span><br><span class=\"line\">      <span class=\"attr\">volumeMounts:</span>           <span class=\"comment\"># 挂载到容器的卷</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">app-storage</span>   <span class=\"comment\"># 卷名称，需要和 volumes 中定义的卷名称一致</span></span><br><span class=\"line\">          <span class=\"attr\">mountPath:</span> <span class=\"string\">/usr/share/nginx/html</span> <span class=\"comment\"># 挂载到容器的目录</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"spec-containers-command-args\">spec.containers.command | args</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>容器启动时执行的命令</p>\n</li>\n<li class=\"lvl-2\">\n<p>默认情况下，容器启动时，会从镜像中获取命令并执行，如果这里配置了命令，则容器启动时，会执行这里的命令，而不是镜像中的命令</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">busybox-container</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">busybox:1.36</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;/bin/sh&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>, <span class=\"string\">&quot;while true; do echo hello; sleep 10;done&quot;</span>]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>或者</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">busybox-container</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">busybox:1.36</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;/bin/sh&quot;</span>,<span class=\"string\">&quot;-c&quot;</span>]</span><br><span class=\"line\">    <span class=\"attr\">args:</span> [<span class=\"string\">&quot;while true; do echo hello; sleep 10;done&quot;</span>]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>或者</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">busybox-container</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">busybox:1.36</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;/bin/bash&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>]</span><br><span class=\"line\">    <span class=\"attr\">args:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">|</span>                  <span class=\"comment\"># 使用 | 符号，表示多行输入</span></span><br><span class=\"line\">        <span class=\"string\">while</span> <span class=\"literal\">true</span><span class=\"string\">;</span> <span class=\"string\">do</span></span><br><span class=\"line\">          <span class=\"string\">echo</span> <span class=\"string\">&quot;hello world&quot;</span></span><br><span class=\"line\">          <span class=\"string\">sleep</span> <span class=\"number\">5</span></span><br><span class=\"line\">        <span class=\"string\">done</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"spec-restartPolicy\">spec.restartPolicy</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>指在系统发生故障或意外停机时，系统或应用程序如何处理和恢复的策略</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">Always：总是重启</li>\n<li class=\"lvl-4\">OnFailure：失败时重启</li>\n<li class=\"lvl-4\">Never：不重启</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">my-nginx</span></span><br><span class=\"line\">      <span class=\"attr\">image:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">  <span class=\"attr\">restartPolicy:</span> <span class=\"string\">OnFailure</span> <span class=\"comment\">#失败时重启</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"spec-terminationGracePeriodSeconds\">spec.terminationGracePeriodSeconds</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Pod 删除时，系统给 Pod 留的时间，用于完成清理工作</p>\n</li>\n<li class=\"lvl-2\">\n<p>宽限期为避免服务突然中断,造成事物不一致的问题,当容器运行完自己的任务后,会等待一段时间,然后优雅的退出</p>\n</li>\n<li class=\"lvl-2\">\n<p>默认值为 30s，单位为秒</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">my-nginx</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">  <span class=\"attr\">terminationGracePeriodSeconds:</span> <span class=\"number\">60</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"spec-volumes\">spec.volumes</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Kubernetes 中的卷（volumes）是为了在容器之间共享数据，或将数据从容器持久化到外部存储。</p>\n</li>\n</ul>\n<h5 id=\"emptyDir（最简单，Pod-生命周期内有效）\">emptyDir（最简单，Pod 生命周期内有效）</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>emptyDir 卷是一个没有名字的临时目录，Pod 创建时创建，Pod 删除时删除。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">app</span></span><br><span class=\"line\">      <span class=\"attr\">image:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">      <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">mountPath:</span> <span class=\"string\">/usr/share/nginx/html</span></span><br><span class=\"line\">          <span class=\"attr\">name:</span> <span class=\"string\">html-volume</span></span><br><span class=\"line\">  <span class=\"attr\">volumes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">html-volume</span></span><br><span class=\"line\">      <span class=\"attr\">emptyDir:</span> &#123;&#125;  <span class=\"comment\"># 表示一个空目录，在 Pod 生命周期内有效</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"hostPath（挂载宿主机路径）\">hostPath（挂载宿主机路径）</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>用于测试或非常了解宿主机结构的场景。生产不推荐。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">volumes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">mydata</span></span><br><span class=\"line\">      <span class=\"attr\">hostPath:</span></span><br><span class=\"line\">        <span class=\"attr\">path:</span> <span class=\"string\">/tmp/data</span>        <span class=\"comment\"># 宿主机路径</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">DirectoryOrCreate</span>  <span class=\"comment\"># 如果目录不存在就创建</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"configMap（挂载配置文件）\">configMap（挂载配置文件）</h5>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">volumes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">config</span></span><br><span class=\"line\">      <span class=\"attr\">configMap:</span></span><br><span class=\"line\">        <span class=\"attr\">name:</span> <span class=\"string\">my-configmap</span>   <span class=\"comment\"># 需提前创建 ConfigMap，这个后面会介绍</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"使用-PVC（挂载持久化存储）\">使用 PVC（挂载持久化存储）</h5>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">volumes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">persistent-storage</span></span><br><span class=\"line\">      <span class=\"attr\">persistentVolumeClaim:</span></span><br><span class=\"line\">        <span class=\"attr\">claimName:</span> <span class=\"string\">mypvc</span>  <span class=\"comment\"># PVC 名称，需要提前创建，这个后面会介绍</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"spec-tolerations-Pod容忍策略\">spec.tolerations: Pod容忍策略</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>tolerations 是 Kubernetes Pod 中用来“容忍”某些 Node 节点的污点（Taints） 的字段。它允许 Pod 被调度到带有相应 Taint 的节点上。</p>\n</li>\n<li class=\"lvl-2\">\n<p>默认情况下，Pod 会因为 Node 节点的 Taint 而不被调度。</p>\n</li>\n<li class=\"lvl-2\">\n<p>比如一个 Node 有 NoSchedule 类型的 taint，而 Pod 没有设置对应的 toleration，该 Pod 就不会被调度到这个 Node 上。</p>\n</li>\n<li class=\"lvl-2\">\n<p>示例： 容忍 key=value:NoSchedule 的 Taint</p>\n</li>\n<li class=\"lvl-2\">\n<p>假设某节点打了如下污点（Taint）：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl taint nodes node1 key=value:NoSchedule</span><br><span class=\"line\"><span class=\"comment\"># NoSchedule\t不调度到该节点，除非容忍策略显式允许</span></span><br><span class=\"line\"><span class=\"comment\"># PreferNoSchedule\t尽量不调度到该节点，但非强制，即可能会被调度</span></span><br><span class=\"line\"><span class=\"comment\"># NoExecute\t不仅不调度到该节点，还会把现有 Pod 驱逐出去，除非设置容忍时间</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># key=value 是用来 区分不同类型的污点的。比如：</span></span><br><span class=\"line\"><span class=\"comment\">#   你可能给 node1 设置 env=prod:NoSchedule</span></span><br><span class=\"line\"><span class=\"comment\">#   给 node2 设置 gpu=true:NoSchedule</span></span><br><span class=\"line\"><span class=\"comment\">#   给 node3 设置 arch=arm64:NoSchedule</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 这些都属于不同的“原因”或“标签”，这样你可以：</span></span><br><span class=\"line\"><span class=\"comment\">#   用不同的 toleration 来容忍不同的 taint；</span></span><br><span class=\"line\"><span class=\"comment\">#   精准控制某些 Pod 只能被调度到符合条件的节点。</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>容忍该 Taint</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">tolerate-example</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">busybox</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">busybox</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;sleep&quot;</span>, <span class=\"string\">&quot;3600&quot;</span>]</span><br><span class=\"line\">  <span class=\"attr\">tolerations:</span>        <span class=\"comment\"># 定义容忍策略</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">operator:</span> <span class=\"string\">&quot;Equal&quot;</span> <span class=\"comment\"># 匹配方式，必选（Equal:精确匹配 key 和 value。Exists:只匹配 key 是否存在，不关心 value 是什么）</span></span><br><span class=\"line\">    <span class=\"attr\">key:</span> <span class=\"string\">&quot;key&quot;</span>        <span class=\"comment\"># 设置键值对的key，为空代表任意键值对</span></span><br><span class=\"line\">    <span class=\"attr\">value:</span> <span class=\"string\">&quot;value&quot;</span>    <span class=\"comment\"># 设置values的值，</span></span><br><span class=\"line\">    <span class=\"attr\">effect:</span> <span class=\"string\">&quot;NoSchedule&quot;</span> <span class=\"comment\"># 设置容忍的标签，为空代表所有污点标签</span></span><br><span class=\"line\">    <span class=\"attr\">tolerationSeconds:</span> <span class=\"number\">60</span> <span class=\"comment\"># 容忍时间，这里Pod 最多可停留 60 秒，之后仍会被驱逐，不设置表示永久容忍</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 Kubernetes 中，effect 有 三个可选值：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><code>effect</code> 值</th>\n<th>含义</th>\n<th>常见用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>NoSchedule</code></td>\n<td>节点上的污点会阻止 Pod 被调度到该节点，除非 Pod 有相应的 toleration。</td>\n<td><strong>最常用</strong>，例如 Master 节点的容忍。</td>\n</tr>\n<tr>\n<td><code>PreferNoSchedule</code></td>\n<td><strong>倾向于不调度</strong> 到该节点，但不是强制性的，调度器会尽量避免把 Pod 安排到该节点。</td>\n<td>用于软约束，尽量不调度。</td>\n</tr>\n<tr>\n<td><code>NoExecute</code></td>\n<td>不仅不调度新 Pod 到该节点，还会把当前节点上没有相应容忍度的 Pod 驱逐出去（<code>eviction</code>）。</td>\n<td>节点异常自动驱逐，比如 not-ready。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"spec-resources\">spec.resources</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Pod资源配额可以限制命名空间或项目中Pod使用的CPU、内存、存储等资源用量</p>\n</li>\n<li class=\"lvl-2\">\n<p>CPU资源的约束和请求以豪核（m）为单位。在k8s中1m是最小的调度单元，CPU的一个核心可以看作1000m</p>\n</li>\n</ul>\n<blockquote>\n<p>如果你有2颗cpu，且每CPU为4核心，那么你的CPU资源总量就是8000</p>\n</blockquote>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spec:</span>                     <span class=\"comment\"># Pod 的具体规范</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span>             <span class=\"comment\"># Pod 中的容器数组，可以有多个容器</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">myapp-container</span>    <span class=\"comment\"># 容器名称</span></span><br><span class=\"line\">      <span class=\"attr\">image:</span> <span class=\"string\">nginx:1.25</span>        <span class=\"comment\"># 使用的镜像</span></span><br><span class=\"line\">      <span class=\"attr\">resources:</span>              <span class=\"comment\"># 资源限制和请求</span></span><br><span class=\"line\">        <span class=\"attr\">limits:</span></span><br><span class=\"line\">          <span class=\"attr\">memory:</span> <span class=\"string\">&quot;512Mi&quot;</span>     <span class=\"comment\"># 最大内存限制</span></span><br><span class=\"line\">          <span class=\"attr\">cpu:</span> <span class=\"string\">&quot;1&quot;</span>            <span class=\"comment\"># 最大 CPU 核心数，这里是 1 核</span></span><br><span class=\"line\">          <span class=\"comment\"># cpu: 1000m          # 1000m = 1 核</span></span><br><span class=\"line\">        <span class=\"attr\">requests:</span></span><br><span class=\"line\">          <span class=\"attr\">memory:</span> <span class=\"string\">&quot;256Mi&quot;</span>     <span class=\"comment\"># 初始分配内存</span></span><br><span class=\"line\">          <span class=\"attr\">cpu:</span> <span class=\"string\">&quot;0.5&quot;</span>          <span class=\"comment\"># 初始分配 CPU, 这里0.5 表示 0.5 核</span></span><br><span class=\"line\">          <span class=\"comment\"># cpu: 500m           # 500 毫核，也就是 0.5 核</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果有大量的容器需要设置资源配额，为每个Pod设置资源配额策略不方便且不好管理</p>\n</li>\n<li class=\"lvl-2\">\n<p>可以以名称空间为单位（namespace），限制其资源的使用与创建，在该名称空间中创建的容器都会受到规则的限制。</p>\n</li>\n</ul>\n<h5 id=\"LimitRange\">LimitRange</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>对单个Pod内存、CPU进行配额</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">LimitRange</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">mem-cpu-limit-range</span>          <span class=\"comment\"># LimitRange 的名称</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">demo</span>                    <span class=\"comment\"># 生效的命名空间</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">limits:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">Container</span>                  <span class=\"comment\"># 表示限制的是每个容器（也可设置为 Pod）</span></span><br><span class=\"line\">    <span class=\"attr\">default:</span>                         <span class=\"comment\"># 容器未指定 resources.limits 时使用的默认值</span></span><br><span class=\"line\">      <span class=\"attr\">cpu:</span> <span class=\"string\">500m</span>                      <span class=\"comment\"># 默认限制 CPU 为 0.5 核</span></span><br><span class=\"line\">      <span class=\"attr\">memory:</span> <span class=\"string\">512Mi</span>                  <span class=\"comment\"># 默认限制内存为 512 MiB</span></span><br><span class=\"line\">    <span class=\"attr\">defaultRequest:</span>                  <span class=\"comment\"># 容器未指定 resources.requests 时使用的默认请求值，初始值</span></span><br><span class=\"line\">      <span class=\"attr\">cpu:</span> <span class=\"string\">100m</span>                      <span class=\"comment\"># 默认请求 CPU 为 0.1 核</span></span><br><span class=\"line\">      <span class=\"attr\">memory:</span> <span class=\"string\">128Mi</span>                  <span class=\"comment\"># 默认请求内存为 128 MiB</span></span><br><span class=\"line\">    <span class=\"attr\">max:</span>                             <span class=\"comment\"># 容器可设置的最大限制值，即 容器中指定的 resources.limits 的最大允许值</span></span><br><span class=\"line\">      <span class=\"attr\">cpu:</span> <span class=\"string\">&quot;1&quot;</span>                       <span class=\"comment\"># 最大可使用 CPU 为 1 核</span></span><br><span class=\"line\">      <span class=\"attr\">memory:</span> <span class=\"string\">1Gi</span>                    <span class=\"comment\"># 最大可使用内存为 1 GiB</span></span><br><span class=\"line\">    <span class=\"attr\">min:</span>                             <span class=\"comment\"># 容器可设置的最小请求值，，即 容器中指定的 resources.requests 的最小允许值</span></span><br><span class=\"line\">      <span class=\"attr\">cpu:</span> <span class=\"string\">50m</span>                       <span class=\"comment\"># 最小请求 CPU 为 0.05 核</span></span><br><span class=\"line\">      <span class=\"attr\">memory:</span> <span class=\"string\">64Mi</span>                   <span class=\"comment\"># 最小请求内存为 64 MiB</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"ResourceQuota\">ResourceQuota</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>限制整个 namespace 的资源总量</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">ResourceQuota</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">compute-resources</span>           <span class=\"comment\"># ResourceQuota 的名称</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">demo</span>                   <span class=\"comment\"># 生效的命名空间</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">hard:</span>                             <span class=\"comment\"># 定义各类资源的总配额上限</span></span><br><span class=\"line\">    <span class=\"attr\">pods:</span> <span class=\"string\">&quot;10&quot;</span>                      <span class=\"comment\"># 该命名空间最多允许创建 10 个 Pod</span></span><br><span class=\"line\">    <span class=\"attr\">requests.cpu:</span> <span class=\"string\">&quot;2&quot;</span>               <span class=\"comment\"># 所有 Pod 的 requests.cpu 总和最多为 2 核</span></span><br><span class=\"line\">    <span class=\"attr\">requests.memory:</span> <span class=\"string\">4Gi</span>            <span class=\"comment\"># 所有 Pod 的 requests.memory 总和最多为 4 GiB</span></span><br><span class=\"line\">    <span class=\"attr\">limits.cpu:</span> <span class=\"string\">&quot;4&quot;</span>                 <span class=\"comment\"># 所有 Pod 的 limits.cpu 总和最多为 4 核</span></span><br><span class=\"line\">    <span class=\"attr\">limits.memory:</span> <span class=\"string\">8Gi</span>              <span class=\"comment\"># 所有 Pod 的 limits.memory 总和最多为 8 GiB</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"spec-priorityClassName\">spec.priorityClassName</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Pod 的优先级，优先级就是为了保证重要的Pod被优先调度并运行</p>\n</li>\n<li class=\"lvl-2\">\n<p>优先级策略：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">非抢占优先：指的是在调度阶段优先进行调度分配，一旦容器调度完成就不可以抢占，资源不足时，只能等待</li>\n<li class=\"lvl-4\">抢占优先：强制调度一个Pod，如果资源不足无法被调度，调度程序会抢占（删除）较低优先级的Pod的资 源，来保证高优先级Pod的运行</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>创建优先级</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PriorityClass</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">scheduling.k8s.io/v1</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">high-non</span> <span class=\"comment\"># 优先级名称</span></span><br><span class=\"line\"><span class=\"attr\">preemptionPolicy:</span> <span class=\"string\">Never</span> <span class=\"comment\"># 策略：非抢占，PreemptLowerPriority:抢占（删除）较低优先级的Pod的资源，保证高优先级Pod的运行</span></span><br><span class=\"line\"><span class=\"attr\">value:</span> <span class=\"number\">1000</span> <span class=\"comment\"># 优先级，可以设置小于10亿的整数值，值越大，优先级越高，默认优先级0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">nodeSelector:</span></span><br><span class=\"line\">    <span class=\"attr\">kubernetes.io/hostname:</span> <span class=\"string\">node01</span> <span class=\"comment\"># 指定匹配具有当前标签的节点</span></span><br><span class=\"line\">  <span class=\"attr\">priorityClassName:</span> <span class=\"string\">high-non</span> <span class=\"comment\"># 优先级名称</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">my-nginx</span></span><br><span class=\"line\">      <span class=\"attr\">image:</span> <span class=\"string\">nginx</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"spec-nodeName-nodeSelector-Pod调度策略\">spec.nodeName | nodeSelector :Pod调度策略</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在k8s中，调度是将Pod分配到合适的节点并运行的过程，kube-scheduler是默认调度器，是集群的核心组件。</p>\n</li>\n<li class=\"lvl-2\">\n<p>调度器通过k8s的监测（Watch）机制来发现集群中尚未被调度到节点上的Pod，调度器依据调度原则将Pod分配到一个合适的节点上运行。</p>\n</li>\n<li class=\"lvl-2\">\n<p>调度器给一个pod做调度包含两个步骤： 过滤 和 打分</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">过滤：首先要筛选出满足Pod所有的资源请求的节点，这里包含计算资源、内存、存储、网络、端口号等等，如果没有节点能满足Pod的需求，Pod将一直停留在Pending状态，直到调度器能够找到合适的节点运行它</li>\n<li class=\"lvl-4\">打分：调度器将节点按照打分规则进行打分，然后按照分数进行排序，将分数最高的节点作为Pod的运行节点。如果存在多个得分最高的节点，调度器会从中随机选取一个。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>Pod 支持两种调度策略：<code>nodeName</code> 和 <code>nodeSelector</code></p>\n</li>\n</ul>\n<h5 id=\"spec-nodeName\">spec.nodeName</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>指定 Pod 运行在指定名称的节点上</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">nodeName:</span> <span class=\"string\">node-1</span> <span class=\"comment\"># 基于节点名进行调度</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">apache</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">myos:httpd</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"spec-nodeSelector\">spec.nodeSelector</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>节点选择器，基于节点的标签进行调度</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">nodeSelector:</span>         <span class=\"comment\"># 基于节点标签进行调度</span></span><br><span class=\"line\">    <span class=\"attr\">kubernetes.io/hostname:</span> <span class=\"string\">node-2</span>  <span class=\"comment\"># 标签</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">apache</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">myos:httpd</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>为节点设置标签</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 所有资源都可以设置标签，语法为： kubectl label &lt;资源&gt; &lt;资源名称&gt; &lt;标签key&gt;=&lt;标签value&gt;</span></span><br><span class=\"line\">kubectl label nodes node-2 kubernetes.io/hostname=node-2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除标签，语法为： kubectl label &lt;资源&gt; &lt;资源名称&gt; &lt;标签key&gt;-</span></span><br><span class=\"line\"><span class=\"comment\"># 这里注意，删除标签就是在标签key后加上 - 符号</span></span><br><span class=\"line\">kubectl label nodes node-2 kubernetes.io/hostname-</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看资源标签：kubectl get &lt;资源&gt; --show-labels</span></span><br><span class=\"line\">kubectl get nodes --show-labels</span><br><span class=\"line\"><span class=\"comment\"># 查看指定节点的标签</span></span><br><span class=\"line\">kubectl get nodes node-2 --show-labels</span><br></pre></td></tr></table></figure>\n<h4 id=\"spec-affinity\">spec.affinity</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>节点亲和性，用于控制 Pod 调度到具有特定标签的节点上，是 nodeSelector 的增强版本</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>功能</th>\n<th>示例用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Node Affinity</td>\n<td>控制调度到有指定标签的节点</td>\n<td>SSD、高内存节点</td>\n</tr>\n<tr>\n<td>Pod Affinity</td>\n<td>调度到和某些 Pod 一起的节点</td>\n<td>微服务协同部署</td>\n</tr>\n<tr>\n<td>Pod Anti-Affinity</td>\n<td>避免和某些 Pod 一起的节点</td>\n<td>高可用副本分散部署</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"节点亲和性-Node-Affinity\">节点亲和性(Node Affinity)</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Pod 只能调度到具有标签 <code>disktype=ssd</code> 的节点上</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">node-affinity-pod</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">  <span class=\"attr\">affinity:</span>   <span class=\"comment\"># 亲和性配置</span></span><br><span class=\"line\">    <span class=\"attr\">nodeAffinity:</span> <span class=\"comment\"># 节点亲和性</span></span><br><span class=\"line\">      <span class=\"attr\">requiredDuringSchedulingIgnoredDuringExecution:</span> <span class=\"comment\"># 在调度期间必须满足，运行中忽略变化（即调度后标签变了不会驱逐 Pod）。也可以设置为 preferredDuringSchedulingIgnoredDuringExecution，表示节点亲和性优先级高，但不强制要求必须满足</span></span><br><span class=\"line\">        <span class=\"attr\">nodeSelectorTerms:</span> <span class=\"comment\"># 节点选择器</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">matchExpressions:</span> <span class=\"comment\"># 匹配表达式，支持复杂逻辑，比如 In、NotIn、Exists、DoesNotExist、Gt、Lt。</span></span><br><span class=\"line\">          <span class=\"bullet\">-</span> <span class=\"attr\">key:</span> <span class=\"string\">disktype</span> <span class=\"comment\"># 键</span></span><br><span class=\"line\">            <span class=\"attr\">operator:</span> <span class=\"string\">In</span> <span class=\"comment\"># 操作符</span></span><br><span class=\"line\">            <span class=\"attr\">values:</span> <span class=\"comment\"># 值</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"string\">ssd</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"Pod-亲和性-Pod-Affinity\">Pod 亲和性(Pod Affinity)</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Pod 会被调度到 与标签为 app=web 的 Pod 所在同一节点（或拓扑层）上。</p>\n</li>\n</ul>\n<blockquote>\n<p>通常用于需要紧密协作的服务部署在一起（如同一机器内通信）。</p>\n</blockquote>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">pod-affinity-pod</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">app</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">busybox</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;sleep&quot;</span>, <span class=\"string\">&quot;3600&quot;</span>]</span><br><span class=\"line\">  <span class=\"attr\">affinity:</span></span><br><span class=\"line\">    <span class=\"attr\">podAffinity:</span>  <span class=\"comment\"># pod 亲和性</span></span><br><span class=\"line\">      <span class=\"attr\">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">labelSelector:</span>  <span class=\"comment\"># 标签选择器</span></span><br><span class=\"line\">          <span class=\"attr\">matchExpressions:</span> <span class=\"comment\"># 标签选择条件</span></span><br><span class=\"line\">          <span class=\"bullet\">-</span> <span class=\"attr\">key:</span> <span class=\"string\">app</span> <span class=\"comment\"># 键</span></span><br><span class=\"line\">            <span class=\"attr\">operator:</span> <span class=\"string\">In</span> <span class=\"comment\"># 操作符</span></span><br><span class=\"line\">            <span class=\"attr\">values:</span>  <span class=\"comment\"># 值</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"string\">web</span></span><br><span class=\"line\">        <span class=\"attr\">topologyKey:</span> <span class=\"string\">&quot;kubernetes.io/hostname&quot;</span> <span class=\"comment\"># 拓扑键，表示“同一主机”</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"Pod-反亲和性-Pod-Anti-Affinity\">Pod 反亲和性(Pod Anti-Affinity)</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>表示不能和 app=web 的 Pod 在同一节点上</p>\n</li>\n</ul>\n<blockquote>\n<p>常用于高可用部署，避免多个副本部署在同一个节点。</p>\n</blockquote>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">pod-anti-affinity-pod</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">app</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">busybox</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;sleep&quot;</span>, <span class=\"string\">&quot;3600&quot;</span>]</span><br><span class=\"line\">  <span class=\"attr\">affinity:</span></span><br><span class=\"line\">    <span class=\"attr\">podAntiAffinity:</span> <span class=\"comment\"># Pod 反亲和性</span></span><br><span class=\"line\">      <span class=\"attr\">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">labelSelector:</span></span><br><span class=\"line\">          <span class=\"attr\">matchExpressions:</span></span><br><span class=\"line\">          <span class=\"bullet\">-</span> <span class=\"attr\">key:</span> <span class=\"string\">app</span></span><br><span class=\"line\">            <span class=\"attr\">operator:</span> <span class=\"string\">In</span></span><br><span class=\"line\">            <span class=\"attr\">values:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"string\">web</span></span><br><span class=\"line\">        <span class=\"attr\">topologyKey:</span> <span class=\"string\">&quot;kubernetes.io/hostname&quot;</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"节点亲和性-Node-Affinity-两种策略的对比\">节点亲和性 (Node Affinity) 两种策略的对比</h5>\n<table>\n<thead>\n<tr>\n<th>策略字段</th>\n<th>含义</th>\n<th>行为特点</th>\n<th>场景适用</th>\n<th>是否强制</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>requiredDuringSchedulingIgnoredDuringExecution</code></td>\n<td><strong>“必须满足”亲和性规则</strong></td>\n<td>Pod <strong>调度时必须满足条件</strong>，不满足则不调度；调度后节点变化不触发驱逐</td>\n<td>硬性约束，比如必须调度到有 GPU 的节点</td>\n<td>✅ 强制</td>\n</tr>\n<tr>\n<td><code>preferredDuringSchedulingIgnoredDuringExecution</code></td>\n<td><strong>“尽量满足”亲和性规则</strong></td>\n<td>Pod <strong>调度时优先考虑满足条件的节点</strong>，但条件不满足时仍然可以调度到其他节点；调度后同样不会强制迁移</td>\n<td>软性倾向，比如尽量调度到 SSD 节点，但实在没有也可调度</td>\n<td>❌ 非强制</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"spec-securityContext-设置安全上下文\">spec.securityContext: 设置安全上下文</h4>\n<h5 id=\"runAsUser-设置运行用户\">runAsUser: 设置运行用户</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>默认情况下容器都是以root用户运行的，但是很多应用需要以非root用户运行，比如 Elasticsearch 。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">pod1</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">centos1</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">centos:v1</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;/bin/sh&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>, <span class=\"string\">&quot;while true; do echo hello; sleep 10;done&quot;</span>]</span><br><span class=\"line\">    <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span></span><br><span class=\"line\">    <span class=\"attr\">securityContext:</span></span><br><span class=\"line\">      <span class=\"attr\">runAsUser:</span> <span class=\"number\">1000</span>   <span class=\"comment\"># 设置运行用户，这个UID可以不存在</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"privileged-是否以特权方式运行\">privileged: 是否以特权方式运行</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>容器与宿主机是共享内核的，默认情况下，容器用户是不允许修改内核参数的，但是可以通过设置 <code>privileged: true</code> 来允许容器以特权方式运行。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">centos1</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">centos:v1</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;/bin/sh&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>, <span class=\"string\">&quot;while true; do echo hello; sleep 10;done&quot;</span>]</span><br><span class=\"line\">    <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span></span><br><span class=\"line\">    <span class=\"attr\">securityContext:</span></span><br><span class=\"line\">      <span class=\"attr\">privileged:</span> <span class=\"literal\">true</span>   <span class=\"comment\"># 特权方式运行，默认为 false</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"allowPrivilegeEscalation-是否可以提权（SUID）\">allowPrivilegeEscalation: 是否可以提权（SUID）</h5>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>s位：当某可执行命令的所有者的位置上有s位时，那么当普通用户执行这个命令时将具有所有者的权限。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">centos1</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">centos:v1</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;/bin/sh&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>, <span class=\"string\">&quot;while true; do echo hello; sleep 10;done&quot;</span>]</span><br><span class=\"line\">    <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span></span><br><span class=\"line\">    <span class=\"attr\">securityContext:</span></span><br><span class=\"line\">      <span class=\"attr\">allowPrivilegeEscalation:</span> <span class=\"literal\">true</span>   <span class=\"comment\"># 提权运行，可以使用suid，默认为 false</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"查看-Pod\">查看 Pod</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看 Pod，默认显示 default 命名空间下的 Pod</span></span><br><span class=\"line\">kubectl get pods</span><br><span class=\"line\"><span class=\"comment\"># 查看 kube-system 命名空间下的 Pod</span></span><br><span class=\"line\">kubectl get pods -n kube-system</span><br><span class=\"line\"><span class=\"comment\"># 查看所有命名空间下的 Pod</span></span><br><span class=\"line\">kubectl get pods -A</span><br><span class=\"line\"><span class=\"comment\"># -o wide: 显示 Pod 的详细信息，此时会看到 pod 的 IP 地址、节点名称等信息</span></span><br><span class=\"line\">kubectl get pods -o wide</span><br><span class=\"line\"><span class=\"comment\"># 显示 Pod 的详细信息，输出为 json/yaml 格式</span></span><br><span class=\"line\">kubectl get pods -o json/yaml</span><br><span class=\"line\"><span class=\"comment\"># 显示 Pod 的标签</span></span><br><span class=\"line\">kubectl get pod --show-labels</span><br><span class=\"line\"><span class=\"comment\"># 按 Pod 的标签进程查询</span></span><br><span class=\"line\">kubectl get pod -l &lt;label_name&gt;=&lt;label_value&gt;</span><br><span class=\"line\"><span class=\"comment\"># 持续查看 Pod 的状态，当 pod 状态发生改变时，会实时显示</span></span><br><span class=\"line\">kubectl get pods -w</span><br><span class=\"line\"><span class=\"comment\">## 状态类型</span></span><br><span class=\"line\">- Pending: Pod 尚未就绪</span><br><span class=\"line\">- ContainerCreating: Pod 正在创建容器</span><br><span class=\"line\">- Running: Pod 正在运行</span><br><span class=\"line\">- Error: Pod 运行错误</span><br><span class=\"line\">- Terminating: Pod 正在删除</span><br><span class=\"line\">- Completed: Pod 执行完成</span><br><span class=\"line\">- Failed: Pod中的所有容器至少有一个容器退出是非0状态</span><br><span class=\"line\">- Unkown: 无法正常获取Pod对象的状态信息</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看-Pod-详情\">查看 Pod 详情</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当 pod 运行错误时，可以通过该命令查看 pod 的详情，找到错误原因</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl describe pod &lt;pod-name&gt;</span><br><span class=\"line\">kubectl describe pod &lt;pod-name&gt; -n &lt;namespace-name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 排查原因时主要观察最后的 Events，从上到下就是 Pod 的运行过程</span></span><br><span class=\"line\">Events:</span><br><span class=\"line\">  Type    Reason     Age        From               Message</span><br><span class=\"line\">  ----    ------     ----       ----               -------</span><br><span class=\"line\">  <span class=\"comment\"># 被调度器分配到 k8s-worker2 节点</span></span><br><span class=\"line\">  Normal  Scheduled  4s         default-scheduler  Successfully assigned default/nginx to k8s-worker2</span><br><span class=\"line\">  <span class=\"comment\"># 开始拉取镜像</span></span><br><span class=\"line\">  Normal  Pulling    &lt;invalid&gt;  kubelet            Pulling image <span class=\"string\">&quot;nginx&quot;</span></span><br><span class=\"line\">  <span class=\"comment\"># 镜像拉取成功</span></span><br><span class=\"line\">  Normal  Pulled     &lt;invalid&gt;  kubelet            Successfully pulled image <span class=\"string\">&quot;nginx&quot;</span> <span class=\"keyword\">in</span> 2.067s (2.067s including waiting). Image size: 72225394 bytes.</span><br><span class=\"line\">  <span class=\"comment\"># 开始创建容器</span></span><br><span class=\"line\">  Normal  Created    &lt;invalid&gt;  kubelet            Created container: nginx</span><br><span class=\"line\">  <span class=\"comment\"># 容器启动成功</span></span><br><span class=\"line\">  Normal  Started    &lt;invalid&gt;  kubelet            Started container nginx</span><br></pre></td></tr></table></figure>\n<h3 id=\"进入容器\">进入容器</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># kubectl exec -it &lt;pod-name&gt; -n &lt;namespace-name&gt; -- &lt;command&gt;</span></span><br><span class=\"line\">kubectl <span class=\"built_in\">exec</span> -it nginx  -- /bin/bash</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除-Pod\">删除 Pod</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl delete pod &lt;pod-name&gt;</span><br><span class=\"line\">kubectl delete pod &lt;pod-name&gt; -n &lt;namespace-name&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看-Pod-日志\">查看 Pod 日志</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl logs &lt;pod-name&gt;</span><br><span class=\"line\">kubectl logs pod/&lt;pod-name&gt;</span><br><span class=\"line\">kubectl logs pod/&lt;pod-name&gt; -n &lt;namespace-name&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"访问-Pod\">访问 Pod</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>我们刚刚创建了一个nginx的pod，该如何访问呢？</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取pod的ip</span></span><br><span class=\"line\">$ k get pod -o wide</span><br><span class=\"line\">NAME    READY   STATUS    RESTARTS   AGE   IP             NODE          NOMINATED NODE   READINESS GATES</span><br><span class=\"line\">nginx   1/1     Running   0          12m   10.244.126.8   k8s-worker2   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在任意节点上访问，nginx 默认端口是80</span></span><br><span class=\"line\">$ curl 10.244.126.8</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>暂时我们还不能通过节点的 IP 访问 Pod，因为 Pod 运行在容器网络中，等我后面讲解 deployment 和 service 之后，会介绍如何通过 service 访问</p>\n</li>\n</ul>\n<h3 id=\"一个-Pod-运行多个容器\">一个 Pod 运行多个容器</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>yaml 文件</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">multi-pod</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">shareProcessNamespace:</span> <span class=\"literal\">true</span> <span class=\"comment\"># 允许相同pod中多个容器共享进程空间，即在一个容器里可以看到另一个容器中的进程，默认值为 false</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">tomcat</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">tomcat</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>运行 pod</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl apply -f multi_pod.yaml</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看运行结果</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 这里看到，READY 里有两个，表示两个容器都运行成功</span></span><br><span class=\"line\">$ kubectl get pods -owide</span><br><span class=\"line\">NAME    READY   STATUS    RESTARTS   AGE    IP              NODE          NOMINATED NODE   READINESS GATES</span><br><span class=\"line\">multi-pod   2/2     Running   0          118s   10.244.194.81   k8s-worker1   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>访问nginx和tomcat</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 访问nginx，ngxin默认端口是80</span></span><br><span class=\"line\">curl http://10.244.194.81</span><br><span class=\"line\"><span class=\"comment\"># 访问tomcat，tomcat默认端口是8080，因为tomcat的webapp是空的，所以看到404就说明正常</span></span><br><span class=\"line\">curl http://10.244.194.81:8080</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>进入容器执行命令</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 进入nginx容器，-c 指定容器名称</span></span><br><span class=\"line\">kubectl <span class=\"built_in\">exec</span> -it multi-pod -c nginx -- /bin/bash</span><br><span class=\"line\"><span class=\"comment\">## 进入nginx容器后访问tomcat可以正常访问，说明同一个pod中的容器共享网络和存储</span></span><br><span class=\"line\">curl http://localhost:8080</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 进入tomcat容器</span></span><br><span class=\"line\">kubectl <span class=\"built_in\">exec</span> -it multi-pod -c tomcat -- /bin/bash</span><br></pre></td></tr></table></figure>\n","content_text":"摘要 本文介绍 K8S 的 Pod，本文以 CentOS 8 为例。 K8S官网 k8s Github k8s Pod 介绍 Pod 介绍 Pod 是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元。 Pod（就像在豌豆荚中）是一组（一个或多个） 容器，这些容器共享存储、网络、以及怎样运行这些容器的规约。 Pod 中的内容总是并置（colocated）的并且一同调度，在共享的上下文中运行。 Kubernetes 集群中的 Pod 主要有两种用法： 运行单个容器的 Pod: &quot;每个 Pod 一个容器&quot;模型是最常见的 Kubernetes 用例，在这种情况下，可以将 Pod 看作单个容器的包装器，并且 Kubernetes 直接管理 Pod，而不是容器。 运行多个协同工作的容器的 Pod: Pod 可以封装由紧密耦合且需要共享资源的多个并置容器组成的应用，这些位于同一位置的容器构成一个内聚单元。 Pod 管理 Pod 创建 run 创建 12345kubectl run nginx --image=nginx# 输出 yamlkubectl run nginx --image=nginx --dry-run=client -o yaml &gt; pod.yaml# 通过 yaml 文件创建kubectl apply -f pod.yaml pod 中至少包含两个容器，一个是业务容器，比如这里的 nginx，另一个是 pause 容器，负责共享容器的网络，进程，存储等资源。 1234# 通过 crictl ps 是看不到 pause 容器的，我们可以使用 ctr 命令查看，ctr 是 containerd 的命令行工具ctr --namespace=k8s.io c ls# 查看容器所属的podctr --namespace=k8s.io c info &lt;container-id&gt; | grep &#x27;pod.name&#x27; pod.yaml 文件说明 因为 Pod 不支持扩缩容，所以日常使用时一般不会直接创建 Pod，而是创建 Deployment, DaemonSet等这些工作负载资源，这些后面会介绍到。 但我们这里还是要重点介绍一下 Pod 的 yaml 文件格式，因为它是后面所有资源创建的基础。 一个最基础的 Pod 配置如下： 12345678apiVersion: v1 # 必填。指定使用的 API 版本，Pod 是核心资源，使用 v1kind: Pod # 必填。资源类型：Podmetadata: # 必填。元数据，包含 Pod 的名称、命名空间、标签、注解等信息 name: nginx # 必填。Pod 的名称，命名空间中唯一spec: # 必填。资源的特性描述（规约），定义Pod具体行为的部分 containers: # 必填。容器列表 - image: nginx # 必填。容器使用的镜像 name: nginx # 必填。容器名称，在同一个 Pod 内必须唯一 Pod是用来配置容器的，我们在学习docker时知道，容器有非常多的配置项，比如端口、网络、存储等，而 pod 的配置项更丰富。 一个Pod的配置主要包含两大部分：metadata 和 spec，每一项中包含的配置项非常多，这里只对常用的配置项进行说明，若要查看每个配置项的说明可以通过如下命令获取： 123456# pod开头，配置项以 . 连接，例如：kubectl explain pod.metadatakubectl explain pod.metadata.labelskubectl explain pod.speckubectl explain pod.spec.containerskubectl explain pod.spec.containers.ports metadata metadata 是 Pod 的元数据，比如 Pod 的名称、命名空间、标签、注解等。 12345678metadata: # 元数据部分 name: myapp-pod # Pod 的名称 namespace: default # Pod 所在的命名空间，默认是 default labels: # 标签，用于选择器、管理、分组 app: myapp tier: frontend annotations: # 注解，用于添加非结构化元信息 description: &quot;A sample pod for demonstration&quot; spec spec 描述了 Pod 的配置信息，包括 Pod 的容器、存储、网络、资源限制、调度策略等 spec.containers containers 描述了 Pod 中容器的配置信息，包括镜像、启动命令、环境变量、资源限制、卷挂载等 123456789101112131415161718192021222324252627spec: #必选，Pod中容器的详细定义 containers: #必选，Pod中容器列表 - name: string #必选，容器名称 image: string #必选，容器的镜像名称 imagePullPolicy: [ Always|Never|IfNotPresent ] #获取镜像的策略，当镜像标签为 latest 时默认值为 Always，否则为 IfNotPresent command: [string] #容器的启动命令列表，如不指定，使用打包时使用的启动命令 args: [string] #容器的启动命令参数列表 workingDir: string #容器的工作目录，如果为指定，则默认为镜像中的配置 volumeMounts: #挂载到容器内部的存储卷配置 - name: string #引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名 mountPath: string #存储卷在容器内mount的绝对路径，应少于512字符 readOnly: boolean #是否为只读模式 ports: #需要暴露的端口库号列表 - name: string #端口的名称 containerPort: 80 #容器需要监听的端口号 hostPort: int #容器所在主机需要监听的端口号，默认与Container相同 protocol: string #端口协议，支持TCP和UDP，默认TCP env: #容器运行前需设置的环境变量列表 - name: string #环境变量名称 value: string #环境变量的值 resources: #资源限制和请求的设置 limits: #资源限制的设置(上限) cpu: string #Cpu的限制，单位为core数，将用于docker run --cpu-shares参数 memory: string #内存限制，单位可以为Mib/Gib，将用于docker run --memory参数 requests: #资源请求的设置(下限) cpu: string #Cpu请求，容器启动的初始可用数量 memory: string #内存请求,容器启动的初始可用数量 示例 123456789101112131415161718192021spec: # Pod 的具体规范 containers: # Pod 中的容器数组，可以有多个容器 - name: myapp-container # 容器名称 image: nginx:1.25 # 使用的镜像 ports: # 容器开放的端口 - containerPort: 80 # 容器内部端口，只是声明性的字段，不具有决定作用 env: # 环境变量配置 - name: ENVIRONMENT value: production resources: # 资源限制和请求 limits: memory: &quot;512Mi&quot; # 最大内存限制 cpu: &quot;1&quot; # 最大 CPU 核心数，这里是 1 核 # cpu: 1000m # 1000m = 1 核 requests: memory: &quot;256Mi&quot; # 初始分配内存 cpu: &quot;0.5&quot; # 初始分配 CPU, 这里0.5 表示 0.5 核 # cpu: 500m # 500 毫核，也就是 0.5 核 volumeMounts: # 挂载到容器的卷 - name: app-storage # 卷名称，需要和 volumes 中定义的卷名称一致 mountPath: /usr/share/nginx/html # 挂载到容器的目录 spec.containers.command | args 容器启动时执行的命令 默认情况下，容器启动时，会从镜像中获取命令并执行，如果这里配置了命令，则容器启动时，会执行这里的命令，而不是镜像中的命令 12345spec: containers: - name: busybox-container image: busybox:1.36 command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;while true; do echo hello; sleep 10;done&quot;] 或者 123456spec: containers: - name: busybox-container image: busybox:1.36 command: [&quot;/bin/sh&quot;,&quot;-c&quot;] args: [&quot;while true; do echo hello; sleep 10;done&quot;] 或者 1234567891011spec: containers: - name: busybox-container image: busybox:1.36 command: [&quot;/bin/bash&quot;, &quot;-c&quot;] args: - | # 使用 | 符号，表示多行输入 while true; do echo &quot;hello world&quot; sleep 5 done spec.restartPolicy 指在系统发生故障或意外停机时，系统或应用程序如何处理和恢复的策略 Always：总是重启 OnFailure：失败时重启 Never：不重启 12345spec: containers: - name: my-nginx image: nginx restartPolicy: OnFailure #失败时重启 spec.terminationGracePeriodSeconds Pod 删除时，系统给 Pod 留的时间，用于完成清理工作 宽限期为避免服务突然中断,造成事物不一致的问题,当容器运行完自己的任务后,会等待一段时间,然后优雅的退出 默认值为 30s，单位为秒 12345spec: containers: - name: my-nginx image: nginx terminationGracePeriodSeconds: 60 spec.volumes Kubernetes 中的卷（volumes）是为了在容器之间共享数据，或将数据从容器持久化到外部存储。 emptyDir（最简单，Pod 生命周期内有效） emptyDir 卷是一个没有名字的临时目录，Pod 创建时创建，Pod 删除时删除。 12345678910spec: containers: - name: app image: nginx volumeMounts: - mountPath: /usr/share/nginx/html name: html-volume volumes: - name: html-volume emptyDir: &#123;&#125; # 表示一个空目录，在 Pod 生命周期内有效 hostPath（挂载宿主机路径） 用于测试或非常了解宿主机结构的场景。生产不推荐。 123456spec: volumes: - name: mydata hostPath: path: /tmp/data # 宿主机路径 type: DirectoryOrCreate # 如果目录不存在就创建 configMap（挂载配置文件） 12345spec: volumes: - name: config configMap: name: my-configmap # 需提前创建 ConfigMap，这个后面会介绍 使用 PVC（挂载持久化存储） 12345spec: volumes: - name: persistent-storage persistentVolumeClaim: claimName: mypvc # PVC 名称，需要提前创建，这个后面会介绍 spec.tolerations: Pod容忍策略 tolerations 是 Kubernetes Pod 中用来“容忍”某些 Node 节点的污点（Taints） 的字段。它允许 Pod 被调度到带有相应 Taint 的节点上。 默认情况下，Pod 会因为 Node 节点的 Taint 而不被调度。 比如一个 Node 有 NoSchedule 类型的 taint，而 Pod 没有设置对应的 toleration，该 Pod 就不会被调度到这个 Node 上。 示例： 容忍 key=value:NoSchedule 的 Taint 假设某节点打了如下污点（Taint）： 12345678910111213kubectl taint nodes node1 key=value:NoSchedule# NoSchedule 不调度到该节点，除非容忍策略显式允许# PreferNoSchedule 尽量不调度到该节点，但非强制，即可能会被调度# NoExecute 不仅不调度到该节点，还会把现有 Pod 驱逐出去，除非设置容忍时间# key=value 是用来 区分不同类型的污点的。比如：# 你可能给 node1 设置 env=prod:NoSchedule# 给 node2 设置 gpu=true:NoSchedule# 给 node3 设置 arch=arm64:NoSchedule# 这些都属于不同的“原因”或“标签”，这样你可以：# 用不同的 toleration 来容忍不同的 taint；# 精准控制某些 Pod 只能被调度到符合条件的节点。 容忍该 Taint 123456789101112131415apiVersion: v1kind: Podmetadata: name: tolerate-examplespec: containers: - name: busybox image: busybox command: [&quot;sleep&quot;, &quot;3600&quot;] tolerations: # 定义容忍策略 - operator: &quot;Equal&quot; # 匹配方式，必选（Equal:精确匹配 key 和 value。Exists:只匹配 key 是否存在，不关心 value 是什么） key: &quot;key&quot; # 设置键值对的key，为空代表任意键值对 value: &quot;value&quot; # 设置values的值， effect: &quot;NoSchedule&quot; # 设置容忍的标签，为空代表所有污点标签 tolerationSeconds: 60 # 容忍时间，这里Pod 最多可停留 60 秒，之后仍会被驱逐，不设置表示永久容忍 在 Kubernetes 中，effect 有 三个可选值： effect 值 含义 常见用途 NoSchedule 节点上的污点会阻止 Pod 被调度到该节点，除非 Pod 有相应的 toleration。 最常用，例如 Master 节点的容忍。 PreferNoSchedule 倾向于不调度 到该节点，但不是强制性的，调度器会尽量避免把 Pod 安排到该节点。 用于软约束，尽量不调度。 NoExecute 不仅不调度新 Pod 到该节点，还会把当前节点上没有相应容忍度的 Pod 驱逐出去（eviction）。 节点异常自动驱逐，比如 not-ready。 spec.resources Pod资源配额可以限制命名空间或项目中Pod使用的CPU、内存、存储等资源用量 CPU资源的约束和请求以豪核（m）为单位。在k8s中1m是最小的调度单元，CPU的一个核心可以看作1000m 如果你有2颗cpu，且每CPU为4核心，那么你的CPU资源总量就是8000 12345678910111213spec: # Pod 的具体规范 containers: # Pod 中的容器数组，可以有多个容器 - name: myapp-container # 容器名称 image: nginx:1.25 # 使用的镜像 resources: # 资源限制和请求 limits: memory: &quot;512Mi&quot; # 最大内存限制 cpu: &quot;1&quot; # 最大 CPU 核心数，这里是 1 核 # cpu: 1000m # 1000m = 1 核 requests: memory: &quot;256Mi&quot; # 初始分配内存 cpu: &quot;0.5&quot; # 初始分配 CPU, 这里0.5 表示 0.5 核 # cpu: 500m # 500 毫核，也就是 0.5 核 如果有大量的容器需要设置资源配额，为每个Pod设置资源配额策略不方便且不好管理 可以以名称空间为单位（namespace），限制其资源的使用与创建，在该名称空间中创建的容器都会受到规则的限制。 LimitRange 对单个Pod内存、CPU进行配额 1234567891011121314151617181920apiVersion: v1kind: LimitRangemetadata: name: mem-cpu-limit-range # LimitRange 的名称 namespace: demo # 生效的命名空间spec: limits: - type: Container # 表示限制的是每个容器（也可设置为 Pod） default: # 容器未指定 resources.limits 时使用的默认值 cpu: 500m # 默认限制 CPU 为 0.5 核 memory: 512Mi # 默认限制内存为 512 MiB defaultRequest: # 容器未指定 resources.requests 时使用的默认请求值，初始值 cpu: 100m # 默认请求 CPU 为 0.1 核 memory: 128Mi # 默认请求内存为 128 MiB max: # 容器可设置的最大限制值，即 容器中指定的 resources.limits 的最大允许值 cpu: &quot;1&quot; # 最大可使用 CPU 为 1 核 memory: 1Gi # 最大可使用内存为 1 GiB min: # 容器可设置的最小请求值，，即 容器中指定的 resources.requests 的最小允许值 cpu: 50m # 最小请求 CPU 为 0.05 核 memory: 64Mi # 最小请求内存为 64 MiB ResourceQuota 限制整个 namespace 的资源总量 123456789101112apiVersion: v1kind: ResourceQuotametadata: name: compute-resources # ResourceQuota 的名称 namespace: demo # 生效的命名空间spec: hard: # 定义各类资源的总配额上限 pods: &quot;10&quot; # 该命名空间最多允许创建 10 个 Pod requests.cpu: &quot;2&quot; # 所有 Pod 的 requests.cpu 总和最多为 2 核 requests.memory: 4Gi # 所有 Pod 的 requests.memory 总和最多为 4 GiB limits.cpu: &quot;4&quot; # 所有 Pod 的 limits.cpu 总和最多为 4 核 limits.memory: 8Gi # 所有 Pod 的 limits.memory 总和最多为 8 GiB spec.priorityClassName Pod 的优先级，优先级就是为了保证重要的Pod被优先调度并运行 优先级策略： 非抢占优先：指的是在调度阶段优先进行调度分配，一旦容器调度完成就不可以抢占，资源不足时，只能等待 抢占优先：强制调度一个Pod，如果资源不足无法被调度，调度程序会抢占（删除）较低优先级的Pod的资 源，来保证高优先级Pod的运行 创建优先级 1234567891011121314151617181920---kind: PriorityClassapiVersion: scheduling.k8s.io/v1metadata: name: high-non # 优先级名称preemptionPolicy: Never # 策略：非抢占，PreemptLowerPriority:抢占（删除）较低优先级的Pod的资源，保证高优先级Pod的运行value: 1000 # 优先级，可以设置小于10亿的整数值，值越大，优先级越高，默认优先级0---kind: PodapiVersion: v1metadata: name: nginxspec: nodeSelector: kubernetes.io/hostname: node01 # 指定匹配具有当前标签的节点 priorityClassName: high-non # 优先级名称 containers: - name: my-nginx image: nginx spec.nodeName | nodeSelector :Pod调度策略 在k8s中，调度是将Pod分配到合适的节点并运行的过程，kube-scheduler是默认调度器，是集群的核心组件。 调度器通过k8s的监测（Watch）机制来发现集群中尚未被调度到节点上的Pod，调度器依据调度原则将Pod分配到一个合适的节点上运行。 调度器给一个pod做调度包含两个步骤： 过滤 和 打分 过滤：首先要筛选出满足Pod所有的资源请求的节点，这里包含计算资源、内存、存储、网络、端口号等等，如果没有节点能满足Pod的需求，Pod将一直停留在Pending状态，直到调度器能够找到合适的节点运行它 打分：调度器将节点按照打分规则进行打分，然后按照分数进行排序，将分数最高的节点作为Pod的运行节点。如果存在多个得分最高的节点，调度器会从中随机选取一个。 Pod 支持两种调度策略：nodeName 和 nodeSelector spec.nodeName 指定 Pod 运行在指定名称的节点上 12345spec: nodeName: node-1 # 基于节点名进行调度 containers: - name: apache image: myos:httpd spec.nodeSelector 节点选择器，基于节点的标签进行调度 123456spec: nodeSelector: # 基于节点标签进行调度 kubernetes.io/hostname: node-2 # 标签 containers: - name: apache image: myos:httpd 为节点设置标签 1234567891011# 所有资源都可以设置标签，语法为： kubectl label &lt;资源&gt; &lt;资源名称&gt; &lt;标签key&gt;=&lt;标签value&gt;kubectl label nodes node-2 kubernetes.io/hostname=node-2# 删除标签，语法为： kubectl label &lt;资源&gt; &lt;资源名称&gt; &lt;标签key&gt;-# 这里注意，删除标签就是在标签key后加上 - 符号kubectl label nodes node-2 kubernetes.io/hostname-# 查看资源标签：kubectl get &lt;资源&gt; --show-labelskubectl get nodes --show-labels# 查看指定节点的标签kubectl get nodes node-2 --show-labels spec.affinity 节点亲和性，用于控制 Pod 调度到具有特定标签的节点上，是 nodeSelector 的增强版本 类型 功能 示例用途 Node Affinity 控制调度到有指定标签的节点 SSD、高内存节点 Pod Affinity 调度到和某些 Pod 一起的节点 微服务协同部署 Pod Anti-Affinity 避免和某些 Pod 一起的节点 高可用副本分散部署 节点亲和性(Node Affinity) Pod 只能调度到具有标签 disktype=ssd 的节点上 1234567891011121314151617apiVersion: v1kind: Podmetadata: name: node-affinity-podspec: containers: - name: nginx image: nginx affinity: # 亲和性配置 nodeAffinity: # 节点亲和性 requiredDuringSchedulingIgnoredDuringExecution: # 在调度期间必须满足，运行中忽略变化（即调度后标签变了不会驱逐 Pod）。也可以设置为 preferredDuringSchedulingIgnoredDuringExecution，表示节点亲和性优先级高，但不强制要求必须满足 nodeSelectorTerms: # 节点选择器 - matchExpressions: # 匹配表达式，支持复杂逻辑，比如 In、NotIn、Exists、DoesNotExist、Gt、Lt。 - key: disktype # 键 operator: In # 操作符 values: # 值 - ssd Pod 亲和性(Pod Affinity) Pod 会被调度到 与标签为 app=web 的 Pod 所在同一节点（或拓扑层）上。 通常用于需要紧密协作的服务部署在一起（如同一机器内通信）。 12345678910111213141516171819apiVersion: v1kind: Podmetadata: name: pod-affinity-podspec: containers: - name: app image: busybox command: [&quot;sleep&quot;, &quot;3600&quot;] affinity: podAffinity: # pod 亲和性 requiredDuringSchedulingIgnoredDuringExecution: - labelSelector: # 标签选择器 matchExpressions: # 标签选择条件 - key: app # 键 operator: In # 操作符 values: # 值 - web topologyKey: &quot;kubernetes.io/hostname&quot; # 拓扑键，表示“同一主机” Pod 反亲和性(Pod Anti-Affinity) 表示不能和 app=web 的 Pod 在同一节点上 常用于高可用部署，避免多个副本部署在同一个节点。 12345678910111213141516171819apiVersion: v1kind: Podmetadata: name: pod-anti-affinity-podspec: containers: - name: app image: busybox command: [&quot;sleep&quot;, &quot;3600&quot;] affinity: podAntiAffinity: # Pod 反亲和性 requiredDuringSchedulingIgnoredDuringExecution: - labelSelector: matchExpressions: - key: app operator: In values: - web topologyKey: &quot;kubernetes.io/hostname&quot; 节点亲和性 (Node Affinity) 两种策略的对比 策略字段 含义 行为特点 场景适用 是否强制 requiredDuringSchedulingIgnoredDuringExecution “必须满足”亲和性规则 Pod 调度时必须满足条件，不满足则不调度；调度后节点变化不触发驱逐 硬性约束，比如必须调度到有 GPU 的节点 ✅ 强制 preferredDuringSchedulingIgnoredDuringExecution “尽量满足”亲和性规则 Pod 调度时优先考虑满足条件的节点，但条件不满足时仍然可以调度到其他节点；调度后同样不会强制迁移 软性倾向，比如尽量调度到 SSD 节点，但实在没有也可调度 ❌ 非强制 spec.securityContext: 设置安全上下文 runAsUser: 设置运行用户 默认情况下容器都是以root用户运行的，但是很多应用需要以非root用户运行，比如 Elasticsearch 。 123456789101112apiVersion: v1kind: Podmetadata: name: pod1spec: containers: - name: centos1 image: centos:v1 command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;while true; do echo hello; sleep 10;done&quot;] imagePullPolicy: IfNotPresent securityContext: runAsUser: 1000 # 设置运行用户，这个UID可以不存在 privileged: 是否以特权方式运行 容器与宿主机是共享内核的，默认情况下，容器用户是不允许修改内核参数的，但是可以通过设置 privileged: true 来允许容器以特权方式运行。 123456789101112apiVersion: v1kind: Podmetadata: name: nginxspec: containers: - name: centos1 image: centos:v1 command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;while true; do echo hello; sleep 10;done&quot;] imagePullPolicy: IfNotPresent securityContext: privileged: true # 特权方式运行，默认为 false allowPrivilegeEscalation: 是否可以提权（SUID） s位：当某可执行命令的所有者的位置上有s位时，那么当普通用户执行这个命令时将具有所有者的权限。 123456789101112apiVersion: v1kind: Podmetadata: name: nginxspec: containers: - name: centos1 image: centos:v1 command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;while true; do echo hello; sleep 10;done&quot;] imagePullPolicy: IfNotPresent securityContext: allowPrivilegeEscalation: true # 提权运行，可以使用suid，默认为 false 查看 Pod 12345678910111213141516171819202122232425# 查看 Pod，默认显示 default 命名空间下的 Podkubectl get pods# 查看 kube-system 命名空间下的 Podkubectl get pods -n kube-system# 查看所有命名空间下的 Podkubectl get pods -A# -o wide: 显示 Pod 的详细信息，此时会看到 pod 的 IP 地址、节点名称等信息kubectl get pods -o wide# 显示 Pod 的详细信息，输出为 json/yaml 格式kubectl get pods -o json/yaml# 显示 Pod 的标签kubectl get pod --show-labels# 按 Pod 的标签进程查询kubectl get pod -l &lt;label_name&gt;=&lt;label_value&gt;# 持续查看 Pod 的状态，当 pod 状态发生改变时，会实时显示kubectl get pods -w## 状态类型- Pending: Pod 尚未就绪- ContainerCreating: Pod 正在创建容器- Running: Pod 正在运行- Error: Pod 运行错误- Terminating: Pod 正在删除- Completed: Pod 执行完成- Failed: Pod中的所有容器至少有一个容器退出是非0状态- Unkown: 无法正常获取Pod对象的状态信息 查看 Pod 详情 当 pod 运行错误时，可以通过该命令查看 pod 的详情，找到错误原因 1234567891011121314151617kubectl describe pod &lt;pod-name&gt;kubectl describe pod &lt;pod-name&gt; -n &lt;namespace-name&gt;## 排查原因时主要观察最后的 Events，从上到下就是 Pod 的运行过程Events: Type Reason Age From Message ---- ------ ---- ---- ------- # 被调度器分配到 k8s-worker2 节点 Normal Scheduled 4s default-scheduler Successfully assigned default/nginx to k8s-worker2 # 开始拉取镜像 Normal Pulling &lt;invalid&gt; kubelet Pulling image &quot;nginx&quot; # 镜像拉取成功 Normal Pulled &lt;invalid&gt; kubelet Successfully pulled image &quot;nginx&quot; in 2.067s (2.067s including waiting). Image size: 72225394 bytes. # 开始创建容器 Normal Created &lt;invalid&gt; kubelet Created container: nginx # 容器启动成功 Normal Started &lt;invalid&gt; kubelet Started container nginx 进入容器 12# kubectl exec -it &lt;pod-name&gt; -n &lt;namespace-name&gt; -- &lt;command&gt;kubectl exec -it nginx -- /bin/bash 删除 Pod 12kubectl delete pod &lt;pod-name&gt;kubectl delete pod &lt;pod-name&gt; -n &lt;namespace-name&gt; 查看 Pod 日志 123kubectl logs &lt;pod-name&gt;kubectl logs pod/&lt;pod-name&gt;kubectl logs pod/&lt;pod-name&gt; -n &lt;namespace-name&gt; 访问 Pod 我们刚刚创建了一个nginx的pod，该如何访问呢？ 1234567# 获取pod的ip$ k get pod -o wideNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATESnginx 1/1 Running 0 12m 10.244.126.8 k8s-worker2 &lt;none&gt; &lt;none&gt;# 在任意节点上访问，nginx 默认端口是80$ curl 10.244.126.8 暂时我们还不能通过节点的 IP 访问 Pod，因为 Pod 运行在容器网络中，等我后面讲解 deployment 和 service 之后，会介绍如何通过 service 访问 一个 Pod 运行多个容器 yaml 文件 1234567891011apiVersion: v1kind: Podmetadata: name: multi-podspec: shareProcessNamespace: true # 允许相同pod中多个容器共享进程空间，即在一个容器里可以看到另一个容器中的进程，默认值为 false containers: - name: nginx image: nginx - name: tomcat image: tomcat 运行 pod 1kubectl apply -f multi_pod.yaml 查看运行结果 1234# 这里看到，READY 里有两个，表示两个容器都运行成功$ kubectl get pods -owideNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATESmulti-pod 2/2 Running 0 118s 10.244.194.81 k8s-worker1 &lt;none&gt; &lt;none&gt; 访问nginx和tomcat 1234# 访问nginx，ngxin默认端口是80curl http://10.244.194.81# 访问tomcat，tomcat默认端口是8080，因为tomcat的webapp是空的，所以看到404就说明正常curl http://10.244.194.81:8080 进入容器执行命令 1234567# 进入nginx容器，-c 指定容器名称kubectl exec -it multi-pod -c nginx -- /bin/bash## 进入nginx容器后访问tomcat可以正常访问，说明同一个pod中的容器共享网络和存储curl http://localhost:8080# 进入tomcat容器kubectl exec -it multi-pod -c tomcat -- /bin/bash","summary":"摘要 本文介绍 K8S 的 Pod，本文以 CentOS 8 为例。 K8S官网 k8s Github k8s Pod 介绍","date_published":"2025-07-04T14:30:05.000Z","tags":["技术","k8s","K8S"]},{"id":"https://blog.hanqunfeng.com/2025/07/02/k8s-namespace/","url":"https://blog.hanqunfeng.com/2025/07/02/k8s-namespace/","title":"K8S 之 Namespace","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 K8S 的 Namespace，本文以 CentOS 8 为例。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/\">K8S官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/kubernetes/kubernetes\">k8s Github</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/namespaces/\">k8s Namespace 介绍</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"命名空间-Namespace-介绍\">命名空间(Namespace) 介绍</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 Kubernetes 中，命名空间提供了一种在单个集群中隔离资源组的机制。资源名称在命名空间内需要唯一，但不需要跨命名空间唯一。</p>\n</li>\n<li class=\"lvl-2\">\n<p>基于命名空间的作用域仅适用于命名空间对象 （例如，Deployments、Services 等），而不适用于集群范围的对象（例如 StorageClass、Nodes、PersistentVolumes 等）。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Namespace 是在多个用户之间划分集群资源的一种方法，适用于跨多个团队或项目的场景，Namespace 不能相互嵌套，每个 Kubernetes 资源只能在一个 Namespace 中。</p>\n</li>\n<li class=\"lvl-2\">\n<p>避免使用前缀 <code>kube-</code> 创建 Namespace，因为它是为 Kubernetes 系统 Namespace 保留的。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Kubernetes 启动时会创建四个初始 Namespace：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>名称空间名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>default</code></td>\n<td>默认命名空间，供用户开始使用新集群时直接部署资源，无需额外创建命名空间。</td>\n</tr>\n<tr>\n<td><code>kube-node-lease</code></td>\n<td>存放与各个 Node 关联的 Lease（租约）对象，用于 Kubelet 发送心跳，帮助控制平面检测节点健康状态。</td>\n</tr>\n<tr>\n<td><code>kube-public</code></td>\n<td>所有客户端（包括匿名用户）都可以读取，主要用于集群范围内需要公开访问的资源。公共属性是一种使用约定。</td>\n</tr>\n<tr>\n<td><code>kube-system</code></td>\n<td>Kubernetes 系统组件（如 kube-dns、kube-proxy 等）运行所在的命名空间。由系统自动管理。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"查看集群中的命名空间\">查看集群中的命名空间</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># namespace 可以简写为 ns</span></span><br><span class=\"line\">kubectl get namespace</span><br><span class=\"line\">kubectl get ns</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建命名空间\">创建命名空间</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>命令行方式</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create namespace &lt;namespace-name&gt;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>yaml 方式</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span>  <span class=\"comment\"># API 版本，可以通过 kubectl api-resources | grep Namespace 获取</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Namespace</span> <span class=\"comment\"># 资源类型</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span>       <span class=\"comment\"># 元数据</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">&lt;namespace-name&gt;</span> <span class=\"comment\"># 命名空间名称</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl apply -f &lt;namespace.yaml&gt;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>通过命令行直接生成yaml文件</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># --dry-run=client: 本地模拟运行命令，不会真的执行，-o yaml: 输出yaml格式</span></span><br><span class=\"line\">kubectl create namespace &lt;namespace-name&gt; --dry-run=client -o yaml &gt; &lt;namespace.yaml&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"删除命名空间\">删除命名空间</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>命令行方式</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl delete namespace &lt;namespace-name&gt;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>yaml 方式</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl delete -f &lt;namespace.yaml&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"设置名字空间偏好\">设置名字空间偏好</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 默认为 default，即我们在执行 &#x27;kubbectl get pod&#x27; 时，默认会查看 default 这个名字空间下的所有 Pod</span></span><br><span class=\"line\">kubectl config set-context --current --namespace=&lt;namespace-name&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"查看资源时指定命名空间\">查看资源时指定命名空间</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get pod -n &lt;namespace-name&gt;</span><br><span class=\"line\">kubectl get service -n &lt;namespace-name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看所有命名空间下的资源，-A, --all-namespaces</span></span><br><span class=\"line\">kubectl get pod -A</span><br><span class=\"line\">kubectl get service -A</span><br></pre></td></tr></table></figure>\n<h2 id=\"并非所有对象都在名字空间中\">并非所有对象都在名字空间中</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 位于名字空间中的资源</span></span><br><span class=\"line\">kubectl api-resources --namespaced=<span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 不在名字空间中的资源</span></span><br><span class=\"line\">kubectl api-resources --namespaced=<span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>kubectl api-resources</code> 这个命令很有用，我们可以通过该命令获取所有资源的 <code>简写</code>，也可以获取资源的 <code>apiVersion</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl api-resources</span><br><span class=\"line\">NAME: 资源名称</span><br><span class=\"line\">SHORTNAMES: 简写</span><br><span class=\"line\">APIVERSION: apiVersion</span><br><span class=\"line\">NAMESPACED: 是否在名字空间中</span><br><span class=\"line\">KIND: 资源类型</span><br></pre></td></tr></table></figure>\n<h2 id=\"Kubernetes-中关于-命名空间（namespace）与-DNS-的机制\">Kubernetes 中关于 命名空间（namespace）与 DNS 的机制</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Kubernetes 服务有自动的 DNS 名称，它和命名空间有关。默认是能在本命名空间内直接访问；跨命名空间访问需要写完整域名（FQDN）。</p>\n</li>\n<li class=\"lvl-2\">\n<p>命名空间名字不能重复，且命名空间名字不能乱起，尤其不要用公共互联网域名名词（如 com、org、net、cn 等）。</p>\n</li>\n</ul>\n<h3 id=\"举个例子说明服务-DNS-是怎么工作的\">举个例子说明服务 DNS 是怎么工作的</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>场景：你在两个命名空间中部署了两个 nginx 服务</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 命名空间 dev 中创建服务 nginx</span></span><br><span class=\"line\">kubectl create ns dev</span><br><span class=\"line\">kubectl create deployment nginx --image=nginx --replicas=2 -n dev</span><br><span class=\"line\">kubectl expose deployment nginx --port=80 --<span class=\"built_in\">type</span>=NodePort -n dev</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 命名空间 prod 中也创建服务 nginx</span></span><br><span class=\"line\">kubectl create ns prod</span><br><span class=\"line\">kubectl create deployment nginx --image=nginx --replicas=2 -n prod</span><br><span class=\"line\">kubectl expose deployment nginx --port=80 --<span class=\"built_in\">type</span>=NodePort -n prod</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1️⃣ 如果你在 dev 命名空间的 Pod 里访问如下请求，它实际解析的 DNS 是 <code>nginx.dev.svc.cluster.local</code>，也就是 <code>&lt;服务名&gt;.&lt;命名空间&gt;.svc.cluster.local</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http://nginx</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2️⃣ 如果你想从 dev 命名空间访问 prod 命名空间的 nginx 服务，你必须这样访问</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http://nginx.prod.svc.cluster.local</span><br></pre></td></tr></table></figure>\n<h2 id=\"快速生成-k8s-资源的yaml模板\">快速生成 k8s 资源的yaml模板</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>安装 vscode 插件：YAML(Red Hat)，Kubernetes Templates(lunuan)</p>\n</li>\n<li class=\"lvl-2\">\n<p>使用时打开一个yaml文件，或者将文件格式切换为yaml，然后输入关键字 pod、deploy、service 等等 k8s 资源名称，就会弹出模板选择，选择后回车就会生成模板</p>\n</li>\n</ul>\n","content_text":"摘要 本文介绍 K8S 的 Namespace，本文以 CentOS 8 为例。 K8S官网 k8s Github k8s Namespace 介绍 命名空间(Namespace) 介绍 在 Kubernetes 中，命名空间提供了一种在单个集群中隔离资源组的机制。资源名称在命名空间内需要唯一，但不需要跨命名空间唯一。 基于命名空间的作用域仅适用于命名空间对象 （例如，Deployments、Services 等），而不适用于集群范围的对象（例如 StorageClass、Nodes、PersistentVolumes 等）。 Namespace 是在多个用户之间划分集群资源的一种方法，适用于跨多个团队或项目的场景，Namespace 不能相互嵌套，每个 Kubernetes 资源只能在一个 Namespace 中。 避免使用前缀 kube- 创建 Namespace，因为它是为 Kubernetes 系统 Namespace 保留的。 Kubernetes 启动时会创建四个初始 Namespace： 名称空间名称 说明 default 默认命名空间，供用户开始使用新集群时直接部署资源，无需额外创建命名空间。 kube-node-lease 存放与各个 Node 关联的 Lease（租约）对象，用于 Kubelet 发送心跳，帮助控制平面检测节点健康状态。 kube-public 所有客户端（包括匿名用户）都可以读取，主要用于集群范围内需要公开访问的资源。公共属性是一种使用约定。 kube-system Kubernetes 系统组件（如 kube-dns、kube-proxy 等）运行所在的命名空间。由系统自动管理。 查看集群中的命名空间 123# namespace 可以简写为 nskubectl get namespacekubectl get ns 创建命名空间 命令行方式 1kubectl create namespace &lt;namespace-name&gt; yaml 方式 1234apiVersion: v1 # API 版本，可以通过 kubectl api-resources | grep Namespace 获取kind: Namespace # 资源类型metadata: # 元数据 name: &lt;namespace-name&gt; # 命名空间名称 1kubectl apply -f &lt;namespace.yaml&gt; 通过命令行直接生成yaml文件 12# --dry-run=client: 本地模拟运行命令，不会真的执行，-o yaml: 输出yaml格式kubectl create namespace &lt;namespace-name&gt; --dry-run=client -o yaml &gt; &lt;namespace.yaml&gt; 删除命名空间 命令行方式 1kubectl delete namespace &lt;namespace-name&gt; yaml 方式 1kubectl delete -f &lt;namespace.yaml&gt; 设置名字空间偏好 12# 默认为 default，即我们在执行 &#x27;kubbectl get pod&#x27; 时，默认会查看 default 这个名字空间下的所有 Podkubectl config set-context --current --namespace=&lt;namespace-name&gt; 查看资源时指定命名空间 123456kubectl get pod -n &lt;namespace-name&gt;kubectl get service -n &lt;namespace-name&gt;# 查看所有命名空间下的资源，-A, --all-namespaceskubectl get pod -Akubectl get service -A 并非所有对象都在名字空间中 12345# 位于名字空间中的资源kubectl api-resources --namespaced=true# 不在名字空间中的资源kubectl api-resources --namespaced=false kubectl api-resources 这个命令很有用，我们可以通过该命令获取所有资源的 简写，也可以获取资源的 apiVersion 123456kubectl api-resourcesNAME: 资源名称SHORTNAMES: 简写APIVERSION: apiVersionNAMESPACED: 是否在名字空间中KIND: 资源类型 Kubernetes 中关于 命名空间（namespace）与 DNS 的机制 Kubernetes 服务有自动的 DNS 名称，它和命名空间有关。默认是能在本命名空间内直接访问；跨命名空间访问需要写完整域名（FQDN）。 命名空间名字不能重复，且命名空间名字不能乱起，尤其不要用公共互联网域名名词（如 com、org、net、cn 等）。 举个例子说明服务 DNS 是怎么工作的 场景：你在两个命名空间中部署了两个 nginx 服务 123456789# 命名空间 dev 中创建服务 nginxkubectl create ns devkubectl create deployment nginx --image=nginx --replicas=2 -n devkubectl expose deployment nginx --port=80 --type=NodePort -n dev# 命名空间 prod 中也创建服务 nginxkubectl create ns prodkubectl create deployment nginx --image=nginx --replicas=2 -n prodkubectl expose deployment nginx --port=80 --type=NodePort -n prod 1️⃣ 如果你在 dev 命名空间的 Pod 里访问如下请求，它实际解析的 DNS 是 nginx.dev.svc.cluster.local，也就是 &lt;服务名&gt;.&lt;命名空间&gt;.svc.cluster.local 1curl http://nginx 2️⃣ 如果你想从 dev 命名空间访问 prod 命名空间的 nginx 服务，你必须这样访问 1curl http://nginx.prod.svc.cluster.local 快速生成 k8s 资源的yaml模板 安装 vscode 插件：YAML(Red Hat)，Kubernetes Templates(lunuan) 使用时打开一个yaml文件，或者将文件格式切换为yaml，然后输入关键字 pod、deploy、service 等等 k8s 资源名称，就会弹出模板选择，选择后回车就会生成模板","summary":"摘要 本文介绍 K8S 的 Namespace，本文以 CentOS 8 为例。 K8S官网 k8s Github k8s Namespace 介绍","date_published":"2025-07-02T13:30:05.000Z","tags":["技术","k8s","K8S"]},{"id":"https://blog.hanqunfeng.com/2025/07/01/k8s-install-sealos/","url":"https://blog.hanqunfeng.com/2025/07/01/k8s-install-sealos/","title":"Linux 安装 K8S 之 sealos","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 Linux 下 使用 sealos 安装 K8S 的方法，本文以 CentOS 8 为例。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/\">K8S官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/kubernetes/kubernetes\">k8s Github</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://sealos.run/docs/k8s/quick-start/deploy-kubernetes\">sealos官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/labring/sealos\">sealos Github</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"安装前设置-所有节点\">安装前设置(所有节点)</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>准备三台可以连接外网的主机，不要安装docker,k8s等，如已安装需先卸载</p>\n</li>\n<li class=\"lvl-2\">\n<p>(推荐)升级系统内核，本文中非必须，升级内核方法参看 <a href=\"/2025/06/29/k8s-install-kubeadm/\" title=\"Linux 安装 K8S 之 kubeadm\">Linux 安装 K8S 之 kubeadm</a></p>\n</li>\n</ul>\n<h3 id=\"每个集群节点应该有不同的主机名，主机名不要带下划线\">每个集群节点应该有不同的主机名，主机名不要带下划线</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 添加主机名映射: vi /etc/hosts</span></span><br><span class=\"line\">10.211.55.12 k8s-m1</span><br><span class=\"line\">10.211.55.13 k8s-w1</span><br><span class=\"line\">10.211.55.14 k8s-w2</span><br></pre></td></tr></table></figure>\n<h3 id=\"修正系统的时间\">修正系统的时间</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装chrony</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> dnf install chrony -y</span><br><span class=\"line\"><span class=\"comment\"># 启动服务</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl <span class=\"built_in\">enable</span> --now chronyd</span><br><span class=\"line\"><span class=\"comment\"># 修正时间</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> chronyc makestep</span><br><span class=\"line\"><span class=\"comment\"># 查看时间</span></span><br><span class=\"line\"><span class=\"built_in\">date</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"安装-sealos\">安装 sealos</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载</span></span><br><span class=\"line\">wget https://github.com/labring/sealos/releases/download/v5.0.1/sealos_5.0.1_linux_amd64.rpm</span><br><span class=\"line\"><span class=\"comment\"># 安装</span></span><br><span class=\"line\">yum install -y sealos_5.0.1_linux_amd64.rpm</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>安装 sealos 的自动补全</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;source &lt;(sealos completion bash)&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建k8s集群-master\">创建k8s集群(master)</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建集群: 使用sealos创建集群只需要一行命令，目前官网示例中的k8s版本为v1.29.9(小版本号越高越稳定)</p>\n</li>\n<li class=\"lvl-2\">\n<p>可以在<a href=\"https://hub.docker.com\">docker hub</a>上查询，或者使用 <a href=\"https://explore.ggcr.dev/\">Registry Explorer</a> 查看如下镜像的所有版本，不建议使用太高的版本，有可能安装失败。</p>\n</li>\n<li class=\"lvl-2\">\n<p>注意 sealos 与 kubernetes 的版本有对应关系，目前 <code>Sealos &gt;=v5.0.0</code> 对应的 <code>K8s &gt;=1.28</code>，具体可以从<a href=\"https://sealos.run/docs/k8s/quick-start/deploy-kubernetes\">sealos官网</a>查询</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 国内可以在镜像前面加上 registry.cn-shanghai.aliyuncs.com/</span></span><br><span class=\"line\"><span class=\"comment\"># sealos 推荐的网络接口是 cilium</span></span><br><span class=\"line\">$ sealos run labring/kubernetes:v1.29.9 labring/helm:v3.9.4 labring/cilium:v1.13.4 \\</span><br><span class=\"line\">     --masters 10.211.55.12 \\</span><br><span class=\"line\">     --nodes 10.211.55.13,10.211.55.14 -p [your-ssh-passwd]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># -masters: 指定 master 节点的 IP 地址，多个节点之间用逗号隔开，但必须是奇数</span></span><br><span class=\"line\"><span class=\"comment\"># -nodes: 指定 worker 节点的 IP 地址，多个节点之间用逗号隔开。</span></span><br><span class=\"line\"><span class=\"comment\"># -p, --passwd: 指定 SSH 登录密码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 安装成功会显示如下内容</span></span><br><span class=\"line\">ℹ️  Using Cilium version 1.13.4</span><br><span class=\"line\">🔮 Auto-detected cluster name: kubernetes</span><br><span class=\"line\">🔮 Auto-detected datapath mode: tunnel</span><br><span class=\"line\">🔮 Auto-detected kube-proxy has been installed</span><br><span class=\"line\">2025-07-01T16:59:27 info succeeded <span class=\"keyword\">in</span> creating a new cluster, enjoy it!</span><br><span class=\"line\">2025-07-01T16:59:27 info</span><br><span class=\"line\">      ___           ___           ___           ___       ___           ___</span><br><span class=\"line\">     /\\  \\         /\\  \\         /\\  \\         /\\__\\     /\\  \\         /\\  \\</span><br><span class=\"line\">    /::\\  \\       /::\\  \\       /::\\  \\       /:/  /    /::\\  \\       /::\\  \\</span><br><span class=\"line\">   /:/\\ \\  \\     /:/\\:\\  \\     /:/\\:\\  \\     /:/  /    /:/\\:\\  \\     /:/\\ \\  \\</span><br><span class=\"line\">  _\\:\\~\\ \\  \\   /::\\~\\:\\  \\   /::\\~\\:\\  \\   /:/  /    /:/  \\:\\  \\   _\\:\\~\\ \\  \\</span><br><span class=\"line\"> /\\ \\:\\ \\ \\__\\ /:/\\:\\ \\:\\__\\ /:/\\:\\ \\:\\__\\ /:/__/    /:/__/ \\:\\__\\ /\\ \\:\\ \\ \\__\\</span><br><span class=\"line\"> \\:\\ \\:\\ \\/__/ \\:\\~\\:\\ \\/__/ \\/__\\:\\/:/  / \\:\\  \\    \\:\\  \\ /:/  / \\:\\ \\:\\ \\/__/</span><br><span class=\"line\">  \\:\\ \\:\\__\\    \\:\\ \\:\\__\\        \\::/  /   \\:\\  \\    \\:\\  /:/  /   \\:\\ \\:\\__\\</span><br><span class=\"line\">   \\:\\/:/  /     \\:\\ \\/__/        /:/  /     \\:\\  \\    \\:\\/:/  /     \\:\\/:/  /</span><br><span class=\"line\">    \\::/  /       \\:\\__\\         /:/  /       \\:\\__\\    \\::/  /       \\::/  /</span><br><span class=\"line\">     \\/__/         \\/__/         \\/__/         \\/__/     \\/__/         \\/__/</span><br><span class=\"line\"></span><br><span class=\"line\">                  Website: https://www.sealos.io/</span><br><span class=\"line\">                  Address: github.com/labring/sealos</span><br><span class=\"line\">                  Version: 5.0.1-2b74a1281</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启用 shell 自动补全功能</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.安装 bash-completion</span></span><br><span class=\"line\"><span class=\"comment\"># 1.1 检查bash-completion是否已安装，有输出说明已经安装</span></span><br><span class=\"line\">$ <span class=\"built_in\">type</span> _init_completion</span><br><span class=\"line\"><span class=\"comment\"># 1.2 安装bash-completion，安装后会创建文件 /usr/share/bash-completion/bash_completion</span></span><br><span class=\"line\">$ dnf install bash-completion</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.安装 kubectl 的自动补全功能</span></span><br><span class=\"line\"><span class=\"comment\"># 2.1 当前用户</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;source &lt;(kubectl completion bash)&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class=\"line\"><span class=\"comment\"># 2.2 所有用户</span></span><br><span class=\"line\">kubectl completion bash | <span class=\"built_in\">sudo</span> <span class=\"built_in\">tee</span> /etc/bash_completion.d/kubectl &gt; /dev/null</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">chmod</span> a+r /etc/bash_completion.d/kubectl</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3 如果 kubectl 有关联的别名，你可以扩展 Shell 补全来适配此别名</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;alias k=kubectl&#x27;</span> &gt;&gt;~/.bashrc</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;complete -o default -F __start_kubectl k&#x27;</span> &gt;&gt;~/.bashrc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4.刷新配置文件</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建集群成功后，查看集群状态</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看版本</span></span><br><span class=\"line\">$ kubectl version</span><br><span class=\"line\">Client Version: v1.29.9</span><br><span class=\"line\">Kustomize Version: v5.0.4-0.20230601165947-6ce0bf390ce3</span><br><span class=\"line\">Server Version: v1.29.9</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看节点</span></span><br><span class=\"line\">$ kubectl get nodes -owide</span><br><span class=\"line\">NAME     STATUS   ROLES           AGE     VERSION   INTERNAL-IP    EXTERNAL-IP   OS-IMAGE                            KERNEL-VERSION             CONTAINER-RUNTIME</span><br><span class=\"line\">k8s-m1   Ready    control-plane   3m11s   v1.29.9   10.211.55.12   &lt;none&gt;        Rocky Linux 8.10 (Green Obsidian)   4.18.0-553.el8_10.x86_64   containerd://1.7.27</span><br><span class=\"line\">k8s-w1   Ready    &lt;none&gt;          2m52s   v1.29.9   10.211.55.13   &lt;none&gt;        Rocky Linux 8.10 (Green Obsidian)   4.18.0-553.el8_10.x86_64   containerd://1.7.27</span><br><span class=\"line\">k8s-w2   Ready    &lt;none&gt;          2m55s   v1.29.9   10.211.55.14   &lt;none&gt;        Rocky Linux 8.10 (Green Obsidian)   4.18.0-553.el8_10.x86_64   containerd://1.7.27</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看资源</span></span><br><span class=\"line\">$ kubectl get all -A -owide</span><br><span class=\"line\">NAMESPACE     NAME                                   READY   STATUS    RESTARTS   AGE     IP             NODE     NOMINATED NODE   READINESS GATES</span><br><span class=\"line\">kube-system   pod/cilium-bbbdl                       1/1     Running   0          3m47s   10.211.55.13   k8s-w1   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">kube-system   pod/cilium-cz47k                       1/1     Running   0          3m47s   10.211.55.14   k8s-w2   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">kube-system   pod/cilium-operator-6946ccbcc5-cxnn4   1/1     Running   0          3m47s   10.211.55.13   k8s-w1   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">kube-system   pod/cilium-vfc22                       1/1     Running   0          3m47s   10.211.55.12   k8s-m1   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">kube-system   pod/coredns-76f75df574-2ln5x           1/1     Running   0          3m54s   10.0.0.74      k8s-w1   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">kube-system   pod/coredns-76f75df574-plsds           1/1     Running   0          3m54s   10.0.0.146     k8s-w1   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">kube-system   pod/etcd-k8s-m1                        1/1     Running   0          4m6s    10.211.55.12   k8s-m1   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">kube-system   pod/kube-apiserver-k8s-m1              1/1     Running   0          4m6s    10.211.55.12   k8s-m1   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">kube-system   pod/kube-controller-manager-k8s-m1     1/1     Running   0          4m6s    10.211.55.12   k8s-m1   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">kube-system   pod/kube-proxy-4xbzt                   1/1     Running   0          3m51s   10.211.55.13   k8s-w1   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">kube-system   pod/kube-proxy-rjs8h                   1/1     Running   0          3m54s   10.211.55.14   k8s-w2   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">kube-system   pod/kube-proxy-xv4fg                   1/1     Running   0          3m55s   10.211.55.12   k8s-m1   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">kube-system   pod/kube-scheduler-k8s-m1              1/1     Running   0          4m6s    10.211.55.12   k8s-m1   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">kube-system   pod/kube-sealos-lvscare-k8s-w1         1/1     Running   0          3m31s   10.211.55.13   k8s-w1   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">kube-system   pod/kube-sealos-lvscare-k8s-w2         1/1     Running   0          3m34s   10.211.55.14   k8s-w2   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">NAMESPACE     NAME                  TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)                  AGE     SELECTOR</span><br><span class=\"line\">default       service/kubernetes    ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP                  4m8s    &lt;none&gt;</span><br><span class=\"line\">kube-system   service/hubble-peer   ClusterIP   10.96.1.9    &lt;none&gt;        443/TCP                  3m47s   k8s-app=cilium</span><br><span class=\"line\">kube-system   service/kube-dns      ClusterIP   10.96.0.10   &lt;none&gt;        53/UDP,53/TCP,9153/TCP   4m7s    k8s-app=kube-dns</span><br><span class=\"line\"></span><br><span class=\"line\">NAMESPACE     NAME                        DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR            AGE     CONTAINERS     IMAGES                               SELECTOR</span><br><span class=\"line\">kube-system   daemonset.apps/cilium       3         3         3       3            3           kubernetes.io/os=linux   3m47s   cilium-agent   quay.io/cilium/cilium:v1.13.4        k8s-app=cilium</span><br><span class=\"line\">kube-system   daemonset.apps/kube-proxy   3         3         3       3            3           kubernetes.io/os=linux   4m7s    kube-proxy     registry.k8s.io/kube-proxy:v1.29.9   k8s-app=kube-proxy</span><br><span class=\"line\"></span><br><span class=\"line\">NAMESPACE     NAME                              READY   UP-TO-DATE   AVAILABLE   AGE     CONTAINERS        IMAGES                                    SELECTOR</span><br><span class=\"line\">kube-system   deployment.apps/cilium-operator   1/1     1            1           3m47s   cilium-operator   quay.io/cilium/operator:v1.13.4           io.cilium/app=operator,name=cilium-operator</span><br><span class=\"line\">kube-system   deployment.apps/coredns           2/2     2            2           4m7s    coredns           registry.k8s.io/coredns/coredns:v1.11.1   k8s-app=kube-dns</span><br><span class=\"line\"></span><br><span class=\"line\">NAMESPACE     NAME                                         DESIRED   CURRENT   READY   AGE     CONTAINERS        IMAGES                                    SELECTOR</span><br><span class=\"line\">kube-system   replicaset.apps/cilium-operator-6946ccbcc5   1         1         1       3m47s   cilium-operator   quay.io/cilium/operator:v1.13.4           io.cilium/app=operator,name=cilium-operator,pod-template-hash=6946ccbcc5</span><br><span class=\"line\">kube-system   replicaset.apps/coredns-76f75df574           2         2         2       3m54s   coredns           registry.k8s.io/coredns/coredns:v1.11.1   k8s-app=kube-dns,pod-template-hash=76f75df574</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"测试：用K8S部署Nginx\">测试：用K8S部署Nginx</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建deployment</span></span><br><span class=\"line\">kubectl create deployment nginx --image=nginx</span><br><span class=\"line\"><span class=\"comment\"># 创建service，--type指定为NodePort，其含义为将deployment的80端口映射到Node的随机端口</span></span><br><span class=\"line\">kubectl expose deployment nginx --<span class=\"built_in\">type</span>=NodePort --port=80</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看pod和service，不加 -n 参数，默认查看的是default命名空间</span></span><br><span class=\"line\">$ k get pods,svc -owide</span><br><span class=\"line\">NAME                         READY   STATUS    RESTARTS   AGE   IP           NODE     NOMINATED NODE   READINESS GATES</span><br><span class=\"line\">pod/nginx-7854ff8877-wgfxc   1/1     Running   0          19s   10.0.1.204   k8s-w2   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)        AGE   SELECTOR</span><br><span class=\"line\">service/kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP        44m   &lt;none&gt;</span><br><span class=\"line\">service/nginx        NodePort    10.96.2.54   &lt;none&gt;        80:31044/TCP   5s    app=nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 浏览器访问任意nodeIP:31044</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除测试资源</span></span><br><span class=\"line\"><span class=\"comment\">## 删除deployment</span></span><br><span class=\"line\">kubectl delete deployment nginx</span><br><span class=\"line\"><span class=\"comment\">## 删除service</span></span><br><span class=\"line\">kubectl delete service nginx</span><br></pre></td></tr></table></figure>\n<h2 id=\"sealos-命令\">sealos 命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>sealos 命令概览</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cluster Management Commands:</span><br><span class=\"line\">  apply         使用 Clusterfile 在 Kubernetes 集群中运行云镜像</span><br><span class=\"line\">  cert          更新 Kubernetes API Server 的证书</span><br><span class=\"line\">  run           轻松运行云原生应用，可用于已有或新建集群</span><br><span class=\"line\">  reset         重置集群中的所有内容</span><br><span class=\"line\">  status        查看 sealos 的状态</span><br><span class=\"line\"></span><br><span class=\"line\">Node Management Commands:</span><br><span class=\"line\">  add           向集群中添加节点</span><br><span class=\"line\">  delete        从集群中移除节点</span><br><span class=\"line\"></span><br><span class=\"line\">Remote Operation Commands:</span><br><span class=\"line\">  <span class=\"built_in\">exec</span>          在指定节点上执行 shell 命令或脚本</span><br><span class=\"line\">  scp           将文件复制到指定节点的远程主机上</span><br><span class=\"line\"></span><br><span class=\"line\">Experimental Commands:</span><br><span class=\"line\">  registry      与镜像仓库相关的实验性功能</span><br><span class=\"line\"></span><br><span class=\"line\">Container and Image Commands:</span><br><span class=\"line\">  build         根据 Containerfile 或 Kubefile 构建镜像</span><br><span class=\"line\">  create        创建集群但不执行命令，用于检查镜像</span><br><span class=\"line\">  diff          查看对象文件系统的更改</span><br><span class=\"line\">  inspect       检查容器或镜像的配置信息</span><br><span class=\"line\">  images        列出本地存储中的镜像</span><br><span class=\"line\">  load          从归档文件加载镜像</span><br><span class=\"line\">  login         登录到容器镜像仓库</span><br><span class=\"line\">  <span class=\"built_in\">logout</span>        登出容器镜像仓库</span><br><span class=\"line\">  manifest      操作 manifest 列表和镜像索引</span><br><span class=\"line\">  merge         合并多个镜像为一个</span><br><span class=\"line\">  pull          从指定位置拉取镜像</span><br><span class=\"line\">  push          将镜像推送到指定目标</span><br><span class=\"line\">  rmi           从本地删除一个或多个镜像</span><br><span class=\"line\">  save          将镜像保存为归档文件</span><br><span class=\"line\">  tag           为本地镜像添加额外的名称标签</span><br><span class=\"line\"></span><br><span class=\"line\">Other Commands:</span><br><span class=\"line\">  completion    生成指定 shell 的自动补全脚本</span><br><span class=\"line\">  docs          生成 API 参考文档</span><br><span class=\"line\">  <span class=\"built_in\">env</span>           输出 sealos 使用的所有环境变量信息</span><br><span class=\"line\">  gen           生成包含默认设置的 Clusterfile</span><br><span class=\"line\">  version       打印版本信息</span><br></pre></td></tr></table></figure>\n<h3 id=\"集群管理-master节点执行命令\">集群管理(master节点执行命令)</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建集群</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sealos run labring/kubernetes:v1.29.9 labring/helm:v3.9.4 labring/cilium:v1.13.4 \\</span><br><span class=\"line\">     --masters 10.211.55.12 \\</span><br><span class=\"line\">     --nodes 10.211.55.13,10.211.55.14 -p [your-ssh-passwd]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 参数说明</span></span><br><span class=\"line\">-masters: 指定 master 节点的 IP 地址，多个节点之间用逗号隔开，但必须是奇数</span><br><span class=\"line\">-nodes: 指定 worker 节点的 IP 地址，多个节点之间用逗号隔开。</span><br><span class=\"line\">-p, --passwd: 指定 SSH 登录密码</span><br><span class=\"line\">-u, --user: 登录用户名，默认为 root</span><br><span class=\"line\">-i, --pk=<span class=\"string\">&#x27;/root/.ssh/id_rsa&#x27;</span>: 指定 SSH 密钥文件路径</span><br><span class=\"line\">--port: 指定 SSH 端口，默认为 22</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Clusterfile 方式创建集群</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 生成集群配置文件，Clusterfile就是一个yaml文件，里面包含集群的配置信息</span></span><br><span class=\"line\">sealos gen labring/kubernetes:v1.29.9 labring/helm:v3.9.4 labring/cilium:v1.13.4 \\</span><br><span class=\"line\">     --masters 10.211.55.12 \\</span><br><span class=\"line\">     --nodes 10.211.55.13,10.211.55.14 -p [your-ssh-passwd] &gt; Clusterfile</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 执行配置文件</span></span><br><span class=\"line\">sealos apply -f Clusterfile</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看集群状态</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sealos status</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>清除K8s集群</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sealos reset</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>更新 Kubernetes API 服务器的证书</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># sealos 创建的证书存放在 /etc/kubernetes/pki/ 下，默认证书有效期为 100 年</span></span><br><span class=\"line\"><span class=\"comment\"># 更新证书一般只会在添加新的访问ip或域名时才需要</span></span><br><span class=\"line\">sealos cert --alt-names apiserver.cluster.local,10.211.55.12,127.0.0.1,localhost</span><br><span class=\"line\"><span class=\"comment\"># 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># --alt-names: 添加新的访问ip或域名，多个逗号分隔</span></span><br><span class=\"line\"><span class=\"comment\"># -c, --cluster=&#x27;default&#x27;: 要执行 exec 操作的集群的名称。默认为 default。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 更新证书后，你可以使用以下命令进行校验：</span></span><br><span class=\"line\">kubectl -n kube-system get cm kubeadm-config -o yaml</span><br><span class=\"line\">openssl x509 -<span class=\"keyword\">in</span> /etc/kubernetes/pki/apiserver.crt -text</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在执行此操作之前，你最好先备份旧的证书。<br>\n执行 sealos cert 命令后，会更新集群 API 服务器的证书，你无需手动重启 API 服务器，sealos会自动帮你重启服务。</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看环境变量</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -v 显示变量的说明</span></span><br><span class=\"line\">sealos <span class=\"built_in\">env</span> -v</span><br><span class=\"line\"><span class=\"comment\">## 说明</span></span><br><span class=\"line\">SEALOS_PROMPT=enabled <span class=\"comment\"># 是否启用终端中的交互提示功能。</span></span><br><span class=\"line\">SEALOS_RUNTIME_ROOT=/root/.sealos <span class=\"comment\"># Sealos 的运行时根目录，用于持久化运行相关的操作或配置。</span></span><br><span class=\"line\">SEALOS_DATA_ROOT=/var/lib/sealos  <span class=\"comment\"># 集群在远程节点上的根目录路径，用于存储集群相关的数据。</span></span><br><span class=\"line\">BUILDAH_FORMAT=oci <span class=\"comment\"># 镜像构建时使用的格式，`oci` 表示符合 OCI 镜像规范。</span></span><br><span class=\"line\">BUILDAH_LOG_LEVEL= <span class=\"comment\"># buildah 模块中使用的日志级别，可以是 &quot;trace&quot;, &quot;debug&quot;, &quot;info&quot;, &quot;warn&quot;, &quot;error&quot;, &quot;fatal&quot;, 或 &quot;panic&quot;。</span></span><br><span class=\"line\">CONTAINERS_STORAGE_CONF= <span class=\"comment\"># 容器存储配置文件的路径，设置这个变量可以覆盖默认的配置位置。</span></span><br><span class=\"line\">SEALOS_SYNC_WORKDIR=<span class=\"literal\">true</span> <span class=\"comment\"># 是否将运行时根目录（SEALOS_RUNTIME_ROOT）同步到所有 master 节点，作为备份用途。</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在集群中执行命令</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># sealos exec &quot;shell command or script&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在所有节点上执行命令</span></span><br><span class=\"line\">sealos <span class=\"built_in\">exec</span> <span class=\"string\">&quot;cat /etc/hosts&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在指定的节点上执行命令，--ips: 参数指定要执行的节点IP，多个节点之间用逗号分隔</span></span><br><span class=\"line\">sealos <span class=\"built_in\">exec</span> <span class=\"string\">&quot;cat /etc/hosts&quot;</span> --ips=10.211.55.13,10.211.55.14</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在集群间拷贝文件</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># sealos scp &quot;source file path&quot; &quot;destination file path&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 在所有节点上执行命令</span></span><br><span class=\"line\">sealos scp ~/Clusterfile /tmp/Clusterfile</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在指定的节点上执行命令，--ips: 参数指定要执行的节点IP，多个节点之间用逗号分隔</span></span><br><span class=\"line\">sealos scp ~/Clusterfile /tmp/Clusterfile --ips=10.211.55.13,10.211.55.14</span><br></pre></td></tr></table></figure>\n<h3 id=\"节点管理-master节点执行命令\">节点管理(master节点执行命令)</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>添加 master 节点</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 添加 master 节点后，总的 master 节点个数必须为奇数，否则会报错</span></span><br><span class=\"line\">sealos add --masters 10.211.55.18,10.211.55.19</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>添加 worker 节点</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 添加 worker 节点，多个都会分隔</span></span><br><span class=\"line\">sealos add --nodes 10.211.55.20,10.211.55.21</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>删除 master 节点</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除 master 节点后，剩余的 master 节点个数必须为奇数，否则会报错</span></span><br><span class=\"line\">sealos delete --masters 10.211.55.18,10.211.55.19</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>删除 worker 节点</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sealos delete --nodes 10.211.55.20,10.211.55.21</span><br></pre></td></tr></table></figure>\n<h3 id=\"镜像管理\">镜像管理</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看所有镜像</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sealos images</span><br><span class=\"line\">REPOSITORY                                                 TAG        IMAGE ID       CREATED         SIZE</span><br><span class=\"line\">docker.io/labring/kubernetes                               v1.29.9    bca192f35556   2 months ago    669 MB</span><br><span class=\"line\">docker.io/labring/cilium                                   v1.13.4    71aa52ad0a11   23 months ago   483 MB</span><br><span class=\"line\">docker.io/labring/helm                                     v3.9.4     3376f6822067   2 years ago     46.4 MB</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>删除镜像</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># sealos rmi [image_id] | [image_name]</span></span><br><span class=\"line\">sealos rmi docker.io/labring/kubernetes:v1.29.9</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>拉取镜像</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sealos pull docker.io/labring/kubernetes:v1.29.9</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>登录镜像仓库，建议登录仓库，这样可以提高拉取镜像的次数，避免拉取镜像失败</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># docker.io 官方dockerhub镜像仓库</span></span><br><span class=\"line\">sealos login docker.io -u [username] -p [password]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>为镜像打tag</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sealos tag docker.io/labring/kubernetes:v1.29.9 docker.io/hanqunfeng/kubernetes:v1.29.9</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>推送镜像</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sealos push docker.io/hanqunfeng/kubernetes:v1.29.9</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看镜像详情</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># sealos inspect [image_id] | [image_name]</span></span><br><span class=\"line\">sealos inspect docker.io/labring/kubernetes:v1.29.9</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>登出镜像仓库</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 登出指定的仓库</span></span><br><span class=\"line\">sealos <span class=\"built_in\">logout</span> docker.io</span><br><span class=\"line\"><span class=\"comment\"># 登出所有仓库</span></span><br><span class=\"line\">sealos <span class=\"built_in\">logout</span> --all</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>通过 Dockerfile 构建镜像</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 与 docker build 类似，构建好的镜像会增加前缀 localhost/</span></span><br><span class=\"line\">sealos build -t myapp:v1.0.0 -f Dockerfile .</span><br></pre></td></tr></table></figure>\n<h3 id=\"容器管理\">容器管理</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看所有容器</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sealos ps</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看容器详情</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># sealos inspect [container_id] | [container_name]</span></span><br><span class=\"line\">sealos inspect bca192f35556</span><br></pre></td></tr></table></figure>\n","content_text":"摘要 本文介绍 Linux 下 使用 sealos 安装 K8S 的方法，本文以 CentOS 8 为例。 K8S官网 k8s Github sealos官网 sealos Github 安装前设置(所有节点) 准备三台可以连接外网的主机，不要安装docker,k8s等，如已安装需先卸载 (推荐)升级系统内核，本文中非必须，升级内核方法参看 Linux 安装 K8S 之 kubeadm 每个集群节点应该有不同的主机名，主机名不要带下划线 1234# 添加主机名映射: vi /etc/hosts10.211.55.12 k8s-m110.211.55.13 k8s-w110.211.55.14 k8s-w2 修正系统的时间 12345678# 安装chronysudo dnf install chrony -y# 启动服务sudo systemctl enable --now chronyd# 修正时间sudo chronyc makestep# 查看时间date 安装 sealos 1234# 下载wget https://github.com/labring/sealos/releases/download/v5.0.1/sealos_5.0.1_linux_amd64.rpm# 安装yum install -y sealos_5.0.1_linux_amd64.rpm 安装 sealos 的自动补全 12echo &#x27;source &lt;(sealos completion bash)&#x27; &gt;&gt; ~/.bashrcsource ~/.bashrc 创建k8s集群(master) 创建集群: 使用sealos创建集群只需要一行命令，目前官网示例中的k8s版本为v1.29.9(小版本号越高越稳定) 可以在docker hub上查询，或者使用 Registry Explorer 查看如下镜像的所有版本，不建议使用太高的版本，有可能安装失败。 注意 sealos 与 kubernetes 的版本有对应关系，目前 Sealos &gt;=v5.0.0 对应的 K8s &gt;=1.28，具体可以从sealos官网查询 123456789101112131415161718192021222324252627282930313233# 国内可以在镜像前面加上 registry.cn-shanghai.aliyuncs.com/# sealos 推荐的网络接口是 cilium$ sealos run labring/kubernetes:v1.29.9 labring/helm:v3.9.4 labring/cilium:v1.13.4 \\ --masters 10.211.55.12 \\ --nodes 10.211.55.13,10.211.55.14 -p [your-ssh-passwd]## 参数说明# -masters: 指定 master 节点的 IP 地址，多个节点之间用逗号隔开，但必须是奇数# -nodes: 指定 worker 节点的 IP 地址，多个节点之间用逗号隔开。# -p, --passwd: 指定 SSH 登录密码## 安装成功会显示如下内容ℹ️ Using Cilium version 1.13.4🔮 Auto-detected cluster name: kubernetes🔮 Auto-detected datapath mode: tunnel🔮 Auto-detected kube-proxy has been installed2025-07-01T16:59:27 info succeeded in creating a new cluster, enjoy it!2025-07-01T16:59:27 info ___ ___ ___ ___ ___ ___ /\\ \\ /\\ \\ /\\ \\ /\\__\\ /\\ \\ /\\ \\ /::\\ \\ /::\\ \\ /::\\ \\ /:/ / /::\\ \\ /::\\ \\ /:/\\ \\ \\ /:/\\:\\ \\ /:/\\:\\ \\ /:/ / /:/\\:\\ \\ /:/\\ \\ \\ _\\:\\~\\ \\ \\ /::\\~\\:\\ \\ /::\\~\\:\\ \\ /:/ / /:/ \\:\\ \\ _\\:\\~\\ \\ \\ /\\ \\:\\ \\ \\__\\ /:/\\:\\ \\:\\__\\ /:/\\:\\ \\:\\__\\ /:/__/ /:/__/ \\:\\__\\ /\\ \\:\\ \\ \\__\\ \\:\\ \\:\\ \\/__/ \\:\\~\\:\\ \\/__/ \\/__\\:\\/:/ / \\:\\ \\ \\:\\ \\ /:/ / \\:\\ \\:\\ \\/__/ \\:\\ \\:\\__\\ \\:\\ \\:\\__\\ \\::/ / \\:\\ \\ \\:\\ /:/ / \\:\\ \\:\\__\\ \\:\\/:/ / \\:\\ \\/__/ /:/ / \\:\\ \\ \\:\\/:/ / \\:\\/:/ / \\::/ / \\:\\__\\ /:/ / \\:\\__\\ \\::/ / \\::/ / \\/__/ \\/__/ \\/__/ \\/__/ \\/__/ \\/__/ Website: https://www.sealos.io/ Address: github.com/labring/sealos Version: 5.0.1-2b74a1281 启用 shell 自动补全功能 12345678910111213141516171819# 1.安装 bash-completion# 1.1 检查bash-completion是否已安装，有输出说明已经安装$ type _init_completion# 1.2 安装bash-completion，安装后会创建文件 /usr/share/bash-completion/bash_completion$ dnf install bash-completion# 2.安装 kubectl 的自动补全功能# 2.1 当前用户echo &#x27;source &lt;(kubectl completion bash)&#x27; &gt;&gt; ~/.bashrc# 2.2 所有用户kubectl completion bash | sudo tee /etc/bash_completion.d/kubectl &gt; /dev/nullsudo chmod a+r /etc/bash_completion.d/kubectl# 3 如果 kubectl 有关联的别名，你可以扩展 Shell 补全来适配此别名echo &#x27;alias k=kubectl&#x27; &gt;&gt;~/.bashrcecho &#x27;complete -o default -F __start_kubectl k&#x27; &gt;&gt;~/.bashrc# 4.刷新配置文件source ~/.bashrc 创建集群成功后，查看集群状态 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 查看版本$ kubectl versionClient Version: v1.29.9Kustomize Version: v5.0.4-0.20230601165947-6ce0bf390ce3Server Version: v1.29.9# 查看节点$ kubectl get nodes -owideNAME STATUS ROLES AGE VERSION INTERNAL-IP EXTERNAL-IP OS-IMAGE KERNEL-VERSION CONTAINER-RUNTIMEk8s-m1 Ready control-plane 3m11s v1.29.9 10.211.55.12 &lt;none&gt; Rocky Linux 8.10 (Green Obsidian) 4.18.0-553.el8_10.x86_64 containerd://1.7.27k8s-w1 Ready &lt;none&gt; 2m52s v1.29.9 10.211.55.13 &lt;none&gt; Rocky Linux 8.10 (Green Obsidian) 4.18.0-553.el8_10.x86_64 containerd://1.7.27k8s-w2 Ready &lt;none&gt; 2m55s v1.29.9 10.211.55.14 &lt;none&gt; Rocky Linux 8.10 (Green Obsidian) 4.18.0-553.el8_10.x86_64 containerd://1.7.27# 查看资源$ kubectl get all -A -owideNAMESPACE NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATESkube-system pod/cilium-bbbdl 1/1 Running 0 3m47s 10.211.55.13 k8s-w1 &lt;none&gt; &lt;none&gt;kube-system pod/cilium-cz47k 1/1 Running 0 3m47s 10.211.55.14 k8s-w2 &lt;none&gt; &lt;none&gt;kube-system pod/cilium-operator-6946ccbcc5-cxnn4 1/1 Running 0 3m47s 10.211.55.13 k8s-w1 &lt;none&gt; &lt;none&gt;kube-system pod/cilium-vfc22 1/1 Running 0 3m47s 10.211.55.12 k8s-m1 &lt;none&gt; &lt;none&gt;kube-system pod/coredns-76f75df574-2ln5x 1/1 Running 0 3m54s 10.0.0.74 k8s-w1 &lt;none&gt; &lt;none&gt;kube-system pod/coredns-76f75df574-plsds 1/1 Running 0 3m54s 10.0.0.146 k8s-w1 &lt;none&gt; &lt;none&gt;kube-system pod/etcd-k8s-m1 1/1 Running 0 4m6s 10.211.55.12 k8s-m1 &lt;none&gt; &lt;none&gt;kube-system pod/kube-apiserver-k8s-m1 1/1 Running 0 4m6s 10.211.55.12 k8s-m1 &lt;none&gt; &lt;none&gt;kube-system pod/kube-controller-manager-k8s-m1 1/1 Running 0 4m6s 10.211.55.12 k8s-m1 &lt;none&gt; &lt;none&gt;kube-system pod/kube-proxy-4xbzt 1/1 Running 0 3m51s 10.211.55.13 k8s-w1 &lt;none&gt; &lt;none&gt;kube-system pod/kube-proxy-rjs8h 1/1 Running 0 3m54s 10.211.55.14 k8s-w2 &lt;none&gt; &lt;none&gt;kube-system pod/kube-proxy-xv4fg 1/1 Running 0 3m55s 10.211.55.12 k8s-m1 &lt;none&gt; &lt;none&gt;kube-system pod/kube-scheduler-k8s-m1 1/1 Running 0 4m6s 10.211.55.12 k8s-m1 &lt;none&gt; &lt;none&gt;kube-system pod/kube-sealos-lvscare-k8s-w1 1/1 Running 0 3m31s 10.211.55.13 k8s-w1 &lt;none&gt; &lt;none&gt;kube-system pod/kube-sealos-lvscare-k8s-w2 1/1 Running 0 3m34s 10.211.55.14 k8s-w2 &lt;none&gt; &lt;none&gt;NAMESPACE NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE SELECTORdefault service/kubernetes ClusterIP 10.96.0.1 &lt;none&gt; 443/TCP 4m8s &lt;none&gt;kube-system service/hubble-peer ClusterIP 10.96.1.9 &lt;none&gt; 443/TCP 3m47s k8s-app=ciliumkube-system service/kube-dns ClusterIP 10.96.0.10 &lt;none&gt; 53/UDP,53/TCP,9153/TCP 4m7s k8s-app=kube-dnsNAMESPACE NAME DESIRED CURRENT READY UP-TO-DATE AVAILABLE NODE SELECTOR AGE CONTAINERS IMAGES SELECTORkube-system daemonset.apps/cilium 3 3 3 3 3 kubernetes.io/os=linux 3m47s cilium-agent quay.io/cilium/cilium:v1.13.4 k8s-app=ciliumkube-system daemonset.apps/kube-proxy 3 3 3 3 3 kubernetes.io/os=linux 4m7s kube-proxy registry.k8s.io/kube-proxy:v1.29.9 k8s-app=kube-proxyNAMESPACE NAME READY UP-TO-DATE AVAILABLE AGE CONTAINERS IMAGES SELECTORkube-system deployment.apps/cilium-operator 1/1 1 1 3m47s cilium-operator quay.io/cilium/operator:v1.13.4 io.cilium/app=operator,name=cilium-operatorkube-system deployment.apps/coredns 2/2 2 2 4m7s coredns registry.k8s.io/coredns/coredns:v1.11.1 k8s-app=kube-dnsNAMESPACE NAME DESIRED CURRENT READY AGE CONTAINERS IMAGES SELECTORkube-system replicaset.apps/cilium-operator-6946ccbcc5 1 1 1 3m47s cilium-operator quay.io/cilium/operator:v1.13.4 io.cilium/app=operator,name=cilium-operator,pod-template-hash=6946ccbcc5kube-system replicaset.apps/coredns-76f75df574 2 2 2 3m54s coredns registry.k8s.io/coredns/coredns:v1.11.1 k8s-app=kube-dns,pod-template-hash=76f75df574 测试：用K8S部署Nginx 123456789101112131415161718192021# 创建deploymentkubectl create deployment nginx --image=nginx# 创建service，--type指定为NodePort，其含义为将deployment的80端口映射到Node的随机端口kubectl expose deployment nginx --type=NodePort --port=80# 查看pod和service，不加 -n 参数，默认查看的是default命名空间$ k get pods,svc -owideNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATESpod/nginx-7854ff8877-wgfxc 1/1 Running 0 19s 10.0.1.204 k8s-w2 &lt;none&gt; &lt;none&gt;NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE SELECTORservice/kubernetes ClusterIP 10.96.0.1 &lt;none&gt; 443/TCP 44m &lt;none&gt;service/nginx NodePort 10.96.2.54 &lt;none&gt; 80:31044/TCP 5s app=nginx# 浏览器访问任意nodeIP:31044# 删除测试资源## 删除deploymentkubectl delete deployment nginx## 删除servicekubectl delete service nginx sealos 命令 sealos 命令概览 1234567891011121314151617181920212223242526272829303132333435363738394041Cluster Management Commands: apply 使用 Clusterfile 在 Kubernetes 集群中运行云镜像 cert 更新 Kubernetes API Server 的证书 run 轻松运行云原生应用，可用于已有或新建集群 reset 重置集群中的所有内容 status 查看 sealos 的状态Node Management Commands: add 向集群中添加节点 delete 从集群中移除节点Remote Operation Commands: exec 在指定节点上执行 shell 命令或脚本 scp 将文件复制到指定节点的远程主机上Experimental Commands: registry 与镜像仓库相关的实验性功能Container and Image Commands: build 根据 Containerfile 或 Kubefile 构建镜像 create 创建集群但不执行命令，用于检查镜像 diff 查看对象文件系统的更改 inspect 检查容器或镜像的配置信息 images 列出本地存储中的镜像 load 从归档文件加载镜像 login 登录到容器镜像仓库 logout 登出容器镜像仓库 manifest 操作 manifest 列表和镜像索引 merge 合并多个镜像为一个 pull 从指定位置拉取镜像 push 将镜像推送到指定目标 rmi 从本地删除一个或多个镜像 save 将镜像保存为归档文件 tag 为本地镜像添加额外的名称标签Other Commands: completion 生成指定 shell 的自动补全脚本 docs 生成 API 参考文档 env 输出 sealos 使用的所有环境变量信息 gen 生成包含默认设置的 Clusterfile version 打印版本信息 集群管理(master节点执行命令) 创建集群 1234567891011sealos run labring/kubernetes:v1.29.9 labring/helm:v3.9.4 labring/cilium:v1.13.4 \\ --masters 10.211.55.12 \\ --nodes 10.211.55.13,10.211.55.14 -p [your-ssh-passwd]## 参数说明-masters: 指定 master 节点的 IP 地址，多个节点之间用逗号隔开，但必须是奇数-nodes: 指定 worker 节点的 IP 地址，多个节点之间用逗号隔开。-p, --passwd: 指定 SSH 登录密码-u, --user: 登录用户名，默认为 root-i, --pk=&#x27;/root/.ssh/id_rsa&#x27;: 指定 SSH 密钥文件路径--port: 指定 SSH 端口，默认为 22 Clusterfile 方式创建集群 1234567# 生成集群配置文件，Clusterfile就是一个yaml文件，里面包含集群的配置信息sealos gen labring/kubernetes:v1.29.9 labring/helm:v3.9.4 labring/cilium:v1.13.4 \\ --masters 10.211.55.12 \\ --nodes 10.211.55.13,10.211.55.14 -p [your-ssh-passwd] &gt; Clusterfile# 执行配置文件sealos apply -f Clusterfile 查看集群状态 1sealos status 清除K8s集群 1sealos reset 更新 Kubernetes API 服务器的证书 12345678910# sealos 创建的证书存放在 /etc/kubernetes/pki/ 下，默认证书有效期为 100 年# 更新证书一般只会在添加新的访问ip或域名时才需要sealos cert --alt-names apiserver.cluster.local,10.211.55.12,127.0.0.1,localhost# 参数说明# --alt-names: 添加新的访问ip或域名，多个逗号分隔# -c, --cluster=&#x27;default&#x27;: 要执行 exec 操作的集群的名称。默认为 default。# 更新证书后，你可以使用以下命令进行校验：kubectl -n kube-system get cm kubeadm-config -o yamlopenssl x509 -in /etc/kubernetes/pki/apiserver.crt -text 在执行此操作之前，你最好先备份旧的证书。 执行 sealos cert 命令后，会更新集群 API 服务器的证书，你无需手动重启 API 服务器，sealos会自动帮你重启服务。 查看环境变量 12345678910# -v 显示变量的说明sealos env -v## 说明SEALOS_PROMPT=enabled # 是否启用终端中的交互提示功能。SEALOS_RUNTIME_ROOT=/root/.sealos # Sealos 的运行时根目录，用于持久化运行相关的操作或配置。SEALOS_DATA_ROOT=/var/lib/sealos # 集群在远程节点上的根目录路径，用于存储集群相关的数据。BUILDAH_FORMAT=oci # 镜像构建时使用的格式，`oci` 表示符合 OCI 镜像规范。BUILDAH_LOG_LEVEL= # buildah 模块中使用的日志级别，可以是 &quot;trace&quot;, &quot;debug&quot;, &quot;info&quot;, &quot;warn&quot;, &quot;error&quot;, &quot;fatal&quot;, 或 &quot;panic&quot;。CONTAINERS_STORAGE_CONF= # 容器存储配置文件的路径，设置这个变量可以覆盖默认的配置位置。SEALOS_SYNC_WORKDIR=true # 是否将运行时根目录（SEALOS_RUNTIME_ROOT）同步到所有 master 节点，作为备份用途。 在集群中执行命令 1234567# sealos exec &quot;shell command or script&quot;# 在所有节点上执行命令sealos exec &quot;cat /etc/hosts&quot;# 在指定的节点上执行命令，--ips: 参数指定要执行的节点IP，多个节点之间用逗号分隔sealos exec &quot;cat /etc/hosts&quot; --ips=10.211.55.13,10.211.55.14 在集群间拷贝文件 123456# sealos scp &quot;source file path&quot; &quot;destination file path&quot;# 在所有节点上执行命令sealos scp ~/Clusterfile /tmp/Clusterfile# 在指定的节点上执行命令，--ips: 参数指定要执行的节点IP，多个节点之间用逗号分隔sealos scp ~/Clusterfile /tmp/Clusterfile --ips=10.211.55.13,10.211.55.14 节点管理(master节点执行命令) 添加 master 节点 12# 添加 master 节点后，总的 master 节点个数必须为奇数，否则会报错sealos add --masters 10.211.55.18,10.211.55.19 添加 worker 节点 12# 添加 worker 节点，多个都会分隔sealos add --nodes 10.211.55.20,10.211.55.21 删除 master 节点 12# 删除 master 节点后，剩余的 master 节点个数必须为奇数，否则会报错sealos delete --masters 10.211.55.18,10.211.55.19 删除 worker 节点 1sealos delete --nodes 10.211.55.20,10.211.55.21 镜像管理 查看所有镜像 12345$ sealos imagesREPOSITORY TAG IMAGE ID CREATED SIZEdocker.io/labring/kubernetes v1.29.9 bca192f35556 2 months ago 669 MBdocker.io/labring/cilium v1.13.4 71aa52ad0a11 23 months ago 483 MBdocker.io/labring/helm v3.9.4 3376f6822067 2 years ago 46.4 MB 删除镜像 12# sealos rmi [image_id] | [image_name]sealos rmi docker.io/labring/kubernetes:v1.29.9 拉取镜像 1sealos pull docker.io/labring/kubernetes:v1.29.9 登录镜像仓库，建议登录仓库，这样可以提高拉取镜像的次数，避免拉取镜像失败 12# docker.io 官方dockerhub镜像仓库sealos login docker.io -u [username] -p [password] 为镜像打tag 1sealos tag docker.io/labring/kubernetes:v1.29.9 docker.io/hanqunfeng/kubernetes:v1.29.9 推送镜像 1sealos push docker.io/hanqunfeng/kubernetes:v1.29.9 查看镜像详情 12# sealos inspect [image_id] | [image_name]sealos inspect docker.io/labring/kubernetes:v1.29.9 登出镜像仓库 1234# 登出指定的仓库sealos logout docker.io# 登出所有仓库sealos logout --all 通过 Dockerfile 构建镜像 12# 与 docker build 类似，构建好的镜像会增加前缀 localhost/sealos build -t myapp:v1.0.0 -f Dockerfile . 容器管理 查看所有容器 1sealos ps 查看容器详情 12# sealos inspect [container_id] | [container_name]sealos inspect bca192f35556","summary":"摘要 本文介绍 Linux 下 使用 sealos 安装 K8S 的方法，本文以 CentOS 8 为例。 K8S官网 k8s Github sealos官网 sealos Github","date_published":"2025-07-01T13:30:05.000Z","tags":["技术","k8s","K8S"]},{"id":"https://blog.hanqunfeng.com/2025/06/29/k8s-install-kubeadm/","url":"https://blog.hanqunfeng.com/2025/06/29/k8s-install-kubeadm/","title":"Linux 安装 K8S 之 kubeadm","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 Linux 下 使用 kubeadm 安装 K8S 的方法，本文以 CentOS 8 为例。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/\">K8S官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/kubernetes/kubernetes\">k8s Github</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/\">使用 kubeadm 引导集群</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/docs/reference/setup-tools/kubeadm/\">kubeadm 命令指南</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/kubeadm/\">用 kubeadm 进行管理</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"安装前设置-所有节点\">安装前设置(所有节点)</h2>\n<h3 id=\"修正系统的时间\">修正系统的时间</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装chrony</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> dnf install chrony -y</span><br><span class=\"line\"><span class=\"comment\"># 启动服务</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl <span class=\"built_in\">enable</span> --now chronyd</span><br><span class=\"line\"><span class=\"comment\"># 修正时间</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> chronyc makestep</span><br><span class=\"line\"><span class=\"comment\"># 查看时间</span></span><br><span class=\"line\"><span class=\"built_in\">date</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"安装-docker-可选\">安装 <code>docker</code>(可选)</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>k8s 使用<code>docker</code>作为容器运行时才需要安装，安装方法参见 <a href=\"/2025/05/20/docker-install/\" title=\"Linux 安装 Docker\">Linux 安装 Docker</a></p>\n</li>\n</ul>\n<h3 id=\"创建用户\">创建用户</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>避免使用root用户，这里创建一个 <code>centos</code> 用户，要求该用户具有<code>sudo</code>权限，如果使用<code>docker</code>运行时，则需要将该用户添加到<code>docker</code>用户组</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.创建用户</span></span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> useradd -m -s /bin/bash centos</span><br><span class=\"line\"><span class=\"comment\"># 2.添加到docker用户组</span></span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> usermod -aG docker centos</span><br><span class=\"line\"><span class=\"comment\"># 3.将用户添加到 sudo（管理员）组，说明：wheel 是 CentOS 中允许使用 sudo 权限的用户组。具体可以通过 visudo 命令查看</span></span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> usermod -aG wheel centos</span><br><span class=\"line\"><span class=\"comment\">## 这种添加方式使用sudo时需要输入密码，如果不希望输入密码，可以通过 visudo 命令修改，将 wheel 组改为 %wheel ALL=(ALL) NOPASSWD: ALL 的形式</span></span><br><span class=\"line\"><span class=\"comment\"># 4.切换用户，以下操作均在该用户下进行</span></span><br><span class=\"line\">$ su - centos</span><br></pre></td></tr></table></figure>\n<h3 id=\"升级内核\">升级内核</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>由 kubeadm 创建的 Kubernetes 集群依赖于使用内核特性的相关软件。</p>\n</li>\n<li class=\"lvl-3\">\n<p>Kubernetes 集群的节点对于使用 Linux 内核版本要求参加<a href=\"https://kubernetes.io/zh-cn/docs/reference/node/kernel-version-requirements/\">Linux 内核版本要求</a></p>\n</li>\n<li class=\"lvl-3\">\n<p>kubeadm 项目支持 LTS 内核。参阅 <a href=\"https://www.kernel.org/category/releases.html\">LTS 内核列表</a>。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看当前内核版本，可以看到当前内核版本为 4.18.0</span></span><br><span class=\"line\">$ <span class=\"built_in\">uname</span> -r</span><br><span class=\"line\">4.18.0-553.el8_10.x86_64</span><br><span class=\"line\"><span class=\"comment\">#查看 yum 中可升级的内核版本</span></span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> yum list kernel --showduplicates</span><br><span class=\"line\"><span class=\"comment\">#如果list中有需要的版本可以直接执行 update 升级，多数是没有的，所以要按以下步骤操作</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#导入ELRepo软件仓库的公共秘钥</span></span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Centos7系统安装ELRepo</span></span><br><span class=\"line\"><span class=\"comment\"># $sudo yum install https://www.elrepo.org/elrepo-release-7.el7.elrepo.noarch.rpm</span></span><br><span class=\"line\"><span class=\"comment\">#Centos8系统安装ELRepo</span></span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> yum install https://www.elrepo.org/elrepo-release-8.el8.elrepo.noarch.rpm</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#查看ELRepo提供的内核版本</span></span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> yum --disablerepo=<span class=\"string\">&quot;*&quot;</span> --enablerepo=<span class=\"string\">&quot;elrepo-kernel&quot;</span> list available</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#kernel-lt：表示longterm，即长期支持的内核，当前lt内核版本为 5.4.295</span></span><br><span class=\"line\"><span class=\"comment\">#kernel-ml：表示mainline，即当前主线的内核，当前ml内核版本为 6.15.4，笔者测试安装该版本内核最后创建集群时会失败</span></span><br><span class=\"line\"><span class=\"comment\">#安装lt内核</span></span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> yum --enablerepo=elrepo-kernel install kernel-lt.x86_64</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看已安装的内核版本，可以看到 刚刚安装的 5.4.295 内核版本的两个文件</span></span><br><span class=\"line\">$ <span class=\"built_in\">ls</span> -lh /boot/vmlinuz-* /boot/initramfs-* | grep <span class=\"string\">&quot;5.4&quot;</span></span><br><span class=\"line\">-rw-------  1 root root  29M 6月  29 17:15 /boot/initramfs-5.4.295-1.el8.elrepo.x86_64.img</span><br><span class=\"line\">-rwxr-xr-x  1 root root 9.5M 6月  28 01:21 /boot/vmlinuz-5.4.295-1.el8.elrepo.x86_64</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看可以使用的内核</span></span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> grubby --info=ALL | grep ^kernel</span><br><span class=\"line\">kernel=<span class=\"string\">&quot;/boot/vmlinuz-5.4.295-1.el8.elrepo.x86_64&quot;</span></span><br><span class=\"line\">kernel=<span class=\"string\">&quot;/boot/vmlinuz-4.18.0-553.el8_10.x86_64&quot;</span></span><br><span class=\"line\">kernel=<span class=\"string\">&quot;/boot/vmlinuz-0-rescue-88f75739047993488aacc30b9cd25ca0&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看默认内核，默认情况下，系统会自动将新安装的内核设置为默认启动内核</span></span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> grubby --default-kernel</span><br><span class=\"line\">/boot/vmlinuz-5.4.295-1.el8.elrepo.x86_64</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果没有自动启用，则通过该命令设置默认内核</span></span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> grubby --set-default /boot/vmlinuz-5.4.295-1.el8.elrepo.x86_64</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重启系统</span></span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> reboot</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重启登录后验证内核版本</span></span><br><span class=\"line\">$ <span class=\"built_in\">uname</span> -r</span><br><span class=\"line\">5.4.295-1.el8.elrepo.x86_64</span><br></pre></td></tr></table></figure>\n<h3 id=\"将-SELinux-设置为-permissive-模式（相当于将其禁用）\">将 SELinux 设置为 permissive 模式（相当于将其禁用）</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">sudo</span> setenforce 0</span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> sed -i <span class=\"string\">&#x27;s/^SELINUX=enforcing$/SELINUX=permissive/&#x27;</span> /etc/selinux/config</span><br></pre></td></tr></table></figure>\n<h3 id=\"禁用Firewalld\">禁用Firewalld</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 为了方便，这里可以禁用 firewalld</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl stop firewalld</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl <span class=\"built_in\">disable</span> firewalld</span><br></pre></td></tr></table></figure>\n<h4 id=\"不关-Firewalld-应该开放哪些端口？-实测还是会遇到各种各样的问题\">不关 Firewalld 应该开放哪些端口？(实测还是会遇到各种各样的问题)</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Master 节点需要开放的端口</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>端口</th>\n<th>协议</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>6443</strong></td>\n<td>TCP</td>\n<td>kube-apiserver，用于 kubectl 与集群通信</td>\n</tr>\n<tr>\n<td><strong>2379-2380</strong></td>\n<td>TCP</td>\n<td>etcd 集群通信（仅在你自己部署 etcd 时）</td>\n</tr>\n<tr>\n<td><strong>10250</strong></td>\n<td>TCP</td>\n<td>kubelet 监听端口，供 apiserver 与节点通信</td>\n</tr>\n<tr>\n<td><strong>10259</strong></td>\n<td>TCP</td>\n<td>kube-scheduler</td>\n</tr>\n<tr>\n<td><strong>10257</strong></td>\n<td>TCP</td>\n<td>kube-controller-manager</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Worker 节点需要开放的端口</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>端口</th>\n<th>协议</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>10250</strong></td>\n<td>TCP</td>\n<td>kubelet 与 apiserver 通信</td>\n</tr>\n<tr>\n<td><strong>30000-32767</strong></td>\n<td>TCP</td>\n<td>NodePort 服务默认端口范围</td>\n</tr>\n<tr>\n<td><strong>10255</strong></td>\n<td>TCP</td>\n<td>kubelet 只读端口（默认关闭，可不开放）</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果你使用的是 Calico 网络插件</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>端口</th>\n<th>协议</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>179</strong></td>\n<td>TCP</td>\n<td>BGP 通信端口，用于 Calico 节点间路由（若使用 BGP 模式）</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果你使用的是 Flannel（VXLAN 模式）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>端口</th>\n<th>协议</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>8472</strong></td>\n<td>UDP</td>\n<td>VXLAN 数据通信</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Ingress 控制器（比如 NGINX Ingress）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>端口</th>\n<th>协议</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>80</strong> / <strong>443</strong></td>\n<td>TCP</td>\n<td>提供 HTTP/HTTPS 服务访问（Ingress 服务）</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例命令：使用 firewall-cmd 开放端口</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启动 firewalld</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl start firewalld</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl <span class=\"built_in\">enable</span> firewalld</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例：开放常用端口</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> firewall-cmd --permanent --add-port=6443/tcp</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> firewall-cmd --permanent --add-port=2379-2380/tcp</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> firewall-cmd --permanent --add-port=10250/tcp</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> firewall-cmd --permanent --add-port=10259/tcp</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> firewall-cmd --permanent --add-port=10257/tcp</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> firewall-cmd --permanent --add-port=30000-32767/tcp</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> firewall-cmd --permanent --add-port=179/tcp       <span class=\"comment\"># 如果用 Calico</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> firewall-cmd --permanent --add-port=8472/udp      <span class=\"comment\"># 如果用 Flannel</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> firewall-cmd --permanent --add-port=80/tcp        <span class=\"comment\"># Ingress</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> firewall-cmd --permanent --add-port=443/tcp       <span class=\"comment\"># Ingress</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 允许 Calico 的封装协议 IPIP ,允许 IPIP 协议（协议号 4）</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> firewall-cmd --permanent --direct --add-rule ipv4 filter INPUT 0 -p 4 -j ACCEPT</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> firewall-cmd --permanent --direct --add-rule ipv4 filter OUTPUT 0 -p 4 -j ACCEPT</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果 Calico 使用 VXLAN 模式，则需要开放 4789 端口</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> firewall-cmd --permanent --add-port=4789/udp</span><br><span class=\"line\"><span class=\"comment\"># Calico Typha 网络</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> firewall-cmd --permanent --add-port=5473/tcp</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Calico WireGuard（IPv4 和 IPv6）</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> firewall-cmd --permanent --add-port=51820/udp</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> firewall-cmd --permanent --add-port=51821/udp</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 应用更改</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> firewall-cmd --reload</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看开放的端口</span></span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> firewall-cmd --list-ports</span><br><span class=\"line\">80/tcp 179/tcp 443/tcp 2377/tcp 2379-2380/tcp 6443/tcp 7946/tcp 10250/tcp 10257/tcp 10259/tcp 30000-32767/tcp 4789/udp 7946/udp 8472/udp</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看开放的直接规则</span></span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> firewall-cmd --direct --get-all-rules</span><br><span class=\"line\">ipv4 filter INPUT 0 -p 4 -j ACCEPT</span><br></pre></td></tr></table></figure>\n<h3 id=\"关闭swap\">关闭swap</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> swapoff -a</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> sed -i <span class=\"string\">&#x27;/ swap / s/^/#/&#x27;</span> /etc/fstab</span><br></pre></td></tr></table></figure>\n<h3 id=\"加载内核模块\">加载内核模块</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> modprobe overlay</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> modprobe br_netfilter</span><br></pre></td></tr></table></figure>\n<h3 id=\"设置内核参数\">设置内核参数</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> &lt;&lt;<span class=\"string\">EOF | sudo tee /etc/sysctl.d/kubernetes.conf</span></span><br><span class=\"line\"><span class=\"string\">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class=\"line\"><span class=\"string\">net.bridge.bridge-nf-call-iptables = 1</span></span><br><span class=\"line\"><span class=\"string\">net.ipv4.ip_forward = 1</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> sysctl --system</span><br></pre></td></tr></table></figure>\n<h3 id=\"安装containerd\">安装containerd</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> yum config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> yum install -y containerd.io</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">mkdir</span> -p /etc/containerd</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> containerd config default | <span class=\"built_in\">sudo</span> <span class=\"built_in\">tee</span> /etc/containerd/config.toml</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置Systemd为cgroup driver</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> sed -i <span class=\"string\">&#x27;s/SystemdCgroup = false/SystemdCgroup = true/&#x27;</span> /etc/containerd/config.toml</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动并设置开机启动</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl <span class=\"built_in\">enable</span> --now containerd</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果是国内环境，可以在<code>/etc/containerd/config.toml</code>添加镜像加速器配置</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> vim /etc/containerd/config.toml</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 找到 registry.mirrors 字段，添加加速器，比如：</span></span><br><span class=\"line\">[plugins.<span class=\"string\">&quot;io.containerd.grpc.v1.cri&quot;</span>.registry.mirrors]</span><br><span class=\"line\">  [plugins.<span class=\"string\">&quot;io.containerd.grpc.v1.cri&quot;</span>.registry.mirrors.<span class=\"string\">&quot;docker.io&quot;</span>]</span><br><span class=\"line\">    endpoint = [<span class=\"string\">&quot;https://docker.1ms.run&quot;</span>, <span class=\"string\">&quot;https://docker.xuanyuan.me&quot;</span>, <span class=\"string\">&quot;https://docker.m.daocloud.io&quot;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 修改后重启 containerd</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl restart containerd</span><br></pre></td></tr></table></figure>\n<h3 id=\"安装cri-dockerd-可选\">安装cri-dockerd(可选)</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果使用 containerd，则不需要安装 cri-dockerd</p>\n</li>\n<li class=\"lvl-2\">\n<p>Kubernetes 1.24+ 默认移除了 dockershim，所以你必须安装 cri-dockerd 才能继续使用 Docker</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载并安装 cri-dockerd RPM，目前最新版是 0.3.19，fc35: Fedora 35 构建，适配 RHEL/CentOS 8 系统的 glibc 和 libstdc++</span></span><br><span class=\"line\">$ curl -LO https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.19/cri-dockerd-0.3.19-3.fc35.x86_64.rpm</span><br><span class=\"line\"><span class=\"comment\"># 安装时报错：cri-dockerd-0.3.19-3.fc35.x86_64.rpm 依赖 GLIBC ≥ 2.32 和 2.34，但 CentOS 8 系统只提供 GLIBC 2.28。</span></span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> dnf install -y ./cri-dockerd-0.3.19-3.fc35.x86_64.rpm</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重新下载一个兼容的版本即可，这里选择：cri-dockerd-0.3.14-3.el8.x86_64.rpm</span></span><br><span class=\"line\">$ curl -LO https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.14/cri-dockerd-0.3.14-3.el8.x86_64.rpm</span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> dnf install -y ./cri-dockerd-0.3.14-3.el8.x86_64.rpm</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重新加载服务</span></span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> systemctl daemon-reload</span><br><span class=\"line\"><span class=\"comment\"># 加入开机启动并立刻启动</span></span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> systemctl <span class=\"built_in\">enable</span> --now cri-docker</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 后面的 kubeadm 命令 都要加上 --cri-socket unix:///var/run/cri-dockerd.sock</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"安装-kubelet-kubeadm-kubectl\">安装 kubelet, kubeadm, kubectl</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>添加 Kubernetes YUM 源，k8s 的版本从<a href=\"https://kubernetes.io/zh-cn/docs/home/supported-doc-versions/\">官网</a>获取</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cat</span> &lt;&lt;<span class=\"string\">EOF | sudo tee /etc/yum.repos.d/kubernetes.repo</span></span><br><span class=\"line\"><span class=\"string\">[kubernetes]</span></span><br><span class=\"line\"><span class=\"string\">name=Kubernetes</span></span><br><span class=\"line\"><span class=\"string\">baseurl=https://pkgs.k8s.io/core:/stable:/v1.33/rpm/</span></span><br><span class=\"line\"><span class=\"string\">enabled=1</span></span><br><span class=\"line\"><span class=\"string\">gpgcheck=1</span></span><br><span class=\"line\"><span class=\"string\">repo_gpgcheck=1</span></span><br><span class=\"line\"><span class=\"string\">gpgkey=https://pkgs.k8s.io/core:/stable:/v1.33/rpm/repodata/repomd.xml.key</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清理yum缓存并重新建立缓存</span></span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> yum clean all &amp;&amp; <span class=\"built_in\">sudo</span> yum makecache</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>安装 kubelet, kubeadm, kubectl</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看kubeadm有什么版本</span></span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> yum list --showduplicates  kubeadm</span><br><span class=\"line\"><span class=\"comment\"># 不指定版本默认那种最新版</span></span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> yum install -y kubelet kubeadm kubectl</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启用kubelet</span></span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> systemctl <span class=\"built_in\">enable</span> --now kubelet</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定容器运行时为containerd，这里通过 crictl 指定容器运行时为 containerd</span></span><br><span class=\"line\"><span class=\"comment\"># 配置文件：/etc/crictl.yaml</span></span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> crictl config runtime-endpoint /run/containerd/containerd.sock</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查</span></span><br><span class=\"line\">$ kubeadm version</span><br><span class=\"line\">$ kubelet --version</span><br><span class=\"line\">$ kubectl version --client</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启用 shell 自动补全功能</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.安装 bash-completion</span></span><br><span class=\"line\"><span class=\"comment\"># 1.1 检查bash-completion是否已安装，有输出说明已经安装</span></span><br><span class=\"line\">$ <span class=\"built_in\">type</span> _init_completion</span><br><span class=\"line\"><span class=\"comment\"># 1.2 安装bash-completion，安装后会创建文件 /usr/share/bash-completion/bash_completion</span></span><br><span class=\"line\">$ dnf install bash-completion</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.安装 kubectl 的自动补全功能</span></span><br><span class=\"line\"><span class=\"comment\"># 2.1 当前用户</span></span><br><span class=\"line\">$ <span class=\"built_in\">echo</span> <span class=\"string\">&#x27;source &lt;(kubectl completion bash)&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class=\"line\"><span class=\"comment\"># 2.2 所有用户</span></span><br><span class=\"line\">$ kubectl completion bash | <span class=\"built_in\">sudo</span> <span class=\"built_in\">tee</span> /etc/bash_completion.d/kubectl &gt; /dev/null</span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> <span class=\"built_in\">chmod</span> a+r /etc/bash_completion.d/kubectl</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3 如果 kubectl 有关联的别名，你可以扩展 Shell 补全来适配此别名</span></span><br><span class=\"line\">$ <span class=\"built_in\">echo</span> <span class=\"string\">&#x27;alias k=kubectl&#x27;</span> &gt;&gt;~/.bashrc</span><br><span class=\"line\">$ <span class=\"built_in\">echo</span> <span class=\"string\">&#x27;complete -o default -F __start_kubectl k&#x27;</span> &gt;&gt;~/.bashrc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4.刷新配置文件</span></span><br><span class=\"line\">$ <span class=\"built_in\">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建集群-master节点\">创建集群(master节点)</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>master节点: [hostname: k8s-master, IP: 10.211.55.11]</p>\n</li>\n<li class=\"lvl-2\">\n<p>初始化master节点的控制面板，容器运行时基于 <code>containerd</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># kubeadm init --help可以查看命令的具体参数用法</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#在master节点执行初始化（node节点不用执行）</span></span><br><span class=\"line\"><span class=\"comment\"># --apiserver-advertise-address  指定apiserver的IP，即master节点的IP</span></span><br><span class=\"line\"><span class=\"comment\"># --image-repository registry.cn-hangzhou.aliyuncs.com/google_containers 设置镜像仓库为国内镜像仓库</span></span><br><span class=\"line\"><span class=\"comment\"># --kubernetes-version  设置k8s的版本，跟kubeadm版本一致</span></span><br><span class=\"line\"><span class=\"comment\"># --service-cidr  这是设置node节点的网络的，暂时这样设置</span></span><br><span class=\"line\"><span class=\"comment\"># --pod-network-cidr  这是设置node节点的网络的，暂时这样设置</span></span><br><span class=\"line\"><span class=\"comment\"># --cri-socket unix:///var/run/cri-dockerd.sock  设置cri使用cri-dockerd</span></span><br><span class=\"line\"><span class=\"comment\"># --ignore-preflight-errors=all  忽略所有预检错误（Preflight Errors）。这会跳过对系统状态的某些检查，例如是否启用了 swap、CPU 核心数、系统配置等。不推荐用于生产，只用于调试或测试环境。</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> kubeadm init \\</span><br><span class=\"line\">--apiserver-advertise-address=10.211.55.11 \\</span><br><span class=\"line\">--kubernetes-version v1.33.2 \\</span><br><span class=\"line\">--service-cidr=10.96.0.0/16 \\</span><br><span class=\"line\">--pod-network-cidr=10.244.0.0/16</span><br><span class=\"line\"><span class=\"comment\">## 安装成功会打印如下信息</span></span><br><span class=\"line\">Your Kubernetes control-plane has initialized successfully!</span><br><span class=\"line\"></span><br><span class=\"line\">To start using your cluster, you need to run the following as a regular user:</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">mkdir</span> -p <span class=\"variable\">$HOME</span>/.kube</span><br><span class=\"line\">  <span class=\"built_in\">sudo</span> <span class=\"built_in\">cp</span> -i /etc/kubernetes/admin.conf <span class=\"variable\">$HOME</span>/.kube/config</span><br><span class=\"line\">  <span class=\"built_in\">sudo</span> <span class=\"built_in\">chown</span> $(<span class=\"built_in\">id</span> -u):$(<span class=\"built_in\">id</span> -g) <span class=\"variable\">$HOME</span>/.kube/config</span><br><span class=\"line\"></span><br><span class=\"line\">Alternatively, <span class=\"keyword\">if</span> you are the root user, you can run:</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class=\"line\"></span><br><span class=\"line\">You should now deploy a pod network to the cluster.</span><br><span class=\"line\">Run <span class=\"string\">&quot;kubectl apply -f [podnetwork].yaml&quot;</span> with one of the options listed at:</span><br><span class=\"line\">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class=\"line\"></span><br><span class=\"line\">Then you can <span class=\"built_in\">join</span> any number of worker nodes by running the following on each as root:</span><br><span class=\"line\"></span><br><span class=\"line\">kubeadm <span class=\"built_in\">join</span> 10.211.55.11:6443 --token sqwk6v.lxlnf0ibtbgr4i27 \\</span><br><span class=\"line\">        --discovery-token-ca-cert-hash sha256:c43f8b6d0e7081a76ab1d8ca8d3c5fb1ef3b21afcd81874566d7840167809412</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看集群状态</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 集群信息</span></span><br><span class=\"line\">$ k cluster-info</span><br><span class=\"line\">Kubernetes control plane is running at https://10.211.55.11:6443</span><br><span class=\"line\">CoreDNS is running at https://10.211.55.11:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy</span><br><span class=\"line\"><span class=\"comment\"># 查看组件状态</span></span><br><span class=\"line\">$ k get cs</span><br><span class=\"line\">Warning: v1 ComponentStatus is deprecated <span class=\"keyword\">in</span> v1.19+</span><br><span class=\"line\">NAME                 STATUS    MESSAGE   ERROR</span><br><span class=\"line\">scheduler            Healthy   ok</span><br><span class=\"line\">controller-manager   Healthy   ok</span><br><span class=\"line\">etcd-0               Healthy   ok</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>为当前用户授予连接集群的权限</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">mkdir</span> -p <span class=\"variable\">$HOME</span>/.kube</span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> <span class=\"built_in\">cp</span> -i /etc/kubernetes/admin.conf <span class=\"variable\">$HOME</span>/.kube/config</span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> <span class=\"built_in\">chown</span> $(<span class=\"built_in\">id</span> -u):$(<span class=\"built_in\">id</span> -g) <span class=\"variable\">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>安装网络插件：<a href=\"https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/addons/\">k8s支持的网络插件</a>，</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://www.tigera.io/project-calico/\">calico官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/projectcalico/calico\">calico GitHub</a>]</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装calico前查看pod，-A 查看所有命名空间</span></span><br><span class=\"line\">$ kubectl get pods -A</span><br><span class=\"line\">NAMESPACE     NAME                          READY   STATUS    RESTARTS      AGE</span><br><span class=\"line\">kube-system   coredns-674b8bbfcf-8xllc      0/1     Pending   0             116m</span><br><span class=\"line\">kube-system   coredns-674b8bbfcf-w2sxz      0/1     Pending   0             116m</span><br><span class=\"line\">kube-system   etcd-k8s                      1/1     Running   2 (74m ago)   116m</span><br><span class=\"line\">kube-system   kube-apiserver-k8s            1/1     Running   2 (74m ago)   116m</span><br><span class=\"line\">kube-system   kube-controller-manager-k8s   1/1     Running   2 (74m ago)   116m</span><br><span class=\"line\">kube-system   kube-proxy-94zqw              1/1     Running   1 (74m ago)   116m</span><br><span class=\"line\">kube-system   kube-scheduler-k8s            1/1     Running   2 (74m ago)   116m</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下载yaml文件，目前最新版为 v3.30.2</span></span><br><span class=\"line\">$ curl -LO https://raw.githubusercontent.com/projectcalico/calico/v3.30.2/manifests/calico.yaml</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建</span></span><br><span class=\"line\">$ kubectl apply -f calico.yaml</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装calico后查看pod，在安装 Calico 之前 CoreDNS 是 Pending 状态，现在已经变成 Running</span></span><br><span class=\"line\"><span class=\"comment\"># -o wide: 显示pod的详细信息</span></span><br><span class=\"line\">$ kubectl get pods -A -o wide</span><br><span class=\"line\">NAMESPACE     NAME                                       READY   STATUS    RESTARTS      AGE     IP             NODE   NOMINATED NODE   READINESS GATES</span><br><span class=\"line\">kube-system   calico-kube-controllers-7bfdc5b57c-9qv9m   1/1     Running   0             6m23s   10.244.77.1    k8s    &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">kube-system   calico-node-m7wc5                          1/1     Running   0             6m23s   10.211.55.11   k8s    &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">kube-system   coredns-674b8bbfcf-8xllc                   1/1     Running   0             123m    10.244.77.3    k8s    &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">kube-system   coredns-674b8bbfcf-w2sxz                   1/1     Running   0             123m    10.244.77.2    k8s    &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">kube-system   etcd-k8s                                   1/1     Running   2 (82m ago)   123m    10.211.55.11   k8s    &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">kube-system   kube-apiserver-k8s                         1/1     Running   2 (82m ago)   123m    10.211.55.11   k8s    &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">kube-system   kube-controller-manager-k8s                1/1     Running   2 (82m ago)   123m    10.211.55.11   k8s    &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">kube-system   kube-proxy-94zqw                           1/1     Running   1 (82m ago)   123m    10.211.55.11   k8s    &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">kube-system   kube-scheduler-k8s                         1/1     Running   2 (82m ago)   123m    10.211.55.11   k8s    &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>calica 安装后可能出现不正常的情况，比如 <code>calico-node-xxx</code> 的pod始终无法正常运行，此时可以尝试重新安装 calica</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除 calico</span></span><br><span class=\"line\">$ kubectl delete -f calico.yaml</span><br><span class=\"line\"><span class=\"comment\">#如果是重装calico，需要先清除旧的配置</span></span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> <span class=\"built_in\">rm</span> -rf /etc/cni/net.d/</span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> <span class=\"built_in\">rm</span> -rf /var/lib/calico</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重新安装 calico</span></span><br><span class=\"line\">$ kubectl apply -f calico.yaml</span><br></pre></td></tr></table></figure>\n<h2 id=\"添加节点-worker节点\">添加节点(worker节点)</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>worker节点: [hostname: k8s-worker1, IP: 10.211.55.15]</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在待加入的节点上执行如下命令，如果忘记token，则使用下文的命令重新获取</span></span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> kubeadm <span class=\"built_in\">join</span> 10.211.55.11:6443 --token sqwk6v.lxlnf0ibtbgr4i27 --discovery-token-ca-cert-hash sha256:c43f8b6d0e7081a76ab1d8ca8d3c5fb1ef3b21afcd81874566d7840167809412</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">[preflight] Running pre-flight checks</span><br><span class=\"line\">        [WARNING SystemVerification]: cgroups v1 support is <span class=\"keyword\">in</span> maintenance mode, please migrate to cgroups v2</span><br><span class=\"line\">[preflight] Reading configuration from the <span class=\"string\">&quot;kubeadm-config&quot;</span> ConfigMap <span class=\"keyword\">in</span> namespace <span class=\"string\">&quot;kube-system&quot;</span>...</span><br><span class=\"line\">[preflight] Use <span class=\"string\">&#x27;kubeadm init phase upload-config --config your-config-file&#x27;</span> to re-upload it.</span><br><span class=\"line\">[kubelet-start] Writing kubelet configuration to file <span class=\"string\">&quot;/var/lib/kubelet/config.yaml&quot;</span></span><br><span class=\"line\">[kubelet-start] Writing kubelet environment file with flags to file <span class=\"string\">&quot;/var/lib/kubelet/kubeadm-flags.env&quot;</span></span><br><span class=\"line\">[kubelet-start] Starting the kubelet</span><br><span class=\"line\">[kubelet-check] Waiting <span class=\"keyword\">for</span> a healthy kubelet at http://127.0.0.1:10248/healthz. This can take up to 4m0s</span><br><span class=\"line\">[kubelet-check] The kubelet is healthy after 1.004135788s</span><br><span class=\"line\">[kubelet-start] Waiting <span class=\"keyword\">for</span> the kubelet to perform the TLS Bootstrap</span><br><span class=\"line\"></span><br><span class=\"line\">This node has joined the cluster:</span><br><span class=\"line\">* Certificate signing request was sent to apiserver and a response was received.</span><br><span class=\"line\">* The Kubelet was informed of the new secure connection details.</span><br><span class=\"line\"></span><br><span class=\"line\">Run <span class=\"string\">&#x27;kubectl get nodes&#x27;</span> on the control-plane to see this node <span class=\"built_in\">join</span> the cluster.</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果上面的令牌忘记了，或者新的 worker 节点加入，在 master 上执行下面的命令，生成新的令牌</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubeadm token create --print-join-command</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">kubeadm <span class=\"built_in\">join</span> 10.211.55.11:6443 --token 5o3p2i.gj95aopph0xbrcig --discovery-token-ca-cert-hash sha256:c43f8b6d0e7081a76ab1d8ca8d3c5fb1ef3b21afcd81874566d7840167809412</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 master 节点上查看新创建的资源，默认情况下 work 节点不支持管理 k8s</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看节点</span></span><br><span class=\"line\">$ kubectl get nodes</span><br><span class=\"line\">NAME          STATUS     ROLES           AGE     VERSION</span><br><span class=\"line\">k8s           Ready      control-plane   3h33m   v1.33.2</span><br><span class=\"line\">k8s-worker1   Ready      &lt;none&gt;          115s    v1.33.2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看pod list</span></span><br><span class=\"line\">$ kubectl get pods -A -o wide</span><br><span class=\"line\">NAMESPACE     NAME                                       READY   STATUS    RESTARTS   AGE     IP               NODE          NOMINATED NODE   READINESS GATES</span><br><span class=\"line\">kube-system   calico-kube-controllers-7bfdc5b57c-q5xwp   1/1     Running   0          37m     10.244.235.193   k8s-master    &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">kube-system   calico-node-7pbbq                          1/1     Running   0          4m51s   10.211.55.15     k8s-worker1   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">kube-system   calico-node-w47qq                          1/1     Running   0          37m     10.211.55.11     k8s-master    &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">kube-system   coredns-674b8bbfcf-2tvld                   1/1     Running   0          37m     10.244.235.195   k8s-master    &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">kube-system   coredns-674b8bbfcf-h6kx7                   1/1     Running   0          37m     10.244.235.194   k8s-master    &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">kube-system   etcd-k8s-master                            1/1     Running   2          37m     10.211.55.11     k8s-master    &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">kube-system   kube-apiserver-k8s-master                  1/1     Running   4          37m     10.211.55.11     k8s-master    &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">kube-system   kube-controller-manager-k8s-master         1/1     Running   4          37m     10.211.55.11     k8s-master    &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">kube-system   kube-proxy-nkbns                           1/1     Running   0          4m51s   10.211.55.15     k8s-worker1   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">kube-system   kube-proxy-plqw8                           1/1     Running   0          37m     10.211.55.11     k8s-master    &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\">kube-system   kube-scheduler-k8s-master                  1/1     Running   4          38m     10.211.55.11     k8s-master    &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>使 work 节点支持管理 k8s(可选)：远程管理</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将 master 节点中的 ~/.kube/config 复制到 work 节点的 ~/.kube/config 即可</span></span><br><span class=\"line\"><span class=\"comment\"># 在 master 节点执行</span></span><br><span class=\"line\">scp ~/.kube/config k8s-work1:/tmp</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在 work 节点执行</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> -p ~/.kube</span><br><span class=\"line\"><span class=\"built_in\">mv</span> /tmp/config ~/.kube/config</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>删除work节点</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># master, 删除节点前先清空节点上的所有 Pod，使其调度到其他节点</span></span><br><span class=\"line\">$ kubectl drain k8s-worker1 --ignore-daemonsets</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># worker节点上执行如下命令</span></span><br><span class=\"line\"><span class=\"comment\">## 在移除节点之前，请重置 kubeadm 安装的状态</span></span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> kubeadm reset</span><br><span class=\"line\"><span class=\"comment\">## 重置过程不会重置或清除 iptables 规则或 IPVS 表。如果你希望重置 iptables，则必须手动进行</span></span><br><span class=\"line\">$ iptables -F &amp;&amp; iptables -t nat -F &amp;&amp; iptables -t mangle -F &amp;&amp; iptables -X</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># master 节点上删除节点</span></span><br><span class=\"line\">$ kubectl delete node k8s-worker1</span><br></pre></td></tr></table></figure>\n<h2 id=\"测试：用K8S部署Nginx\">测试：用K8S部署Nginx</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建deployment</span></span><br><span class=\"line\">kubectl create deployment nginx --image=nginx</span><br><span class=\"line\"><span class=\"comment\"># 创建service，--type指定为NodePort，其含义为将deployment的80端口映射到Node的随机端口</span></span><br><span class=\"line\">kubectl expose deployment nginx --<span class=\"built_in\">type</span>=NodePort --port=80</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看pod和service，不加 -n 参数，默认查看的是default命名空间</span></span><br><span class=\"line\">$ kubectl get pod,svc -o wide</span><br><span class=\"line\">NAME                         READY   STATUS    RESTARTS   AGE   IP              NODE          NOMINATED NODE   READINESS GATES</span><br><span class=\"line\">pod/nginx-5869d7778c-95z74   1/1     Running   0          19m   10.244.194.65   k8s-worker1   &lt;none&gt;           &lt;none&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                 TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE   SELECTOR</span><br><span class=\"line\">service/kubernetes   ClusterIP   10.96.0.1      &lt;none&gt;        443/TCP        61m   &lt;none&gt;</span><br><span class=\"line\">service/nginx        NodePort    10.96.48.156   &lt;none&gt;        80:30291/TCP   14m   app=nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 浏览器访问任意nodeIP:30291</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除测试资源</span></span><br><span class=\"line\"><span class=\"comment\">## 删除deployment</span></span><br><span class=\"line\">kubectl delete deployment nginx</span><br><span class=\"line\"><span class=\"comment\">## 删除service</span></span><br><span class=\"line\">kubectl delete service nginx</span><br></pre></td></tr></table></figure>\n<h2 id=\"通过-kubeadm-卸载-Kubernetes\">通过 kubeadm 卸载 Kubernetes</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 停止 kubelet 相关组件,删除 /etc/kubernetes 配置,清除证书、状态目录等,取消 iptables 规则,清除容器运行时中的 Pod、镜像信息等</span></span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> kubeadm reset</span><br><span class=\"line\"><span class=\"comment\"># 虽然 kubeadm reset 已经会清除大部分内容，但以下文件和配置可能依然存在，建议一并手动清理</span></span><br><span class=\"line\"><span class=\"comment\">## 删除 kubeconfig 文件（本地 kubectl 配置）</span></span><br><span class=\"line\"><span class=\"built_in\">rm</span> -rf <span class=\"variable\">$HOME</span>/.kube</span><br><span class=\"line\"><span class=\"comment\">## 清理 etcd 数据（如你启用了本地 etcd）</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">rm</span> -rf /var/lib/etcd</span><br><span class=\"line\"><span class=\"comment\">## 清理 CNI 网络配置和状态</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">rm</span> -rf /etc/cni/net.d</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">rm</span> -rf /var/lib/cni/</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">rm</span> -rf /var/lib/kubelet/*</span><br><span class=\"line\"><span class=\"comment\"># 清理 Calico</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">rm</span> -rf /var/lib/calico</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清理 iptables</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> iptables -F</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> iptables -X</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> iptables -t nat -F</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> iptables -t nat -X</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> iptables -t mangle -F</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> iptables -t mangle -X</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> iptables -P INPUT ACCEPT</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> iptables -P FORWARD ACCEPT</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> iptables -P OUTPUT ACCEPT</span><br></pre></td></tr></table></figure>\n<h2 id=\"停止和禁用-kubelet-服务\">停止和禁用 kubelet 服务</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl stop kubelet</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl <span class=\"built_in\">disable</span> kubelet</span><br></pre></td></tr></table></figure>\n<h2 id=\"升级-kubeadm-集群\">升级 kubeadm 集群</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>将 kubeadm 创建的 Kubernetes 集群从 1.32.x 版本 升级到 1.33.x 版本以及从 1.33.x 升级到 1.33.y（其中 y &gt; x），略过次版本号的升级是 不被支持的。</p>\n</li>\n</ul>\n<h3 id=\"升级步骤\">升级步骤</h3>\n<h4 id=\"升级-master-节点\">升级 master 节点</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/\">升级 master 节点</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>如果要从 <code>v1.33</code> 升级到 <code>v1.34</code>，则需要先修改 Kubernetes YUM 源，因为我上面配置 yum 源时配置的是 <code>v1.33</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>如果只是从 <code>v1.33.2</code> 升级到 <code>v1.33.3</code>，则不需要修改 Kubernetes YUM 源</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看 kubeadm 可以升级的版本</span></span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> yum list --showduplicates kubeadm</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定要升级的版本，比如这里要升级到 1.33.3</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> yum install -y kubeadm-1.33.3</span><br><span class=\"line\"><span class=\"comment\"># 查看升级后的版本</span></span><br><span class=\"line\">kubeadm version</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 验证升级计划: 此命令检查你的集群是否可被升级，并取回你要升级的目标版本。 命令也会显示一个包含组件配置版本状态的表格。</span></span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> kubeadm upgrade plan</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 升级 master 节点: 这一步会升级 kube-apiserver、controller-manager、scheduler 等静态 Pod。</span></span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> kubeadm upgrade apply v1.33.3</span><br><span class=\"line\"><span class=\"comment\">## 一旦该命令结束，你应该会看到：</span></span><br><span class=\"line\"> [upgrade/successful] SUCCESS! Your cluster was upgraded to <span class=\"string\">&quot;v1.33.3&quot;</span>. Enjoy!</span><br><span class=\"line\"></span><br><span class=\"line\"> [upgrade/kubelet] Now that your control plane is upgraded, please proceed with upgrading your kubelets <span class=\"keyword\">if</span> you haven<span class=\"string\">&#x27;t already done so.</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>手动升级你的 CNI 驱动插件，比如 Calico</p>\n</li>\n<li class=\"lvl-2\">\n<p>升级 kubelet 和 kubectl</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装指定的版本</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> yum install -y kubelet-1.33.3 kubectl-1.33.3</span><br><span class=\"line\"><span class=\"comment\"># 重启 kubelet</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl daemon-reload</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl restart kubelet</span><br></pre></td></tr></table></figure>\n<h4 id=\"升级-worker-节点\">升级 worker 节点</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/kubeadm/upgrading-linux-nodes/\">升级 worker 节点</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>如果要从 <code>v1.33</code> 升级到 <code>v1.34</code>，则需要先修改 Kubernetes YUM 源，因为我上面配置 yum 源时配置的是 <code>v1.33</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>如果只是从 <code>v1.33.2</code> 升级到 <code>v1.33.3</code>，则不需要修改 Kubernetes YUM 源</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看 kubeadm 可以升级的版本</span></span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> yum list --showduplicates kubeadm</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定要升级的版本，比如这里要升级到 1.33.3</span></span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> yum install -y kubeadm-1.33.3</span><br><span class=\"line\"><span class=\"comment\"># 查看升级后的版本</span></span><br><span class=\"line\">$ kubeadm version</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>腾空节点：如果有多个 worker 节点，可以选择先腾空节点。如果只有一个 worker 节点，则不需要。</p>\n</li>\n</ul>\n<blockquote>\n<p>drain 是为了在升级期间 避免该节点上正在运行的业务容器受到影响</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在控制平面节点上执行此命令</span></span><br><span class=\"line\"><span class=\"comment\"># 将 &lt;node-to-drain&gt; 替换为你正腾空的节点的名称</span></span><br><span class=\"line\">$ kubectl drain &lt;node-to-drain&gt; --ignore-daemonsets</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>升级 node 节点</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">sudo</span> kubeadm upgrade node</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>升级 kubelet 和 kubectl</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装指定的版本</span></span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> yum install -y kubelet-1.33.3 kubectl-1.33.3</span><br><span class=\"line\"><span class=\"comment\"># 重启 kubelet</span></span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> systemctl daemon-reload</span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> systemctl restart kubelet</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果前面对节点做了 腾空节点 操作，则需要取消对节点的保护，将节点标记为可调度，让节点重新上线</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在控制平面节点上执行此命令</span></span><br><span class=\"line\"><span class=\"comment\"># 将 &lt;node-to-uncordon&gt; 替换为你的节点名称</span></span><br><span class=\"line\">$ kubectl uncordon &lt;node-to-uncordon&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"更新证书\">更新证书</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>kubeadm 创建的证书存放在 <code>/etc/kubernetes/pki/</code> 下，默认客户端证书有效期为 1 年</p>\n</li>\n<li class=\"lvl-2\">\n<p>可以通过如下命令查看证书信息</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl -n kube-system get cm kubeadm-config -o yaml</span><br><span class=\"line\">openssl x509 -<span class=\"keyword\">in</span> /etc/kubernetes/pki/apiserver.crt -text</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看证书到期时间</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> kubeadm certs check-expiration</span><br><span class=\"line\"><span class=\"comment\">## 输出结果</span></span><br><span class=\"line\"><span class=\"comment\">## 可以看到 客户端 的证书的过期时间，默认值为 1 年</span></span><br><span class=\"line\">CERTIFICATE                EXPIRES                  RESIDUAL TIME   CERTIFICATE AUTHORITY   EXTERNALLY MANAGED</span><br><span class=\"line\">admin.conf                 Jun 29, 2026 14:41 UTC   363d            ca                      no</span><br><span class=\"line\">apiserver                  Jun 29, 2026 14:41 UTC   363d            ca                      no</span><br><span class=\"line\">apiserver-etcd-client      Jun 29, 2026 14:41 UTC   363d            etcd-ca                 no</span><br><span class=\"line\">apiserver-kubelet-client   Jun 29, 2026 14:41 UTC   363d            ca                      no</span><br><span class=\"line\">controller-manager.conf    Jun 29, 2026 14:41 UTC   363d            ca                      no</span><br><span class=\"line\">etcd-healthcheck-client    Jun 29, 2026 14:41 UTC   363d            etcd-ca                 no</span><br><span class=\"line\">etcd-peer                  Jun 29, 2026 14:41 UTC   363d            etcd-ca                 no</span><br><span class=\"line\">etcd-server                Jun 29, 2026 14:41 UTC   363d            etcd-ca                 no</span><br><span class=\"line\">front-proxy-client         Jun 29, 2026 14:41 UTC   363d            front-proxy-ca          no</span><br><span class=\"line\">scheduler.conf             Jun 29, 2026 14:41 UTC   363d            ca                      no</span><br><span class=\"line\">super-admin.conf           Jun 29, 2026 14:41 UTC   363d            ca                      no</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 根证书默认有效期为 10 年</span></span><br><span class=\"line\">CERTIFICATE AUTHORITY   EXPIRES                  RESIDUAL TIME   EXTERNALLY MANAGED</span><br><span class=\"line\">ca                      Jun 27, 2035 14:41 UTC   9y              no</span><br><span class=\"line\">etcd-ca                 Jun 27, 2035 14:41 UTC   9y              no</span><br><span class=\"line\">front-proxy-ca          Jun 27, 2035 14:41 UTC   9y              no</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>更新客户端证书</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 更新前备份</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">cp</span> -rf /etc/kubernetes/ /etc/kubernetes.bak</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">cp</span> -rf /var/lib/etcd/ /var/lib/etcd.bak</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 可以更新单个客户端证书</span></span><br><span class=\"line\"><span class=\"comment\"># sudo kubeadm certs renew admin.conf</span></span><br><span class=\"line\"><span class=\"comment\"># sudo kubeadm certs renew apiserver</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 升级全部客户端证书，也只能续期1年</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> kubeadm certs renew all</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">[renew] Reading configuration from the <span class=\"string\">&quot;kubeadm-config&quot;</span> ConfigMap <span class=\"keyword\">in</span> namespace <span class=\"string\">&quot;kube-system&quot;</span>...</span><br><span class=\"line\">[renew] Use <span class=\"string\">&#x27;kubeadm init phase upload-config --config your-config-file&#x27;</span> to re-upload it.</span><br><span class=\"line\"></span><br><span class=\"line\">certificate embedded <span class=\"keyword\">in</span> the kubeconfig file <span class=\"keyword\">for</span> the admin to use and <span class=\"keyword\">for</span> kubeadm itself renewed</span><br><span class=\"line\">certificate <span class=\"keyword\">for</span> serving the Kubernetes API renewed</span><br><span class=\"line\">certificate the apiserver uses to access etcd renewed</span><br><span class=\"line\">certificate <span class=\"keyword\">for</span> the API server to connect to kubelet renewed</span><br><span class=\"line\">certificate embedded <span class=\"keyword\">in</span> the kubeconfig file <span class=\"keyword\">for</span> the controller manager to use renewed</span><br><span class=\"line\">certificate <span class=\"keyword\">for</span> liveness probes to healthcheck etcd renewed</span><br><span class=\"line\">certificate <span class=\"keyword\">for</span> etcd nodes to communicate with each other renewed</span><br><span class=\"line\">certificate <span class=\"keyword\">for</span> serving etcd renewed</span><br><span class=\"line\">certificate <span class=\"keyword\">for</span> the front proxy client renewed</span><br><span class=\"line\">certificate embedded <span class=\"keyword\">in</span> the kubeconfig file <span class=\"keyword\">for</span> the scheduler manager to use renewed</span><br><span class=\"line\">certificate embedded <span class=\"keyword\">in</span> the kubeconfig file <span class=\"keyword\">for</span> the super-admin renewed</span><br><span class=\"line\"></span><br><span class=\"line\">Done renewing certificates. You must restart the kube-apiserver, kube-controller-manager, kube-scheduler and etcd, so that they can use the new certificates.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 需要根据输出提示重启 kube-apiserver, kube-controller-manager, kube-scheduler 和 etcd</span></span><br><span class=\"line\"><span class=\"comment\"># 这几个组件是通过pod 启动的，可以通过 kubectl get pod -n kube-system 查看</span></span><br><span class=\"line\">$ kubectl get pods -n kube-system</span><br><span class=\"line\">NAME                                       READY   STATUS    RESTARTS        AGE</span><br><span class=\"line\">calico-kube-controllers-7bfdc5b57c-q5xwp   1/1     Running   3 (5h37m ago)   41h</span><br><span class=\"line\">calico-node-7pbbq                          1/1     Running   3 (5h36m ago)   41h</span><br><span class=\"line\">calico-node-v4hzr                          1/1     Running   2 (5h37m ago)   19h</span><br><span class=\"line\">calico-node-w47qq                          1/1     Running   3 (5h37m ago)   41h</span><br><span class=\"line\">coredns-674b8bbfcf-2tvld                   1/1     Running   3 (5h37m ago)   41h</span><br><span class=\"line\">coredns-674b8bbfcf-h6kx7                   1/1     Running   3 (5h37m ago)   41h</span><br><span class=\"line\">etcd-k8s-master                            1/1     Running   5 (5h37m ago)   41h</span><br><span class=\"line\">kube-apiserver-k8s-master                  1/1     Running   7 (5h37m ago)   41h</span><br><span class=\"line\">kube-controller-manager-k8s-master         1/1     Running   7 (5h37m ago)   41h</span><br><span class=\"line\">kube-proxy-nkbns                           1/1     Running   3 (5h36m ago)   41h</span><br><span class=\"line\">kube-proxy-plqw8                           1/1     Running   3 (5h37m ago)   41h</span><br><span class=\"line\">kube-proxy-sbgh6                           1/1     Running   2 (5h37m ago)   19h</span><br><span class=\"line\">kube-scheduler-k8s-master                  1/1     Running   7 (5h37m ago)   41h</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除指定的pod就会自动重启</span></span><br><span class=\"line\">kubectl delete pod -n kube-system kube-apiserver-k8s-master kube-controller-manager-k8s-master  kube-scheduler-k8s-master etcd-k8s-master</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重启成功后再次查看证书信息，就会看到更新后的到期时间为1年</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> kubeadm certs check-expiration</span><br></pre></td></tr></table></figure>\n<h2 id=\"Kubernetes-节点组件\">Kubernetes 节点组件</h2>\n<table>\n<thead>\n<tr>\n<th>角色</th>\n<th>组件名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Master Node</strong></td>\n<td><code>kube-apiserver</code></td>\n<td>Kubernetes 的 API 请求入口，处理所有 REST 请求，协调各组件。</td>\n</tr>\n<tr>\n<td></td>\n<td><code>kube-scheduler</code></td>\n<td>调度器，决定将 Pod 调度到哪个合适的 Node。</td>\n</tr>\n<tr>\n<td></td>\n<td><code>kube-controller-manager</code></td>\n<td>包含多个控制器（如 NodeController、ReplicationController、DeploymentController 等），用于控制和调整集群状态。</td>\n</tr>\n<tr>\n<td></td>\n<td><code>etcd</code></td>\n<td>分布式 KV 存储系统，存储 Kubernetes 所有状态数据。只有 API Server 能直接访问。</td>\n</tr>\n<tr>\n<td><strong>Worker Node</strong></td>\n<td><code>kubelet</code></td>\n<td>负责与 Master 通信，执行其下发的 Pod 管理任务，控制容器生命周期。</td>\n</tr>\n<tr>\n<td></td>\n<td><code>kube-proxy</code></td>\n<td>负责维护 Node 上的网络规则，支持服务负载均衡和网络通信。</td>\n</tr>\n<tr>\n<td></td>\n<td><code>container runtime</code></td>\n<td>容器运行时，比如 Docker、containerd、CRI-O，负责实际运行容器。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"crictl-命令\">crictl 命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>crictl</code> 是k8s官方出品的一个命令行工具，用于与 containerd 进行通信。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>crictl</code> 命令默认需要 sudo 权限，如果不想每次都加 sudo，可以将用户加入 containerd 的 socket 权限组</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># containerd 的默认 socket 是 /var/run/containerd/containerd.sock</span></span><br><span class=\"line\">$ <span class=\"built_in\">ls</span> -l /var/run/containerd/containerd.sock</span><br><span class=\"line\">srw-rw---- 1 root root 0 7月   1 10:57 /var/run/containerd/containerd.sock</span><br><span class=\"line\"><span class=\"comment\"># 如果 group 是 root：你可以改为其它组，比如 docker</span></span><br><span class=\"line\"><span class=\"comment\"># 如果 docker 组不存在则创建</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> groupadd docker</span><br><span class=\"line\"><span class=\"comment\"># 修改文件所属组为 docker</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">chgrp</span> docker /var/run/containerd/containerd.sock</span><br><span class=\"line\"><span class=\"comment\"># 为组添加读写权限</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">chmod</span> g+rw /var/run/containerd/containerd.sock</span><br><span class=\"line\"><span class=\"comment\"># 添加用户到 docker 组</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> usermod -aG docker <span class=\"variable\">$USER</span></span><br><span class=\"line\"><span class=\"comment\"># 刷新权限</span></span><br><span class=\"line\">newgrp docker</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 此时虽然已经可以不用 sudo 了，但是一旦重启 containerd 就会重新回到 root 权限，因此需要添加如下配置</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">mkdir</span> -p /etc/systemd/system/containerd.service.d/</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">tee</span> /etc/systemd/system/containerd.service.d/override.conf &lt;&lt;<span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">[Service]</span></span><br><span class=\"line\"><span class=\"string\">ExecStartPost=/bin/bash -c &#x27;chmod 660 /run/containerd/containerd.sock &amp;&amp; chgrp docker /run/containerd/containerd.sock&#x27;</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl daemon-reload</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl restart containerd</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>crictl</code> 命令的使用方式比较类似<code>docker</code>命令</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th><code>docker</code> 命令</th>\n<th><code>crictl</code> 命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>查看正在运行的容器</td>\n<td><code>docker ps</code></td>\n<td><code>crictl ps</code></td>\n<td></td>\n</tr>\n<tr>\n<td>查看所有容器（包括已停止）</td>\n<td><code>docker ps -a</code></td>\n<td><code>crictl ps -a</code></td>\n<td></td>\n</tr>\n<tr>\n<td>查看镜像</td>\n<td><code>docker images</code></td>\n<td><code>crictl images</code></td>\n<td></td>\n</tr>\n<tr>\n<td>查看容器日志</td>\n<td><code>docker logs &lt;container_id&gt;</code></td>\n<td><code>crictl logs &lt;container_id&gt;</code></td>\n<td></td>\n</tr>\n<tr>\n<td>进入容器交互</td>\n<td><code>docker exec -it &lt;id&gt; sh</code></td>\n<td><code>crictl exec -it &lt;id&gt; sh</code></td>\n<td></td>\n</tr>\n<tr>\n<td>查看容器详细信息</td>\n<td><code>docker inspect &lt;container_id&gt;</code></td>\n<td><code>crictl inspect &lt;container_id&gt;</code></td>\n<td></td>\n</tr>\n<tr>\n<td>查看 Pod 详细信息</td>\n<td>❌（不支持）</td>\n<td><code>crictl inspectp &lt;pod_id&gt;</code></td>\n<td>K8s 专属</td>\n</tr>\n<tr>\n<td>删除容器</td>\n<td><code>docker rm &lt;container_id&gt;</code></td>\n<td><code>crictl rm &lt;container_id&gt;</code></td>\n<td></td>\n</tr>\n<tr>\n<td>删除镜像</td>\n<td><code>docker rmi &lt;image_id&gt;</code></td>\n<td><code>crictl rmi &lt;image_id&gt;</code></td>\n<td></td>\n</tr>\n<tr>\n<td>拉取镜像</td>\n<td><code>docker pull nginx</code></td>\n<td><code>crictl pull nginx</code></td>\n<td></td>\n</tr>\n<tr>\n<td>运行容器（非 K8s 场景）</td>\n<td><code>docker run -it nginx</code></td>\n<td>❌（不支持）</td>\n<td><code>crictl</code> 不运行容器，仅调试现有容器</td>\n</tr>\n<tr>\n<td>列出容器运行时信息</td>\n<td><code>docker info</code></td>\n<td><code>crictl info</code></td>\n<td></td>\n</tr>\n<tr>\n<td>查看容器运行状态</td>\n<td><code>docker stats</code></td>\n<td><code>crictl stats</code></td>\n<td>简要版</td>\n</tr>\n<tr>\n<td>设置配置文件</td>\n<td><code>~/.docker/config.json</code></td>\n<td><code>/etc/crictl.yaml</code></td>\n<td>如设置 endpoint</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"nerdctl\">nerdctl</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/containerd/nerdctl\">nerdctl</a> 是一个 兼容 Docker CLI 的容器命令行工具，用于管理 containerd 容器运行时。</p>\n</li>\n<li class=\"lvl-2\">\n<p>它是 containerd 官方子项目，由 CNCF 维护，其命令语法与 Docker CLI 兼容，目标是让习惯 Docker 的用户也能轻松使用 containerd。</p>\n</li>\n<li class=\"lvl-2\">\n<p>安装 nerdctl</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. 下载最新版本</span></span><br><span class=\"line\">VERSION=2.1.3</span><br><span class=\"line\">wget https://github.com/containerd/nerdctl/releases/download/v<span class=\"variable\">$&#123;VERSION&#125;</span>/nerdctl-<span class=\"variable\">$&#123;VERSION&#125;</span>-linux-amd64.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. 解压</span></span><br><span class=\"line\">tar -xvf nerdctl-<span class=\"variable\">$&#123;VERSION&#125;</span>-linux-amd64.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. 移动到系统 PATH</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">mv</span> nerdctl /usr/local/bin/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># nerdctl 需要 sudo 权限</span></span><br><span class=\"line\"><span class=\"comment\">## 为 sudo 添加 PATH</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> visudo</span><br><span class=\"line\"><span class=\"comment\">## 找到这一行</span></span><br><span class=\"line\">Defaults    secure_path = /sbin:/bin:/usr/sbin:/usr/bin</span><br><span class=\"line\"><span class=\"comment\">## 修改为，即将 nerdctl 所在的目录加入 PATH</span></span><br><span class=\"line\">Defaults    secure_path = /sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4.测试</span></span><br><span class=\"line\"><span class=\"comment\">## 查看版本</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> nerdctl version</span><br><span class=\"line\"><span class=\"comment\">## 列出容器，--namespace k8s.io 表示查看 k8s 中的容器</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> nerdctl ps --namespace k8s.io</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 如果不想每次都加上 --namespace k8s.io，可以设置别名</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;alias kps=&#x27;sudo nerdctl --namespace=k8s.io ps&#x27;&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bashrc</span><br><span class=\"line\"><span class=\"comment\">## 测试</span></span><br><span class=\"line\">kps</span><br></pre></td></tr></table></figure>\n<h2 id=\"远程连接-k8s-集群\">远程连接 k8s 集群</h2>\n<h3 id=\"本地不存在-kubeconfig-文件\">本地不存在 kubeconfig 文件</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>获取 kubeconfig 文件，位于 Master 节点：/etc/kubernetes/admin.conf，将其拷贝到本地</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp k8s-master:/etc/kubernetes/admin.conf ~/.kube/config</span><br></pre></td></tr></table></figure>\n<h3 id=\"本地已存在-kubeconfig-文件\">本地已存在 kubeconfig 文件</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>已经配置了一个集群的连接，还想再添加一个集群，可以通过通过合并的方式添加</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将新集群的 kubeconfig 文件拷贝到本地</span></span><br><span class=\"line\">scp k8s-master:/etc/kubernetes/admin.conf ~/.kube/new-cluster.conf</span><br><span class=\"line\"><span class=\"comment\"># 合并</span></span><br><span class=\"line\">KUBECONFIG=~/.kube/config:new-cluster.conf kubectl config view --flatten &gt; merged-config.yaml</span><br><span class=\"line\"><span class=\"comment\"># 替换</span></span><br><span class=\"line\"><span class=\"built_in\">mv</span> merged-config.yaml ~/.kube/config</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>获取集群配置相关命令</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取所有集群配置</span></span><br><span class=\"line\">kubectl config get-contexts</span><br><span class=\"line\"><span class=\"comment\"># 查看当前默认的 context</span></span><br><span class=\"line\">kubectl config current-context</span><br><span class=\"line\"><span class=\"comment\"># 切换 context</span></span><br><span class=\"line\">kubectl config use-context &lt;context_name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取集群名称</span></span><br><span class=\"line\">kubectl config get-clusters</span><br><span class=\"line\"><span class=\"comment\"># 获取用户名称</span></span><br><span class=\"line\">kubectl config get-users</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>测试</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get node</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>删除集群配置</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除 context</span></span><br><span class=\"line\">kubectl config delete-context &lt;context_name&gt;</span><br><span class=\"line\"><span class=\"comment\"># 删除 cluster</span></span><br><span class=\"line\">kubectl config delete-cluster &lt;cluster_name&gt;</span><br><span class=\"line\"><span class=\"comment\"># 删除 user</span></span><br><span class=\"line\">kubectl config delete-user &lt;user_name&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>也可以直接编辑 kubeconfig（~/.kube/config） 文件，添加或删除不需要的集群、用户、上下文等信息</p>\n</blockquote>\n","content_text":"摘要 本文介绍 Linux 下 使用 kubeadm 安装 K8S 的方法，本文以 CentOS 8 为例。 K8S官网 k8s Github 使用 kubeadm 引导集群 kubeadm 命令指南 用 kubeadm 进行管理 安装前设置(所有节点) 修正系统的时间 12345678# 安装chronysudo dnf install chrony -y# 启动服务sudo systemctl enable --now chronyd# 修正时间sudo chronyc makestep# 查看时间date 安装 docker(可选) k8s 使用docker作为容器运行时才需要安装，安装方法参见 Linux 安装 Docker 创建用户 避免使用root用户，这里创建一个 centos 用户，要求该用户具有sudo权限，如果使用docker运行时，则需要将该用户添加到docker用户组 123456789# 1.创建用户$ sudo useradd -m -s /bin/bash centos# 2.添加到docker用户组$ sudo usermod -aG docker centos# 3.将用户添加到 sudo（管理员）组，说明：wheel 是 CentOS 中允许使用 sudo 权限的用户组。具体可以通过 visudo 命令查看$ sudo usermod -aG wheel centos## 这种添加方式使用sudo时需要输入密码，如果不希望输入密码，可以通过 visudo 命令修改，将 wheel 组改为 %wheel ALL=(ALL) NOPASSWD: ALL 的形式# 4.切换用户，以下操作均在该用户下进行$ su - centos 升级内核 由 kubeadm 创建的 Kubernetes 集群依赖于使用内核特性的相关软件。 Kubernetes 集群的节点对于使用 Linux 内核版本要求参加Linux 内核版本要求 kubeadm 项目支持 LTS 内核。参阅 LTS 内核列表。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 查看当前内核版本，可以看到当前内核版本为 4.18.0$ uname -r4.18.0-553.el8_10.x86_64#查看 yum 中可升级的内核版本$ sudo yum list kernel --showduplicates#如果list中有需要的版本可以直接执行 update 升级，多数是没有的，所以要按以下步骤操作#导入ELRepo软件仓库的公共秘钥$ sudo rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org#Centos7系统安装ELRepo# $sudo yum install https://www.elrepo.org/elrepo-release-7.el7.elrepo.noarch.rpm#Centos8系统安装ELRepo$ sudo yum install https://www.elrepo.org/elrepo-release-8.el8.elrepo.noarch.rpm#查看ELRepo提供的内核版本$ sudo yum --disablerepo=&quot;*&quot; --enablerepo=&quot;elrepo-kernel&quot; list available#kernel-lt：表示longterm，即长期支持的内核，当前lt内核版本为 5.4.295#kernel-ml：表示mainline，即当前主线的内核，当前ml内核版本为 6.15.4，笔者测试安装该版本内核最后创建集群时会失败#安装lt内核$ sudo yum --enablerepo=elrepo-kernel install kernel-lt.x86_64# 查看已安装的内核版本，可以看到 刚刚安装的 5.4.295 内核版本的两个文件$ ls -lh /boot/vmlinuz-* /boot/initramfs-* | grep &quot;5.4&quot;-rw------- 1 root root 29M 6月 29 17:15 /boot/initramfs-5.4.295-1.el8.elrepo.x86_64.img-rwxr-xr-x 1 root root 9.5M 6月 28 01:21 /boot/vmlinuz-5.4.295-1.el8.elrepo.x86_64# 查看可以使用的内核$ sudo grubby --info=ALL | grep ^kernelkernel=&quot;/boot/vmlinuz-5.4.295-1.el8.elrepo.x86_64&quot;kernel=&quot;/boot/vmlinuz-4.18.0-553.el8_10.x86_64&quot;kernel=&quot;/boot/vmlinuz-0-rescue-88f75739047993488aacc30b9cd25ca0&quot;# 查看默认内核，默认情况下，系统会自动将新安装的内核设置为默认启动内核$ sudo grubby --default-kernel/boot/vmlinuz-5.4.295-1.el8.elrepo.x86_64# 如果没有自动启用，则通过该命令设置默认内核$ sudo grubby --set-default /boot/vmlinuz-5.4.295-1.el8.elrepo.x86_64# 重启系统$ sudo reboot# 重启登录后验证内核版本$ uname -r5.4.295-1.el8.elrepo.x86_64 将 SELinux 设置为 permissive 模式（相当于将其禁用） 12$ sudo setenforce 0$ sudo sed -i &#x27;s/^SELINUX=enforcing$/SELINUX=permissive/&#x27; /etc/selinux/config 禁用Firewalld 123# 为了方便，这里可以禁用 firewalldsudo systemctl stop firewalldsudo systemctl disable firewalld 不关 Firewalld 应该开放哪些端口？(实测还是会遇到各种各样的问题) Master 节点需要开放的端口 端口 协议 说明 6443 TCP kube-apiserver，用于 kubectl 与集群通信 2379-2380 TCP etcd 集群通信（仅在你自己部署 etcd 时） 10250 TCP kubelet 监听端口，供 apiserver 与节点通信 10259 TCP kube-scheduler 10257 TCP kube-controller-manager Worker 节点需要开放的端口 端口 协议 说明 10250 TCP kubelet 与 apiserver 通信 30000-32767 TCP NodePort 服务默认端口范围 10255 TCP kubelet 只读端口（默认关闭，可不开放） 如果你使用的是 Calico 网络插件 端口 协议 说明 179 TCP BGP 通信端口，用于 Calico 节点间路由（若使用 BGP 模式） 如果你使用的是 Flannel（VXLAN 模式） 端口 协议 说明 8472 UDP VXLAN 数据通信 Ingress 控制器（比如 NGINX Ingress） 端口 协议 说明 80 / 443 TCP 提供 HTTP/HTTPS 服务访问（Ingress 服务） 示例命令：使用 firewall-cmd 开放端口 123456789101112131415161718192021222324252627282930313233343536373839# 启动 firewalldsudo systemctl start firewalldsudo systemctl enable firewalld# 示例：开放常用端口sudo firewall-cmd --permanent --add-port=6443/tcpsudo firewall-cmd --permanent --add-port=2379-2380/tcpsudo firewall-cmd --permanent --add-port=10250/tcpsudo firewall-cmd --permanent --add-port=10259/tcpsudo firewall-cmd --permanent --add-port=10257/tcpsudo firewall-cmd --permanent --add-port=30000-32767/tcpsudo firewall-cmd --permanent --add-port=179/tcp # 如果用 Calicosudo firewall-cmd --permanent --add-port=8472/udp # 如果用 Flannelsudo firewall-cmd --permanent --add-port=80/tcp # Ingresssudo firewall-cmd --permanent --add-port=443/tcp # Ingress# 允许 Calico 的封装协议 IPIP ,允许 IPIP 协议（协议号 4）sudo firewall-cmd --permanent --direct --add-rule ipv4 filter INPUT 0 -p 4 -j ACCEPTsudo firewall-cmd --permanent --direct --add-rule ipv4 filter OUTPUT 0 -p 4 -j ACCEPT# 如果 Calico 使用 VXLAN 模式，则需要开放 4789 端口sudo firewall-cmd --permanent --add-port=4789/udp# Calico Typha 网络sudo firewall-cmd --permanent --add-port=5473/tcp# Calico WireGuard（IPv4 和 IPv6）sudo firewall-cmd --permanent --add-port=51820/udpsudo firewall-cmd --permanent --add-port=51821/udp# 应用更改sudo firewall-cmd --reload# 查看开放的端口$ sudo firewall-cmd --list-ports80/tcp 179/tcp 443/tcp 2377/tcp 2379-2380/tcp 6443/tcp 7946/tcp 10250/tcp 10257/tcp 10259/tcp 30000-32767/tcp 4789/udp 7946/udp 8472/udp# 查看开放的直接规则$ sudo firewall-cmd --direct --get-all-rulesipv4 filter INPUT 0 -p 4 -j ACCEPT 关闭swap 12sudo swapoff -asudo sed -i &#x27;/ swap / s/^/#/&#x27; /etc/fstab 加载内核模块 12sudo modprobe overlaysudo modprobe br_netfilter 设置内核参数 1234567cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/kubernetes.confnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1net.ipv4.ip_forward = 1EOFsudo sysctl --system 安装containerd 123456789101112sudo yum install -y yum-utils device-mapper-persistent-data lvm2sudo yum config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.reposudo yum install -y containerd.iosudo mkdir -p /etc/containerdsudo containerd config default | sudo tee /etc/containerd/config.toml# 设置Systemd为cgroup driversudo sed -i &#x27;s/SystemdCgroup = false/SystemdCgroup = true/&#x27; /etc/containerd/config.toml# 启动并设置开机启动sudo systemctl enable --now containerd 如果是国内环境，可以在/etc/containerd/config.toml添加镜像加速器配置 123456789sudo vim /etc/containerd/config.toml# 找到 registry.mirrors 字段，添加加速器，比如：[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors] [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors.&quot;docker.io&quot;] endpoint = [&quot;https://docker.1ms.run&quot;, &quot;https://docker.xuanyuan.me&quot;, &quot;https://docker.m.daocloud.io&quot;]# 修改后重启 containerdsudo systemctl restart containerd 安装cri-dockerd(可选) 如果使用 containerd，则不需要安装 cri-dockerd Kubernetes 1.24+ 默认移除了 dockershim，所以你必须安装 cri-dockerd 才能继续使用 Docker 123456789101112131415# 下载并安装 cri-dockerd RPM，目前最新版是 0.3.19，fc35: Fedora 35 构建，适配 RHEL/CentOS 8 系统的 glibc 和 libstdc++$ curl -LO https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.19/cri-dockerd-0.3.19-3.fc35.x86_64.rpm# 安装时报错：cri-dockerd-0.3.19-3.fc35.x86_64.rpm 依赖 GLIBC ≥ 2.32 和 2.34，但 CentOS 8 系统只提供 GLIBC 2.28。$ sudo dnf install -y ./cri-dockerd-0.3.19-3.fc35.x86_64.rpm# 重新下载一个兼容的版本即可，这里选择：cri-dockerd-0.3.14-3.el8.x86_64.rpm$ curl -LO https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.14/cri-dockerd-0.3.14-3.el8.x86_64.rpm$ sudo dnf install -y ./cri-dockerd-0.3.14-3.el8.x86_64.rpm# 重新加载服务$ sudo systemctl daemon-reload# 加入开机启动并立刻启动$ sudo systemctl enable --now cri-docker# 后面的 kubeadm 命令 都要加上 --cri-socket unix:///var/run/cri-dockerd.sock 安装 kubelet, kubeadm, kubectl 添加 Kubernetes YUM 源，k8s 的版本从官网获取 123456789101112$ cat &lt;&lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=https://pkgs.k8s.io/core:/stable:/v1.33/rpm/enabled=1gpgcheck=1repo_gpgcheck=1gpgkey=https://pkgs.k8s.io/core:/stable:/v1.33/rpm/repodata/repomd.xml.keyEOF# 清理yum缓存并重新建立缓存$ sudo yum clean all &amp;&amp; sudo yum makecache 安装 kubelet, kubeadm, kubectl 12345678910111213141516# 查看kubeadm有什么版本$ sudo yum list --showduplicates kubeadm# 不指定版本默认那种最新版$ sudo yum install -y kubelet kubeadm kubectl# 启用kubelet$ sudo systemctl enable --now kubelet# 指定容器运行时为containerd，这里通过 crictl 指定容器运行时为 containerd# 配置文件：/etc/crictl.yaml$ sudo crictl config runtime-endpoint /run/containerd/containerd.sock# 检查$ kubeadm version$ kubelet --version$ kubectl version --client 启用 shell 自动补全功能 12345678910111213141516171819# 1.安装 bash-completion# 1.1 检查bash-completion是否已安装，有输出说明已经安装$ type _init_completion# 1.2 安装bash-completion，安装后会创建文件 /usr/share/bash-completion/bash_completion$ dnf install bash-completion# 2.安装 kubectl 的自动补全功能# 2.1 当前用户$ echo &#x27;source &lt;(kubectl completion bash)&#x27; &gt;&gt; ~/.bashrc# 2.2 所有用户$ kubectl completion bash | sudo tee /etc/bash_completion.d/kubectl &gt; /dev/null$ sudo chmod a+r /etc/bash_completion.d/kubectl# 3 如果 kubectl 有关联的别名，你可以扩展 Shell 补全来适配此别名$ echo &#x27;alias k=kubectl&#x27; &gt;&gt;~/.bashrc$ echo &#x27;complete -o default -F __start_kubectl k&#x27; &gt;&gt;~/.bashrc# 4.刷新配置文件$ source ~/.bashrc 创建集群(master节点) master节点: [hostname: k8s-master, IP: 10.211.55.11] 初始化master节点的控制面板，容器运行时基于 containerd 1234567891011121314151617181920212223242526272829303132333435363738# kubeadm init --help可以查看命令的具体参数用法#在master节点执行初始化（node节点不用执行）# --apiserver-advertise-address 指定apiserver的IP，即master节点的IP# --image-repository registry.cn-hangzhou.aliyuncs.com/google_containers 设置镜像仓库为国内镜像仓库# --kubernetes-version 设置k8s的版本，跟kubeadm版本一致# --service-cidr 这是设置node节点的网络的，暂时这样设置# --pod-network-cidr 这是设置node节点的网络的，暂时这样设置# --cri-socket unix:///var/run/cri-dockerd.sock 设置cri使用cri-dockerd# --ignore-preflight-errors=all 忽略所有预检错误（Preflight Errors）。这会跳过对系统状态的某些检查，例如是否启用了 swap、CPU 核心数、系统配置等。不推荐用于生产，只用于调试或测试环境。$ sudo kubeadm init \\--apiserver-advertise-address=10.211.55.11 \\--kubernetes-version v1.33.2 \\--service-cidr=10.96.0.0/16 \\--pod-network-cidr=10.244.0.0/16## 安装成功会打印如下信息Your Kubernetes control-plane has initialized successfully!To start using your cluster, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/configAlternatively, if you are the root user, you can run: export KUBECONFIG=/etc/kubernetes/admin.confYou should now deploy a pod network to the cluster.Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at: https://kubernetes.io/docs/concepts/cluster-administration/addons/Then you can join any number of worker nodes by running the following on each as root:kubeadm join 10.211.55.11:6443 --token sqwk6v.lxlnf0ibtbgr4i27 \\ --discovery-token-ca-cert-hash sha256:c43f8b6d0e7081a76ab1d8ca8d3c5fb1ef3b21afcd81874566d7840167809412 查看集群状态 1234567891011# 集群信息$ k cluster-infoKubernetes control plane is running at https://10.211.55.11:6443CoreDNS is running at https://10.211.55.11:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy# 查看组件状态$ k get csWarning: v1 ComponentStatus is deprecated in v1.19+NAME STATUS MESSAGE ERRORscheduler Healthy okcontroller-manager Healthy oketcd-0 Healthy ok 为当前用户授予连接集群的权限 123$ mkdir -p $HOME/.kube$ sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config$ sudo chown $(id -u):$(id -g) $HOME/.kube/config 安装网络插件：k8s支持的网络插件， calico官网 calico GitHub] 123456789101112131415161718192021222324252627282930# 安装calico前查看pod，-A 查看所有命名空间$ kubectl get pods -ANAMESPACE NAME READY STATUS RESTARTS AGEkube-system coredns-674b8bbfcf-8xllc 0/1 Pending 0 116mkube-system coredns-674b8bbfcf-w2sxz 0/1 Pending 0 116mkube-system etcd-k8s 1/1 Running 2 (74m ago) 116mkube-system kube-apiserver-k8s 1/1 Running 2 (74m ago) 116mkube-system kube-controller-manager-k8s 1/1 Running 2 (74m ago) 116mkube-system kube-proxy-94zqw 1/1 Running 1 (74m ago) 116mkube-system kube-scheduler-k8s 1/1 Running 2 (74m ago) 116m# 下载yaml文件，目前最新版为 v3.30.2$ curl -LO https://raw.githubusercontent.com/projectcalico/calico/v3.30.2/manifests/calico.yaml# 创建$ kubectl apply -f calico.yaml# 安装calico后查看pod，在安装 Calico 之前 CoreDNS 是 Pending 状态，现在已经变成 Running# -o wide: 显示pod的详细信息$ kubectl get pods -A -o wideNAMESPACE NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATESkube-system calico-kube-controllers-7bfdc5b57c-9qv9m 1/1 Running 0 6m23s 10.244.77.1 k8s &lt;none&gt; &lt;none&gt;kube-system calico-node-m7wc5 1/1 Running 0 6m23s 10.211.55.11 k8s &lt;none&gt; &lt;none&gt;kube-system coredns-674b8bbfcf-8xllc 1/1 Running 0 123m 10.244.77.3 k8s &lt;none&gt; &lt;none&gt;kube-system coredns-674b8bbfcf-w2sxz 1/1 Running 0 123m 10.244.77.2 k8s &lt;none&gt; &lt;none&gt;kube-system etcd-k8s 1/1 Running 2 (82m ago) 123m 10.211.55.11 k8s &lt;none&gt; &lt;none&gt;kube-system kube-apiserver-k8s 1/1 Running 2 (82m ago) 123m 10.211.55.11 k8s &lt;none&gt; &lt;none&gt;kube-system kube-controller-manager-k8s 1/1 Running 2 (82m ago) 123m 10.211.55.11 k8s &lt;none&gt; &lt;none&gt;kube-system kube-proxy-94zqw 1/1 Running 1 (82m ago) 123m 10.211.55.11 k8s &lt;none&gt; &lt;none&gt;kube-system kube-scheduler-k8s 1/1 Running 2 (82m ago) 123m 10.211.55.11 k8s &lt;none&gt; &lt;none&gt; calica 安装后可能出现不正常的情况，比如 calico-node-xxx 的pod始终无法正常运行，此时可以尝试重新安装 calica 12345678# 删除 calico$ kubectl delete -f calico.yaml#如果是重装calico，需要先清除旧的配置$ sudo rm -rf /etc/cni/net.d/$ sudo rm -rf /var/lib/calico# 重新安装 calico$ kubectl apply -f calico.yaml 添加节点(worker节点) worker节点: [hostname: k8s-worker1, IP: 10.211.55.15] 12345678910111213141516171819# 在待加入的节点上执行如下命令，如果忘记token，则使用下文的命令重新获取$ sudo kubeadm join 10.211.55.11:6443 --token sqwk6v.lxlnf0ibtbgr4i27 --discovery-token-ca-cert-hash sha256:c43f8b6d0e7081a76ab1d8ca8d3c5fb1ef3b21afcd81874566d7840167809412## 输出[preflight] Running pre-flight checks [WARNING SystemVerification]: cgroups v1 support is in maintenance mode, please migrate to cgroups v2[preflight] Reading configuration from the &quot;kubeadm-config&quot; ConfigMap in namespace &quot;kube-system&quot;...[preflight] Use &#x27;kubeadm init phase upload-config --config your-config-file&#x27; to re-upload it.[kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot;[kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot;[kubelet-start] Starting the kubelet[kubelet-check] Waiting for a healthy kubelet at http://127.0.0.1:10248/healthz. This can take up to 4m0s[kubelet-check] The kubelet is healthy after 1.004135788s[kubelet-start] Waiting for the kubelet to perform the TLS BootstrapThis node has joined the cluster:* Certificate signing request was sent to apiserver and a response was received.* The Kubelet was informed of the new secure connection details.Run &#x27;kubectl get nodes&#x27; on the control-plane to see this node join the cluster. 如果上面的令牌忘记了，或者新的 worker 节点加入，在 master 上执行下面的命令，生成新的令牌 123$ kubeadm token create --print-join-command## 输出kubeadm join 10.211.55.11:6443 --token 5o3p2i.gj95aopph0xbrcig --discovery-token-ca-cert-hash sha256:c43f8b6d0e7081a76ab1d8ca8d3c5fb1ef3b21afcd81874566d7840167809412 在 master 节点上查看新创建的资源，默认情况下 work 节点不支持管理 k8s 1234567891011121314151617181920# 查看节点$ kubectl get nodesNAME STATUS ROLES AGE VERSIONk8s Ready control-plane 3h33m v1.33.2k8s-worker1 Ready &lt;none&gt; 115s v1.33.2# 查看pod list$ kubectl get pods -A -o wideNAMESPACE NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATESkube-system calico-kube-controllers-7bfdc5b57c-q5xwp 1/1 Running 0 37m 10.244.235.193 k8s-master &lt;none&gt; &lt;none&gt;kube-system calico-node-7pbbq 1/1 Running 0 4m51s 10.211.55.15 k8s-worker1 &lt;none&gt; &lt;none&gt;kube-system calico-node-w47qq 1/1 Running 0 37m 10.211.55.11 k8s-master &lt;none&gt; &lt;none&gt;kube-system coredns-674b8bbfcf-2tvld 1/1 Running 0 37m 10.244.235.195 k8s-master &lt;none&gt; &lt;none&gt;kube-system coredns-674b8bbfcf-h6kx7 1/1 Running 0 37m 10.244.235.194 k8s-master &lt;none&gt; &lt;none&gt;kube-system etcd-k8s-master 1/1 Running 2 37m 10.211.55.11 k8s-master &lt;none&gt; &lt;none&gt;kube-system kube-apiserver-k8s-master 1/1 Running 4 37m 10.211.55.11 k8s-master &lt;none&gt; &lt;none&gt;kube-system kube-controller-manager-k8s-master 1/1 Running 4 37m 10.211.55.11 k8s-master &lt;none&gt; &lt;none&gt;kube-system kube-proxy-nkbns 1/1 Running 0 4m51s 10.211.55.15 k8s-worker1 &lt;none&gt; &lt;none&gt;kube-system kube-proxy-plqw8 1/1 Running 0 37m 10.211.55.11 k8s-master &lt;none&gt; &lt;none&gt;kube-system kube-scheduler-k8s-master 1/1 Running 4 38m 10.211.55.11 k8s-master &lt;none&gt; &lt;none&gt; 使 work 节点支持管理 k8s(可选)：远程管理 1234567# 将 master 节点中的 ~/.kube/config 复制到 work 节点的 ~/.kube/config 即可# 在 master 节点执行scp ~/.kube/config k8s-work1:/tmp# 在 work 节点执行mkdir -p ~/.kubemv /tmp/config ~/.kube/config 删除work节点 1234567891011# master, 删除节点前先清空节点上的所有 Pod，使其调度到其他节点$ kubectl drain k8s-worker1 --ignore-daemonsets# worker节点上执行如下命令## 在移除节点之前，请重置 kubeadm 安装的状态$ sudo kubeadm reset## 重置过程不会重置或清除 iptables 规则或 IPVS 表。如果你希望重置 iptables，则必须手动进行$ iptables -F &amp;&amp; iptables -t nat -F &amp;&amp; iptables -t mangle -F &amp;&amp; iptables -X# master 节点上删除节点$ kubectl delete node k8s-worker1 测试：用K8S部署Nginx 123456789101112131415161718192021# 创建deploymentkubectl create deployment nginx --image=nginx# 创建service，--type指定为NodePort，其含义为将deployment的80端口映射到Node的随机端口kubectl expose deployment nginx --type=NodePort --port=80# 查看pod和service，不加 -n 参数，默认查看的是default命名空间$ kubectl get pod,svc -o wideNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATESpod/nginx-5869d7778c-95z74 1/1 Running 0 19m 10.244.194.65 k8s-worker1 &lt;none&gt; &lt;none&gt;NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE SELECTORservice/kubernetes ClusterIP 10.96.0.1 &lt;none&gt; 443/TCP 61m &lt;none&gt;service/nginx NodePort 10.96.48.156 &lt;none&gt; 80:30291/TCP 14m app=nginx# 浏览器访问任意nodeIP:30291# 删除测试资源## 删除deploymentkubectl delete deployment nginx## 删除servicekubectl delete service nginx 通过 kubeadm 卸载 Kubernetes 123456789101112131415161718192021222324# 停止 kubelet 相关组件,删除 /etc/kubernetes 配置,清除证书、状态目录等,取消 iptables 规则,清除容器运行时中的 Pod、镜像信息等$ sudo kubeadm reset# 虽然 kubeadm reset 已经会清除大部分内容，但以下文件和配置可能依然存在，建议一并手动清理## 删除 kubeconfig 文件（本地 kubectl 配置）rm -rf $HOME/.kube## 清理 etcd 数据（如你启用了本地 etcd）sudo rm -rf /var/lib/etcd## 清理 CNI 网络配置和状态sudo rm -rf /etc/cni/net.dsudo rm -rf /var/lib/cni/sudo rm -rf /var/lib/kubelet/*# 清理 Calicosudo rm -rf /var/lib/calico# 清理 iptablessudo iptables -Fsudo iptables -Xsudo iptables -t nat -Fsudo iptables -t nat -Xsudo iptables -t mangle -Fsudo iptables -t mangle -Xsudo iptables -P INPUT ACCEPTsudo iptables -P FORWARD ACCEPTsudo iptables -P OUTPUT ACCEPT 停止和禁用 kubelet 服务 12sudo systemctl stop kubeletsudo systemctl disable kubelet 升级 kubeadm 集群 将 kubeadm 创建的 Kubernetes 集群从 1.32.x 版本 升级到 1.33.x 版本以及从 1.33.x 升级到 1.33.y（其中 y &gt; x），略过次版本号的升级是 不被支持的。 升级步骤 升级 master 节点 升级 master 节点 如果要从 v1.33 升级到 v1.34，则需要先修改 Kubernetes YUM 源，因为我上面配置 yum 源时配置的是 v1.33 如果只是从 v1.33.2 升级到 v1.33.3，则不需要修改 Kubernetes YUM 源 1234567891011121314151617# 查看 kubeadm 可以升级的版本$ sudo yum list --showduplicates kubeadm# 指定要升级的版本，比如这里要升级到 1.33.3sudo yum install -y kubeadm-1.33.3# 查看升级后的版本kubeadm version# 验证升级计划: 此命令检查你的集群是否可被升级，并取回你要升级的目标版本。 命令也会显示一个包含组件配置版本状态的表格。$ sudo kubeadm upgrade plan# 升级 master 节点: 这一步会升级 kube-apiserver、controller-manager、scheduler 等静态 Pod。$ sudo kubeadm upgrade apply v1.33.3## 一旦该命令结束，你应该会看到： [upgrade/successful] SUCCESS! Your cluster was upgraded to &quot;v1.33.3&quot;. Enjoy! [upgrade/kubelet] Now that your control plane is upgraded, please proceed with upgrading your kubelets if you haven&#x27;t already done so. 手动升级你的 CNI 驱动插件，比如 Calico 升级 kubelet 和 kubectl 12345# 安装指定的版本sudo yum install -y kubelet-1.33.3 kubectl-1.33.3# 重启 kubeletsudo systemctl daemon-reloadsudo systemctl restart kubelet 升级 worker 节点 升级 worker 节点 如果要从 v1.33 升级到 v1.34，则需要先修改 Kubernetes YUM 源，因为我上面配置 yum 源时配置的是 v1.33 如果只是从 v1.33.2 升级到 v1.33.3，则不需要修改 Kubernetes YUM 源 1234567# 查看 kubeadm 可以升级的版本$ sudo yum list --showduplicates kubeadm# 指定要升级的版本，比如这里要升级到 1.33.3$ sudo yum install -y kubeadm-1.33.3# 查看升级后的版本$ kubeadm version 腾空节点：如果有多个 worker 节点，可以选择先腾空节点。如果只有一个 worker 节点，则不需要。 drain 是为了在升级期间 避免该节点上正在运行的业务容器受到影响 123# 在控制平面节点上执行此命令# 将 &lt;node-to-drain&gt; 替换为你正腾空的节点的名称$ kubectl drain &lt;node-to-drain&gt; --ignore-daemonsets 升级 node 节点 1$ sudo kubeadm upgrade node 升级 kubelet 和 kubectl 12345# 安装指定的版本$ sudo yum install -y kubelet-1.33.3 kubectl-1.33.3# 重启 kubelet$ sudo systemctl daemon-reload$ sudo systemctl restart kubelet 如果前面对节点做了 腾空节点 操作，则需要取消对节点的保护，将节点标记为可调度，让节点重新上线 123# 在控制平面节点上执行此命令# 将 &lt;node-to-uncordon&gt; 替换为你的节点名称$ kubectl uncordon &lt;node-to-uncordon&gt; 更新证书 kubeadm 创建的证书存放在 /etc/kubernetes/pki/ 下，默认客户端证书有效期为 1 年 可以通过如下命令查看证书信息 12kubectl -n kube-system get cm kubeadm-config -o yamlopenssl x509 -in /etc/kubernetes/pki/apiserver.crt -text 查看证书到期时间 123456789101112131415161718192021sudo kubeadm certs check-expiration## 输出结果## 可以看到 客户端 的证书的过期时间，默认值为 1 年CERTIFICATE EXPIRES RESIDUAL TIME CERTIFICATE AUTHORITY EXTERNALLY MANAGEDadmin.conf Jun 29, 2026 14:41 UTC 363d ca noapiserver Jun 29, 2026 14:41 UTC 363d ca noapiserver-etcd-client Jun 29, 2026 14:41 UTC 363d etcd-ca noapiserver-kubelet-client Jun 29, 2026 14:41 UTC 363d ca nocontroller-manager.conf Jun 29, 2026 14:41 UTC 363d ca noetcd-healthcheck-client Jun 29, 2026 14:41 UTC 363d etcd-ca noetcd-peer Jun 29, 2026 14:41 UTC 363d etcd-ca noetcd-server Jun 29, 2026 14:41 UTC 363d etcd-ca nofront-proxy-client Jun 29, 2026 14:41 UTC 363d front-proxy-ca noscheduler.conf Jun 29, 2026 14:41 UTC 363d ca nosuper-admin.conf Jun 29, 2026 14:41 UTC 363d ca no# 根证书默认有效期为 10 年CERTIFICATE AUTHORITY EXPIRES RESIDUAL TIME EXTERNALLY MANAGEDca Jun 27, 2035 14:41 UTC 9y noetcd-ca Jun 27, 2035 14:41 UTC 9y nofront-proxy-ca Jun 27, 2035 14:41 UTC 9y no 更新客户端证书 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# 更新前备份sudo cp -rf /etc/kubernetes/ /etc/kubernetes.baksudo cp -rf /var/lib/etcd/ /var/lib/etcd.bak# 可以更新单个客户端证书# sudo kubeadm certs renew admin.conf# sudo kubeadm certs renew apiserver# 升级全部客户端证书，也只能续期1年sudo kubeadm certs renew all## 输出[renew] Reading configuration from the &quot;kubeadm-config&quot; ConfigMap in namespace &quot;kube-system&quot;...[renew] Use &#x27;kubeadm init phase upload-config --config your-config-file&#x27; to re-upload it.certificate embedded in the kubeconfig file for the admin to use and for kubeadm itself renewedcertificate for serving the Kubernetes API renewedcertificate the apiserver uses to access etcd renewedcertificate for the API server to connect to kubelet renewedcertificate embedded in the kubeconfig file for the controller manager to use renewedcertificate for liveness probes to healthcheck etcd renewedcertificate for etcd nodes to communicate with each other renewedcertificate for serving etcd renewedcertificate for the front proxy client renewedcertificate embedded in the kubeconfig file for the scheduler manager to use renewedcertificate embedded in the kubeconfig file for the super-admin renewedDone renewing certificates. You must restart the kube-apiserver, kube-controller-manager, kube-scheduler and etcd, so that they can use the new certificates.# 需要根据输出提示重启 kube-apiserver, kube-controller-manager, kube-scheduler 和 etcd# 这几个组件是通过pod 启动的，可以通过 kubectl get pod -n kube-system 查看$ kubectl get pods -n kube-systemNAME READY STATUS RESTARTS AGEcalico-kube-controllers-7bfdc5b57c-q5xwp 1/1 Running 3 (5h37m ago) 41hcalico-node-7pbbq 1/1 Running 3 (5h36m ago) 41hcalico-node-v4hzr 1/1 Running 2 (5h37m ago) 19hcalico-node-w47qq 1/1 Running 3 (5h37m ago) 41hcoredns-674b8bbfcf-2tvld 1/1 Running 3 (5h37m ago) 41hcoredns-674b8bbfcf-h6kx7 1/1 Running 3 (5h37m ago) 41hetcd-k8s-master 1/1 Running 5 (5h37m ago) 41hkube-apiserver-k8s-master 1/1 Running 7 (5h37m ago) 41hkube-controller-manager-k8s-master 1/1 Running 7 (5h37m ago) 41hkube-proxy-nkbns 1/1 Running 3 (5h36m ago) 41hkube-proxy-plqw8 1/1 Running 3 (5h37m ago) 41hkube-proxy-sbgh6 1/1 Running 2 (5h37m ago) 19hkube-scheduler-k8s-master 1/1 Running 7 (5h37m ago) 41h# 删除指定的pod就会自动重启kubectl delete pod -n kube-system kube-apiserver-k8s-master kube-controller-manager-k8s-master kube-scheduler-k8s-master etcd-k8s-master# 重启成功后再次查看证书信息，就会看到更新后的到期时间为1年sudo kubeadm certs check-expiration Kubernetes 节点组件 角色 组件名 说明 Master Node kube-apiserver Kubernetes 的 API 请求入口，处理所有 REST 请求，协调各组件。 kube-scheduler 调度器，决定将 Pod 调度到哪个合适的 Node。 kube-controller-manager 包含多个控制器（如 NodeController、ReplicationController、DeploymentController 等），用于控制和调整集群状态。 etcd 分布式 KV 存储系统，存储 Kubernetes 所有状态数据。只有 API Server 能直接访问。 Worker Node kubelet 负责与 Master 通信，执行其下发的 Pod 管理任务，控制容器生命周期。 kube-proxy 负责维护 Node 上的网络规则，支持服务负载均衡和网络通信。 container runtime 容器运行时，比如 Docker、containerd、CRI-O，负责实际运行容器。 crictl 命令 crictl 是k8s官方出品的一个命令行工具，用于与 containerd 进行通信。 crictl 命令默认需要 sudo 权限，如果不想每次都加 sudo，可以将用户加入 containerd 的 socket 权限组 123456789101112131415161718192021222324# containerd 的默认 socket 是 /var/run/containerd/containerd.sock$ ls -l /var/run/containerd/containerd.socksrw-rw---- 1 root root 0 7月 1 10:57 /var/run/containerd/containerd.sock# 如果 group 是 root：你可以改为其它组，比如 docker# 如果 docker 组不存在则创建sudo groupadd docker# 修改文件所属组为 dockersudo chgrp docker /var/run/containerd/containerd.sock# 为组添加读写权限sudo chmod g+rw /var/run/containerd/containerd.sock# 添加用户到 docker 组sudo usermod -aG docker $USER# 刷新权限newgrp docker# 此时虽然已经可以不用 sudo 了，但是一旦重启 containerd 就会重新回到 root 权限，因此需要添加如下配置sudo mkdir -p /etc/systemd/system/containerd.service.d/sudo tee /etc/systemd/system/containerd.service.d/override.conf &lt;&lt;EOF[Service]ExecStartPost=/bin/bash -c &#x27;chmod 660 /run/containerd/containerd.sock &amp;&amp; chgrp docker /run/containerd/containerd.sock&#x27;EOFsudo systemctl daemon-reloadsudo systemctl restart containerd crictl 命令的使用方式比较类似docker命令 操作 docker 命令 crictl 命令 说明 查看正在运行的容器 docker ps crictl ps 查看所有容器（包括已停止） docker ps -a crictl ps -a 查看镜像 docker images crictl images 查看容器日志 docker logs &lt;container_id&gt; crictl logs &lt;container_id&gt; 进入容器交互 docker exec -it &lt;id&gt; sh crictl exec -it &lt;id&gt; sh 查看容器详细信息 docker inspect &lt;container_id&gt; crictl inspect &lt;container_id&gt; 查看 Pod 详细信息 ❌（不支持） crictl inspectp &lt;pod_id&gt; K8s 专属 删除容器 docker rm &lt;container_id&gt; crictl rm &lt;container_id&gt; 删除镜像 docker rmi &lt;image_id&gt; crictl rmi &lt;image_id&gt; 拉取镜像 docker pull nginx crictl pull nginx 运行容器（非 K8s 场景） docker run -it nginx ❌（不支持） crictl 不运行容器，仅调试现有容器 列出容器运行时信息 docker info crictl info 查看容器运行状态 docker stats crictl stats 简要版 设置配置文件 ~/.docker/config.json /etc/crictl.yaml 如设置 endpoint nerdctl nerdctl 是一个 兼容 Docker CLI 的容器命令行工具，用于管理 containerd 容器运行时。 它是 containerd 官方子项目，由 CNCF 维护，其命令语法与 Docker CLI 兼容，目标是让习惯 Docker 的用户也能轻松使用 containerd。 安装 nerdctl 1234567891011121314151617181920212223242526272829# 1. 下载最新版本VERSION=2.1.3wget https://github.com/containerd/nerdctl/releases/download/v$&#123;VERSION&#125;/nerdctl-$&#123;VERSION&#125;-linux-amd64.tar.gz# 2. 解压tar -xvf nerdctl-$&#123;VERSION&#125;-linux-amd64.tar.gz# 3. 移动到系统 PATHsudo mv nerdctl /usr/local/bin/# nerdctl 需要 sudo 权限## 为 sudo 添加 PATHsudo visudo## 找到这一行Defaults secure_path = /sbin:/bin:/usr/sbin:/usr/bin## 修改为，即将 nerdctl 所在的目录加入 PATHDefaults secure_path = /sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin# 4.测试## 查看版本sudo nerdctl version## 列出容器，--namespace k8s.io 表示查看 k8s 中的容器sudo nerdctl ps --namespace k8s.io## 如果不想每次都加上 --namespace k8s.io，可以设置别名echo &quot;alias kps=&#x27;sudo nerdctl --namespace=k8s.io ps&#x27;&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc## 测试kps 远程连接 k8s 集群 本地不存在 kubeconfig 文件 获取 kubeconfig 文件，位于 Master 节点：/etc/kubernetes/admin.conf，将其拷贝到本地 1scp k8s-master:/etc/kubernetes/admin.conf ~/.kube/config 本地已存在 kubeconfig 文件 已经配置了一个集群的连接，还想再添加一个集群，可以通过通过合并的方式添加 123456# 将新集群的 kubeconfig 文件拷贝到本地scp k8s-master:/etc/kubernetes/admin.conf ~/.kube/new-cluster.conf# 合并KUBECONFIG=~/.kube/config:new-cluster.conf kubectl config view --flatten &gt; merged-config.yaml# 替换mv merged-config.yaml ~/.kube/config 获取集群配置相关命令 1234567891011# 获取所有集群配置kubectl config get-contexts# 查看当前默认的 contextkubectl config current-context# 切换 contextkubectl config use-context &lt;context_name&gt;# 获取集群名称kubectl config get-clusters# 获取用户名称kubectl config get-users 测试 1kubectl get node 删除集群配置 123456# 删除 contextkubectl config delete-context &lt;context_name&gt;# 删除 clusterkubectl config delete-cluster &lt;cluster_name&gt;# 删除 userkubectl config delete-user &lt;user_name&gt; 也可以直接编辑 kubeconfig（~/.kube/config） 文件，添加或删除不需要的集群、用户、上下文等信息","summary":"摘要 本文介绍 Linux 下 使用 kubeadm 安装 K8S 的方法，本文以 CentOS 8 为例。 K8S官网 k8s Github 使用 kubeadm 引导集群 kubeadm 命令指南 用 kubeadm 进行管理","date_published":"2025-06-29T14:30:05.000Z","tags":["技术","k8s","K8S"]},{"id":"https://blog.hanqunfeng.com/2025/06/28/k8s-install-minikube/","url":"https://blog.hanqunfeng.com/2025/06/28/k8s-install-minikube/","title":"Linux 安装 K8S 之 minikube","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 Linux 下 使用 minikube 安装 K8S 的方法，本文以 CentOS 8 为例。</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kubernetes.io/zh-cn/\">K8S官网</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://github.com/kubernetes/kubernetes\">k8s Github</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://minikube.sigs.k8s.io/docs/\">minikube官网</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"安装前设置\">安装前设置</h2>\n<h3 id=\"修正系统的时间\">修正系统的时间</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装chrony</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> dnf install chrony -y</span><br><span class=\"line\"><span class=\"comment\"># 启动服务</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl <span class=\"built_in\">enable</span> --now chronyd</span><br><span class=\"line\"><span class=\"comment\"># 修正时间</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> chronyc makestep</span><br><span class=\"line\"><span class=\"comment\"># 查看时间</span></span><br><span class=\"line\"><span class=\"built_in\">date</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"安装-docker\">安装 <code>docker</code></h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>安装方法参见 <a href=\"/2025/05/20/docker-install/\" title=\"Linux 安装 Docker\">Linux 安装 Docker</a></p>\n</li>\n</ul>\n<h3 id=\"创建用户\">创建用户</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>避免使用root用户，这里创建一个 <code>centos</code> 用户，要求该用户具有<code>sudo</code>权限，如果使用<code>docker</code>运行时，则需要将该用户添加到<code>docker</code>用户组</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.创建用户</span></span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> useradd -m -s /bin/bash centos</span><br><span class=\"line\"><span class=\"comment\"># 2.添加到docker用户组</span></span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> usermod -aG docker centos</span><br><span class=\"line\"><span class=\"comment\"># 3.将用户添加到 sudo（管理员）组，说明：wheel 是 CentOS 中允许使用 sudo 权限的用户组。具体可以通过 visudo 命令查看</span></span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> usermod -aG wheel centos</span><br><span class=\"line\"><span class=\"comment\">## 这种添加方式使用sudo时需要输入密码，如果不希望输入密码，可以通过 visudo 命令修改，将 wheel 组改为 %wheel ALL=(ALL) NOPASSWD: ALL 的形式</span></span><br><span class=\"line\"><span class=\"comment\"># 4.切换用户，以下操作均在该用户下进行</span></span><br><span class=\"line\">$ su - centos</span><br></pre></td></tr></table></figure>\n<h3 id=\"安装-kubectl\">安装 <code>kubectl</code></h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.下载 kubectl</span></span><br><span class=\"line\">$ curl -LO <span class=\"string\">&quot;https://dl.k8s.io/release/<span class=\"subst\">$(curl -L -s https://dl.k8s.io/release/stable.txt)</span>/bin/linux/amd64/kubectl&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.验证下载(可选)</span></span><br><span class=\"line\">$ curl -LO <span class=\"string\">&quot;https://dl.k8s.io/release/<span class=\"subst\">$(curl -L -s https://dl.k8s.io/release/stable.txt)</span>/bin/linux/amd64/kubectl.sha256&quot;</span></span><br><span class=\"line\">$ <span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"subst\">$(cat kubectl.sha256)</span>  kubectl&quot;</span> | <span class=\"built_in\">sha256sum</span> --check</span><br><span class=\"line\"><span class=\"comment\">## 验证通过输出</span></span><br><span class=\"line\">kubectl: 成功</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3.安装 kubectl</span></span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4.查看安装的版本</span></span><br><span class=\"line\">$ kubectl version --client</span><br><span class=\"line\">Client Version: v1.33.2</span><br><span class=\"line\">Kustomize Version: v5.6.0</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启用 shell 自动补全功能</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.安装 bash-completion</span></span><br><span class=\"line\"><span class=\"comment\"># 1.1 检查bash-completion是否已安装，有输出说明已经安装</span></span><br><span class=\"line\">$ <span class=\"built_in\">type</span> _init_completion</span><br><span class=\"line\"><span class=\"comment\"># 1.2 安装bash-completion，安装后会创建文件 /usr/share/bash-completion/bash_completion</span></span><br><span class=\"line\">$ dnf install bash-completion</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.安装 kubectl 的自动补全功能</span></span><br><span class=\"line\"><span class=\"comment\"># 2.1 当前用户</span></span><br><span class=\"line\">$ <span class=\"built_in\">echo</span> <span class=\"string\">&#x27;source &lt;(kubectl completion bash)&#x27;</span> &gt;&gt;~/.bashrc</span><br><span class=\"line\"><span class=\"comment\"># 2.2 所有用户</span></span><br><span class=\"line\">$ kubectl completion bash | <span class=\"built_in\">sudo</span> <span class=\"built_in\">tee</span> /etc/bash_completion.d/kubectl &gt; /dev/null</span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> <span class=\"built_in\">chmod</span> a+r /etc/bash_completion.d/kubectl</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3 如果 kubectl 有关联的别名，你可以扩展 Shell 补全来适配此别名</span></span><br><span class=\"line\">$ <span class=\"built_in\">echo</span> <span class=\"string\">&#x27;alias k=kubectl&#x27;</span> &gt;&gt;~/.bashrc</span><br><span class=\"line\">$ <span class=\"built_in\">echo</span> <span class=\"string\">&#x27;complete -o default -F __start_kubectl k&#x27;</span> &gt;&gt;~/.bashrc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4.刷新配置文件</span></span><br><span class=\"line\">$ <span class=\"built_in\">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用-minikube-创建-K8S-集群\">使用 minikube 创建 K8S 集群</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>该工具只适合在本机进行开发和测试时使用，其原理是在本机的docker环境中创建一个<code>minikube</code>容器作为<code>k8s</code>的节点机。</p>\n</li>\n</ul>\n<h3 id=\"安装-minikube\">安装 minikube</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://minikube.sigs.k8s.io/docs/start/?arch=%2Flinux%2Fx86-64%2Fstable%2Fbinary+download\">minikube安装说明</a></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.下载</span></span><br><span class=\"line\">$ curl -LO https://github.com/kubernetes/minikube/releases/latest/download/minikube-linux-amd64</span><br><span class=\"line\"><span class=\"comment\"># 2.安装</span></span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> install minikube-linux-amd64 /usr/local/bin/minikube &amp;&amp; <span class=\"built_in\">rm</span> minikube-linux-amd64</span><br><span class=\"line\"><span class=\"comment\"># 3.验证</span></span><br><span class=\"line\">$ minikube version</span><br><span class=\"line\"><span class=\"comment\"># 4.查看帮助</span></span><br><span class=\"line\">$ minikube --<span class=\"built_in\">help</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"创建集群\">创建集群</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建集群，注意不能使用 root 用户，要求该用户具有 docker 权限，并且具有sudo权限，否则会报错</span></span><br><span class=\"line\"><span class=\"comment\"># 系统内存至少 4G，以保证稳定性</span></span><br><span class=\"line\"><span class=\"comment\"># 默认使用docker驱动 --driver=docker，minikube 支持的驱动：https://minikube.sigs.k8s.io/docs/drivers/</span></span><br><span class=\"line\">$ minikube start</span><br><span class=\"line\">😄  Rocky 8.10 (amd64) 上的 minikube v1.36.0</span><br><span class=\"line\">✨  根据现有的配置文件使用 docker 驱动程序</span><br><span class=\"line\">👍  在集群中 <span class=\"string\">&quot;minikube&quot;</span> 启动节点 <span class=\"string\">&quot;minikube&quot;</span> primary control-plane</span><br><span class=\"line\">🚜  正在拉取基础镜像 v0.0.47 ...</span><br><span class=\"line\">    &gt; index.docker.io/kicbase/sta...:  502.26 MiB / 502.26 MiB  100.00% 27.50 M</span><br><span class=\"line\">❗  minikube was unable to download gcr.io/k8s-minikube/kicbase:v0.0.47, but successfully downloaded docker.io/kicbase/stable:v0.0.47@sha256:6ed579c9292b4370177b7ef3c42cc4b4a6dcd0735a1814916cbc22c8bf38412b as a fallback image</span><br><span class=\"line\">🔥  创建 docker container（CPU=2，内存=2200MB）...</span><br><span class=\"line\">🐳  正在 Docker 28.1.1 中准备 Kubernetes v1.33.1…</span><br><span class=\"line\">    ▪ 正在生成证书和密钥...</span><br><span class=\"line\">    ▪ 正在启动控制平面...</span><br><span class=\"line\">    ▪ 配置 RBAC 规则 ...</span><br><span class=\"line\">🔗  配置 bridge CNI (Container Networking Interface) ...</span><br><span class=\"line\">🔎  正在验证 Kubernetes 组件...</span><br><span class=\"line\">    ▪ 正在使用镜像 gcr.io/k8s-minikube/storage-provisioner:v5</span><br><span class=\"line\">🌟  启用插件： default-storageclass, storage-provisioner</span><br><span class=\"line\">🏄  完成！kubectl 现在已配置，默认使用<span class=\"string\">&quot;minikube&quot;</span>集群和<span class=\"string\">&quot;default&quot;</span>命名空间</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Minikube 允许你创建多个独立的 Kubernetes 集群，每个 profile 是一个单独的 minikube 实例，互不干扰。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -p 是 --profile 的缩写，表示 指定使用哪个 Minikube 集群（Profile）,默认 profile 名是 minikube</span></span><br><span class=\"line\">minikube start -p dev</span><br><span class=\"line\">minikube start -p <span class=\"built_in\">test</span></span><br><span class=\"line\">minikube start -p prod</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>获取集群状态</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl get nodes</span><br><span class=\"line\">NAME       STATUS   ROLES           AGE   VERSION</span><br><span class=\"line\">minikube   Ready    control-plane   27s   v1.33.1</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看本机容器，k8s 集群就在这个容器中</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker ps</span><br><span class=\"line\">CONTAINER ID   IMAGE                    COMMAND                   CREATED          STATUS          PORTS                                                                                                                                  NAMES</span><br><span class=\"line\">4e7eaad73934   kicbase/stable:v0.0.47   <span class=\"string\">&quot;/usr/local/bin/entr…&quot;</span>   47 minutes ago   Up 47 minutes   127.0.0.1:32772-&gt;22/tcp, 127.0.0.1:32771-&gt;2376/tcp, 127.0.0.1:32770-&gt;5000/tcp, 127.0.0.1:32769-&gt;8443/tcp, 127.0.0.1:32768-&gt;32443/tcp   minikube</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看该容器中的docker容器</span></span><br><span class=\"line\">$ docker <span class=\"built_in\">exec</span> -it minikube docker ps</span><br><span class=\"line\">CONTAINER ID   IMAGE                        COMMAND                  CREATED         STATUS         PORTS     NAMES</span><br><span class=\"line\">c25bcc3cb76c   1cf5f116067c                 <span class=\"string\">&quot;/coredns -conf /etc…&quot;</span>   2 minutes ago   Up 2 minutes             k8s_coredns_coredns-674b8bbfcf-8jrx4_kube-system_bc7a83c7-31e7-495c-820a-a29414099387_0</span><br><span class=\"line\">a22714ccfce2   b79c189b052c                 <span class=\"string\">&quot;/usr/local/bin/kube…&quot;</span>   2 minutes ago   Up 2 minutes             k8s_kube-proxy_kube-proxy-5dkt4_kube-system_8ad25d8e-b023-4383-9441-0ddbb5159c9b_0</span><br><span class=\"line\">a368d902aef9   registry.k8s.io/pause:3.10   <span class=\"string\">&quot;/pause&quot;</span>                 2 minutes ago   Up 2 minutes             k8s_POD_kube-proxy-5dkt4_kube-system_8ad25d8e-b023-4383-9441-0ddbb5159c9b_0</span><br><span class=\"line\">973caed86b2c   registry.k8s.io/pause:3.10   <span class=\"string\">&quot;/pause&quot;</span>                 2 minutes ago   Up 2 minutes             k8s_POD_coredns-674b8bbfcf-8jrx4_kube-system_bc7a83c7-31e7-495c-820a-a29414099387_0</span><br><span class=\"line\">9db7567143a2   6e38f40d628d                 <span class=\"string\">&quot;/storage-provisioner&quot;</span>   2 minutes ago   Up 2 minutes             k8s_storage-provisioner_storage-provisioner_kube-system_4e82402e-ba65-4061-920e-988a71cb529b_0</span><br><span class=\"line\">ba39fe88ad59   registry.k8s.io/pause:3.10   <span class=\"string\">&quot;/pause&quot;</span>                 2 minutes ago   Up 2 minutes             k8s_POD_storage-provisioner_kube-system_4e82402e-ba65-4061-920e-988a71cb529b_0</span><br><span class=\"line\">ef0733df95b4   ef43894fa110                 <span class=\"string\">&quot;kube-controller-man…&quot;</span>   2 minutes ago   Up 2 minutes             k8s_kube-controller-manager_kube-controller-manager-minikube_kube-system_0378f173c980f85a71d36305bacb0ad1_0</span><br><span class=\"line\">852828a600d5   c6ab243b29f8                 <span class=\"string\">&quot;kube-apiserver --ad…&quot;</span>   2 minutes ago   Up 2 minutes             k8s_kube-apiserver_kube-apiserver-minikube_kube-system_78e1292e1d47cc7d09b2c6f5826fa624_0</span><br><span class=\"line\">97efb54702cd   499038711c08                 <span class=\"string\">&quot;etcd --advertise-cl…&quot;</span>   2 minutes ago   Up 2 minutes             k8s_etcd_etcd-minikube_kube-system_3924ef3609584191d8d09190210d2d78_0</span><br><span class=\"line\">a3dd2c2817f1   398c985c0d95                 <span class=\"string\">&quot;kube-scheduler --au…&quot;</span>   2 minutes ago   Up 2 minutes             k8s_kube-scheduler_kube-scheduler-minikube_kube-system_feee622ba49882ef945e2406d3ba86df_0</span><br><span class=\"line\">927ebc63cf80   registry.k8s.io/pause:3.10   <span class=\"string\">&quot;/pause&quot;</span>                 2 minutes ago   Up 2 minutes             k8s_POD_kube-scheduler-minikube_kube-system_feee622ba49882ef945e2406d3ba86df_0</span><br><span class=\"line\">744d4c6e3571   registry.k8s.io/pause:3.10   <span class=\"string\">&quot;/pause&quot;</span>                 2 minutes ago   Up 2 minutes             k8s_POD_kube-controller-manager-minikube_kube-system_0378f173c980f85a71d36305bacb0ad1_0</span><br><span class=\"line\">4ae6bdc25908   registry.k8s.io/pause:3.10   <span class=\"string\">&quot;/pause&quot;</span>                 2 minutes ago   Up 2 minutes             k8s_POD_kube-apiserver-minikube_kube-system_78e1292e1d47cc7d09b2c6f5826fa624_0</span><br><span class=\"line\">dff641d8672a   registry.k8s.io/pause:3.10   <span class=\"string\">&quot;/pause&quot;</span>                 2 minutes ago   Up 2 minutes             k8s_POD_etcd-minikube_kube-system_3924ef3609584191d8d09190210d2d78_0</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-3\">\n<p>配置你的终端，让 Docker CLI 指向 minikube 内部的 Docker 守护进程（就是通过 docker 远程连接的方式）</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看docker远程的环境变量，我们可以将其配置到宿主机的环境变量中</span></span><br><span class=\"line\">$ minikube docker-env</span><br><span class=\"line\"><span class=\"built_in\">export</span> DOCKER_TLS_VERIFY=<span class=\"string\">&quot;1&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> DOCKER_HOST=<span class=\"string\">&quot;tcp://192.168.49.2:2376&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> DOCKER_CERT_PATH=<span class=\"string\">&quot;/home/centos/.minikube/certs&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> MINIKUBE_ACTIVE_DOCKERD=<span class=\"string\">&quot;minikube&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># To point your shell to minikube&#x27;s docker-daemon, run:</span></span><br><span class=\"line\"><span class=\"comment\"># eval $(minikube -p minikube docker-env)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 临时配置宿主机环境变量，此时我们再执行docker命令，就会使用minikube的docker-daemon</span></span><br><span class=\"line\">$ <span class=\"built_in\">eval</span> $(minikube -p minikube docker-env)</span><br><span class=\"line\"><span class=\"comment\"># 取消临时配置,-u 是 --unset 的缩写</span></span><br><span class=\"line\">$ <span class=\"built_in\">eval</span> $(minikube -p minikube docker-env -u)</span><br></pre></td></tr></table></figure>\n<h3 id=\"minikube-命令\">minikube 命令</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>登录到 minikube 环境（用于调试）</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 实际上就是进入minikube容器的shell</span></span><br><span class=\"line\">$ minikube ssh</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>运行 kubectl 命令</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看支持的命令</span></span><br><span class=\"line\">$ minikube kubectl -- --<span class=\"built_in\">help</span></span><br><span class=\"line\"><span class=\"comment\"># 运行 kubectl 命令，这里注意 minikube kubectl -- 前面有空格</span></span><br><span class=\"line\">$ minikube kubectl -- get pods --namespace kube-system</span><br><span class=\"line\">NAME                               READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">coredns-674b8bbfcf-8jrx4           1/1     Running   0          45m</span><br><span class=\"line\">etcd-minikube                      1/1     Running   0          45m</span><br><span class=\"line\">kube-apiserver-minikube            1/1     Running   0          45m</span><br><span class=\"line\">kube-controller-manager-minikube   1/1     Running   0          45m</span><br><span class=\"line\">kube-proxy-5dkt4                   1/1     Running   0          45m</span><br><span class=\"line\">kube-scheduler-minikube            1/1     Running   0          45m</span><br><span class=\"line\">storage-provisioner                1/1     Running   0          45m</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>node节点管理</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 添加一个worker节点，此时就是又启动了一个minikube容器</span></span><br><span class=\"line\">$ minikube node add</span><br><span class=\"line\">😄  将节点 m02 作为 [worker] 添加到集群 minikube</span><br><span class=\"line\">❗  在没有任何 CNI 的情况下创建集群，向其中添加节点可能会导致网络中断。</span><br><span class=\"line\">👍  在集群中 <span class=\"string\">&quot;minikube&quot;</span> 启动节点 <span class=\"string\">&quot;minikube-m02&quot;</span> worker</span><br><span class=\"line\">🚜  正在拉取基础镜像 v0.0.47 ...</span><br><span class=\"line\">🔥  创建 docker container（CPU=2，内存=2200MB）...</span><br><span class=\"line\">🐳  正在 Docker 28.1.1 中准备 Kubernetes v1.33.1…</span><br><span class=\"line\">🔎  正在验证 Kubernetes 组件...</span><br><span class=\"line\">🏄  已成功将 m02 添加到 minikube！</span><br><span class=\"line\"></span><br><span class=\"line\">$ docker ps</span><br><span class=\"line\">CONTAINER ID   IMAGE                    COMMAND                   CREATED             STATUS             PORTS                                                                                                                                  NAMES</span><br><span class=\"line\">ce5431e994c3   kicbase/stable:v0.0.47   <span class=\"string\">&quot;/usr/local/bin/entr…&quot;</span>   24 minutes ago      Up 24 minutes      127.0.0.1:32792-&gt;22/tcp, 127.0.0.1:32791-&gt;2376/tcp, 127.0.0.1:32790-&gt;5000/tcp, 127.0.0.1:32789-&gt;8443/tcp, 127.0.0.1:32788-&gt;32443/tcp   minikube-m02</span><br><span class=\"line\">2739aa21a085   kicbase/stable:v0.0.47   <span class=\"string\">&quot;/usr/local/bin/entr…&quot;</span>   About an hour ago   Up About an hour   127.0.0.1:32777-&gt;22/tcp, 127.0.0.1:32776-&gt;2376/tcp, 127.0.0.1:32775-&gt;5000/tcp, 127.0.0.1:32774-&gt;8443/tcp, 127.0.0.1:32773-&gt;32443/tcp   minikube</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看节点</span></span><br><span class=\"line\">$ kubectl get nodes</span><br><span class=\"line\">NAME           STATUS   ROLES           AGE   VERSION</span><br><span class=\"line\">minikube       Ready    control-plane   55m   v1.33.1</span><br><span class=\"line\">minikube-m02   Ready    &lt;none&gt;          70s   v1.33.1</span><br><span class=\"line\"></span><br><span class=\"line\">$ minikube node list</span><br><span class=\"line\">minikube        192.168.49.2</span><br><span class=\"line\">minikube-m02    192.168.49.3</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 停止节点</span></span><br><span class=\"line\">$ minikube node stop minikube-m02</span><br><span class=\"line\">✋  正在停止节点 <span class=\"string\">&quot;minikube-m02&quot;</span> ...</span><br><span class=\"line\">🛑  正在通过 SSH 关闭“minikube-m02”…</span><br><span class=\"line\">🛑  成功停止节点 minikube-m02</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动节点</span></span><br><span class=\"line\">$ minikube node start minikube-m02</span><br><span class=\"line\">👍  在集群中 <span class=\"string\">&quot;minikube&quot;</span> 启动节点 <span class=\"string\">&quot;minikube-m02&quot;</span> worker</span><br><span class=\"line\">🚜  正在拉取基础镜像 v0.0.47 ...</span><br><span class=\"line\">🔄  正在为<span class=\"string\">&quot;minikube-m02&quot;</span>重启现有的 docker container ...</span><br><span class=\"line\">🐳  正在 Docker 28.1.1 中准备 Kubernetes v1.33.1…</span><br><span class=\"line\">🔎  正在验证 Kubernetes 组件...</span><br><span class=\"line\">🌟  启用插件：</span><br><span class=\"line\">😄  成功启动节点 minikube-m02！</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除节点</span></span><br><span class=\"line\">$ minikube node delete minikube-m02</span><br><span class=\"line\">🔥  正在从集群 minikube 中删除节点 minikube-m02</span><br><span class=\"line\">✋  正在停止节点 <span class=\"string\">&quot;minikube-m02&quot;</span> ...</span><br><span class=\"line\">🛑  正在通过 SSH 关闭“minikube-m02”…</span><br><span class=\"line\">🔥  正在删除 docker 中的“minikube-m02”…</span><br><span class=\"line\">💀  节点 minikube-m02 已成功删除。</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>停止集群: 此时只是停止容器</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ minikube stop</span><br><span class=\"line\">✋  正在停止节点 <span class=\"string\">&quot;minikube&quot;</span> ...</span><br><span class=\"line\">🛑  正在通过 SSH 关闭“minikube”…</span><br><span class=\"line\">🛑  1 个节点已停止</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>删除集群: 删除容器及其配置</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ minikube delete</span><br><span class=\"line\">🔥  正在删除 docker 中的“minikube”…</span><br><span class=\"line\">🔥  正在删除容器 <span class=\"string\">&quot;minikube&quot;</span> ...</span><br><span class=\"line\">🔥  正在移除 /home/centos/.minikube/machines/minikube…</span><br><span class=\"line\">💀  已删除所有关于 <span class=\"string\">&quot;minikube&quot;</span> 集群的痕迹。</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>具体的使用方法参考<a href=\"https://kubernetes.io/zh-cn/docs/tutorials/hello-minikube/\">https://kubernetes.io/zh-cn/docs/tutorials/hello-minikube/</a></p>\n</li>\n</ul>\n","content_text":"摘要 本文介绍 Linux 下 使用 minikube 安装 K8S 的方法，本文以 CentOS 8 为例。 K8S官网 k8s Github minikube官网 安装前设置 修正系统的时间 12345678# 安装chronysudo dnf install chrony -y# 启动服务sudo systemctl enable --now chronyd# 修正时间sudo chronyc makestep# 查看时间date 安装 docker 安装方法参见 Linux 安装 Docker 创建用户 避免使用root用户，这里创建一个 centos 用户，要求该用户具有sudo权限，如果使用docker运行时，则需要将该用户添加到docker用户组 123456789# 1.创建用户$ sudo useradd -m -s /bin/bash centos# 2.添加到docker用户组$ sudo usermod -aG docker centos# 3.将用户添加到 sudo（管理员）组，说明：wheel 是 CentOS 中允许使用 sudo 权限的用户组。具体可以通过 visudo 命令查看$ sudo usermod -aG wheel centos## 这种添加方式使用sudo时需要输入密码，如果不希望输入密码，可以通过 visudo 命令修改，将 wheel 组改为 %wheel ALL=(ALL) NOPASSWD: ALL 的形式# 4.切换用户，以下操作均在该用户下进行$ su - centos 安装 kubectl 12345678910111213141516# 1.下载 kubectl$ curl -LO &quot;https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl&quot;# 2.验证下载(可选)$ curl -LO &quot;https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl.sha256&quot;$ echo &quot;$(cat kubectl.sha256) kubectl&quot; | sha256sum --check## 验证通过输出kubectl: 成功# 3.安装 kubectl$ sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl# 4.查看安装的版本$ kubectl version --clientClient Version: v1.33.2Kustomize Version: v5.6.0 启用 shell 自动补全功能 12345678910111213141516171819# 1.安装 bash-completion# 1.1 检查bash-completion是否已安装，有输出说明已经安装$ type _init_completion# 1.2 安装bash-completion，安装后会创建文件 /usr/share/bash-completion/bash_completion$ dnf install bash-completion# 2.安装 kubectl 的自动补全功能# 2.1 当前用户$ echo &#x27;source &lt;(kubectl completion bash)&#x27; &gt;&gt;~/.bashrc# 2.2 所有用户$ kubectl completion bash | sudo tee /etc/bash_completion.d/kubectl &gt; /dev/null$ sudo chmod a+r /etc/bash_completion.d/kubectl# 3 如果 kubectl 有关联的别名，你可以扩展 Shell 补全来适配此别名$ echo &#x27;alias k=kubectl&#x27; &gt;&gt;~/.bashrc$ echo &#x27;complete -o default -F __start_kubectl k&#x27; &gt;&gt;~/.bashrc# 4.刷新配置文件$ source ~/.bashrc 使用 minikube 创建 K8S 集群 该工具只适合在本机进行开发和测试时使用，其原理是在本机的docker环境中创建一个minikube容器作为k8s的节点机。 安装 minikube minikube安装说明 12345678# 1.下载$ curl -LO https://github.com/kubernetes/minikube/releases/latest/download/minikube-linux-amd64# 2.安装$ sudo install minikube-linux-amd64 /usr/local/bin/minikube &amp;&amp; rm minikube-linux-amd64# 3.验证$ minikube version# 4.查看帮助$ minikube --help 创建集群 1234567891011121314151617181920# 创建集群，注意不能使用 root 用户，要求该用户具有 docker 权限，并且具有sudo权限，否则会报错# 系统内存至少 4G，以保证稳定性# 默认使用docker驱动 --driver=docker，minikube 支持的驱动：https://minikube.sigs.k8s.io/docs/drivers/$ minikube start😄 Rocky 8.10 (amd64) 上的 minikube v1.36.0✨ 根据现有的配置文件使用 docker 驱动程序👍 在集群中 &quot;minikube&quot; 启动节点 &quot;minikube&quot; primary control-plane🚜 正在拉取基础镜像 v0.0.47 ... &gt; index.docker.io/kicbase/sta...: 502.26 MiB / 502.26 MiB 100.00% 27.50 M❗ minikube was unable to download gcr.io/k8s-minikube/kicbase:v0.0.47, but successfully downloaded docker.io/kicbase/stable:v0.0.47@sha256:6ed579c9292b4370177b7ef3c42cc4b4a6dcd0735a1814916cbc22c8bf38412b as a fallback image🔥 创建 docker container（CPU=2，内存=2200MB）...🐳 正在 Docker 28.1.1 中准备 Kubernetes v1.33.1… ▪ 正在生成证书和密钥... ▪ 正在启动控制平面... ▪ 配置 RBAC 规则 ...🔗 配置 bridge CNI (Container Networking Interface) ...🔎 正在验证 Kubernetes 组件... ▪ 正在使用镜像 gcr.io/k8s-minikube/storage-provisioner:v5🌟 启用插件： default-storageclass, storage-provisioner🏄 完成！kubectl 现在已配置，默认使用&quot;minikube&quot;集群和&quot;default&quot;命名空间 Minikube 允许你创建多个独立的 Kubernetes 集群，每个 profile 是一个单独的 minikube 实例，互不干扰。 1234# -p 是 --profile 的缩写，表示 指定使用哪个 Minikube 集群（Profile）,默认 profile 名是 minikubeminikube start -p devminikube start -p testminikube start -p prod 获取集群状态 123$ kubectl get nodesNAME STATUS ROLES AGE VERSIONminikube Ready control-plane 27s v1.33.1 查看本机容器，k8s 集群就在这个容器中 123456789101112131415161718192021$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES4e7eaad73934 kicbase/stable:v0.0.47 &quot;/usr/local/bin/entr…&quot; 47 minutes ago Up 47 minutes 127.0.0.1:32772-&gt;22/tcp, 127.0.0.1:32771-&gt;2376/tcp, 127.0.0.1:32770-&gt;5000/tcp, 127.0.0.1:32769-&gt;8443/tcp, 127.0.0.1:32768-&gt;32443/tcp minikube# 查看该容器中的docker容器$ docker exec -it minikube docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESc25bcc3cb76c 1cf5f116067c &quot;/coredns -conf /etc…&quot; 2 minutes ago Up 2 minutes k8s_coredns_coredns-674b8bbfcf-8jrx4_kube-system_bc7a83c7-31e7-495c-820a-a29414099387_0a22714ccfce2 b79c189b052c &quot;/usr/local/bin/kube…&quot; 2 minutes ago Up 2 minutes k8s_kube-proxy_kube-proxy-5dkt4_kube-system_8ad25d8e-b023-4383-9441-0ddbb5159c9b_0a368d902aef9 registry.k8s.io/pause:3.10 &quot;/pause&quot; 2 minutes ago Up 2 minutes k8s_POD_kube-proxy-5dkt4_kube-system_8ad25d8e-b023-4383-9441-0ddbb5159c9b_0973caed86b2c registry.k8s.io/pause:3.10 &quot;/pause&quot; 2 minutes ago Up 2 minutes k8s_POD_coredns-674b8bbfcf-8jrx4_kube-system_bc7a83c7-31e7-495c-820a-a29414099387_09db7567143a2 6e38f40d628d &quot;/storage-provisioner&quot; 2 minutes ago Up 2 minutes k8s_storage-provisioner_storage-provisioner_kube-system_4e82402e-ba65-4061-920e-988a71cb529b_0ba39fe88ad59 registry.k8s.io/pause:3.10 &quot;/pause&quot; 2 minutes ago Up 2 minutes k8s_POD_storage-provisioner_kube-system_4e82402e-ba65-4061-920e-988a71cb529b_0ef0733df95b4 ef43894fa110 &quot;kube-controller-man…&quot; 2 minutes ago Up 2 minutes k8s_kube-controller-manager_kube-controller-manager-minikube_kube-system_0378f173c980f85a71d36305bacb0ad1_0852828a600d5 c6ab243b29f8 &quot;kube-apiserver --ad…&quot; 2 minutes ago Up 2 minutes k8s_kube-apiserver_kube-apiserver-minikube_kube-system_78e1292e1d47cc7d09b2c6f5826fa624_097efb54702cd 499038711c08 &quot;etcd --advertise-cl…&quot; 2 minutes ago Up 2 minutes k8s_etcd_etcd-minikube_kube-system_3924ef3609584191d8d09190210d2d78_0a3dd2c2817f1 398c985c0d95 &quot;kube-scheduler --au…&quot; 2 minutes ago Up 2 minutes k8s_kube-scheduler_kube-scheduler-minikube_kube-system_feee622ba49882ef945e2406d3ba86df_0927ebc63cf80 registry.k8s.io/pause:3.10 &quot;/pause&quot; 2 minutes ago Up 2 minutes k8s_POD_kube-scheduler-minikube_kube-system_feee622ba49882ef945e2406d3ba86df_0744d4c6e3571 registry.k8s.io/pause:3.10 &quot;/pause&quot; 2 minutes ago Up 2 minutes k8s_POD_kube-controller-manager-minikube_kube-system_0378f173c980f85a71d36305bacb0ad1_04ae6bdc25908 registry.k8s.io/pause:3.10 &quot;/pause&quot; 2 minutes ago Up 2 minutes k8s_POD_kube-apiserver-minikube_kube-system_78e1292e1d47cc7d09b2c6f5826fa624_0dff641d8672a registry.k8s.io/pause:3.10 &quot;/pause&quot; 2 minutes ago Up 2 minutes k8s_POD_etcd-minikube_kube-system_3924ef3609584191d8d09190210d2d78_0 配置你的终端，让 Docker CLI 指向 minikube 内部的 Docker 守护进程（就是通过 docker 远程连接的方式） 1234567891011121314# 查看docker远程的环境变量，我们可以将其配置到宿主机的环境变量中$ minikube docker-envexport DOCKER_TLS_VERIFY=&quot;1&quot;export DOCKER_HOST=&quot;tcp://192.168.49.2:2376&quot;export DOCKER_CERT_PATH=&quot;/home/centos/.minikube/certs&quot;export MINIKUBE_ACTIVE_DOCKERD=&quot;minikube&quot;# To point your shell to minikube&#x27;s docker-daemon, run:# eval $(minikube -p minikube docker-env)# 临时配置宿主机环境变量，此时我们再执行docker命令，就会使用minikube的docker-daemon$ eval $(minikube -p minikube docker-env)# 取消临时配置,-u 是 --unset 的缩写$ eval $(minikube -p minikube docker-env -u) minikube 命令 登录到 minikube 环境（用于调试） 12# 实际上就是进入minikube容器的shell$ minikube ssh 运行 kubectl 命令 123456789101112# 查看支持的命令$ minikube kubectl -- --help# 运行 kubectl 命令，这里注意 minikube kubectl -- 前面有空格$ minikube kubectl -- get pods --namespace kube-systemNAME READY STATUS RESTARTS AGEcoredns-674b8bbfcf-8jrx4 1/1 Running 0 45metcd-minikube 1/1 Running 0 45mkube-apiserver-minikube 1/1 Running 0 45mkube-controller-manager-minikube 1/1 Running 0 45mkube-proxy-5dkt4 1/1 Running 0 45mkube-scheduler-minikube 1/1 Running 0 45mstorage-provisioner 1/1 Running 0 45m node节点管理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 添加一个worker节点，此时就是又启动了一个minikube容器$ minikube node add😄 将节点 m02 作为 [worker] 添加到集群 minikube❗ 在没有任何 CNI 的情况下创建集群，向其中添加节点可能会导致网络中断。👍 在集群中 &quot;minikube&quot; 启动节点 &quot;minikube-m02&quot; worker🚜 正在拉取基础镜像 v0.0.47 ...🔥 创建 docker container（CPU=2，内存=2200MB）...🐳 正在 Docker 28.1.1 中准备 Kubernetes v1.33.1…🔎 正在验证 Kubernetes 组件...🏄 已成功将 m02 添加到 minikube！$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESce5431e994c3 kicbase/stable:v0.0.47 &quot;/usr/local/bin/entr…&quot; 24 minutes ago Up 24 minutes 127.0.0.1:32792-&gt;22/tcp, 127.0.0.1:32791-&gt;2376/tcp, 127.0.0.1:32790-&gt;5000/tcp, 127.0.0.1:32789-&gt;8443/tcp, 127.0.0.1:32788-&gt;32443/tcp minikube-m022739aa21a085 kicbase/stable:v0.0.47 &quot;/usr/local/bin/entr…&quot; About an hour ago Up About an hour 127.0.0.1:32777-&gt;22/tcp, 127.0.0.1:32776-&gt;2376/tcp, 127.0.0.1:32775-&gt;5000/tcp, 127.0.0.1:32774-&gt;8443/tcp, 127.0.0.1:32773-&gt;32443/tcp minikube# 查看节点$ kubectl get nodesNAME STATUS ROLES AGE VERSIONminikube Ready control-plane 55m v1.33.1minikube-m02 Ready &lt;none&gt; 70s v1.33.1$ minikube node listminikube 192.168.49.2minikube-m02 192.168.49.3# 停止节点$ minikube node stop minikube-m02✋ 正在停止节点 &quot;minikube-m02&quot; ...🛑 正在通过 SSH 关闭“minikube-m02”…🛑 成功停止节点 minikube-m02# 启动节点$ minikube node start minikube-m02👍 在集群中 &quot;minikube&quot; 启动节点 &quot;minikube-m02&quot; worker🚜 正在拉取基础镜像 v0.0.47 ...🔄 正在为&quot;minikube-m02&quot;重启现有的 docker container ...🐳 正在 Docker 28.1.1 中准备 Kubernetes v1.33.1…🔎 正在验证 Kubernetes 组件...🌟 启用插件：😄 成功启动节点 minikube-m02！# 删除节点$ minikube node delete minikube-m02🔥 正在从集群 minikube 中删除节点 minikube-m02✋ 正在停止节点 &quot;minikube-m02&quot; ...🛑 正在通过 SSH 关闭“minikube-m02”…🔥 正在删除 docker 中的“minikube-m02”…💀 节点 minikube-m02 已成功删除。 停止集群: 此时只是停止容器 1234$ minikube stop✋ 正在停止节点 &quot;minikube&quot; ...🛑 正在通过 SSH 关闭“minikube”…🛑 1 个节点已停止 删除集群: 删除容器及其配置 12345$ minikube delete🔥 正在删除 docker 中的“minikube”…🔥 正在删除容器 &quot;minikube&quot; ...🔥 正在移除 /home/centos/.minikube/machines/minikube…💀 已删除所有关于 &quot;minikube&quot; 集群的痕迹。 具体的使用方法参考https://kubernetes.io/zh-cn/docs/tutorials/hello-minikube/","summary":"摘要 本文介绍 Linux 下 使用 minikube 安装 K8S 的方法，本文以 CentOS 8 为例。 K8S官网 k8s Github minikube官网","date_published":"2025-06-28T13:30:05.000Z","tags":["技术","k8s","K8S"]},{"id":"https://blog.hanqunfeng.com/2025/06/12/docker-swarm-config-secret/","url":"https://blog.hanqunfeng.com/2025/06/12/docker-swarm-config-secret/","title":"Docker Swarm 之 Config 与  Secret","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 Docker Swarm 中的 Config 与  Secret</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com\">Docker官方文档</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com/engine/swarm/\">Docker Swarm 官方文档</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com/reference/compose-file/\">Compose file reference</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Config-简介\">Config 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 Docker Swarm 中，Config 是一种用于管理配置资源的机制，允许你将配置文件与容器分离，便于在不同环境中重用和共享配置。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Config 和 Volume 都是 Docker 中用于管理数据的机制，但它们的设计目的和使用场景有显著不同：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Config</th>\n<th>Volume</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>用途</td>\n<td>只能是文件，用于存储配置文件、只读数据</td>\n<td>文件目录均可，存储应用数据、可读写数据</td>\n</tr>\n<tr>\n<td>可变性</td>\n<td>通常不可变（只读）</td>\n<td>可变（读写）</td>\n</tr>\n<tr>\n<td>生命周期</td>\n<td>随服务部署更新</td>\n<td>独立于容器生命周期</td>\n</tr>\n<tr>\n<td>存储位置</td>\n<td>存储在Docker管理的内存/文件系统</td>\n<td>存储在主机文件系统或网络存储</td>\n</tr>\n<tr>\n<td>Swarm支持</td>\n<td>原生Swarm功能</td>\n<td>通用功能</td>\n</tr>\n<tr>\n<td>更新机制</td>\n<td>更新需要重新部署服务</td>\n<td>可动态更新</td>\n</tr>\n<tr>\n<td>典型用例</td>\n<td>配置文件、环境变量</td>\n<td>数据库文件、日志、用户上传内容</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Config-命令\">Config 命令</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>中文说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>create</code></td>\n<td>从文件或标准输入创建一个 config</td>\n<td><code>docker config create my_config config.txt</code></td>\n</tr>\n<tr>\n<td><code>inspect</code></td>\n<td>显示一个或多个 config 的详细信息</td>\n<td><code>docker config inspect my_config</code></td>\n</tr>\n<tr>\n<td><code>ls</code></td>\n<td>列出所有 configs</td>\n<td><code>docker config ls</code></td>\n</tr>\n<tr>\n<td><code>rm</code></td>\n<td>删除一个或多个 config</td>\n<td><code>docker config rm my_config</code></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"docker-config-create-创建一个-config\"><code>docker config create</code>:  创建一个 config</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 从文件中创建</span></span><br><span class=\"line\">docker config create my_config my_config.json</span><br><span class=\"line\"><span class=\"comment\"># 从标准输入创建</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> my_config.json | docker config create my_config -</span><br></pre></td></tr></table></figure>\n<h4 id=\"docker-config-inspect-查看-config-的信息\"><code>docker config inspect</code>:  查看 config 的信息</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker config inspect my_config</span><br><span class=\"line\"><span class=\"comment\">## 输出，可以看到 Data 字段，用 base64 解码后，就是 config 的原始内容</span></span><br><span class=\"line\">[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;ID&quot;</span>: <span class=\"string\">&quot;q4257t5c2wq6uvvkm4g3hssae&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Version&quot;</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;Index&quot;</span>: 3145</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;CreatedAt&quot;</span>: <span class=\"string\">&quot;2025-06-10T06:09:25.712614071Z&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;UpdatedAt&quot;</span>: <span class=\"string\">&quot;2025-06-10T06:09:25.712614071Z&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Spec&quot;</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;Name&quot;</span>: <span class=\"string\">&quot;my_config&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;Labels&quot;</span>: &#123;&#125;,</span><br><span class=\"line\">            <span class=\"string\">&quot;Data&quot;</span>: <span class=\"string\">&quot;WwogICAgewogICAgICAgICJJRCI6ICJxbGtsc2t2eHRocDYxaTBuYnZ6dnI2d3V3IiwKICAgICAgICAiVmVyc2lvbiI6IHsKICAgICAgICAgICAgIkluZGV4IjogMzE0NAogICAgICAgIH0sCiAgICAgICAgIkNyZWF0ZWRBdCI6ICIyMDI1LTA2LTEwVDA2OjA3OjAzLjQwMzg4OTU2NVoiLAogICAgICAgICJVcGRhdGVkQXQiOiAiMjAyNS0wNi0xMFQwNjowNzowMy40MDM4ODk1NjVaIiwKICAgICAgICAiU3BlYyI6IHsKICAgICAgICAgICAgIk5hbWUiOiAibXlfc2VjcmV0IiwKICAgICAgICAgICAgIkxhYmVscyI6IHt9CiAgICAgICAgfQogICAgfQpdCg==&quot;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\"><span class=\"comment\"># 解码</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;WwogICAgewogICAgICAgICJJRCI6ICJxbGtsc2t2eHRocDYxaTBuYnZ6dnI2d3V3IiwKICAgICAgICAiVmVyc2lvbiI6IHsKICAgICAgICAgICAgIkluZGV4IjogMzE0NAogICAgICAgIH0sCiAgICAgICAgIkNyZWF0ZWRBdCI6ICIyMDI1LTA2LTEwVDA2OjA3OjAzLjQwMzg4OTU2NVoiLAogICAgICAgICJVcGRhdGVkQXQiOiAiMjAyNS0wNi0xMFQwNjowNzowMy40MDM4ODk1NjVaIiwKICAgICAgICAiU3BlYyI6IHsKICAgICAgICAgICAgIk5hbWUiOiAibXlfc2VjcmV0IiwKICAgICAgICAgICAgIkxhYmVscyI6IHt9CiAgICAgICAgfQogICAgfQpdCg==&quot;</span> | <span class=\"built_in\">base64</span> -d</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 更易读</span></span><br><span class=\"line\">docker config inspect --pretty my_config</span><br><span class=\"line\">docker config inspect --format <span class=\"string\">&quot;&#123;&#123;.ID&#125;&#125; &#123;&#123;.Spec.Name&#125;&#125;&quot;</span> my_config</span><br></pre></td></tr></table></figure>\n<h4 id=\"docker-config-ls-列出所有-config\"><code>docker config ls</code>:  列出所有 config</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker config <span class=\"built_in\">ls</span></span><br><span class=\"line\"><span class=\"comment\">#  只显示 ID</span></span><br><span class=\"line\">docker config <span class=\"built_in\">ls</span> -q</span><br></pre></td></tr></table></figure>\n<h4 id=\"docker-config-rm-删除一个或多个-config\"><code>docker config rm</code>:  删除一个或多个 config</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker config <span class=\"built_in\">rm</span> my_config</span><br><span class=\"line\"><span class=\"comment\"># 删除多个</span></span><br><span class=\"line\">docker config <span class=\"built_in\">rm</span> my_config1 my_config2</span><br><span class=\"line\"><span class=\"comment\"># 删除所有 ，慎重使用</span></span><br><span class=\"line\">docker config <span class=\"built_in\">rm</span> $(docker config <span class=\"built_in\">ls</span> -q)</span><br></pre></td></tr></table></figure>\n<h3 id=\"Stack中使用Config\">Stack中使用Config</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com/reference/compose-file/configs/\">Configs top-level elements</a></p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">configs:</span> <span class=\"comment\">#  声明 config 列表</span></span><br><span class=\"line\">  <span class=\"attr\">nginx_config:</span>  <span class=\"comment\">#  config 名称</span></span><br><span class=\"line\">    <span class=\"attr\">file:</span> <span class=\"string\">./nginx/nginx.conf</span> <span class=\"comment\">#  config 文件</span></span><br><span class=\"line\">  <span class=\"attr\">my_config:</span> <span class=\"comment\">#  使用外部 config，即 docker config create 创建的</span></span><br><span class=\"line\">    <span class=\"attr\">external:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">web:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">nginx:alpine</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;80:80&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">configs:</span> <span class=\"comment\"># 服务使用 config</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">source:</span> <span class=\"string\">nginx_config</span> <span class=\"comment\"># 指定 config 名称</span></span><br><span class=\"line\">        <span class=\"attr\">target:</span> <span class=\"string\">/etc/nginx/nginx.conf</span> <span class=\"comment\"># 指定容器中配置文件存放位置</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">source:</span> <span class=\"string\">my_config</span>  <span class=\"comment\">#  使用外部 config</span></span><br><span class=\"line\">        <span class=\"attr\">target:</span> <span class=\"string\">/app/config.json</span></span><br><span class=\"line\">        <span class=\"attr\">mode:</span> <span class=\"number\">0444</span> <span class=\"comment\">#  指定权限</span></span><br><span class=\"line\">        <span class=\"attr\">uid:</span> <span class=\"string\">&quot;1000&quot;</span> <span class=\"comment\"># 指定用户</span></span><br><span class=\"line\">        <span class=\"attr\">gid:</span> <span class=\"string\">&quot;1000&quot;</span> <span class=\"comment\"># 指定用户组</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Secret-简介\">Secret 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Secrets 是 Docker 专门为敏感数据设计的安全管理机制，用于安全地存储和传输密码、API密钥、TLS证书等敏感信息。</p>\n</li>\n<li class=\"lvl-2\">\n<p>与 Configs 的主要区别</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Secrets</th>\n<th>Configs</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>用途</td>\n<td>敏感数据（密码、密钥等）</td>\n<td>普通配置文件</td>\n</tr>\n<tr>\n<td>存储</td>\n<td>加密存储</td>\n<td>明文存储</td>\n</tr>\n<tr>\n<td>传输</td>\n<td>加密传输</td>\n<td>明文传输</td>\n</tr>\n<tr>\n<td>访问</td>\n<td>挂载为内存文件</td>\n<td>常规文件挂载</td>\n</tr>\n<tr>\n<td>权限</td>\n<td>默认仅 root 可读（0440）</td>\n<td>可自定义权限</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Secret-命令\">Secret 命令</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>中文说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>create</code></td>\n<td>从文件或标准输入创建一个 secret</td>\n<td><code>docker secret create my_secret secret.txt</code></td>\n</tr>\n<tr>\n<td><code>inspect</code></td>\n<td>显示一个或多个 secret 的详细信息</td>\n<td><code>docker secret inspect my_secret</code></td>\n</tr>\n<tr>\n<td><code>ls</code></td>\n<td>列出所有 secrets</td>\n<td><code>docker secret ls</code></td>\n</tr>\n<tr>\n<td><code>rm</code></td>\n<td>删除一个或多个 secret</td>\n<td><code>docker secret rm my_secret</code></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"docker-secret-create-创建一个-secret\"><code>docker secret create</code>:  创建一个 secret</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 从文件中创建</span></span><br><span class=\"line\">docker secret create my_secret my_secret.txt</span><br><span class=\"line\"><span class=\"comment\"># 从标准输入创建</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;my_secret&quot;</span> | docker secret create my_secret -</span><br></pre></td></tr></table></figure>\n<h4 id=\"docker-secret-inspect-查看-secret-的信息\"><code>docker secret inspect</code>:  查看 secret 的信息</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker secret inspect my_secret</span><br><span class=\"line\"><span class=\"comment\">## 输出，可以看到 没有 data 字段，所以无法查看原始的内容</span></span><br><span class=\"line\">[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;ID&quot;</span>: <span class=\"string\">&quot;qlklskvxthp61i0nbvzvr6wuw&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Version&quot;</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;Index&quot;</span>: 3144</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;CreatedAt&quot;</span>: <span class=\"string\">&quot;2025-06-10T06:07:03.403889565Z&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;UpdatedAt&quot;</span>: <span class=\"string\">&quot;2025-06-10T06:07:03.403889565Z&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Spec&quot;</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;Name&quot;</span>: <span class=\"string\">&quot;my_secret&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;Labels&quot;</span>: &#123;&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\"><span class=\"comment\"># 输出更易读</span></span><br><span class=\"line\">docker secret inspect --pretty my_secret</span><br><span class=\"line\">docker secret inspect --format <span class=\"string\">&quot;&#123;&#123;.ID&#125;&#125; &#123;&#123;.Spec.Name&#125;&#125;&quot;</span> my_secret</span><br></pre></td></tr></table></figure>\n<h4 id=\"docker-secret-ls-列出所有的-secret\"><code>docker secret ls</code>:  列出所有的 secret</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker secret <span class=\"built_in\">ls</span></span><br><span class=\"line\"><span class=\"comment\"># 列出所有的 secret 的 ID</span></span><br><span class=\"line\">docker secret <span class=\"built_in\">ls</span> -q</span><br><span class=\"line\">docker secret <span class=\"built_in\">ls</span> --filter name=my_secret</span><br></pre></td></tr></table></figure>\n<h4 id=\"docker-secret-rm-删除-secret\"><code>docker secret rm</code>:  删除 secret</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker secret <span class=\"built_in\">rm</span> my_secret</span><br><span class=\"line\"><span class=\"comment\"># 删除所有，慎重使用</span></span><br><span class=\"line\">docker secret <span class=\"built_in\">rm</span> $(docker secret <span class=\"built_in\">ls</span> -q)</span><br></pre></td></tr></table></figure>\n<h3 id=\"Stack中使用Secret\">Stack中使用Secret</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com/reference/compose-file/secrets/\">Secrets top-level elements</a></p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">mysql:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:8.0</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"attr\">MYSQL_ROOT_PASSWORD_FILE:</span> <span class=\"string\">/run/secrets/db_root_password</span></span><br><span class=\"line\">    <span class=\"attr\">secrets:</span> <span class=\"comment\"># 关联secret，容器内关联路径为 /run/secrets/&lt;secret_name&gt;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db_root_password</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">my_secret</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">secrets:</span> <span class=\"comment\"># 声明 secret 列表</span></span><br><span class=\"line\">  <span class=\"attr\">db_root_password:</span> <span class=\"comment\">#  secret 名称</span></span><br><span class=\"line\">    <span class=\"attr\">file:</span> <span class=\"string\">./mysql_root_password.txt</span> <span class=\"comment\">#  secret 文件</span></span><br><span class=\"line\">  <span class=\"attr\">my_secret:</span> <span class=\"comment\"># 生产环境建议使用预创建的secret</span></span><br><span class=\"line\">    <span class=\"attr\">external:</span> <span class=\"literal\">true</span>  <span class=\"comment\"># 引用预先创建的secret</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>优化: 使用非root用户，并隐藏 secret 文件</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">mysql:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:8.0</span></span><br><span class=\"line\">    <span class=\"attr\">user:</span> <span class=\"string\">&quot;mysql:mysql&quot;</span>  <span class=\"comment\"># 关键点1：使用非root用户</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"attr\">MYSQL_ROOT_PASSWORD_FILE:</span> <span class=\"string\">/run/secrets/.db_root_password</span>  <span class=\"comment\"># 关键点2：隐藏文件</span></span><br><span class=\"line\">    <span class=\"attr\">secrets:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">source:</span> <span class=\"string\">db_root_password</span></span><br><span class=\"line\">        <span class=\"attr\">target:</span> <span class=\"string\">.db_root_password</span>  <span class=\"comment\"># 隐藏文件名</span></span><br><span class=\"line\">        <span class=\"attr\">uid:</span> <span class=\"string\">&quot;999&quot;</span>  <span class=\"comment\"># mysql用户ID</span></span><br><span class=\"line\">        <span class=\"attr\">gid:</span> <span class=\"string\">&quot;999&quot;</span>  <span class=\"comment\"># mysql组ID</span></span><br><span class=\"line\">        <span class=\"attr\">mode:</span> <span class=\"number\">0400</span>  <span class=\"comment\"># 仅拥有者可读</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">source:</span> <span class=\"string\">my_secret</span></span><br><span class=\"line\">        <span class=\"attr\">target:</span> <span class=\"string\">.my_secret</span></span><br><span class=\"line\">        <span class=\"attr\">uid:</span> <span class=\"string\">&quot;999&quot;</span></span><br><span class=\"line\">        <span class=\"attr\">gid:</span> <span class=\"string\">&quot;999&quot;</span></span><br><span class=\"line\">        <span class=\"attr\">mode:</span> <span class=\"number\">0400</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">secrets:</span></span><br><span class=\"line\">  <span class=\"attr\">db_root_password:</span></span><br><span class=\"line\">    <span class=\"attr\">file:</span> <span class=\"string\">./mysql_root_password.txt</span></span><br><span class=\"line\">  <span class=\"attr\">my_secret:</span></span><br><span class=\"line\">    <span class=\"attr\">external:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍 Docker Swarm 中的 Config 与 Secret Docker官方文档 Docker Swarm 官方文档 Compose file reference Config 简介 在 Docker Swarm 中，Config 是一种用于管理配置资源的机制，允许你将配置文件与容器分离，便于在不同环境中重用和共享配置。 Config 和 Volume 都是 Docker 中用于管理数据的机制，但它们的设计目的和使用场景有显著不同： 特性 Config Volume 用途 只能是文件，用于存储配置文件、只读数据 文件目录均可，存储应用数据、可读写数据 可变性 通常不可变（只读） 可变（读写） 生命周期 随服务部署更新 独立于容器生命周期 存储位置 存储在Docker管理的内存/文件系统 存储在主机文件系统或网络存储 Swarm支持 原生Swarm功能 通用功能 更新机制 更新需要重新部署服务 可动态更新 典型用例 配置文件、环境变量 数据库文件、日志、用户上传内容 Config 命令 命令 中文说明 示例 create 从文件或标准输入创建一个 config docker config create my_config config.txt inspect 显示一个或多个 config 的详细信息 docker config inspect my_config ls 列出所有 configs docker config ls rm 删除一个或多个 config docker config rm my_config docker config create: 创建一个 config 1234# 从文件中创建docker config create my_config my_config.json# 从标准输入创建cat my_config.json | docker config create my_config - docker config inspect: 查看 config 的信息 123456789101112131415161718192021222324docker config inspect my_config## 输出，可以看到 Data 字段，用 base64 解码后，就是 config 的原始内容[ &#123; &quot;ID&quot;: &quot;q4257t5c2wq6uvvkm4g3hssae&quot;, &quot;Version&quot;: &#123; &quot;Index&quot;: 3145 &#125;, &quot;CreatedAt&quot;: &quot;2025-06-10T06:09:25.712614071Z&quot;, &quot;UpdatedAt&quot;: &quot;2025-06-10T06:09:25.712614071Z&quot;, &quot;Spec&quot;: &#123; &quot;Name&quot;: &quot;my_config&quot;, &quot;Labels&quot;: &#123;&#125;, &quot;Data&quot;: &quot;WwogICAgewogICAgICAgICJJRCI6ICJxbGtsc2t2eHRocDYxaTBuYnZ6dnI2d3V3IiwKICAgICAgICAiVmVyc2lvbiI6IHsKICAgICAgICAgICAgIkluZGV4IjogMzE0NAogICAgICAgIH0sCiAgICAgICAgIkNyZWF0ZWRBdCI6ICIyMDI1LTA2LTEwVDA2OjA3OjAzLjQwMzg4OTU2NVoiLAogICAgICAgICJVcGRhdGVkQXQiOiAiMjAyNS0wNi0xMFQwNjowNzowMy40MDM4ODk1NjVaIiwKICAgICAgICAiU3BlYyI6IHsKICAgICAgICAgICAgIk5hbWUiOiAibXlfc2VjcmV0IiwKICAgICAgICAgICAgIkxhYmVscyI6IHt9CiAgICAgICAgfQogICAgfQpdCg==&quot; &#125; &#125;]# 解码echo &quot;WwogICAgewogICAgICAgICJJRCI6ICJxbGtsc2t2eHRocDYxaTBuYnZ6dnI2d3V3IiwKICAgICAgICAiVmVyc2lvbiI6IHsKICAgICAgICAgICAgIkluZGV4IjogMzE0NAogICAgICAgIH0sCiAgICAgICAgIkNyZWF0ZWRBdCI6ICIyMDI1LTA2LTEwVDA2OjA3OjAzLjQwMzg4OTU2NVoiLAogICAgICAgICJVcGRhdGVkQXQiOiAiMjAyNS0wNi0xMFQwNjowNzowMy40MDM4ODk1NjVaIiwKICAgICAgICAiU3BlYyI6IHsKICAgICAgICAgICAgIk5hbWUiOiAibXlfc2VjcmV0IiwKICAgICAgICAgICAgIkxhYmVscyI6IHt9CiAgICAgICAgfQogICAgfQpdCg==&quot; | base64 -d# 更易读docker config inspect --pretty my_configdocker config inspect --format &quot;&#123;&#123;.ID&#125;&#125; &#123;&#123;.Spec.Name&#125;&#125;&quot; my_config docker config ls: 列出所有 config 123docker config ls# 只显示 IDdocker config ls -q docker config rm: 删除一个或多个 config 12345docker config rm my_config# 删除多个docker config rm my_config1 my_config2# 删除所有 ，慎重使用docker config rm $(docker config ls -q) Stack中使用Config Configs top-level elements 12345678910111213141516171819configs: # 声明 config 列表 nginx_config: # config 名称 file: ./nginx/nginx.conf # config 文件 my_config: # 使用外部 config，即 docker config create 创建的 external: trueservices: web: image: nginx:alpine ports: - &quot;80:80&quot; configs: # 服务使用 config - source: nginx_config # 指定 config 名称 target: /etc/nginx/nginx.conf # 指定容器中配置文件存放位置 - source: my_config # 使用外部 config target: /app/config.json mode: 0444 # 指定权限 uid: &quot;1000&quot; # 指定用户 gid: &quot;1000&quot; # 指定用户组 Secret 简介 Secrets 是 Docker 专门为敏感数据设计的安全管理机制，用于安全地存储和传输密码、API密钥、TLS证书等敏感信息。 与 Configs 的主要区别 特性 Secrets Configs 用途 敏感数据（密码、密钥等） 普通配置文件 存储 加密存储 明文存储 传输 加密传输 明文传输 访问 挂载为内存文件 常规文件挂载 权限 默认仅 root 可读（0440） 可自定义权限 Secret 命令 命令 中文说明 示例 create 从文件或标准输入创建一个 secret docker secret create my_secret secret.txt inspect 显示一个或多个 secret 的详细信息 docker secret inspect my_secret ls 列出所有 secrets docker secret ls rm 删除一个或多个 secret docker secret rm my_secret docker secret create: 创建一个 secret 1234# 从文件中创建docker secret create my_secret my_secret.txt# 从标准输入创建echo &quot;my_secret&quot; | docker secret create my_secret - docker secret inspect: 查看 secret 的信息 12345678910111213141516171819docker secret inspect my_secret## 输出，可以看到 没有 data 字段，所以无法查看原始的内容[ &#123; &quot;ID&quot;: &quot;qlklskvxthp61i0nbvzvr6wuw&quot;, &quot;Version&quot;: &#123; &quot;Index&quot;: 3144 &#125;, &quot;CreatedAt&quot;: &quot;2025-06-10T06:07:03.403889565Z&quot;, &quot;UpdatedAt&quot;: &quot;2025-06-10T06:07:03.403889565Z&quot;, &quot;Spec&quot;: &#123; &quot;Name&quot;: &quot;my_secret&quot;, &quot;Labels&quot;: &#123;&#125; &#125; &#125;]# 输出更易读docker secret inspect --pretty my_secretdocker secret inspect --format &quot;&#123;&#123;.ID&#125;&#125; &#123;&#123;.Spec.Name&#125;&#125;&quot; my_secret docker secret ls: 列出所有的 secret 1234docker secret ls# 列出所有的 secret 的 IDdocker secret ls -qdocker secret ls --filter name=my_secret docker secret rm: 删除 secret 123docker secret rm my_secret# 删除所有，慎重使用docker secret rm $(docker secret ls -q) Stack中使用Secret Secrets top-level elements 1234567891011121314services: mysql: image: mysql:8.0 environment: MYSQL_ROOT_PASSWORD_FILE: /run/secrets/db_root_password secrets: # 关联secret，容器内关联路径为 /run/secrets/&lt;secret_name&gt; - db_root_password - my_secretsecrets: # 声明 secret 列表 db_root_password: # secret 名称 file: ./mysql_root_password.txt # secret 文件 my_secret: # 生产环境建议使用预创建的secret external: true # 引用预先创建的secret 优化: 使用非root用户，并隐藏 secret 文件 123456789101112131415161718192021222324services: mysql: image: mysql:8.0 user: &quot;mysql:mysql&quot; # 关键点1：使用非root用户 environment: MYSQL_ROOT_PASSWORD_FILE: /run/secrets/.db_root_password # 关键点2：隐藏文件 secrets: - source: db_root_password target: .db_root_password # 隐藏文件名 uid: &quot;999&quot; # mysql用户ID gid: &quot;999&quot; # mysql组ID mode: 0400 # 仅拥有者可读 - source: my_secret target: .my_secret uid: &quot;999&quot; gid: &quot;999&quot; mode: 0400secrets: db_root_password: file: ./mysql_root_password.txt my_secret: external: true","summary":"摘要 本文介绍 Docker Swarm 中的 Config 与 Secret Docker官方文档 Docker Swarm 官方文档 Compose file reference","date_published":"2025-06-12T14:30:05.000Z","tags":["技术","docker","docker"]},{"id":"https://blog.hanqunfeng.com/2025/06/11/docker-swarm-stack/","url":"https://blog.hanqunfeng.com/2025/06/11/docker-swarm-stack/","title":"Docker Swarm 之 栈(Stack)","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 Docker Swarm 的 栈管理</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com\">Docker官方文档</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com/engine/swarm/\">Docker Swarm 官方文档</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com/reference/compose-file/\">Compose file reference</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Stack简介\">Stack简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>前面我们在Swarm中创建服务都是通过Service，每次创建一个，有没有类似<code>docker compose</code>的方式来创建多个服务呢？Docker Swarm为我们提供了Stack</p>\n</li>\n<li class=\"lvl-2\">\n<p>在 Docker Swarm 中，Stack（栈） 是用来定义和部署一组相关服务的集合。你可以把它看成是一个应用的整体，由多个服务（service）、网络（network）、卷（volume）等组成。</p>\n</li>\n</ul>\n<h2 id=\"Stack-通常用-Docker-Compose-文件（YAML-格式）-描述\">Stack 通常用 Docker Compose 文件（YAML 格式） 描述</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Stack 完全兼容 Docker Compose 文件，并可以在 compose 文件中声明副本集等与Service相关的配置项。</p>\n</li>\n<li class=\"lvl-2\">\n<p>我用表格总结一下二者的差异，重点放在「Stack 支持的配置」上：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>配置项</th>\n<th>Docker Compose (本地)</th>\n<th>Docker Stack (Swarm 集群)</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>name</code></td>\n<td>✅</td>\n<td>❌</td>\n<td>Stack 不支持 name  属性</td>\n</tr>\n<tr>\n<td><code>build</code></td>\n<td>✅</td>\n<td>❌</td>\n<td>Stack 不支持 build 属性，只能使用image</td>\n</tr>\n<tr>\n<td><code>deploy</code></td>\n<td>❌（部分支持，通常被忽略）</td>\n<td>✅（核心支持）</td>\n<td>Stack 支持用 <code>deploy</code> 定义副本数、资源限制、更新策略等</td>\n</tr>\n<tr>\n<td><code>deploy.replicas</code></td>\n<td>❌</td>\n<td>✅</td>\n<td>定义服务副本数</td>\n</tr>\n<tr>\n<td><code>deploy.resources</code></td>\n<td>❌</td>\n<td>✅</td>\n<td>定义 CPU、内存限制</td>\n</tr>\n<tr>\n<td><code>deploy.placement</code></td>\n<td>❌</td>\n<td>✅</td>\n<td>定义服务调度策略（在哪些节点上运行）</td>\n</tr>\n<tr>\n<td><code>deploy.update_config</code></td>\n<td>❌</td>\n<td>✅</td>\n<td>定义滚动更新的参数</td>\n</tr>\n<tr>\n<td><code>deploy.restart_policy</code></td>\n<td>❌</td>\n<td>✅</td>\n<td>定义重启策略</td>\n</tr>\n<tr>\n<td><code>deploy.mode</code></td>\n<td>❌</td>\n<td>✅</td>\n<td><code>replicated</code> 或 <code>global</code></td>\n</tr>\n<tr>\n<td><code>depends_on</code></td>\n<td>✅</td>\n<td>🚫（被忽略）</td>\n<td>Stack 不支持容器启动顺序控制</td>\n</tr>\n<tr>\n<td><code>build</code></td>\n<td>✅</td>\n<td>🚫（被忽略）</td>\n<td>Stack 不支持直接构建镜像，只能用已存在的镜像</td>\n</tr>\n<tr>\n<td><code>network.external</code></td>\n<td>✅</td>\n<td>✅</td>\n<td>都支持外部网络</td>\n</tr>\n<tr>\n<td><code>volumes.external</code></td>\n<td>✅</td>\n<td>✅</td>\n<td>都支持外部卷</td>\n</tr>\n<tr>\n<td><code>configs</code></td>\n<td>🚫</td>\n<td>✅</td>\n<td>Stack 支持 Config 对象，适合配置文件管理</td>\n</tr>\n<tr>\n<td><code>secrets</code></td>\n<td>🚫</td>\n<td>✅</td>\n<td>Stack 支持 Secrets，用于安全存储敏感信息</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>以<a href=\"https://docs.portainer.io/\">Portainer:Docker可视化管理工具</a>的stack配置文件为例</p>\n</li>\n</ul>\n<blockquote>\n<p>Portainer 社区版 （CE）可让您在 Docker、Docker Swarm、Kubernetes 和 Azure ACI 中轻松构建和管理容器。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -L https://downloads.portainer.io/ce-lts/portainer-agent-stack.yml -o portainer-agent-stack.yml</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&quot;3.2&quot;</span> <span class=\"comment\">#  docker-compose版本，新版的docker已经不需要配置版本号了</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">agent:</span>  <span class=\"comment\"># agent服务</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">portainer/agent:lts</span> <span class=\"comment\"># 镜像，不能使用 Dockerfile</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span>  <span class=\"comment\"># 挂载卷</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">/var/run/docker.sock:/var/run/docker.sock</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">/var/lib/docker/volumes:/var/lib/docker/volumes</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span> <span class=\"comment\"># 挂载网络，必须是 overlay</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">agent_network</span></span><br><span class=\"line\">    <span class=\"attr\">deploy:</span>   <span class=\"comment\"># 部署策略，service 特有属性</span></span><br><span class=\"line\">      <span class=\"attr\">mode:</span> <span class=\"string\">global</span> <span class=\"comment\"># 全局模式</span></span><br><span class=\"line\">      <span class=\"attr\">placement:</span> <span class=\"comment\"># 部署条件</span></span><br><span class=\"line\">        <span class=\"attr\">constraints:</span> [<span class=\"string\">node.platform.os</span> <span class=\"string\">==</span> <span class=\"string\">linux</span>] <span class=\"comment\">#  运行在linux节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">portainer:</span> <span class=\"comment\">#  portainer服务</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">portainer/portainer-ce:lts</span> <span class=\"comment\">#  镜像</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> <span class=\"string\">-H</span> <span class=\"string\">tcp://tasks.agent:9001</span> <span class=\"string\">--tlsskipverify</span> <span class=\"comment\">#  启动参数</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span> <span class=\"comment\"># 端口映射</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;9443:9443&quot;</span>  <span class=\"comment\"># 浏览器访问 https://localhost:9443</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;9000:9000&quot;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;8000:8000&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span> <span class=\"comment\">#  挂载卷</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">portainer_data:/data</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span> <span class=\"comment\"># 挂载网络，与agent服务网络一致</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">agent_network</span></span><br><span class=\"line\">    <span class=\"attr\">deploy:</span> <span class=\"comment\">#  部署配置</span></span><br><span class=\"line\">      <span class=\"attr\">mode:</span> <span class=\"string\">replicated</span> <span class=\"comment\"># 副本模式</span></span><br><span class=\"line\">      <span class=\"attr\">replicas:</span> <span class=\"number\">1</span> <span class=\"comment\">#  副本数量</span></span><br><span class=\"line\">      <span class=\"attr\">placement:</span> <span class=\"comment\">#  部署条件</span></span><br><span class=\"line\">        <span class=\"attr\">constraints:</span> [<span class=\"string\">node.role</span> <span class=\"string\">==</span> <span class=\"string\">manager</span>] <span class=\"comment\">#  节点角色为manager</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">networks:</span> <span class=\"comment\">#  网络声明</span></span><br><span class=\"line\">  <span class=\"attr\">agent_network:</span> <span class=\"comment\">#  网络名称</span></span><br><span class=\"line\">    <span class=\"attr\">driver:</span> <span class=\"string\">overlay</span> <span class=\"comment\">#  网络驱动</span></span><br><span class=\"line\">    <span class=\"attr\">attachable:</span> <span class=\"literal\">true</span> <span class=\"comment\"># 允许容器加入</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">volumes:</span> <span class=\"comment\">#  挂载卷声明</span></span><br><span class=\"line\">  <span class=\"attr\">portainer_data:</span> <span class=\"comment\">#  挂载卷名称</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Stack-命令\">Stack 命令</h2>\n<table>\n<thead>\n<tr>\n<th>子命令</th>\n<th>中文说明</th>\n<th>示例命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>config</code></td>\n<td>输出最终的配置文件（经过合并与变量替换后）</td>\n<td><code>docker stack config -c docker-compose.yml</code></td>\n</tr>\n<tr>\n<td><code>deploy</code></td>\n<td>部署新 stack 或更新已有 stack</td>\n<td><code>docker stack deploy -c docker-compose.yml mystack</code></td>\n</tr>\n<tr>\n<td><code>ls</code></td>\n<td>列出所有已部署的 stack</td>\n<td><code>docker stack ls</code></td>\n</tr>\n<tr>\n<td><code>ps</code></td>\n<td>查看 stack 中的所有任务（即各个容器实例）</td>\n<td><code>docker stack ps mystack</code></td>\n</tr>\n<tr>\n<td><code>rm</code></td>\n<td>删除一个或多个 stack</td>\n<td><code>docker stack rm mystack</code></td>\n</tr>\n<tr>\n<td><code>services</code></td>\n<td>列出某个 stack 中的所有服务</td>\n<td><code>docker stack services mystack</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"docker-stack-config-输出最终的配置文件\"><code>docker stack config</code>: 输出最终的配置文件</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 此命令也可以用来验证compose文件格式是否正确，只保证格式正确，不保证逻辑正确</span></span><br><span class=\"line\">docker stack config -c portainer-agent-stack.yml</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-stack-deploy-部署-stack\"><code>docker stack deploy</code>: 部署 stack</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-3\">\n<p><code>docker stack deploy</code> == <code>docker stack up</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker stack deploy -c portainer-agent-stack.yml portainer</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">Creating network portainer_agent_network</span><br><span class=\"line\">Creating service portainer_agent</span><br><span class=\"line\">Creating service portainer_portainer</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-stack-ls-列出所有-stack\"><code>docker stack ls</code>: 列出所有 stack</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker stack ls</code> == <code>docker stack list</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker stack <span class=\"built_in\">ls</span></span><br><span class=\"line\"><span class=\"comment\">## 输出，stack名称为portainer，其内部有两个服务，agent和portainer</span></span><br><span class=\"line\">NAME        SERVICES</span><br><span class=\"line\">portainer   2</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-stack-services-查看服务\"><code>docker stack services</code>:  查看服务</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker stack services portainer</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">ID             NAME                  MODE         REPLICAS   IMAGE                        PORTS</span><br><span class=\"line\">h5foyujr6jq9   portainer_agent       global       5/5        portainer/agent:lts</span><br><span class=\"line\">zcek2jtloe09   portainer_portainer   replicated   1/1        portainer/portainer-ce:lts   *:8000-&gt;8000/tcp, *:9000-&gt;9000/tcp, *:9443-&gt;9443/tcp</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 等效</span></span><br><span class=\"line\">docker service <span class=\"built_in\">ls</span></span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">ID             NAME                  MODE         REPLICAS   IMAGE                        PORTS</span><br><span class=\"line\">h5foyujr6jq9   portainer_agent       global       5/5        portainer/agent:lts</span><br><span class=\"line\">zcek2jtloe09   portainer_portainer   replicated   1/1        portainer/portainer-ce:lts   *:8000-&gt;8000/tcp, *:9000-&gt;9000/tcp, *:9443-&gt;9443/tcp</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-stack-ps-列出-stack-下的所有服务实例\"><code>docker stack ps</code>: 列出 stack 下的所有服务实例</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker stack ps portainer</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">ID             NAME                                        IMAGE                        NODE       DESIRED STATE   CURRENT STATE            ERROR     PORTS</span><br><span class=\"line\">wshk9s6gyxh1   portainer_agent.hvzkh3ip5ef8gx973z1ywahbu   portainer/agent:lts          worker2    Running         Running 30 seconds ago</span><br><span class=\"line\">n3jjzmr2fcv9   portainer_agent.kp2zerd28xgz5mmglnje0jp22   portainer/agent:lts          manager1   Running         Running 59 seconds ago</span><br><span class=\"line\">24yy1ew3tiya   portainer_agent.oymi74epagdqeprah7s81tsa2   portainer/agent:lts          manager2   Running         Running 3 minutes ago</span><br><span class=\"line\">kpo4hhdvwcwd   portainer_agent.r7388xl84nczjtnf53pwh7hla   portainer/agent:lts          manager3   Running         Running 35 seconds ago</span><br><span class=\"line\">t8xjbotfuas0   portainer_agent.xkww4853bbdgv7bv8771xibob   portainer/agent:lts          worker1    Running         Running 48 seconds ago</span><br><span class=\"line\">qox3kqypon69   portainer_portainer.1                       portainer/portainer-ce:lts   manager2   Running         Running 2 minutes ago</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 等效</span></span><br><span class=\"line\">docker service ps portainer_agent portainer_portainer</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">ID             NAME                                        IMAGE                        NODE       DESIRED STATE   CURRENT STATE            ERROR     PORTS</span><br><span class=\"line\">wshk9s6gyxh1   portainer_agent.hvzkh3ip5ef8gx973z1ywahbu   portainer/agent:lts          worker2    Running         Running 7 minutes ago</span><br><span class=\"line\">n3jjzmr2fcv9   portainer_agent.kp2zerd28xgz5mmglnje0jp22   portainer/agent:lts          manager1   Running         Running 8 minutes ago</span><br><span class=\"line\">24yy1ew3tiya   portainer_agent.oymi74epagdqeprah7s81tsa2   portainer/agent:lts          manager2   Running         Running 10 minutes ago</span><br><span class=\"line\">kpo4hhdvwcwd   portainer_agent.r7388xl84nczjtnf53pwh7hla   portainer/agent:lts          manager3   Running         Running 7 minutes ago</span><br><span class=\"line\">t8xjbotfuas0   portainer_agent.xkww4853bbdgv7bv8771xibob   portainer/agent:lts          worker1    Running         Running 7 minutes ago</span><br><span class=\"line\">qox3kqypon69   portainer_portainer.1                       portainer/portainer-ce:lts   manager2   Running         Running 10 minutes ago</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-stack-rm-停止并删除-stack\"><code>docker stack rm</code>: 停止并删除 stack</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker stack rm</code> == <code>docker stack remove</code> == <code>docker stack down</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker stack <span class=\"built_in\">rm</span> portainer</span><br></pre></td></tr></table></figure>\n<h2 id=\"deploy-参数详解\"><code>deploy</code> 参数详解</h2>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">my-service:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">myapp:latest</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">deploy:</span></span><br><span class=\"line\">      <span class=\"attr\">replicas:</span> <span class=\"number\">3</span>  <span class=\"comment\"># 指定副本数，仅在 mode: replicated 下有效。表示同时运行3个容器副本。</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"attr\">mode:</span> <span class=\"string\">replicated</span>  <span class=\"comment\"># 服务运行模式，可选值：</span></span><br><span class=\"line\">                        <span class=\"comment\"># - replicated：通过 replicas 指定副本数量（默认）</span></span><br><span class=\"line\">                        <span class=\"comment\"># - global：每个节点运行一个副本，忽略 replicas 配置</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"attr\">resources:</span></span><br><span class=\"line\">        <span class=\"attr\">limits:</span>         <span class=\"comment\"># 容器的“硬限制”，超过会被强制限制</span></span><br><span class=\"line\">          <span class=\"attr\">cpus:</span> <span class=\"string\">&#x27;1.0&#x27;</span>    <span class=\"comment\"># 限制每个容器最多使用1个逻辑 CPU</span></span><br><span class=\"line\">          <span class=\"attr\">memory:</span> <span class=\"string\">512M</span>   <span class=\"comment\"># 限制每个容器最多使用512MB内存</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"attr\">reservations:</span>   <span class=\"comment\"># 容器的“软限制”，Swarm调度时预留资源参考值（不会强制限制）</span></span><br><span class=\"line\">          <span class=\"attr\">cpus:</span> <span class=\"string\">&#x27;0.25&#x27;</span>   <span class=\"comment\"># 建议每个容器至少分配0.25个CPU</span></span><br><span class=\"line\">          <span class=\"attr\">memory:</span> <span class=\"string\">128M</span>   <span class=\"comment\"># 建议每个容器至少分配128MB内存</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"attr\">restart_policy:</span></span><br><span class=\"line\">        <span class=\"attr\">condition:</span> <span class=\"string\">on-failure</span>  <span class=\"comment\"># 控制容器重启行为，可选值：</span></span><br><span class=\"line\">                               <span class=\"comment\"># - none：不重启</span></span><br><span class=\"line\">                               <span class=\"comment\"># - on-failure：失败时重启（非0退出码）</span></span><br><span class=\"line\">                               <span class=\"comment\"># - any：无论是否失败都重启</span></span><br><span class=\"line\">        <span class=\"attr\">delay:</span> <span class=\"string\">5s</span>              <span class=\"comment\"># 重启前等待时间</span></span><br><span class=\"line\">        <span class=\"attr\">max_attempts:</span> <span class=\"number\">3</span>        <span class=\"comment\"># 最多重启3次</span></span><br><span class=\"line\">        <span class=\"attr\">window:</span> <span class=\"string\">60s</span>            <span class=\"comment\"># 判断失败次数的时间窗口（60秒内最多失败3次）</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"attr\">placement:</span></span><br><span class=\"line\">        <span class=\"attr\">constraints:</span>           <span class=\"comment\"># 指定容器调度到哪些节点上运行，可用条件有：</span></span><br><span class=\"line\">                               <span class=\"comment\"># - node.role == manager/worker</span></span><br><span class=\"line\">                               <span class=\"comment\"># - node.hostname == xxx</span></span><br><span class=\"line\">                               <span class=\"comment\"># - node.labels.xxx == yyy</span></span><br><span class=\"line\">          <span class=\"bullet\">-</span> <span class=\"string\">node.role</span> <span class=\"string\">==</span> <span class=\"string\">worker</span>  <span class=\"comment\"># 只调度到 worker 节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"attr\">preferences:</span>           <span class=\"comment\"># 调度偏好（不是强约束）</span></span><br><span class=\"line\">          <span class=\"bullet\">-</span> <span class=\"attr\">spread:</span> <span class=\"string\">node.labels.zone</span>  <span class=\"comment\"># 将服务均匀地分布在 zone 标签不同的节点上</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"attr\">update_config:</span>           <span class=\"comment\"># 控制服务滚动更新的行为</span></span><br><span class=\"line\">        <span class=\"attr\">parallelism:</span> <span class=\"number\">2</span>         <span class=\"comment\"># 每次最多并发更新2个容器</span></span><br><span class=\"line\">        <span class=\"attr\">delay:</span> <span class=\"string\">10s</span>             <span class=\"comment\"># 每批更新之间等待10秒</span></span><br><span class=\"line\">        <span class=\"attr\">failure_action:</span> <span class=\"string\">rollback</span>  <span class=\"comment\"># 更新失败时的处理方式，可选值：</span></span><br><span class=\"line\">                                  <span class=\"comment\"># - pause：暂停更新（默认）</span></span><br><span class=\"line\">                                  <span class=\"comment\"># - continue：继续更新</span></span><br><span class=\"line\">                                  <span class=\"comment\"># - rollback：回滚到旧版本</span></span><br><span class=\"line\">        <span class=\"attr\">order:</span> <span class=\"string\">stop-first</span>      <span class=\"comment\"># 控制更新顺序，可选值：</span></span><br><span class=\"line\">                               <span class=\"comment\"># - stop-first（先停后启，默认）</span></span><br><span class=\"line\">                               <span class=\"comment\"># - start-first（先启后停，适用于无状态服务）</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"attr\">rollback_config:</span>         <span class=\"comment\"># 回滚时的行为，字段与 update_config 类似</span></span><br><span class=\"line\">        <span class=\"attr\">parallelism:</span> <span class=\"number\">1</span>         <span class=\"comment\"># 回滚时每次最多处理1个容器</span></span><br><span class=\"line\">        <span class=\"attr\">delay:</span> <span class=\"string\">5s</span>              <span class=\"comment\"># 每批回滚之间等待5秒</span></span><br><span class=\"line\">        <span class=\"attr\">failure_action:</span> <span class=\"string\">pause</span>  <span class=\"comment\"># 回滚失败时暂停</span></span><br><span class=\"line\">        <span class=\"attr\">order:</span> <span class=\"string\">stop-first</span>      <span class=\"comment\"># 回滚时先停再启</span></span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍 Docker Swarm 的 栈管理 Docker官方文档 Docker Swarm 官方文档 Compose file reference Stack简介 前面我们在Swarm中创建服务都是通过Service，每次创建一个，有没有类似docker compose的方式来创建多个服务呢？Docker Swarm为我们提供了Stack 在 Docker Swarm 中，Stack（栈） 是用来定义和部署一组相关服务的集合。你可以把它看成是一个应用的整体，由多个服务（service）、网络（network）、卷（volume）等组成。 Stack 通常用 Docker Compose 文件（YAML 格式） 描述 Stack 完全兼容 Docker Compose 文件，并可以在 compose 文件中声明副本集等与Service相关的配置项。 我用表格总结一下二者的差异，重点放在「Stack 支持的配置」上： 配置项 Docker Compose (本地) Docker Stack (Swarm 集群) 说明 name ✅ ❌ Stack 不支持 name 属性 build ✅ ❌ Stack 不支持 build 属性，只能使用image deploy ❌（部分支持，通常被忽略） ✅（核心支持） Stack 支持用 deploy 定义副本数、资源限制、更新策略等 deploy.replicas ❌ ✅ 定义服务副本数 deploy.resources ❌ ✅ 定义 CPU、内存限制 deploy.placement ❌ ✅ 定义服务调度策略（在哪些节点上运行） deploy.update_config ❌ ✅ 定义滚动更新的参数 deploy.restart_policy ❌ ✅ 定义重启策略 deploy.mode ❌ ✅ replicated 或 global depends_on ✅ 🚫（被忽略） Stack 不支持容器启动顺序控制 build ✅ 🚫（被忽略） Stack 不支持直接构建镜像，只能用已存在的镜像 network.external ✅ ✅ 都支持外部网络 volumes.external ✅ ✅ 都支持外部卷 configs 🚫 ✅ Stack 支持 Config 对象，适合配置文件管理 secrets 🚫 ✅ Stack 支持 Secrets，用于安全存储敏感信息 以Portainer:Docker可视化管理工具的stack配置文件为例 Portainer 社区版 （CE）可让您在 Docker、Docker Swarm、Kubernetes 和 Azure ACI 中轻松构建和管理容器。 1curl -L https://downloads.portainer.io/ce-lts/portainer-agent-stack.yml -o portainer-agent-stack.yml 1234567891011121314151617181920212223242526272829303132333435363738version: &quot;3.2&quot; # docker-compose版本，新版的docker已经不需要配置版本号了services: agent: # agent服务 image: portainer/agent:lts # 镜像，不能使用 Dockerfile volumes: # 挂载卷 - /var/run/docker.sock:/var/run/docker.sock - /var/lib/docker/volumes:/var/lib/docker/volumes networks: # 挂载网络，必须是 overlay - agent_network deploy: # 部署策略，service 特有属性 mode: global # 全局模式 placement: # 部署条件 constraints: [node.platform.os == linux] # 运行在linux节点 portainer: # portainer服务 image: portainer/portainer-ce:lts # 镜像 command: -H tcp://tasks.agent:9001 --tlsskipverify # 启动参数 ports: # 端口映射 - &quot;9443:9443&quot; # 浏览器访问 https://localhost:9443 - &quot;9000:9000&quot; - &quot;8000:8000&quot; volumes: # 挂载卷 - portainer_data:/data networks: # 挂载网络，与agent服务网络一致 - agent_network deploy: # 部署配置 mode: replicated # 副本模式 replicas: 1 # 副本数量 placement: # 部署条件 constraints: [node.role == manager] # 节点角色为managernetworks: # 网络声明 agent_network: # 网络名称 driver: overlay # 网络驱动 attachable: true # 允许容器加入volumes: # 挂载卷声明 portainer_data: # 挂载卷名称 Stack 命令 子命令 中文说明 示例命令 config 输出最终的配置文件（经过合并与变量替换后） docker stack config -c docker-compose.yml deploy 部署新 stack 或更新已有 stack docker stack deploy -c docker-compose.yml mystack ls 列出所有已部署的 stack docker stack ls ps 查看 stack 中的所有任务（即各个容器实例） docker stack ps mystack rm 删除一个或多个 stack docker stack rm mystack services 列出某个 stack 中的所有服务 docker stack services mystack docker stack config: 输出最终的配置文件 12# 此命令也可以用来验证compose文件格式是否正确，只保证格式正确，不保证逻辑正确docker stack config -c portainer-agent-stack.yml docker stack deploy: 部署 stack docker stack deploy == docker stack up 12345docker stack deploy -c portainer-agent-stack.yml portainer## 输出Creating network portainer_agent_networkCreating service portainer_agentCreating service portainer_portainer docker stack ls: 列出所有 stack docker stack ls == docker stack list 1234docker stack ls## 输出，stack名称为portainer，其内部有两个服务，agent和portainerNAME SERVICESportainer 2 docker stack services: 查看服务 123456789101112docker stack services portainer## 输出ID NAME MODE REPLICAS IMAGE PORTSh5foyujr6jq9 portainer_agent global 5/5 portainer/agent:ltszcek2jtloe09 portainer_portainer replicated 1/1 portainer/portainer-ce:lts *:8000-&gt;8000/tcp, *:9000-&gt;9000/tcp, *:9443-&gt;9443/tcp## 等效docker service ls## 输出ID NAME MODE REPLICAS IMAGE PORTSh5foyujr6jq9 portainer_agent global 5/5 portainer/agent:ltszcek2jtloe09 portainer_portainer replicated 1/1 portainer/portainer-ce:lts *:8000-&gt;8000/tcp, *:9000-&gt;9000/tcp, *:9443-&gt;9443/tcp docker stack ps: 列出 stack 下的所有服务实例 1234567891011121314151617181920docker stack ps portainer## 输出ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTSwshk9s6gyxh1 portainer_agent.hvzkh3ip5ef8gx973z1ywahbu portainer/agent:lts worker2 Running Running 30 seconds agon3jjzmr2fcv9 portainer_agent.kp2zerd28xgz5mmglnje0jp22 portainer/agent:lts manager1 Running Running 59 seconds ago24yy1ew3tiya portainer_agent.oymi74epagdqeprah7s81tsa2 portainer/agent:lts manager2 Running Running 3 minutes agokpo4hhdvwcwd portainer_agent.r7388xl84nczjtnf53pwh7hla portainer/agent:lts manager3 Running Running 35 seconds agot8xjbotfuas0 portainer_agent.xkww4853bbdgv7bv8771xibob portainer/agent:lts worker1 Running Running 48 seconds agoqox3kqypon69 portainer_portainer.1 portainer/portainer-ce:lts manager2 Running Running 2 minutes ago## 等效docker service ps portainer_agent portainer_portainer## 输出ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTSwshk9s6gyxh1 portainer_agent.hvzkh3ip5ef8gx973z1ywahbu portainer/agent:lts worker2 Running Running 7 minutes agon3jjzmr2fcv9 portainer_agent.kp2zerd28xgz5mmglnje0jp22 portainer/agent:lts manager1 Running Running 8 minutes ago24yy1ew3tiya portainer_agent.oymi74epagdqeprah7s81tsa2 portainer/agent:lts manager2 Running Running 10 minutes agokpo4hhdvwcwd portainer_agent.r7388xl84nczjtnf53pwh7hla portainer/agent:lts manager3 Running Running 7 minutes agot8xjbotfuas0 portainer_agent.xkww4853bbdgv7bv8771xibob portainer/agent:lts worker1 Running Running 7 minutes agoqox3kqypon69 portainer_portainer.1 portainer/portainer-ce:lts manager2 Running Running 10 minutes ago docker stack rm: 停止并删除 stack docker stack rm == docker stack remove == docker stack down 1docker stack rm portainer deploy 参数详解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455services: my-service: image: myapp:latest deploy: replicas: 3 # 指定副本数，仅在 mode: replicated 下有效。表示同时运行3个容器副本。 mode: replicated # 服务运行模式，可选值： # - replicated：通过 replicas 指定副本数量（默认） # - global：每个节点运行一个副本，忽略 replicas 配置 resources: limits: # 容器的“硬限制”，超过会被强制限制 cpus: &#x27;1.0&#x27; # 限制每个容器最多使用1个逻辑 CPU memory: 512M # 限制每个容器最多使用512MB内存 reservations: # 容器的“软限制”，Swarm调度时预留资源参考值（不会强制限制） cpus: &#x27;0.25&#x27; # 建议每个容器至少分配0.25个CPU memory: 128M # 建议每个容器至少分配128MB内存 restart_policy: condition: on-failure # 控制容器重启行为，可选值： # - none：不重启 # - on-failure：失败时重启（非0退出码） # - any：无论是否失败都重启 delay: 5s # 重启前等待时间 max_attempts: 3 # 最多重启3次 window: 60s # 判断失败次数的时间窗口（60秒内最多失败3次） placement: constraints: # 指定容器调度到哪些节点上运行，可用条件有： # - node.role == manager/worker # - node.hostname == xxx # - node.labels.xxx == yyy - node.role == worker # 只调度到 worker 节点 preferences: # 调度偏好（不是强约束） - spread: node.labels.zone # 将服务均匀地分布在 zone 标签不同的节点上 update_config: # 控制服务滚动更新的行为 parallelism: 2 # 每次最多并发更新2个容器 delay: 10s # 每批更新之间等待10秒 failure_action: rollback # 更新失败时的处理方式，可选值： # - pause：暂停更新（默认） # - continue：继续更新 # - rollback：回滚到旧版本 order: stop-first # 控制更新顺序，可选值： # - stop-first（先停后启，默认） # - start-first（先启后停，适用于无状态服务） rollback_config: # 回滚时的行为，字段与 update_config 类似 parallelism: 1 # 回滚时每次最多处理1个容器 delay: 5s # 每批回滚之间等待5秒 failure_action: pause # 回滚失败时暂停 order: stop-first # 回滚时先停再启","summary":"摘要 本文介绍 Docker Swarm 的 栈管理 Docker官方文档 Docker Swarm 官方文档 Compose file reference","date_published":"2025-06-11T14:30:05.000Z","tags":["技术","docker","docker"]},{"id":"https://blog.hanqunfeng.com/2025/06/11/docker-swarm-overlay/","url":"https://blog.hanqunfeng.com/2025/06/11/docker-swarm-overlay/","title":"Docker Swarm 之 网络(Overlay)","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 Docker Swarm 的 网络(Overlay)</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com\">Docker官方文档</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com/engine/swarm/\">Docker Swarm 官方文档</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Overlay-简介\">Overlay 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 Docker Swarm 中，overlay 网络 是一种分布式网络驱动，用于将集群中不同主机上的容器连接到同一个逻辑网络中，就像它们在同一台主机上一样。</p>\n</li>\n<li class=\"lvl-2\">\n<p>当你使用 Docker Swarm 部署服务时，Swarm 会自动使用 overlay 网络来连接不同节点上的容器，实现服务发现和负载均衡，保证容器间的通信安全（通过加密）。</p>\n</li>\n<li class=\"lvl-2\">\n<p>overlay 网络特点</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">跨主机通信：容器无论在哪个节点上，都可以使用 overlay 网络进行通信。</li>\n<li class=\"lvl-4\">内置服务发现：容器之间可以通过服务名称直接通信。</li>\n<li class=\"lvl-4\">支持加密：Swarm 的 overlay 网络支持数据加密，提高安全性。</li>\n<li class=\"lvl-4\">自动配置：Swarm 会自动为 overlay 网络分配子网、管理 IP 等。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Swarm-中的-overlay-网络\">Swarm 中的 overlay 网络</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当我们初始化Swarm 时，Swarm 会自动创建两个network，一个是 bridge network：<code>docker_gwbridge</code> ，一个是 overlay network：<code>ingress</code>。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker network <span class=\"built_in\">ls</span></span><br><span class=\"line\">NETWORK ID     NAME              DRIVER    SCOPE</span><br><span class=\"line\">6b7aadbbd180   bridge            bridge    <span class=\"built_in\">local</span></span><br><span class=\"line\">5ddadf5d0608   docker_gwbridge   bridge    <span class=\"built_in\">local</span></span><br><span class=\"line\">21c6f5b1bedd   host              host      <span class=\"built_in\">local</span></span><br><span class=\"line\">idx465x3jg68   ingress           overlay   swarm</span><br><span class=\"line\">a770c5ad4b13   none              null      <span class=\"built_in\">local</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-gwbridge\"><code>docker_gwbridge</code></h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看 <code>docker_gwbridge</code> 详情，其网段为 <code>172.18.0.0/16</code>，网关为 <code>172.18.0.1</code>，内部有一个容器 <code>ingress-sbox</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker inspect docker_gwbridge</span><br><span class=\"line\">[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;Name&quot;</span>: <span class=\"string\">&quot;docker_gwbridge&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Id&quot;</span>: <span class=\"string\">&quot;5ddadf5d06086fcdad5890b8d59edcca4b1293bde23a26f1968fd6114fcaec93&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Created&quot;</span>: <span class=\"string\">&quot;2025-06-08T07:29:52.119033035-04:00&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Scope&quot;</span>: <span class=\"string\">&quot;local&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Driver&quot;</span>: <span class=\"string\">&quot;bridge&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;EnableIPv6&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;IPAM&quot;</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;Driver&quot;</span>: <span class=\"string\">&quot;default&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;Options&quot;</span>: null,</span><br><span class=\"line\">            <span class=\"string\">&quot;Config&quot;</span>: [</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"string\">&quot;Subnet&quot;</span>: <span class=\"string\">&quot;172.18.0.0/16&quot;</span>,</span><br><span class=\"line\">                    <span class=\"string\">&quot;Gateway&quot;</span>: <span class=\"string\">&quot;172.18.0.1&quot;</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;Internal&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Attachable&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Ingress&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;ConfigFrom&quot;</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;Network&quot;</span>: <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;ConfigOnly&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Containers&quot;</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;ingress-sbox&quot;</span>: &#123;</span><br><span class=\"line\">                <span class=\"string\">&quot;Name&quot;</span>: <span class=\"string\">&quot;gateway_ingress-sbox&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;EndpointID&quot;</span>: <span class=\"string\">&quot;4764160a1b048da6d325a2f14165a981a446892ea3b4ebb12e20ee689fdac397&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;MacAddress&quot;</span>: <span class=\"string\">&quot;02:42:ac:12:00:02&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;IPv4Address&quot;</span>: <span class=\"string\">&quot;172.18.0.2/16&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;IPv6Address&quot;</span>: <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;Options&quot;</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;com.docker.network.bridge.enable_icc&quot;</span>: <span class=\"string\">&quot;false&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;com.docker.network.bridge.enable_ip_masquerade&quot;</span>: <span class=\"string\">&quot;true&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;com.docker.network.bridge.name&quot;</span>: <span class=\"string\">&quot;docker_gwbridge&quot;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;Labels&quot;</span>: &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>先来看这个网段 <code>172.18.0.0/16</code>，我们查看主机的网络和路由表，可以看到 <code>261: docker_gwbridge</code>，其IP地址为 <code>172.18.0.1</code>，所以这里我们就可以知道 <code>docker_gwbridge</code> 就是连接到<code>261: docker_gwbridge</code>这块网卡上的，另外当前还有一个<code>263: veth3176100@if262</code>虚拟网络接口也连接到<code>261: docker_gwbridge</code>上，通过路由表我们得知其最终连接到<code>2: enp0s5</code>上，也就是这台主机的网卡。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ip a</span><br><span class=\"line\"><span class=\"comment\">## 输出结果</span></span><br><span class=\"line\">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class=\"line\">    inet 127.0.0.1/8 scope host lo</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">    inet6 ::1/128 scope host</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">2: enp0s5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/ether 00:1c:42:49:12:82 brd ff:ff:ff:ff:ff:ff</span><br><span class=\"line\">    inet 10.211.55.10/24 brd 10.211.55.255 scope global noprefixroute enp0s5</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">    inet6 fdb2:2c26:f4e4:0:21c:42ff:fe49:1282/64 scope global dynamic noprefixroute</span><br><span class=\"line\">       valid_lft 2591886sec preferred_lft 604686sec</span><br><span class=\"line\">    inet6 fe80::21c:42ff:fe49:1282/64 scope <span class=\"built_in\">link</span> noprefixroute</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/ether 02:42:5c:31:<span class=\"built_in\">cd</span>:30 brd ff:ff:ff:ff:ff:ff</span><br><span class=\"line\">    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">    inet6 fe80::42:5cff:fe31:cd30/64 scope <span class=\"built_in\">link</span></span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">261: docker_gwbridge: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/ether 02:42:fe:e3:ca:f7 brd ff:ff:ff:ff:ff:ff</span><br><span class=\"line\">    inet 172.18.0.1/16 brd 172.18.255.255 scope global docker_gwbridge</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">    inet6 fe80::42:feff:fee3:caf7/64 scope <span class=\"built_in\">link</span></span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">263: veth3176100@if262: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker_gwbridge state UP group default</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/ether 96:4b:c1:d9:83:c5 brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br><span class=\"line\">    inet6 fe80::944b:c1ff:fed9:83c5/64 scope <span class=\"built_in\">link</span></span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看路由表</span></span><br><span class=\"line\">route -n</span><br><span class=\"line\"><span class=\"comment\">## 输出结果，其目的地址最终都会转到网关 10.211.55.1 上</span></span><br><span class=\"line\">Kernel IP routing table</span><br><span class=\"line\">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class=\"line\">0.0.0.0         10.211.55.1     0.0.0.0         UG    100    0        0 enp0s5</span><br><span class=\"line\">10.211.55.0     0.0.0.0         255.255.255.0   U     100    0        0 enp0s5</span><br><span class=\"line\">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</span><br><span class=\"line\">172.18.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker_gwbridge</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看docker_gwbridge网桥设备信息，可以看到其挂载了一个虚拟网卡 veth3176100</span></span><br><span class=\"line\">brctl show docker_gwbridge</span><br><span class=\"line\">bridge name     bridge <span class=\"built_in\">id</span>               STP enabled     interfaces</span><br><span class=\"line\">docker_gwbridge         8000.0242fee3caf7       no              veth3176100</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>按理说<code>263: veth3176100@if262</code>虚拟网络接口应该对应到一个容器上，那么接下来我们就看一看这个容器 <code>ingress-sbox</code>，当前docker中并没有这个容器，那么这个容器在哪里呢？docker创建的容器都会有一个网络命名空间，其保存在宿主机的<code>/var/run/docker/netns/</code>下</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /var/run/docker/netns/</span><br><span class=\"line\"><span class=\"built_in\">ls</span></span><br><span class=\"line\"><span class=\"comment\">## 输出，在这里我们还真的发现了与这个容器名称类似的网络命名空间，容器名称是中划线，网络命名空间名称是下划线</span></span><br><span class=\"line\">1-idx465x3jg  ingress_sbox</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>进入这个网络，我们就找到与宿主机上的虚拟网络接口对应的容器网络接口了：<code>262: eth1@if263</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nsenter --net=ingress_sbox ip a</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class=\"line\">    inet 127.0.0.1/8 scope host lo</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">    inet6 ::1/128 scope host</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">259: eth0@if260: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UP group default</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/ether 02:42:0a:00:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class=\"line\">    inet 10.0.0.2/24 brd 10.0.0.255 scope global eth0</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">262: eth1@if263: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br><span class=\"line\">    inet 172.18.0.2/16 brd 172.18.255.255 scope global eth1</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里还有一个网络接口 <code>259: eth0@if260</code>，它又是与谁对接的呢？别着急，我们接着往下看。</p>\n</li>\n</ul>\n<h3 id=\"ingress\"><code>ingress</code></h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看 <code>ingress</code> 详情，其网段为 <code>10.0.0.0/24</code>，网关为 <code>10.0.0.1</code>，内部有一个容器 <code>ingress-sbox</code>，另外其有一个<code>Peers</code>属性，内部包含了集群中所有的节点IP，所以从这里也能大概猜出这个网络是负责节点间通信的。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker network inspect ingress</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;Name&quot;</span>: <span class=\"string\">&quot;ingress&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Id&quot;</span>: <span class=\"string\">&quot;idx465x3jg682fmceumsio297&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Created&quot;</span>: <span class=\"string\">&quot;2025-06-08T07:29:51.734714967-04:00&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Scope&quot;</span>: <span class=\"string\">&quot;swarm&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Driver&quot;</span>: <span class=\"string\">&quot;overlay&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;EnableIPv6&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;IPAM&quot;</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;Driver&quot;</span>: <span class=\"string\">&quot;default&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;Options&quot;</span>: null,</span><br><span class=\"line\">            <span class=\"string\">&quot;Config&quot;</span>: [</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"string\">&quot;Subnet&quot;</span>: <span class=\"string\">&quot;10.0.0.0/24&quot;</span>,</span><br><span class=\"line\">                    <span class=\"string\">&quot;Gateway&quot;</span>: <span class=\"string\">&quot;10.0.0.1&quot;</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;Internal&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Attachable&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Ingress&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;ConfigFrom&quot;</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;Network&quot;</span>: <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;ConfigOnly&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Containers&quot;</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;ingress-sbox&quot;</span>: &#123;</span><br><span class=\"line\">                <span class=\"string\">&quot;Name&quot;</span>: <span class=\"string\">&quot;ingress-endpoint&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;EndpointID&quot;</span>: <span class=\"string\">&quot;fd05086c5104e28c75dbed3e3b308236aaa0e87b698dad6186c23c81755bb009&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;MacAddress&quot;</span>: <span class=\"string\">&quot;02:42:0a:00:00:02&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;IPv4Address&quot;</span>: <span class=\"string\">&quot;10.0.0.2/24&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;IPv6Address&quot;</span>: <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;Options&quot;</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;com.docker.network.driver.overlay.vxlanid_list&quot;</span>: <span class=\"string\">&quot;4096&quot;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;Labels&quot;</span>: &#123;&#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;Peers&quot;</span>: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"string\">&quot;Name&quot;</span>: <span class=\"string\">&quot;4969a4611607&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;IP&quot;</span>: <span class=\"string\">&quot;10.211.55.10&quot;</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"string\">&quot;Name&quot;</span>: <span class=\"string\">&quot;ae3756658a26&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;IP&quot;</span>: <span class=\"string\">&quot;10.211.55.14&quot;</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"string\">&quot;Name&quot;</span>: <span class=\"string\">&quot;f12309731131&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;IP&quot;</span>: <span class=\"string\">&quot;10.211.55.13&quot;</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"string\">&quot;Name&quot;</span>: <span class=\"string\">&quot;de5000b11067&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;IP&quot;</span>: <span class=\"string\">&quot;10.211.55.12&quot;</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"string\">&quot;Name&quot;</span>: <span class=\"string\">&quot;377001904d63&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;IP&quot;</span>: <span class=\"string\">&quot;10.211.55.11&quot;</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>我们还是先来看这个网关<code>10.0.0.1</code>，在哪呢？宿主机的网络设备中并没有，所以它应该是docker创建的，我们还是要从<code>/var/run/docker/netns</code>中查看一下，这里还有一个名称为 <code>1-idx465x3jg</code> 的网络命名空间，我们进去看看</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nsenter --net=/var/run/docker/netns/1-idx465x3jg ip a</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class=\"line\">    inet 127.0.0.1/8 scope host lo</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">    inet6 ::1/128 scope host</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">258: vxlan0@if258: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue master br0 state UNKNOWN group default</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/ether 32:c9:a4:01:8a:19 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class=\"line\">2: br0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UP group default</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/ether 32:c9:a4:01:8a:19 brd ff:ff:ff:ff:ff:ff</span><br><span class=\"line\">    inet 10.0.0.1/24 brd 10.0.0.255 scope global br0</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">260: veth0@if259: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue master br0 state UP group default</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/ether 8a:d3:52:ac:7d:<span class=\"built_in\">cd</span> brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在这里我们找到了<code>2: br0</code>，其IP地址为<code>10.0.0.1</code>，所以它就是我们要找的网关。其上面还挂载了两个网络设备，一个是 <code>260: veth0@if259</code>，这个就是与<code>ingress_sbox</code> 中<code>259: eth0@if260</code>对应的网络接口 ，另一个是 <code>258: vxlan0@if258</code>，其基于<code>vxlan</code>协议，负责集群跨主机通信。</p>\n</li>\n</ul>\n<h3 id=\"overlay总结\">overlay总结</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker_gwbridge</code>中的容器<code>ingress-sbox</code>，其有两块网卡，一块对接宿主机上的 <code>261: docker_gwbridge</code>，另一块对接<code>/var/run/docker/netns/1-idx465x3jg</code>中的 <code>2: br0</code>。</p>\n</li>\n<li class=\"lvl-2\">\n<p>实际上Swarm中的所有容器都有两个网卡，一块对接宿主机上的 <code>261: docker_gwbridge</code>，另一块对接<code>/var/run/docker/netns/1-idx465x3jg</code>中的 <code>2: br0</code>。</p>\n</li>\n<li class=\"lvl-2\">\n<p>当请求到达宿主机时，会通过<code>enp0s5</code>转发到<code>docker_gwbridge</code>，然后先被转到<code>ingress-sbox</code>容器，然后再经过其转发到<code>br0</code>网关，再由它负责查找目标容器。如果目标容器不在本节点，则通过<code>vxlan0</code>网络接口转发到其它节点进行查找，中间经过一系列的网络地址转换。</p>\n</li>\n</ul>\n<p><img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/9UVZzm.png\" alt=\"\"></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当你通过<code>docker network create --driver overlay my-network</code>创建一个overlay网络时，Docker会创建一个类似“ingress”的网络结构(新的<code>br0</code>)，如果不指定ip段，其ip段会从<code>10.0.1.0/24</code>开始，依次递增一个网段。但会共用<code>docker_gwbridge</code>。</p>\n</li>\n</ul>\n<h2 id=\"查看overlay网络中的负载均衡\">查看overlay网络中的负载均衡</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动一个service</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker service create --name my-nginx --replicas 5 --publish 80:80 nginx</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看<code>ingress_sbox</code>的<code>iptables</code>数据链中的 mangle 表</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nsenter --net=/var/run/docker/netns/ingress_sbox iptables -nvL -t mangle</span><br><span class=\"line\"><span class=\"comment\">## 输出结果，这里看到 PREROUTING 链中有一条监听80端口的规则，其被打了Mark标记: 0x105，换算为10进制：261</span></span><br><span class=\"line\">Chain PREROUTING (policy ACCEPT 0 packets, 0 bytes)</span><br><span class=\"line\"> pkts bytes target     prot opt <span class=\"keyword\">in</span>     out     <span class=\"built_in\">source</span>               destination</span><br><span class=\"line\">    0     0 MARK       tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp dpt:80 MARK <span class=\"built_in\">set</span> 0x105</span><br><span class=\"line\"></span><br><span class=\"line\">Chain INPUT (policy ACCEPT 0 packets, 0 bytes)</span><br><span class=\"line\"> pkts bytes target     prot opt <span class=\"keyword\">in</span>     out     <span class=\"built_in\">source</span>               destination</span><br><span class=\"line\">    0     0 MARK       all  --  *      *       0.0.0.0/0            10.0.0.33            MARK <span class=\"built_in\">set</span> 0x105</span><br><span class=\"line\"></span><br><span class=\"line\">Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)</span><br><span class=\"line\"> pkts bytes target     prot opt <span class=\"keyword\">in</span>     out     <span class=\"built_in\">source</span>               destination</span><br><span class=\"line\"></span><br><span class=\"line\">Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes)</span><br><span class=\"line\"> pkts bytes target     prot opt <span class=\"keyword\">in</span>     out     <span class=\"built_in\">source</span>               destination</span><br><span class=\"line\"></span><br><span class=\"line\">Chain POSTROUTING (policy ACCEPT 0 packets, 0 bytes)</span><br><span class=\"line\"> pkts bytes target     prot opt <span class=\"keyword\">in</span>     out     <span class=\"built_in\">source</span>               destination</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>通过<code>ipvsadm</code>查看负载均衡信息</p>\n</li>\n</ul>\n<blockquote>\n<p>ipvsadm 是 Linux 下管理 IPVS（IP Virtual Server）负载均衡器的命令之一</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果没有ipvsadm，则安装</span></span><br><span class=\"line\">dnf install ipvsadm -y</span><br><span class=\"line\"><span class=\"comment\"># 查看ipvs信息</span></span><br><span class=\"line\">nsenter --net=/var/run/docker/netns/ingress_sbox ipvsadm -Ln</span><br><span class=\"line\"><span class=\"comment\"># -L：表示列出当前 IPVS 的规则和状态（List）。</span></span><br><span class=\"line\"><span class=\"comment\"># -n：表示以数字方式显示地址和端口，而不进行 DNS 解析或端口名解析（即：IP 和端口号以数字显示，更直观，也更快）。</span></span><br><span class=\"line\"><span class=\"comment\">## 输出，可以看到 FWM 261 rr，这里rr表示轮询</span></span><br><span class=\"line\">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class=\"line\">Prot LocalAddress:Port Scheduler Flags</span><br><span class=\"line\">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</span><br><span class=\"line\">FWM  261 rr</span><br><span class=\"line\">  -&gt; 10.0.0.34:0                  Masq    1      0          0</span><br><span class=\"line\">  -&gt; 10.0.0.35:0                  Masq    1      0          0</span><br><span class=\"line\">  -&gt; 10.0.0.36:0                  Masq    1      0          0</span><br><span class=\"line\">  -&gt; 10.0.0.37:0                  Masq    1      0          0</span><br><span class=\"line\">  -&gt; 10.0.0.38:0                  Masq    1      0          0</span><br><span class=\"line\"><span class=\"comment\">## 输出解释</span></span><br><span class=\"line\"><span class=\"comment\"># Prot: 协议（TCP/UDP）,这里是 FWM，表示Firewall Mark（防火墙标记）模式</span></span><br><span class=\"line\"><span class=\"comment\"># LocalAddress:Port: 本地地址和端口号，这里是 261 ，这是防火墙标记值（mark 值）,就是上面看到的那个16进制 0x105</span></span><br><span class=\"line\"><span class=\"comment\"># Scheduler: 调度算法，这里是 rr，表示轮询(round-robin)，调度算法还有 wrr（加权轮询）、lc（最少连接）等</span></span><br><span class=\"line\"><span class=\"comment\"># RemoteAddress:Port: 远程地址和端口号，这里是 10.0.0.34:0，表示负载均衡到的第一个节点，后面同理</span></span><br><span class=\"line\"><span class=\"comment\"># Forward: 转发策略，这里是 Masq，表示将负载均衡到的节点的IP地址转换成宿主机的IP地址，即 Masquerade（伪装）。转发方式（如：Masq、Tunnel、Direct Route）</span></span><br><span class=\"line\"><span class=\"comment\"># Weight: 权重，这里是 1，表示负载均衡到的节点的权重，默认为 1</span></span><br><span class=\"line\"><span class=\"comment\"># ActiveConn: 当前活动连接数，这里是 0</span></span><br><span class=\"line\"><span class=\"comment\"># InActConn: 当前不活动连接数（等待关闭的连接），这里是 0</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"VXLAN是什么？\">VXLAN是什么？</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>VXLAN（Virtual Extensible LAN）是 Cisco 公司开发的一种虚拟局域网（VLAN）技术，它可以将多个 VLAN 逻辑分组，并使用单个物理网络进行管理。VXLAN 的主要作用是提高网络性能和扩展性。</p>\n</li>\n<li class=\"lvl-2\">\n<p>它本质上是一种 网络封装协议（overlay protocol），用来在已有的 IP 网络之上，构建二层（L2）虚拟网络。</p>\n</li>\n</ul>\n<h3 id=\"为什么需要-VXLAN？\">为什么需要 VXLAN？</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在传统数据中心或云计算中，经常有这样的需求：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">跨不同物理网络或子网，部署在不同服务器上的虚拟机或容器，要能像在同一个二层网络里一样直接通信。</li>\n<li class=\"lvl-6\">VLAN（802.1Q）提供的二层隔离能力只有 12 bit VLAN ID（最多 4096 个 VLAN），在大型数据中心远远不够用。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>数据中心想要更好的弹性、跨区域部署、容器编排、大规模租户隔离。</p>\n</li>\n</ul>\n<h3 id=\"VXLAN-核心原理\">VXLAN 核心原理</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>VXLAN 通过封装的方式，把二层以太网帧包在 UDP 数据报里，在三层 IP 网络中传递。</p>\n</li>\n<li class=\"lvl-2\">\n<p>封装格式大致是：</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+-------------------------+</span><br><span class=\"line\">| 外层IP头 (IP Header)    |</span><br><span class=\"line\">+-------------------------+</span><br><span class=\"line\">| 外层UDP头 (UDP Header)  |</span><br><span class=\"line\">+-------------------------+</span><br><span class=\"line\">| VXLAN头 (VXLAN Header)  |</span><br><span class=\"line\">+-------------------------+</span><br><span class=\"line\">| 内层二层帧 (Ethernet)   |</span><br><span class=\"line\">+-------------------------+</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>外层 IP/UDP 用于三层传输</p>\n</li>\n<li class=\"lvl-2\">\n<p>内层保留原本的二层以太网帧（如 MAC 地址）</p>\n</li>\n<li class=\"lvl-2\">\n<p>VXLAN 头部里面包含了一个 VNI (VXLAN Network Identifier)：24 bit，可支持 1600万个虚拟网络</p>\n</li>\n<li class=\"lvl-2\">\n<p>简单示意图</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VM1 (10.1.1.1) ——&gt; VTEP1 ——&gt; Underlay IP网络 ——&gt; VTEP2 ——&gt; VM2 (10.1.1.2)</span><br><span class=\"line\"></span><br><span class=\"line\">VTEP1 封装：</span><br><span class=\"line\">  内层以太网帧  + VXLAN头 (VNI) + UDP + IP</span><br><span class=\"line\"></span><br><span class=\"line\">VTEP2 解封装：</span><br><span class=\"line\">  去掉外层头部，还原原始二层帧</span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍 Docker Swarm 的 网络(Overlay) Docker官方文档 Docker Swarm 官方文档 Overlay 简介 在 Docker Swarm 中，overlay 网络 是一种分布式网络驱动，用于将集群中不同主机上的容器连接到同一个逻辑网络中，就像它们在同一台主机上一样。 当你使用 Docker Swarm 部署服务时，Swarm 会自动使用 overlay 网络来连接不同节点上的容器，实现服务发现和负载均衡，保证容器间的通信安全（通过加密）。 overlay 网络特点 跨主机通信：容器无论在哪个节点上，都可以使用 overlay 网络进行通信。 内置服务发现：容器之间可以通过服务名称直接通信。 支持加密：Swarm 的 overlay 网络支持数据加密，提高安全性。 自动配置：Swarm 会自动为 overlay 网络分配子网、管理 IP 等。 Swarm 中的 overlay 网络 当我们初始化Swarm 时，Swarm 会自动创建两个network，一个是 bridge network：docker_gwbridge ，一个是 overlay network：ingress。 1234567docker network lsNETWORK ID NAME DRIVER SCOPE6b7aadbbd180 bridge bridge local5ddadf5d0608 docker_gwbridge bridge local21c6f5b1bedd host host localidx465x3jg68 ingress overlay swarma770c5ad4b13 none null local docker_gwbridge 查看 docker_gwbridge 详情，其网段为 172.18.0.0/16，网关为 172.18.0.1，内部有一个容器 ingress-sbox 12345678910111213141516171819202122232425262728293031323334353637383940414243docker inspect docker_gwbridge[ &#123; &quot;Name&quot;: &quot;docker_gwbridge&quot;, &quot;Id&quot;: &quot;5ddadf5d06086fcdad5890b8d59edcca4b1293bde23a26f1968fd6114fcaec93&quot;, &quot;Created&quot;: &quot;2025-06-08T07:29:52.119033035-04:00&quot;, &quot;Scope&quot;: &quot;local&quot;, &quot;Driver&quot;: &quot;bridge&quot;, &quot;EnableIPv6&quot;: false, &quot;IPAM&quot;: &#123; &quot;Driver&quot;: &quot;default&quot;, &quot;Options&quot;: null, &quot;Config&quot;: [ &#123; &quot;Subnet&quot;: &quot;172.18.0.0/16&quot;, &quot;Gateway&quot;: &quot;172.18.0.1&quot; &#125; ] &#125;, &quot;Internal&quot;: false, &quot;Attachable&quot;: false, &quot;Ingress&quot;: false, &quot;ConfigFrom&quot;: &#123; &quot;Network&quot;: &quot;&quot; &#125;, &quot;ConfigOnly&quot;: false, &quot;Containers&quot;: &#123; &quot;ingress-sbox&quot;: &#123; &quot;Name&quot;: &quot;gateway_ingress-sbox&quot;, &quot;EndpointID&quot;: &quot;4764160a1b048da6d325a2f14165a981a446892ea3b4ebb12e20ee689fdac397&quot;, &quot;MacAddress&quot;: &quot;02:42:ac:12:00:02&quot;, &quot;IPv4Address&quot;: &quot;172.18.0.2/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125; &#125;, &quot;Options&quot;: &#123; &quot;com.docker.network.bridge.enable_icc&quot;: &quot;false&quot;, &quot;com.docker.network.bridge.enable_ip_masquerade&quot;: &quot;true&quot;, &quot;com.docker.network.bridge.name&quot;: &quot;docker_gwbridge&quot; &#125;, &quot;Labels&quot;: &#123;&#125; &#125;] 先来看这个网段 172.18.0.0/16，我们查看主机的网络和路由表，可以看到 261: docker_gwbridge，其IP地址为 172.18.0.1，所以这里我们就可以知道 docker_gwbridge 就是连接到261: docker_gwbridge这块网卡上的，另外当前还有一个263: veth3176100@if262虚拟网络接口也连接到261: docker_gwbridge上，通过路由表我们得知其最终连接到2: enp0s5上，也就是这台主机的网卡。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647ip a## 输出结果1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: enp0s5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether 00:1c:42:49:12:82 brd ff:ff:ff:ff:ff:ff inet 10.211.55.10/24 brd 10.211.55.255 scope global noprefixroute enp0s5 valid_lft forever preferred_lft forever inet6 fdb2:2c26:f4e4:0:21c:42ff:fe49:1282/64 scope global dynamic noprefixroute valid_lft 2591886sec preferred_lft 604686sec inet6 fe80::21c:42ff:fe49:1282/64 scope link noprefixroute valid_lft forever preferred_lft forever3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default link/ether 02:42:5c:31:cd:30 brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever inet6 fe80::42:5cff:fe31:cd30/64 scope link valid_lft forever preferred_lft forever261: docker_gwbridge: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:fe:e3:ca:f7 brd ff:ff:ff:ff:ff:ff inet 172.18.0.1/16 brd 172.18.255.255 scope global docker_gwbridge valid_lft forever preferred_lft forever inet6 fe80::42:feff:fee3:caf7/64 scope link valid_lft forever preferred_lft forever263: veth3176100@if262: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker_gwbridge state UP group default link/ether 96:4b:c1:d9:83:c5 brd ff:ff:ff:ff:ff:ff link-netnsid 1 inet6 fe80::944b:c1ff:fed9:83c5/64 scope link valid_lft forever preferred_lft forever# 查看路由表route -n## 输出结果，其目的地址最终都会转到网关 10.211.55.1 上Kernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface0.0.0.0 10.211.55.1 0.0.0.0 UG 100 0 0 enp0s510.211.55.0 0.0.0.0 255.255.255.0 U 100 0 0 enp0s5172.17.0.0 0.0.0.0 255.255.0.0 U 0 0 0 docker0172.18.0.0 0.0.0.0 255.255.0.0 U 0 0 0 docker_gwbridge# 查看docker_gwbridge网桥设备信息，可以看到其挂载了一个虚拟网卡 veth3176100brctl show docker_gwbridgebridge name bridge id STP enabled interfacesdocker_gwbridge 8000.0242fee3caf7 no veth3176100 按理说263: veth3176100@if262虚拟网络接口应该对应到一个容器上，那么接下来我们就看一看这个容器 ingress-sbox，当前docker中并没有这个容器，那么这个容器在哪里呢？docker创建的容器都会有一个网络命名空间，其保存在宿主机的/var/run/docker/netns/下 1234cd /var/run/docker/netns/ls## 输出，在这里我们还真的发现了与这个容器名称类似的网络命名空间，容器名称是中划线，网络命名空间名称是下划线1-idx465x3jg ingress_sbox 进入这个网络，我们就找到与宿主机上的虚拟网络接口对应的容器网络接口了：262: eth1@if263 12345678910111213141516nsenter --net=ingress_sbox ip a## 输出1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever259: eth0@if260: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UP group default link/ether 02:42:0a:00:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 10.0.0.2/24 brd 10.0.0.255 scope global eth0 valid_lft forever preferred_lft forever262: eth1@if263: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 1 inet 172.18.0.2/16 brd 172.18.255.255 scope global eth1 valid_lft forever preferred_lft forever 这里还有一个网络接口 259: eth0@if260，它又是与谁对接的呢？别着急，我们接着往下看。 ingress 查看 ingress 详情，其网段为 10.0.0.0/24，网关为 10.0.0.1，内部有一个容器 ingress-sbox，另外其有一个Peers属性，内部包含了集群中所有的节点IP，所以从这里也能大概猜出这个网络是负责节点间通信的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364docker network inspect ingress## 输出[ &#123; &quot;Name&quot;: &quot;ingress&quot;, &quot;Id&quot;: &quot;idx465x3jg682fmceumsio297&quot;, &quot;Created&quot;: &quot;2025-06-08T07:29:51.734714967-04:00&quot;, &quot;Scope&quot;: &quot;swarm&quot;, &quot;Driver&quot;: &quot;overlay&quot;, &quot;EnableIPv6&quot;: false, &quot;IPAM&quot;: &#123; &quot;Driver&quot;: &quot;default&quot;, &quot;Options&quot;: null, &quot;Config&quot;: [ &#123; &quot;Subnet&quot;: &quot;10.0.0.0/24&quot;, &quot;Gateway&quot;: &quot;10.0.0.1&quot; &#125; ] &#125;, &quot;Internal&quot;: false, &quot;Attachable&quot;: false, &quot;Ingress&quot;: true, &quot;ConfigFrom&quot;: &#123; &quot;Network&quot;: &quot;&quot; &#125;, &quot;ConfigOnly&quot;: false, &quot;Containers&quot;: &#123; &quot;ingress-sbox&quot;: &#123; &quot;Name&quot;: &quot;ingress-endpoint&quot;, &quot;EndpointID&quot;: &quot;fd05086c5104e28c75dbed3e3b308236aaa0e87b698dad6186c23c81755bb009&quot;, &quot;MacAddress&quot;: &quot;02:42:0a:00:00:02&quot;, &quot;IPv4Address&quot;: &quot;10.0.0.2/24&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125; &#125;, &quot;Options&quot;: &#123; &quot;com.docker.network.driver.overlay.vxlanid_list&quot;: &quot;4096&quot; &#125;, &quot;Labels&quot;: &#123;&#125;, &quot;Peers&quot;: [ &#123; &quot;Name&quot;: &quot;4969a4611607&quot;, &quot;IP&quot;: &quot;10.211.55.10&quot; &#125;, &#123; &quot;Name&quot;: &quot;ae3756658a26&quot;, &quot;IP&quot;: &quot;10.211.55.14&quot; &#125;, &#123; &quot;Name&quot;: &quot;f12309731131&quot;, &quot;IP&quot;: &quot;10.211.55.13&quot; &#125;, &#123; &quot;Name&quot;: &quot;de5000b11067&quot;, &quot;IP&quot;: &quot;10.211.55.12&quot; &#125;, &#123; &quot;Name&quot;: &quot;377001904d63&quot;, &quot;IP&quot;: &quot;10.211.55.11&quot; &#125; ] &#125;] 我们还是先来看这个网关10.0.0.1，在哪呢？宿主机的网络设备中并没有，所以它应该是docker创建的，我们还是要从/var/run/docker/netns中查看一下，这里还有一个名称为 1-idx465x3jg 的网络命名空间，我们进去看看 12345678910111213141516nsenter --net=/var/run/docker/netns/1-idx465x3jg ip a## 输出1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever258: vxlan0@if258: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue master br0 state UNKNOWN group default link/ether 32:c9:a4:01:8a:19 brd ff:ff:ff:ff:ff:ff link-netnsid 02: br0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UP group default link/ether 32:c9:a4:01:8a:19 brd ff:ff:ff:ff:ff:ff inet 10.0.0.1/24 brd 10.0.0.255 scope global br0 valid_lft forever preferred_lft forever260: veth0@if259: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue master br0 state UP group default link/ether 8a:d3:52:ac:7d:cd brd ff:ff:ff:ff:ff:ff link-netnsid 1 在这里我们找到了2: br0，其IP地址为10.0.0.1，所以它就是我们要找的网关。其上面还挂载了两个网络设备，一个是 260: veth0@if259，这个就是与ingress_sbox 中259: eth0@if260对应的网络接口 ，另一个是 258: vxlan0@if258，其基于vxlan协议，负责集群跨主机通信。 overlay总结 docker_gwbridge中的容器ingress-sbox，其有两块网卡，一块对接宿主机上的 261: docker_gwbridge，另一块对接/var/run/docker/netns/1-idx465x3jg中的 2: br0。 实际上Swarm中的所有容器都有两个网卡，一块对接宿主机上的 261: docker_gwbridge，另一块对接/var/run/docker/netns/1-idx465x3jg中的 2: br0。 当请求到达宿主机时，会通过enp0s5转发到docker_gwbridge，然后先被转到ingress-sbox容器，然后再经过其转发到br0网关，再由它负责查找目标容器。如果目标容器不在本节点，则通过vxlan0网络接口转发到其它节点进行查找，中间经过一系列的网络地址转换。 当你通过docker network create --driver overlay my-network创建一个overlay网络时，Docker会创建一个类似“ingress”的网络结构(新的br0)，如果不指定ip段，其ip段会从10.0.1.0/24开始，依次递增一个网段。但会共用docker_gwbridge。 查看overlay网络中的负载均衡 启动一个service 1docker service create --name my-nginx --replicas 5 --publish 80:80 nginx 查看ingress_sbox的iptables数据链中的 mangle 表 123456789101112131415161718nsenter --net=/var/run/docker/netns/ingress_sbox iptables -nvL -t mangle## 输出结果，这里看到 PREROUTING 链中有一条监听80端口的规则，其被打了Mark标记: 0x105，换算为10进制：261Chain PREROUTING (policy ACCEPT 0 packets, 0 bytes) pkts bytes target prot opt in out source destination 0 0 MARK tcp -- * * 0.0.0.0/0 0.0.0.0/0 tcp dpt:80 MARK set 0x105Chain INPUT (policy ACCEPT 0 packets, 0 bytes) pkts bytes target prot opt in out source destination 0 0 MARK all -- * * 0.0.0.0/0 10.0.0.33 MARK set 0x105Chain FORWARD (policy ACCEPT 0 packets, 0 bytes) pkts bytes target prot opt in out source destinationChain OUTPUT (policy ACCEPT 0 packets, 0 bytes) pkts bytes target prot opt in out source destinationChain POSTROUTING (policy ACCEPT 0 packets, 0 bytes) pkts bytes target prot opt in out source destination 通过ipvsadm查看负载均衡信息 ipvsadm 是 Linux 下管理 IPVS（IP Virtual Server）负载均衡器的命令之一 12345678910111213141516171819202122232425# 如果没有ipvsadm，则安装dnf install ipvsadm -y# 查看ipvs信息nsenter --net=/var/run/docker/netns/ingress_sbox ipvsadm -Ln# -L：表示列出当前 IPVS 的规则和状态（List）。# -n：表示以数字方式显示地址和端口，而不进行 DNS 解析或端口名解析（即：IP 和端口号以数字显示，更直观，也更快）。## 输出，可以看到 FWM 261 rr，这里rr表示轮询IP Virtual Server version 1.2.1 (size=4096)Prot LocalAddress:Port Scheduler Flags -&gt; RemoteAddress:Port Forward Weight ActiveConn InActConnFWM 261 rr -&gt; 10.0.0.34:0 Masq 1 0 0 -&gt; 10.0.0.35:0 Masq 1 0 0 -&gt; 10.0.0.36:0 Masq 1 0 0 -&gt; 10.0.0.37:0 Masq 1 0 0 -&gt; 10.0.0.38:0 Masq 1 0 0## 输出解释# Prot: 协议（TCP/UDP）,这里是 FWM，表示Firewall Mark（防火墙标记）模式# LocalAddress:Port: 本地地址和端口号，这里是 261 ，这是防火墙标记值（mark 值）,就是上面看到的那个16进制 0x105# Scheduler: 调度算法，这里是 rr，表示轮询(round-robin)，调度算法还有 wrr（加权轮询）、lc（最少连接）等# RemoteAddress:Port: 远程地址和端口号，这里是 10.0.0.34:0，表示负载均衡到的第一个节点，后面同理# Forward: 转发策略，这里是 Masq，表示将负载均衡到的节点的IP地址转换成宿主机的IP地址，即 Masquerade（伪装）。转发方式（如：Masq、Tunnel、Direct Route）# Weight: 权重，这里是 1，表示负载均衡到的节点的权重，默认为 1# ActiveConn: 当前活动连接数，这里是 0# InActConn: 当前不活动连接数（等待关闭的连接），这里是 0 VXLAN是什么？ VXLAN（Virtual Extensible LAN）是 Cisco 公司开发的一种虚拟局域网（VLAN）技术，它可以将多个 VLAN 逻辑分组，并使用单个物理网络进行管理。VXLAN 的主要作用是提高网络性能和扩展性。 它本质上是一种 网络封装协议（overlay protocol），用来在已有的 IP 网络之上，构建二层（L2）虚拟网络。 为什么需要 VXLAN？ 在传统数据中心或云计算中，经常有这样的需求： 跨不同物理网络或子网，部署在不同服务器上的虚拟机或容器，要能像在同一个二层网络里一样直接通信。 VLAN（802.1Q）提供的二层隔离能力只有 12 bit VLAN ID（最多 4096 个 VLAN），在大型数据中心远远不够用。 数据中心想要更好的弹性、跨区域部署、容器编排、大规模租户隔离。 VXLAN 核心原理 VXLAN 通过封装的方式，把二层以太网帧包在 UDP 数据报里，在三层 IP 网络中传递。 封装格式大致是： 123456789+-------------------------+| 外层IP头 (IP Header) |+-------------------------+| 外层UDP头 (UDP Header) |+-------------------------+| VXLAN头 (VXLAN Header) |+-------------------------+| 内层二层帧 (Ethernet) |+-------------------------+ 外层 IP/UDP 用于三层传输 内层保留原本的二层以太网帧（如 MAC 地址） VXLAN 头部里面包含了一个 VNI (VXLAN Network Identifier)：24 bit，可支持 1600万个虚拟网络 简单示意图 1234567VM1 (10.1.1.1) ——&gt; VTEP1 ——&gt; Underlay IP网络 ——&gt; VTEP2 ——&gt; VM2 (10.1.1.2)VTEP1 封装： 内层以太网帧 + VXLAN头 (VNI) + UDP + IPVTEP2 解封装： 去掉外层头部，还原原始二层帧","summary":"摘要 本文介绍 Docker Swarm 的 网络(Overlay) Docker官方文档 Docker Swarm 官方文档","date_published":"2025-06-11T13:30:05.000Z","tags":["技术","docker","docker"]},{"id":"https://blog.hanqunfeng.com/2025/06/10/docker-swarm-service/","url":"https://blog.hanqunfeng.com/2025/06/10/docker-swarm-service/","title":"Docker Swarm 之 服务(Service)","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 Docker Swarm 的 服务管理</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com\">Docker官方文档</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com/engine/swarm/\">Docker Swarm 官方文档</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Service-与-Task\">Service 与 Task</h2>\n<h3 id=\"什么是-Service？\">什么是 Service？</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Service 是用户定义的服务抽象，一个 Service 表示你希望在 Swarm 集群中运行的某个“应用”。</p>\n</li>\n<li class=\"lvl-2\">\n<p>它定义了你要运行的容器镜像、启动命令、副本数量、网络配置、环境变量、端口映射等信息。</p>\n</li>\n<li class=\"lvl-2\">\n<p>可以类比成 Kubernetes 中的 Deployment，代表的是“期望状态”。</p>\n</li>\n</ul>\n<h3 id=\"什么是-Task？\">什么是 Task？</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Task 是 Service 的实际执行实例，Swarm 会根据 Service 的配置生成 Task。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Service中的每个副本对应一个 Task，每一个 Task 代表一个要在某个节点上运行的容器。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Task 的状态由 Swarm 管理，它负责启动、调度、重启等生命周期操作。</p>\n</li>\n<li class=\"lvl-2\">\n<p>当某个 Task 崩溃，Swarm 会自动重新调度一个新的 Task 来替代它。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Task 是不可变的，一旦创建不能修改，更新 Service 会创建新的 Task。</p>\n</li>\n</ul>\n<h3 id=\"示例\">示例</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建一个名为 nginx 的 Service，并指定镜像为 nginx:latest，并设置副本数为 3。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker service create --name nginx --replicas 3 nginx:latest</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里创建了一个名为 nginx 的 Service，并设置了副本数为 3，即Swarm会创建3个Task来完成这个任务，每个 Task 最终会对应一个具体的nginx容器。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th>Service</th>\n<th>Task</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>定义</td>\n<td>用户定义的服务配置</td>\n<td>服务配置生成的执行单元</td>\n</tr>\n<tr>\n<td>数量关系</td>\n<td>一个 Service 包含多个 Task</td>\n<td>一个 Task 属于一个 Service</td>\n</tr>\n<tr>\n<td>状态</td>\n<td>描述“期望状态”</td>\n<td>代表“实际状态”</td>\n</tr>\n<tr>\n<td>生命周期</td>\n<td>可以更新</td>\n<td>不可变，更新意味着重新创建</td>\n</tr>\n<tr>\n<td>管理者</td>\n<td>由用户管理</td>\n<td>完全由 Swarm 调度和管理</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Service-相关命令\">Service 相关命令</h2>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>中文说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>create</td>\n<td>创建一个新的服务</td>\n</tr>\n<tr>\n<td>inspect</td>\n<td>显示一个或多个服务的详细信息</td>\n</tr>\n<tr>\n<td>logs</td>\n<td>获取服务或任务的日志</td>\n</tr>\n<tr>\n<td>ls</td>\n<td>列出所有服务</td>\n</tr>\n<tr>\n<td>ps</td>\n<td>列出一个或多个服务的任务（Task）</td>\n</tr>\n<tr>\n<td>rm</td>\n<td>删除一个或多个服务</td>\n</tr>\n<tr>\n<td>rollback</td>\n<td>回滚服务的配置更改</td>\n</tr>\n<tr>\n<td>scale</td>\n<td>扩缩一个或多个可复制服务的副本数量</td>\n</tr>\n<tr>\n<td>update</td>\n<td>更新服务配置</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"docker-service-create-创建服务\"><code>docker service create</code>:  创建服务</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>常用参数说明</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n<th>示例命令（含说明）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>--name</code></td>\n<td>指定服务名称</td>\n<td><code>docker service create --name my-web nginx</code><br>→ 创建一个名为 <code>my-web</code> 的 nginx 服务</td>\n</tr>\n<tr>\n<td><code>--replicas</code></td>\n<td>设置副本数量（仅适用于 replicated 模式）</td>\n<td><code>docker service create --replicas 3 nginx</code><br>→ 启动 3 个 nginx 副本</td>\n</tr>\n<tr>\n<td><code>--publish</code> 或 <code>-p</code></td>\n<td>映射端口（格式如 <code>80:80</code>）</td>\n<td><code>docker service create -p 8080:80 nginx</code><br>→ 将容器的 80 端口映射到主机 8080</td>\n</tr>\n<tr>\n<td><code>--env</code> 或 <code>-e</code></td>\n<td>设置环境变量</td>\n<td><code>docker service create -e ENV=prod nginx</code><br>→ 设置环境变量 <code>ENV=prod</code></td>\n</tr>\n<tr>\n<td><code>--mount</code></td>\n<td>设置数据卷挂载</td>\n<td><code>docker service create --mount type=bind,src=/data,target=/app nginx</code><br>→ 将主机的 <code>/data</code> 目录挂载到容器内 <code>/app</code></td>\n</tr>\n<tr>\n<td><code>--constraint</code></td>\n<td>设置部署约束（如指定节点）</td>\n<td><code>docker service create --constraint 'node.labels.type == web' nginx</code><br>→ 仅部署在带标签 <code>type=web</code> 的节点上</td>\n</tr>\n<tr>\n<td><code>--network</code></td>\n<td>指定服务所属的网络（通常使用 overlay 网络）</td>\n<td><code>docker service create --network my-net nginx</code><br>→ 将服务连接到自定义网络 <code>my-net</code></td>\n</tr>\n<tr>\n<td><code>--detach</code> 或 <code>-d</code></td>\n<td>后台运行服务（默认行为）</td>\n<td><code>docker service create -d nginx</code><br>→ 后台创建服务，不阻塞终端，因为是默认行为，所以不加 -d 也是一样的，service不支持像 docker run 那样支持前台运行</td>\n</tr>\n<tr>\n<td><code>--limit-cpu</code> / <code>--limit-memory</code></td>\n<td>设置资源限制</td>\n<td><code>docker service create --limit-cpu 0.5 --limit-memory 256M nginx</code><br>→ 每个任务最多使用 0.5 个 CPU 和 256MB 内存</td>\n</tr>\n<tr>\n<td><code>--restart-condition</code></td>\n<td>设置重启策略（如 on-failure、any、none）</td>\n<td><code>docker service create --restart-condition on-failure nginx</code><br>→ 仅当容器失败时自动重启</td>\n</tr>\n<tr>\n<td><code>--mode</code></td>\n<td>指定服务运行模式，支持：<code>replicated</code>、<code>global</code>、<code>replicated-job</code>、<code>global-job</code></td>\n<td><code>docker service create --mode global nginx</code><br>→ 在集群每个节点上运行一个 nginx 实例</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>cpu 与 内存限制</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>--limit-cpu 1.0</code></td>\n<td>限制每个容器最多使用 1 核 CPU时间 , 1 CPU = 在每个调度周期中可占满 CPU 的全部时间份额(一个周期时间默认100ms)</td>\n</tr>\n<tr>\n<td><code>--limit-cpu 0.5</code></td>\n<td>限制每个容器最多使用 50% 的单核CPU时间</td>\n</tr>\n<tr>\n<td><code>--limit-cpu 3.5</code></td>\n<td>每个容器最多可以使用 3.5 核的 CPU 时间，由调度器决定分配。并不是限制成只能跑在一个核上，而是限制“总共使用不超过 3.5 核的时间片”。</td>\n</tr>\n<tr>\n<td><code>--limit-memory 512M</code></td>\n<td>限制每个容器最多使用指定内存（如 512M）</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>服务运行模式（–mode）详解</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>模式名称</th>\n<th>说明</th>\n<th>使用场景示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>replicated</code></td>\n<td>默认模式。用户指定需要运行多少个副本，Swarm 在合适的节点上调度这些副本。</td>\n<td>典型的 Web 服务，如 nginx、Node.js、Java 应用等</td>\n</tr>\n<tr>\n<td><code>global</code></td>\n<td>每个可用节点只部署一个任务实例，不需要用户指定副本数。</td>\n<td>系统级服务，如日志收集器（Fluentd）、监控代理（Prometheus node exporter）</td>\n</tr>\n<tr>\n<td><code>replicated-job</code></td>\n<td>在多个节点上<strong>按副本数</strong>运行一次性任务，任务完成后即退出。</td>\n<td>数据处理、批处理任务，如转换文件或跑 ETL</td>\n</tr>\n<tr>\n<td><code>global-job</code></td>\n<td>在<strong>所有节点上各运行一次</strong>的短暂任务，执行完毕即退出。</td>\n<td>初始化脚本、每台机器上运行一次的数据清洗、初始化环境任务等</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>job 模式通常配合镜像中设定的入口命令使用，不适用于长期运行的服务。<br>\nreplicated 和 global 模式适用于持续运行的服务，Swarm 会自动重启失败的任务。</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>服务重启策略（–restart-condition）详解</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>含义说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>none</code></td>\n<td>不重启任务。即使任务失败，也不会尝试恢复。适用于短生命周期的任务或测试服务。</td>\n</tr>\n<tr>\n<td><code>on-failure</code></td>\n<td><strong>仅在任务异常失败时</strong>（exit code 非 0）自动重启。常用于可能偶发失败的服务。</td>\n</tr>\n<tr>\n<td><code>any</code>（默认）</td>\n<td><strong>无论任务如何退出</strong>（包括正常退出或失败），都会尝试重启。适用于持续运行服务。</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>情景总结</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>情景</th>\n<th><code>none</code></th>\n<th><code>on-failure</code></th>\n<th><code>any</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>服务运行时崩溃（exit code ≠ 0）</td>\n<td>❌ 不重启</td>\n<td>✅ 自动重启</td>\n<td>✅ 自动重启</td>\n</tr>\n<tr>\n<td>服务正常结束（exit code = 0）</td>\n<td>❌ 不重启</td>\n<td>❌ 不重启</td>\n<td>✅ 自动重启</td>\n</tr>\n<tr>\n<td>持续运行型服务（如 nginx）</td>\n<td>❌ 不推荐</td>\n<td>可用</td>\n<td>✅ 推荐</td>\n</tr>\n<tr>\n<td>一次性任务（如批处理、数据初始化）</td>\n<td>✅ 推荐</td>\n<td>可用</td>\n<td>❌ 不推荐</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"docker-service-create-使用示例\"><code>docker service create</code> 使用示例</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建一个名为 my-nginx 的服务，并指定 3 个副本，将 80 端口映射到主机的 80 端口，并使用 nginx 镜像</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 此时在浏览器中输入Swarm中任意节点的IP地址，即可访问到Nginx服务，即使任务没有被分配到这个节点，也能访问到Nginx服务，这就是Swarm的负载均衡功能</span></span><br><span class=\"line\">docker service create \\</span><br><span class=\"line\">  --name my-nginx \\</span><br><span class=\"line\">  --replicas 3 \\</span><br><span class=\"line\">  --publish 80:80 \\</span><br><span class=\"line\">  nginx</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建一个名为 log-agent 的全局服务，并使用 fluentd 镜像，即每个节点都会运行一个 fluentd 容器</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># global</span></span><br><span class=\"line\">docker service create --name log-agent --mode global fluentd</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建一个名称为 web-app 的服务，并设置环境变量 NODE_ENV=production ，挂载 /data 目录到容器的 /app/data 目录，并设置 2 个副本，并且指定启动容器的命令为 node server.js</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker service create \\</span><br><span class=\"line\">  --name web-app \\</span><br><span class=\"line\">  --<span class=\"built_in\">env</span> NODE_ENV=production \\</span><br><span class=\"line\">  --mount <span class=\"built_in\">type</span>=<span class=\"built_in\">bind</span>,src=/data,target=/app/data \\</span><br><span class=\"line\">  --replicas 2 \\</span><br><span class=\"line\">  node:18 node server.js</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建一个名称为 db 的服务，并指定运行在具有 role=db 标签的节点上，并且使用名为 db-data 的卷挂载数据</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建数据卷</span></span><br><span class=\"line\">docker volume create db-data</span><br><span class=\"line\"><span class=\"comment\"># 创建服务</span></span><br><span class=\"line\">docker service create \\</span><br><span class=\"line\">  --name db \\</span><br><span class=\"line\">  --constraint <span class=\"string\">&#x27;node.labels.role == db&#x27;</span> \\</span><br><span class=\"line\">  --mount <span class=\"built_in\">type</span>=volume,<span class=\"built_in\">source</span>=db-data,target=/var/lib/mysql \\</span><br><span class=\"line\">  mysql:8</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>使用 on-failure 策略，仅在失败时自动重启</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker service create \\</span><br><span class=\"line\">  --name unstable-worker \\</span><br><span class=\"line\">  --restart-condition on-failure \\</span><br><span class=\"line\">  my-worker-image</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>指定网络，网络驱动类型为 overlay</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 先在manager节点上创建一个 overlay 网络（适用于 Swarm 模式）</span></span><br><span class=\"line\">docker network create --driver overlay my-overlay-net</span><br><span class=\"line\"><span class=\"comment\"># 创建驱动类型为 overlay 的网络，会立即同步所有 manager 节点，但不会同步到 worker 节点，只有当任务被分配到 worker 节点时，该网络才会同步到 worker 节点</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建服务并加入该网络</span></span><br><span class=\"line\">docker service create \\</span><br><span class=\"line\">  --name web-service \\</span><br><span class=\"line\">  --network my-overlay-net \\</span><br><span class=\"line\">  --replicas 5 \\</span><br><span class=\"line\">  nginx</span><br><span class=\"line\">  <span class=\"comment\"># --network: 指定服务运行时连接到该网络，这样在同一个网络中的服务之间可以使用 服务名互相访问，实现服务发现和负载均衡。</span></span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>小贴士</strong></em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker network <span class=\"built_in\">ls</span></span><br><span class=\"line\">NETWORK ID     NAME              DRIVER    SCOPE</span><br><span class=\"line\">6b7aadbbd180   bridge            bridge    <span class=\"built_in\">local</span></span><br><span class=\"line\">5ddadf5d0608   docker_gwbridge   bridge    <span class=\"built_in\">local</span></span><br><span class=\"line\">21c6f5b1bedd   host              host      <span class=\"built_in\">local</span></span><br><span class=\"line\">idx465x3jg68   ingress           overlay   swarm</span><br><span class=\"line\">a770c5ad4b13   none              null      <span class=\"built_in\">local</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">初始化Swarm集群后，会创建一个默认的 overlay 网络: ingress，如果我们创建服务时没有指定网络，那么服务就会加入 ingress 网络。</li>\n<li class=\"lvl-2\">但是这个默认的 ingress 网络并不能用于服务之间通过服务名称互相访问，但可以通过IP或Hostname访问服务。</li>\n<li class=\"lvl-2\">默认的 ingress 网络仅用于 ingress 负载均衡（即 -p 端口映射），不支持服务内部通信或 DNS 服务发现。</li>\n<li class=\"lvl-2\">另外，初始化Swarm集群后，还会创建一个默认的 bridge 网络: docker_gwbridge，负责连接 Swarm 集群的 Overlay 网络与宿主机网络，负责跨节点的流量转发\n<ul class=\"lvl-3\">\n<li class=\"lvl-4\">当一个容器在 Overlay 网络里访问外部 IP，比如访问公网，流量最终通过 docker_gwbridge 网络出口出去。</li>\n<li class=\"lvl-4\">节点间 VXLAN 隧道的流量也会借助此网络桥接到宿主机的物理网络接口。</li>\n</ul>\n</li>\n</ul>\n</div>\n<h3 id=\"docker-service-ls-列出所有服务\"><code>docker service ls</code>: 列出所有服务</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker service <span class=\"built_in\">ls</span></span><br><span class=\"line\">ID             NAME       MODE         REPLICAS   IMAGE          PORTS</span><br><span class=\"line\">dmnztimv3pb8   my-nginx   replicated   2/2        nginx:latest   *:80-&gt;80/tcp</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-service-inspect-查看服务详情\"><code>docker service inspect</code>: 查看服务详情</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker service inspect my-nginx</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-service-log-查看服务日志\"><code>docker service log</code>: 查看服务日志</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看指定服务下所有任务的日志</span></span><br><span class=\"line\">docker service logs my-nginx</span><br><span class=\"line\"><span class=\"comment\"># 查看指定任务的日志，指定任务ID，不支持任务名称</span></span><br><span class=\"line\">docker service logs p4tats0f9npk</span><br><span class=\"line\"><span class=\"comment\"># 滚动查看日志</span></span><br><span class=\"line\">docker service logs -f my-nginx</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-service-ps-列出服务任务\"><code>docker service ps</code>: 列出服务任务</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker service ps my-nginx</span><br><span class=\"line\">ID             NAME         IMAGE          NODE       DESIRED STATE   CURRENT STATE            ERROR     PORTS</span><br><span class=\"line\">p4tats0f9npk   my-nginx.1   nginx:latest   manager1   Running         Running 13 minutes ago</span><br><span class=\"line\">v7z383xy7dso   my-nginx.2   nginx:latest   manager2   Running         Running 15 minutes ago</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-service-scale-扩容-缩容服务\"><code>docker service scale</code>: 扩容/缩容服务</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启动一个服务</span></span><br><span class=\"line\">docker service create \\</span><br><span class=\"line\">  --name my-nginx \\</span><br><span class=\"line\">  --replicas 3 \\</span><br><span class=\"line\">  --publish 80:80 \\</span><br><span class=\"line\">  nginx</span><br><span class=\"line\"><span class=\"comment\"># 查看服务任务</span></span><br><span class=\"line\">docker service ps my-nginx</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">ID             NAME         IMAGE          NODE       DESIRED STATE   CURRENT STATE            ERROR     PORTS</span><br><span class=\"line\">p4tats0f9npk   my-nginx.1   nginx:latest   manager1   Running         Running 14 seconds ago</span><br><span class=\"line\">v7z383xy7dso   my-nginx.2   nginx:latest   manager2   Running         Running 2 minutes ago</span><br><span class=\"line\">w0sm5ixvi6eb   my-nginx.3   nginx:latest   worker2    Running         Running 4 seconds ago</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 扩容到5个任务</span></span><br><span class=\"line\">docker service scale my-nginx=5</span><br><span class=\"line\"><span class=\"comment\"># 查看服务任务</span></span><br><span class=\"line\">docker service ps my-nginx</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">ID             NAME         IMAGE          NODE       DESIRED STATE   CURRENT STATE                    ERROR     PORTS</span><br><span class=\"line\">p4tats0f9npk   my-nginx.1   nginx:latest   manager1   Running         Running about a minute ago</span><br><span class=\"line\">v7z383xy7dso   my-nginx.2   nginx:latest   manager2   Running         Running 3 minutes ago</span><br><span class=\"line\">w0sm5ixvi6eb   my-nginx.3   nginx:latest   worker2    Running         Running about a minute ago</span><br><span class=\"line\">ksbeflwg3mcj   my-nginx.4   nginx:latest   worker1    Running         Running less than a second ago</span><br><span class=\"line\">iw4zlm56n1x8   my-nginx.5   nginx:latest   manager3   Running         Running less than a second ago</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 缩容到2个人任务</span></span><br><span class=\"line\">docker service scale my-nginx=2</span><br><span class=\"line\"><span class=\"comment\"># 查看服务任务</span></span><br><span class=\"line\">docker service ps my-nginx</span><br><span class=\"line\">ID             NAME         IMAGE          NODE       DESIRED STATE   CURRENT STATE           ERROR     PORTS</span><br><span class=\"line\">p4tats0f9npk   my-nginx.1   nginx:latest   manager1   Running         Running 2 minutes ago</span><br><span class=\"line\">v7z383xy7dso   my-nginx.2   nginx:latest   manager2   Running         Running 4 minutes ago</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 还可以使用如下命令进行扩缩容</span></span><br><span class=\"line\">docker service update --replicas=5 my-nginx</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-service-update-更新服务\"><code>docker service update</code>: 更新服务</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>支持的参数</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>--image</code></td>\n<td>更新服务使用的镜像</td>\n<td><code>--image nginx:1.25</code></td>\n</tr>\n<tr>\n<td><code>--replicas</code></td>\n<td>设置服务的副本数量（仅适用于 replicated 模式）</td>\n<td><code>--replicas 5</code></td>\n</tr>\n<tr>\n<td><code>--env-add</code></td>\n<td>添加环境变量</td>\n<td><code>--env-add DEBUG=true</code></td>\n</tr>\n<tr>\n<td><code>--env-rm</code></td>\n<td>移除环境变量</td>\n<td><code>--env-rm OLD_VAR</code></td>\n</tr>\n<tr>\n<td><code>--publish-add</code></td>\n<td>添加端口映射</td>\n<td><code>--publish-add published=8080,target=80</code></td>\n</tr>\n<tr>\n<td><code>--publish-rm</code></td>\n<td>移除端口映射</td>\n<td><code>--publish-rm 80</code></td>\n</tr>\n<tr>\n<td><code>--mount-add</code></td>\n<td>添加挂载</td>\n<td><code>--mount-add type=bind,src=/data,dst=/data</code></td>\n</tr>\n<tr>\n<td><code>--mount-rm</code></td>\n<td>移除挂载</td>\n<td><code>--mount-rm /data</code></td>\n</tr>\n<tr>\n<td><code>--constraint-add</code></td>\n<td>添加部署约束</td>\n<td><code>--constraint-add 'node.labels.zone==east'</code></td>\n</tr>\n<tr>\n<td><code>--constraint-rm</code></td>\n<td>移除部署约束</td>\n<td><code>--constraint-rm 'node.labels.zone==east'</code></td>\n</tr>\n<tr>\n<td><code>--limit-cpu</code></td>\n<td>设置 CPU 限制</td>\n<td><code>--limit-cpu 0.5</code></td>\n</tr>\n<tr>\n<td><code>--limit-memory</code></td>\n<td>设置内存限制</td>\n<td><code>--limit-memory 256M</code></td>\n</tr>\n<tr>\n<td><code>--restart-condition</code></td>\n<td>设置重启策略（none、on-failure、any）</td>\n<td><code>--restart-condition on-failure</code></td>\n</tr>\n<tr>\n<td><code>--update-delay</code></td>\n<td>设置任务更新之间的延迟</td>\n<td><code>--update-delay 10s</code></td>\n</tr>\n<tr>\n<td><code>--update-parallelism</code></td>\n<td>设置并发更新任务的数量</td>\n<td><code>--update-parallelism 2</code></td>\n</tr>\n<tr>\n<td><code>--update-order</code></td>\n<td>设置更新顺序（start-first 或 stop-first）</td>\n<td><code>--update-order start-first</code></td>\n</tr>\n<tr>\n<td><code>--update-failure-action</code></td>\n<td>更新失败后的动作（pause、continue、rollback）</td>\n<td><code>--update-failure-action rollback</code></td>\n</tr>\n<tr>\n<td><code>--rollback</code></td>\n<td>回滚到上一次成功配置</td>\n<td><code>--rollback</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker service update \\</span><br><span class=\"line\">  --image nginx:1.25 \\</span><br><span class=\"line\">  --replicas 4 \\</span><br><span class=\"line\">  --env-add ENV=prod \\</span><br><span class=\"line\">  --limit-memory 512M \\</span><br><span class=\"line\">  --limit-cpu 1.0 \\</span><br><span class=\"line\">  --update-delay 10s \\</span><br><span class=\"line\">  --update-parallelism 2 \\</span><br><span class=\"line\">  --update-failure-action rollback \\</span><br><span class=\"line\">  my-nginx</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-service-rollback-回滚服务\"><code>docker service rollback</code>: 回滚服务</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>会将服务回滚到上一次成功部署的版本，包括镜像、环境变量、部署约束等。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># docker service rollback &lt;service_name&gt;</span></span><br><span class=\"line\">docker service rollback my-nginx</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-service-rm-删除服务\"><code>docker service rm</code>: 删除服务</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>删除服务会停止服务并删除服务。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># docker service rm &lt;service_name&gt;</span></span><br><span class=\"line\">docker service <span class=\"built_in\">rm</span> my-nginx</span><br></pre></td></tr></table></figure>\n<h2 id=\"经验技巧\">经验技巧</h2>\n<h3 id=\"如何让任务运行在指定的节点上？\">如何让任务运行在指定的节点上？</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建服务时，可以使用 <code>--constraint</code> 参数指定节点的标签，使其运行在具有指定标签的节点上。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 给结点加标签</span></span><br><span class=\"line\">docker node update --label-add <span class=\"built_in\">env</span>=prod worker1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># node.labels 是Swarm内置属性，表示节点的标签，这里指定节点标签为 env=prod</span></span><br><span class=\"line\">docker service create \\</span><br><span class=\"line\">--name my-nginx \\</span><br><span class=\"line\">--replicas 2 \\</span><br><span class=\"line\">--constraint <span class=\"string\">&#x27;node.labels.env == prod&#x27;</span> \\</span><br><span class=\"line\">nginx:latest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 这里要注意，运行任务后如果修改了node的标签，那么任务就会重新分配，分配是如果找不到符合标签的节点，就会运行失败。</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>只能运行在管理节点上</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># node.role 是 Swarm 的内置属性，表示节点的类型，值为 manager 或 worker。</span></span><br><span class=\"line\">docker service create \\</span><br><span class=\"line\">  --name manager-only-service \\</span><br><span class=\"line\">  --constraint <span class=\"string\">&#x27;node.role == manager&#x27;</span> \\</span><br><span class=\"line\">  nginx</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Swarm 内置属性</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>示例值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>node.id</code></td>\n<td><code>node.id == abcd1234</code></td>\n<td>节点的唯一 ID（可用 <code>docker node ls</code> 查看）</td>\n</tr>\n<tr>\n<td><code>node.hostname</code></td>\n<td><code>node.hostname == manager-1</code></td>\n<td>节点主机名</td>\n</tr>\n<tr>\n<td><code>node.role</code></td>\n<td><code>node.role == manager</code> 或 <code>node.role == worker</code></td>\n<td>节点在 Swarm 中的角色（管理/工作）</td>\n</tr>\n<tr>\n<td><code>engine.labels.*</code></td>\n<td><code>engine.labels.disk == ssd</code></td>\n<td>Docker 引擎级别的标签（需手动设置）</td>\n</tr>\n<tr>\n<td><code>node.platform.os</code></td>\n<td><code>node.platform.os == linux</code></td>\n<td>节点操作系统类型</td>\n</tr>\n<tr>\n<td><code>node.platform.arch</code></td>\n<td><code>node.platform.arch == x86_64</code></td>\n<td>节点架构类型（如 <code>arm64</code>, <code>x86_64</code>）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"如何访问Service服务？\">如何访问Service服务？</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启动一个service，3个副本，镜像为 whoami，这个镜像会返回当前访问的容器的ID，即返回的Hostname</span></span><br><span class=\"line\">docker service create --name <span class=\"built_in\">whoami</span> \\</span><br><span class=\"line\">  --replicas 3 \\</span><br><span class=\"line\">  -p 80:80 \\</span><br><span class=\"line\">  traefik/whoami</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看service服务运行在哪些节点上，看到这里只有 manager1\\manager2\\worker2 节点上运行，注意这里看到的ID是Task ID，并非容器ID</span></span><br><span class=\"line\">docker service ps <span class=\"built_in\">whoami</span></span><br><span class=\"line\">ID             NAME       IMAGE                   NODE       DESIRED STATE   CURRENT STATE            ERROR     PORTS</span><br><span class=\"line\">u1elzp22hyvm   whoami.1   traefik/whoami:latest   manager2   Running         Running 2 minutes ago</span><br><span class=\"line\">4cent1kfgghb   whoami.2   traefik/whoami:latest   worker2    Running         Running 17 seconds ago</span><br><span class=\"line\">lu6u6j8ji0uq   whoami.3   traefik/whoami:latest   manager1   Running         Running 40 seconds ago</span><br><span class=\"line\"><span class=\"comment\"># 如果希望查询某个Service的所有容器的ID，可以执行如下命令</span></span><br><span class=\"line\">docker service ps <span class=\"built_in\">whoami</span> -q | xargs docker inspect --format <span class=\"string\">&#x27;&#123;&#123;.Status.ContainerStatus.ContainerID&#125;&#125;&#x27;</span> | <span class=\"built_in\">cut</span> -c 1-12</span><br><span class=\"line\">a3fb63bde8e7</span><br><span class=\"line\">a14e30a02987</span><br><span class=\"line\">549610f3a1e9</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时我们通过curl访问 Swarm 集群中的任意一个节点的IP，都可以访问到这个服务，比如 <code>curl 10.211.55.12</code>，这是 manager3 节点的 IP 地址，虽然这个服务并没有在 manager3 节点上运行，但是我们依旧可以访问到这个服务，不仅如此，每次运行命令返回的Hostname(就是容器ID)都会发生变化，其效果就是在各个运行的容器间轮询，这就是 Swarm 集群的负载均衡效果。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http://10.211.55.12</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">Hostname: a3fb63bde8e7   <span class=\"comment\"># 容器ID</span></span><br><span class=\"line\">IP: 127.0.0.1</span><br><span class=\"line\">IP: ::1</span><br><span class=\"line\">IP: 10.0.0.36            <span class=\"comment\"># 容器IP，对接 br0</span></span><br><span class=\"line\">IP: 172.18.0.4           <span class=\"comment\"># 容器IP，对接 docker_gwbridge</span></span><br><span class=\"line\">RemoteAddr: 10.0.0.6:52964</span><br><span class=\"line\">GET / HTTP/1.1</span><br><span class=\"line\">Host: 10.211.55.12</span><br><span class=\"line\">User-Agent: curl/7.61.1</span><br><span class=\"line\">Accept: */*</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在集群内部访问服务，建议将所有服务运行在相同的network中，这样可以不同的service之间可以通过服务名称访问服务，在集群外部，可以通过nginx等代理访问服务。</p>\n</li>\n<li class=\"lvl-2\">\n<p>可以编写一个脚本方便查看service与container的运行关系，比如：docker_service_container</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># filename: docker_service_container</span></span><br><span class=\"line\"><span class=\"comment\"># 用法提示</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ -z <span class=\"string\">&quot;<span class=\"variable\">$1</span>&quot;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;用法: <span class=\"variable\">$0</span> &lt;SERVICE_NAME&gt;&quot;</span></span><br><span class=\"line\">  <span class=\"built_in\">exit</span> 1</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"comment\"># service名称</span></span><br><span class=\"line\">SERVCIE_NAME=<span class=\"variable\">$1</span></span><br><span class=\"line\"><span class=\"comment\"># 所属network,默认 ingress，这里要注意一下，如果是自定义的overlay网络，只能获取到当前主机上的容器IP</span></span><br><span class=\"line\">NETWORK=<span class=\"variable\">$2</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ -z <span class=\"string\">&quot;<span class=\"variable\">$2</span>&quot;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  NETWORK=$(docker service inspect <span class=\"variable\">$SERVCIE_NAME</span> --format <span class=\"string\">&#x27;&#123;&#123;json .Endpoint.VirtualIPs&#125;&#125;&#x27;</span> | jq <span class=\"string\">&#x27;.[0].NetworkID&#x27;</span> | sed <span class=\"string\">&#x27;s/&quot;//g&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># NETWORK=$&#123;2:-ingress&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">d1=$(<span class=\"built_in\">echo</span> -e <span class=\"string\">&quot;SERVICE-ID TASK-ID CONTAINER-ID NODE-ID&quot;</span> | awk <span class=\"string\">&#x27;&#123;printf &quot;%-12s    %-12s    %-12s    %-12s\\n&quot;, substr($1,1,12), substr($2,1,12), substr($3,1,12), substr($4,1,12)&#125;&#x27;</span> ;\\</span><br><span class=\"line\">docker service ps <span class=\"variable\">$SERVCIE_NAME</span> --filter <span class=\"string\">&quot;desired-state=running&quot;</span> -q | xargs docker inspect --format <span class=\"string\">&#x27;&#123;&#123;.ServiceID&#125;&#125;    &#123;&#123;.ID&#125;&#125;    &#123;&#123;.Status.ContainerStatus.ContainerID&#125;&#125;    &#123;&#123;.NodeID&#125;&#125;&#x27;</span> \\</span><br><span class=\"line\">| awk <span class=\"string\">&#x27;&#123;printf &quot;%-12s    %-12s    %-12s    %-12s\\n&quot;, substr($1,1,12), substr($2,1,12), substr($3,1,12), substr($4,1,12)&#125;&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#echo &quot;$d1&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">d2=$(docker service ps <span class=\"variable\">$SERVCIE_NAME</span> --filter <span class=\"string\">&quot;desired-state=running&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#echo &quot;$d2&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">nn1=$(awk <span class=\"string\">&#x27;</span></span><br><span class=\"line\"><span class=\"string\">NR==FNR &amp;&amp; FNR &gt; 1 &#123;</span></span><br><span class=\"line\"><span class=\"string\">  id = $1</span></span><br><span class=\"line\"><span class=\"string\">  name = $2</span></span><br><span class=\"line\"><span class=\"string\">  node = $4</span></span><br><span class=\"line\"><span class=\"string\">  desired = $5</span></span><br><span class=\"line\"><span class=\"string\">  # 拼接 CURRENT STATE（从第6列开始的所有字段）</span></span><br><span class=\"line\"><span class=\"string\">  current = &quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">  for (i=6; i&lt;=NF; i++) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    current = current $i &quot; &quot;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">  gsub(/ /, &quot;-&quot;, current)</span></span><br><span class=\"line\"><span class=\"string\">  current = substr(current, 1, length(current)-1)  # 去掉最后空格</span></span><br><span class=\"line\"><span class=\"string\">  info[id] = name &quot;\\t&quot; node &quot;\\t&quot; desired &quot;\\t&quot; current</span></span><br><span class=\"line\"><span class=\"string\">  next</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">FNR==1 &#123;</span></span><br><span class=\"line\"><span class=\"string\">  print $0 &quot;\\tTASK-NAME\\tNODE\\tDESIRED_STATE\\tCURRENT_STATE&quot;</span></span><br><span class=\"line\"><span class=\"string\">  next</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">  print $0 &quot;\\t&quot; info[$2]</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">&#x27;</span> &lt;(<span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$d2</span>&quot;</span>) &lt;(<span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$d1</span>&quot;</span>) | <span class=\"built_in\">tail</span> -n +2 | column -t)</span><br><span class=\"line\"></span><br><span class=\"line\">nn2=$(<span class=\"built_in\">echo</span> <span class=\"string\">&quot;CONTAINER-ID IP&quot;</span>;docker network inspect <span class=\"variable\">$&#123;NETWORK&#125;</span> -f <span class=\"string\">&#x27;&#123;&#123;range $id, $container := .Containers&#125;&#125;&#123;&#123;slice $id 0 12&#125;&#125; &#123;&#123;$container.Name&#125;&#125; &#123;&#123;$container.IPv4Address&#125;&#125;&#123;&#123;println&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;</span> | grep <span class=\"variable\">$SERVCIE_NAME</span> | awk -F <span class=\"string\">&quot; &quot;</span> <span class=\"string\">&#x27;&#123;print $1&quot; &quot;$3&#125;&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">awk <span class=\"string\">&#x27;</span></span><br><span class=\"line\"><span class=\"string\">NR==FNR &#123; ip[$1]=$2; next &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123; print $0, ip[$3] &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#x27;</span> &lt;(<span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$nn2</span>&quot;</span>) &lt;(<span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$nn1</span>&quot;</span>) | column -t</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>运行</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chmod</span> +x /usr/local/bin/docker-swarm-service</span><br><span class=\"line\"><span class=\"comment\"># 执行脚本</span></span><br><span class=\"line\">docker-swarm-service <span class=\"built_in\">whoami</span></span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">SERVICE-ID    TASK-ID       CONTAINER-ID  NODE-ID       TASK-NAME  NODE      DESIRED_STATE  CURRENT_STATE              IP</span><br><span class=\"line\">snuhv0g2dm1q  czisrjrp8k2t  9e4ce349971c  kp2zerd28xgz  whoami.1   manager1  Running        Running-about-an-hour-ago  10.0.0.35/24</span><br><span class=\"line\">snuhv0g2dm1q  tvbkwmnafedw  0d586021260d  kp2zerd28xgz  whoami.2   manager1  Running        Running-about-an-hour-ago  10.0.0.36/24</span><br><span class=\"line\">snuhv0g2dm1q  815qp859a1f4  449d5e1a231d  kp2zerd28xgz  whoami.3   manager1  Running        Running-about-an-hour-ago  10.0.0.15/24</span><br></pre></td></tr></table></figure>\n","content_text":"摘要 本文介绍 Docker Swarm 的 服务管理 Docker官方文档 Docker Swarm 官方文档 Service 与 Task 什么是 Service？ Service 是用户定义的服务抽象，一个 Service 表示你希望在 Swarm 集群中运行的某个“应用”。 它定义了你要运行的容器镜像、启动命令、副本数量、网络配置、环境变量、端口映射等信息。 可以类比成 Kubernetes 中的 Deployment，代表的是“期望状态”。 什么是 Task？ Task 是 Service 的实际执行实例，Swarm 会根据 Service 的配置生成 Task。 Service中的每个副本对应一个 Task，每一个 Task 代表一个要在某个节点上运行的容器。 Task 的状态由 Swarm 管理，它负责启动、调度、重启等生命周期操作。 当某个 Task 崩溃，Swarm 会自动重新调度一个新的 Task 来替代它。 Task 是不可变的，一旦创建不能修改，更新 Service 会创建新的 Task。 示例 创建一个名为 nginx 的 Service，并指定镜像为 nginx:latest，并设置副本数为 3。 1docker service create --name nginx --replicas 3 nginx:latest 这里创建了一个名为 nginx 的 Service，并设置了副本数为 3，即Swarm会创建3个Task来完成这个任务，每个 Task 最终会对应一个具体的nginx容器。 项目 Service Task 定义 用户定义的服务配置 服务配置生成的执行单元 数量关系 一个 Service 包含多个 Task 一个 Task 属于一个 Service 状态 描述“期望状态” 代表“实际状态” 生命周期 可以更新 不可变，更新意味着重新创建 管理者 由用户管理 完全由 Swarm 调度和管理 Service 相关命令 命令 中文说明 create 创建一个新的服务 inspect 显示一个或多个服务的详细信息 logs 获取服务或任务的日志 ls 列出所有服务 ps 列出一个或多个服务的任务（Task） rm 删除一个或多个服务 rollback 回滚服务的配置更改 scale 扩缩一个或多个可复制服务的副本数量 update 更新服务配置 docker service create: 创建服务 常用参数说明 参数 说明 示例命令（含说明） --name 指定服务名称 docker service create --name my-web nginx→ 创建一个名为 my-web 的 nginx 服务 --replicas 设置副本数量（仅适用于 replicated 模式） docker service create --replicas 3 nginx→ 启动 3 个 nginx 副本 --publish 或 -p 映射端口（格式如 80:80） docker service create -p 8080:80 nginx→ 将容器的 80 端口映射到主机 8080 --env 或 -e 设置环境变量 docker service create -e ENV=prod nginx→ 设置环境变量 ENV=prod --mount 设置数据卷挂载 docker service create --mount type=bind,src=/data,target=/app nginx→ 将主机的 /data 目录挂载到容器内 /app --constraint 设置部署约束（如指定节点） docker service create --constraint 'node.labels.type == web' nginx→ 仅部署在带标签 type=web 的节点上 --network 指定服务所属的网络（通常使用 overlay 网络） docker service create --network my-net nginx→ 将服务连接到自定义网络 my-net --detach 或 -d 后台运行服务（默认行为） docker service create -d nginx→ 后台创建服务，不阻塞终端，因为是默认行为，所以不加 -d 也是一样的，service不支持像 docker run 那样支持前台运行 --limit-cpu / --limit-memory 设置资源限制 docker service create --limit-cpu 0.5 --limit-memory 256M nginx→ 每个任务最多使用 0.5 个 CPU 和 256MB 内存 --restart-condition 设置重启策略（如 on-failure、any、none） docker service create --restart-condition on-failure nginx→ 仅当容器失败时自动重启 --mode 指定服务运行模式，支持：replicated、global、replicated-job、global-job docker service create --mode global nginx→ 在集群每个节点上运行一个 nginx 实例 cpu 与 内存限制 参数 意义 --limit-cpu 1.0 限制每个容器最多使用 1 核 CPU时间 , 1 CPU = 在每个调度周期中可占满 CPU 的全部时间份额(一个周期时间默认100ms) --limit-cpu 0.5 限制每个容器最多使用 50% 的单核CPU时间 --limit-cpu 3.5 每个容器最多可以使用 3.5 核的 CPU 时间，由调度器决定分配。并不是限制成只能跑在一个核上，而是限制“总共使用不超过 3.5 核的时间片”。 --limit-memory 512M 限制每个容器最多使用指定内存（如 512M） 服务运行模式（–mode）详解 模式名称 说明 使用场景示例 replicated 默认模式。用户指定需要运行多少个副本，Swarm 在合适的节点上调度这些副本。 典型的 Web 服务，如 nginx、Node.js、Java 应用等 global 每个可用节点只部署一个任务实例，不需要用户指定副本数。 系统级服务，如日志收集器（Fluentd）、监控代理（Prometheus node exporter） replicated-job 在多个节点上按副本数运行一次性任务，任务完成后即退出。 数据处理、批处理任务，如转换文件或跑 ETL global-job 在所有节点上各运行一次的短暂任务，执行完毕即退出。 初始化脚本、每台机器上运行一次的数据清洗、初始化环境任务等 job 模式通常配合镜像中设定的入口命令使用，不适用于长期运行的服务。 replicated 和 global 模式适用于持续运行的服务，Swarm 会自动重启失败的任务。 服务重启策略（–restart-condition）详解 值 含义说明 none 不重启任务。即使任务失败，也不会尝试恢复。适用于短生命周期的任务或测试服务。 on-failure 仅在任务异常失败时（exit code 非 0）自动重启。常用于可能偶发失败的服务。 any（默认） 无论任务如何退出（包括正常退出或失败），都会尝试重启。适用于持续运行服务。 情景总结 情景 none on-failure any 服务运行时崩溃（exit code ≠ 0） ❌ 不重启 ✅ 自动重启 ✅ 自动重启 服务正常结束（exit code = 0） ❌ 不重启 ❌ 不重启 ✅ 自动重启 持续运行型服务（如 nginx） ❌ 不推荐 可用 ✅ 推荐 一次性任务（如批处理、数据初始化） ✅ 推荐 可用 ❌ 不推荐 docker service create 使用示例 创建一个名为 my-nginx 的服务，并指定 3 个副本，将 80 端口映射到主机的 80 端口，并使用 nginx 镜像 123456# 此时在浏览器中输入Swarm中任意节点的IP地址，即可访问到Nginx服务，即使任务没有被分配到这个节点，也能访问到Nginx服务，这就是Swarm的负载均衡功能docker service create \\ --name my-nginx \\ --replicas 3 \\ --publish 80:80 \\ nginx 创建一个名为 log-agent 的全局服务，并使用 fluentd 镜像，即每个节点都会运行一个 fluentd 容器 12# globaldocker service create --name log-agent --mode global fluentd 创建一个名称为 web-app 的服务，并设置环境变量 NODE_ENV=production ，挂载 /data 目录到容器的 /app/data 目录，并设置 2 个副本，并且指定启动容器的命令为 node server.js 123456docker service create \\ --name web-app \\ --env NODE_ENV=production \\ --mount type=bind,src=/data,target=/app/data \\ --replicas 2 \\ node:18 node server.js 创建一个名称为 db 的服务，并指定运行在具有 role=db 标签的节点上，并且使用名为 db-data 的卷挂载数据 12345678# 创建数据卷docker volume create db-data# 创建服务docker service create \\ --name db \\ --constraint &#x27;node.labels.role == db&#x27; \\ --mount type=volume,source=db-data,target=/var/lib/mysql \\ mysql:8 使用 on-failure 策略，仅在失败时自动重启 1234docker service create \\ --name unstable-worker \\ --restart-condition on-failure \\ my-worker-image 指定网络，网络驱动类型为 overlay 1234567891011# 先在manager节点上创建一个 overlay 网络（适用于 Swarm 模式）docker network create --driver overlay my-overlay-net# 创建驱动类型为 overlay 的网络，会立即同步所有 manager 节点，但不会同步到 worker 节点，只有当任务被分配到 worker 节点时，该网络才会同步到 worker 节点# 创建服务并加入该网络docker service create \\ --name web-service \\ --network my-overlay-net \\ --replicas 5 \\ nginx # --network: 指定服务运行时连接到该网络，这样在同一个网络中的服务之间可以使用 服务名互相访问，实现服务发现和负载均衡。 小贴士 1234567docker network lsNETWORK ID NAME DRIVER SCOPE6b7aadbbd180 bridge bridge local5ddadf5d0608 docker_gwbridge bridge local21c6f5b1bedd host host localidx465x3jg68 ingress overlay swarma770c5ad4b13 none null local 初始化Swarm集群后，会创建一个默认的 overlay 网络: ingress，如果我们创建服务时没有指定网络，那么服务就会加入 ingress 网络。 但是这个默认的 ingress 网络并不能用于服务之间通过服务名称互相访问，但可以通过IP或Hostname访问服务。 默认的 ingress 网络仅用于 ingress 负载均衡（即 -p 端口映射），不支持服务内部通信或 DNS 服务发现。 另外，初始化Swarm集群后，还会创建一个默认的 bridge 网络: docker_gwbridge，负责连接 Swarm 集群的 Overlay 网络与宿主机网络，负责跨节点的流量转发 当一个容器在 Overlay 网络里访问外部 IP，比如访问公网，流量最终通过 docker_gwbridge 网络出口出去。 节点间 VXLAN 隧道的流量也会借助此网络桥接到宿主机的物理网络接口。 docker service ls: 列出所有服务 123docker service lsID NAME MODE REPLICAS IMAGE PORTSdmnztimv3pb8 my-nginx replicated 2/2 nginx:latest *:80-&gt;80/tcp docker service inspect: 查看服务详情 1docker service inspect my-nginx docker service log: 查看服务日志 123456# 查看指定服务下所有任务的日志docker service logs my-nginx# 查看指定任务的日志，指定任务ID，不支持任务名称docker service logs p4tats0f9npk# 滚动查看日志docker service logs -f my-nginx docker service ps: 列出服务任务 1234docker service ps my-nginxID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTSp4tats0f9npk my-nginx.1 nginx:latest manager1 Running Running 13 minutes agov7z383xy7dso my-nginx.2 nginx:latest manager2 Running Running 15 minutes ago docker service scale: 扩容/缩容服务 12345678910111213141516171819202122232425262728293031323334353637# 启动一个服务docker service create \\ --name my-nginx \\ --replicas 3 \\ --publish 80:80 \\ nginx# 查看服务任务docker service ps my-nginx## 输出ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTSp4tats0f9npk my-nginx.1 nginx:latest manager1 Running Running 14 seconds agov7z383xy7dso my-nginx.2 nginx:latest manager2 Running Running 2 minutes agow0sm5ixvi6eb my-nginx.3 nginx:latest worker2 Running Running 4 seconds ago# 扩容到5个任务docker service scale my-nginx=5# 查看服务任务docker service ps my-nginx## 输出ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTSp4tats0f9npk my-nginx.1 nginx:latest manager1 Running Running about a minute agov7z383xy7dso my-nginx.2 nginx:latest manager2 Running Running 3 minutes agow0sm5ixvi6eb my-nginx.3 nginx:latest worker2 Running Running about a minute agoksbeflwg3mcj my-nginx.4 nginx:latest worker1 Running Running less than a second agoiw4zlm56n1x8 my-nginx.5 nginx:latest manager3 Running Running less than a second ago# 缩容到2个人任务docker service scale my-nginx=2# 查看服务任务docker service ps my-nginxID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTSp4tats0f9npk my-nginx.1 nginx:latest manager1 Running Running 2 minutes agov7z383xy7dso my-nginx.2 nginx:latest manager2 Running Running 4 minutes ago# 还可以使用如下命令进行扩缩容docker service update --replicas=5 my-nginx docker service update: 更新服务 支持的参数 参数 说明 示例 --image 更新服务使用的镜像 --image nginx:1.25 --replicas 设置服务的副本数量（仅适用于 replicated 模式） --replicas 5 --env-add 添加环境变量 --env-add DEBUG=true --env-rm 移除环境变量 --env-rm OLD_VAR --publish-add 添加端口映射 --publish-add published=8080,target=80 --publish-rm 移除端口映射 --publish-rm 80 --mount-add 添加挂载 --mount-add type=bind,src=/data,dst=/data --mount-rm 移除挂载 --mount-rm /data --constraint-add 添加部署约束 --constraint-add 'node.labels.zone==east' --constraint-rm 移除部署约束 --constraint-rm 'node.labels.zone==east' --limit-cpu 设置 CPU 限制 --limit-cpu 0.5 --limit-memory 设置内存限制 --limit-memory 256M --restart-condition 设置重启策略（none、on-failure、any） --restart-condition on-failure --update-delay 设置任务更新之间的延迟 --update-delay 10s --update-parallelism 设置并发更新任务的数量 --update-parallelism 2 --update-order 设置更新顺序（start-first 或 stop-first） --update-order start-first --update-failure-action 更新失败后的动作（pause、continue、rollback） --update-failure-action rollback --rollback 回滚到上一次成功配置 --rollback 示例 12345678910docker service update \\ --image nginx:1.25 \\ --replicas 4 \\ --env-add ENV=prod \\ --limit-memory 512M \\ --limit-cpu 1.0 \\ --update-delay 10s \\ --update-parallelism 2 \\ --update-failure-action rollback \\ my-nginx docker service rollback: 回滚服务 会将服务回滚到上一次成功部署的版本，包括镜像、环境变量、部署约束等。 12# docker service rollback &lt;service_name&gt;docker service rollback my-nginx docker service rm: 删除服务 删除服务会停止服务并删除服务。 12# docker service rm &lt;service_name&gt;docker service rm my-nginx 经验技巧 如何让任务运行在指定的节点上？ 创建服务时，可以使用 --constraint 参数指定节点的标签，使其运行在具有指定标签的节点上。 1234567891011# 给结点加标签docker node update --label-add env=prod worker1# node.labels 是Swarm内置属性，表示节点的标签，这里指定节点标签为 env=proddocker service create \\--name my-nginx \\--replicas 2 \\--constraint &#x27;node.labels.env == prod&#x27; \\nginx:latest# 这里要注意，运行任务后如果修改了node的标签，那么任务就会重新分配，分配是如果找不到符合标签的节点，就会运行失败。 只能运行在管理节点上 12345# node.role 是 Swarm 的内置属性，表示节点的类型，值为 manager 或 worker。docker service create \\ --name manager-only-service \\ --constraint &#x27;node.role == manager&#x27; \\ nginx Swarm 内置属性 属性名 示例值 说明 node.id node.id == abcd1234 节点的唯一 ID（可用 docker node ls 查看） node.hostname node.hostname == manager-1 节点主机名 node.role node.role == manager 或 node.role == worker 节点在 Swarm 中的角色（管理/工作） engine.labels.* engine.labels.disk == ssd Docker 引擎级别的标签（需手动设置） node.platform.os node.platform.os == linux 节点操作系统类型 node.platform.arch node.platform.arch == x86_64 节点架构类型（如 arm64, x86_64） 如何访问Service服务？ 1234567891011121314151617# 启动一个service，3个副本，镜像为 whoami，这个镜像会返回当前访问的容器的ID，即返回的Hostnamedocker service create --name whoami \\ --replicas 3 \\ -p 80:80 \\ traefik/whoami# 查看service服务运行在哪些节点上，看到这里只有 manager1\\manager2\\worker2 节点上运行，注意这里看到的ID是Task ID，并非容器IDdocker service ps whoamiID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTSu1elzp22hyvm whoami.1 traefik/whoami:latest manager2 Running Running 2 minutes ago4cent1kfgghb whoami.2 traefik/whoami:latest worker2 Running Running 17 seconds agolu6u6j8ji0uq whoami.3 traefik/whoami:latest manager1 Running Running 40 seconds ago# 如果希望查询某个Service的所有容器的ID，可以执行如下命令docker service ps whoami -q | xargs docker inspect --format &#x27;&#123;&#123;.Status.ContainerStatus.ContainerID&#125;&#125;&#x27; | cut -c 1-12a3fb63bde8e7a14e30a02987549610f3a1e9 此时我们通过curl访问 Swarm 集群中的任意一个节点的IP，都可以访问到这个服务，比如 curl 10.211.55.12，这是 manager3 节点的 IP 地址，虽然这个服务并没有在 manager3 节点上运行，但是我们依旧可以访问到这个服务，不仅如此，每次运行命令返回的Hostname(就是容器ID)都会发生变化，其效果就是在各个运行的容器间轮询，这就是 Swarm 集群的负载均衡效果。 123456789101112curl http://10.211.55.12## 输出Hostname: a3fb63bde8e7 # 容器IDIP: 127.0.0.1IP: ::1IP: 10.0.0.36 # 容器IP，对接 br0IP: 172.18.0.4 # 容器IP，对接 docker_gwbridgeRemoteAddr: 10.0.0.6:52964GET / HTTP/1.1Host: 10.211.55.12User-Agent: curl/7.61.1Accept: */* 在集群内部访问服务，建议将所有服务运行在相同的network中，这样可以不同的service之间可以通过服务名称访问服务，在集群外部，可以通过nginx等代理访问服务。 可以编写一个脚本方便查看service与container的运行关系，比如：docker_service_container 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#!/bin/bash# filename: docker_service_container# 用法提示if [ -z &quot;$1&quot; ]; then echo &quot;用法: $0 &lt;SERVICE_NAME&gt;&quot; exit 1fi# service名称SERVCIE_NAME=$1# 所属network,默认 ingress，这里要注意一下，如果是自定义的overlay网络，只能获取到当前主机上的容器IPNETWORK=$2if [ -z &quot;$2&quot; ]; then NETWORK=$(docker service inspect $SERVCIE_NAME --format &#x27;&#123;&#123;json .Endpoint.VirtualIPs&#125;&#125;&#x27; | jq &#x27;.[0].NetworkID&#x27; | sed &#x27;s/&quot;//g&#x27;)fi# NETWORK=$&#123;2:-ingress&#125;d1=$(echo -e &quot;SERVICE-ID TASK-ID CONTAINER-ID NODE-ID&quot; | awk &#x27;&#123;printf &quot;%-12s %-12s %-12s %-12s\\n&quot;, substr($1,1,12), substr($2,1,12), substr($3,1,12), substr($4,1,12)&#125;&#x27; ;\\docker service ps $SERVCIE_NAME --filter &quot;desired-state=running&quot; -q | xargs docker inspect --format &#x27;&#123;&#123;.ServiceID&#125;&#125; &#123;&#123;.ID&#125;&#125; &#123;&#123;.Status.ContainerStatus.ContainerID&#125;&#125; &#123;&#123;.NodeID&#125;&#125;&#x27; \\| awk &#x27;&#123;printf &quot;%-12s %-12s %-12s %-12s\\n&quot;, substr($1,1,12), substr($2,1,12), substr($3,1,12), substr($4,1,12)&#125;&#x27;)#echo &quot;$d1&quot;d2=$(docker service ps $SERVCIE_NAME --filter &quot;desired-state=running&quot;)#echo &quot;$d2&quot;nn1=$(awk &#x27;NR==FNR &amp;&amp; FNR &gt; 1 &#123; id = $1 name = $2 node = $4 desired = $5 # 拼接 CURRENT STATE（从第6列开始的所有字段） current = &quot;&quot; for (i=6; i&lt;=NF; i++) &#123; current = current $i &quot; &quot; &#125; gsub(/ /, &quot;-&quot;, current) current = substr(current, 1, length(current)-1) # 去掉最后空格 info[id] = name &quot;\\t&quot; node &quot;\\t&quot; desired &quot;\\t&quot; current next&#125;FNR==1 &#123; print $0 &quot;\\tTASK-NAME\\tNODE\\tDESIRED_STATE\\tCURRENT_STATE&quot; next&#125;&#123; print $0 &quot;\\t&quot; info[$2]&#125;&#x27; &lt;(echo &quot;$d2&quot;) &lt;(echo &quot;$d1&quot;) | tail -n +2 | column -t)nn2=$(echo &quot;CONTAINER-ID IP&quot;;docker network inspect $&#123;NETWORK&#125; -f &#x27;&#123;&#123;range $id, $container := .Containers&#125;&#125;&#123;&#123;slice $id 0 12&#125;&#125; &#123;&#123;$container.Name&#125;&#125; &#123;&#123;$container.IPv4Address&#125;&#125;&#123;&#123;println&#125;&#125;&#123;&#123;end&#125;&#125;&#x27; | grep $SERVCIE_NAME | awk -F &quot; &quot; &#x27;&#123;print $1&quot; &quot;$3&#125;&#x27;)awk &#x27;NR==FNR &#123; ip[$1]=$2; next &#125;&#123; print $0, ip[$3] &#125;&#x27; &lt;(echo &quot;$nn2&quot;) &lt;(echo &quot;$nn1&quot;) | column -t 运行 12345678chmod +x /usr/local/bin/docker-swarm-service# 执行脚本docker-swarm-service whoami## 输出SERVICE-ID TASK-ID CONTAINER-ID NODE-ID TASK-NAME NODE DESIRED_STATE CURRENT_STATE IPsnuhv0g2dm1q czisrjrp8k2t 9e4ce349971c kp2zerd28xgz whoami.1 manager1 Running Running-about-an-hour-ago 10.0.0.35/24snuhv0g2dm1q tvbkwmnafedw 0d586021260d kp2zerd28xgz whoami.2 manager1 Running Running-about-an-hour-ago 10.0.0.36/24snuhv0g2dm1q 815qp859a1f4 449d5e1a231d kp2zerd28xgz whoami.3 manager1 Running Running-about-an-hour-ago 10.0.0.15/24","summary":"摘要 本文介绍 Docker Swarm 的 服务管理 Docker官方文档 Docker Swarm 官方文档","date_published":"2025-06-10T13:30:05.000Z","tags":["技术","docker","docker"]},{"id":"https://blog.hanqunfeng.com/2025/06/09/docker-swarm-node/","url":"https://blog.hanqunfeng.com/2025/06/09/docker-swarm-node/","title":"Docker Swarm 之 节点(Node)","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 Docker Swarm 的 节点管理</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com\">Docker官方文档</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com/engine/swarm/\">Docker Swarm 官方文档</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Docker-Swarm-简介\">Docker Swarm 简介</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Docker Swarm 是 Docker 官方提供的一个集群管理工具，基于 Docker Swarm 可以快速实现 Docker 集群的管理。</p>\n</li>\n<li class=\"lvl-2\">\n<p>从 Docker v1.12 版本开始，Docker Swarm 已经包含在 Docker Engine 中，不需要单独安装。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Docker Swarm 具有服务编排、服务负载均衡、服务升级和服务失败迁移等功能。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Docker Swarm 集群中的节点分为两种类型：管理节点(Manager Node)和工作节点(Worker Node)，管理节点负责集群的管理，工作节点负责运行容器。<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/KwTed9.png\" alt=\"\"></p>\n</li>\n<li class=\"lvl-2\">\n<p>以下是 Docker Swarm 中 管理节点（Manager Node） 和 工作节点（Worker Node） 的对比</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>特性/功能</th>\n<th>管理节点（Manager Node）</th>\n<th>工作节点（Worker Node）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>角色</td>\n<td>负责集群管理和决策</td>\n<td>执行分配的服务任务</td>\n</tr>\n<tr>\n<td>是否参与服务运行</td>\n<td>可以运行服务任务，也可以只做管理（可配置）</td>\n<td>仅运行服务任务，不参与管理决策</td>\n</tr>\n<tr>\n<td>集群状态维护</td>\n<td>维护整个 Swarm 的状态（使用 Raft 协议）</td>\n<td>不维护集群状态</td>\n</tr>\n<tr>\n<td>调度任务</td>\n<td>决定将服务任务分配给哪个节点</td>\n<td>不负责调度，只执行接收到的任务</td>\n</tr>\n<tr>\n<td>管理命令处理</td>\n<td>接收并处理 Swarm 管理命令（如创建服务、扩缩容等）</td>\n<td>不处理管理命令</td>\n</tr>\n<tr>\n<td>数据一致性</td>\n<td>需要保持一致性（至少 3 个管理节点形成高可用）</td>\n<td>不涉及一致性</td>\n</tr>\n<tr>\n<td>资源要求</td>\n<td>相对较高，需要承担管理和协调开销</td>\n<td>相对较低，专注于运行容器</td>\n</tr>\n<tr>\n<td>可用性要求</td>\n<td>通常配置奇数个（3、5、7…）以保障高可用</td>\n<td>可根据需要自由扩展或缩减</td>\n</tr>\n<tr>\n<td>节点加入方式</td>\n<td>通过 manager token 加入 Swarm</td>\n<td>通过 worker token 加入 Swarm</td>\n</tr>\n<tr>\n<td>故障影响</td>\n<td>多个管理节点故障可能影响整个 Swarm 的控制能力</td>\n<td>部分工作节点故障通常不会影响 Swarm 的管理能力</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>manager 节点通常配置为奇数个，默认创建集群的节点就是 manager 节点，并且是 manager 节点中的的 Leader 节点。Leader 节点负责管理集群，Leader 节点在集群中只能有一个。当 Leader 节点故障时，Swarm 会自动从其它 manager 节点中选举出一个新的 Leader 节点。</p>\n</li>\n<li class=\"lvl-2\">\n<p>worker 节点是运行容器的节点，不参与机器的管理和调度，不支持执行任何和集群管理相关的操作。</p>\n</li>\n<li class=\"lvl-2\">\n<p>默认情况下，manager 节点也会参与接收运行容器的任务，但是可以通过设置来指定 manager 节点不参与接收任务。</p>\n</li>\n<li class=\"lvl-2\">\n<p>manager 节点和 worker 节点可以通过“升级”和“降级”相互转换。</p>\n</li>\n</ul>\n<h2 id=\"搭建Swarm集群\">搭建Swarm集群</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本教程需要五台安装了Docker且能够通过网络通信的 Linux 主机，这些主机可以是物理机、虚拟机、Amazon EC2 实例，也可以以其他方式托管。</p>\n</li>\n<li class=\"lvl-2\">\n<p>其中三台机器是管理节点（称为manager1,manager2,manager3），另外两台是工作节点（worker1和worker2）。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>IP 地址</th>\n<th>HostName</th>\n<th>角色类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>10.211.55.10</td>\n<td>manager1</td>\n<td>管理节点</td>\n</tr>\n<tr>\n<td>10.211.55.11</td>\n<td>manager2</td>\n<td>管理节点</td>\n</tr>\n<tr>\n<td>10.211.55.12</td>\n<td>manager3</td>\n<td>管理节点</td>\n</tr>\n<tr>\n<td>10.211.55.13</td>\n<td>worker1</td>\n<td>工作节点</td>\n</tr>\n<tr>\n<td>10.211.55.14</td>\n<td>worker2</td>\n<td>工作节点</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>所有主机上必须开启如下端口，以确保Docker Swarm 集群正常通信：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>端口号</th>\n<th>协议</th>\n<th>用途说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>2377</td>\n<td>TCP</td>\n<td>管理器节点之间通信（管理指令和加入集群）</td>\n</tr>\n<tr>\n<td>7946</td>\n<td>TCP/UDP</td>\n<td>节点发现和通信（集群内部发现机制）</td>\n</tr>\n<tr>\n<td>4789</td>\n<td>UDP</td>\n<td>覆盖网络流量（VXLAN，用于容器间网络）</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 开放 Swarm 管理节点通信端口</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> firewall-cmd --permanent --add-port=2377/tcp</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 节点发现（cluster communication）</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> firewall-cmd --permanent --add-port=7946/tcp</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> firewall-cmd --permanent --add-port=7946/udp</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># overlay 网络流量（容器间通信）</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> firewall-cmd --permanent --add-port=4789/udp</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 应用更改</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> firewall-cmd --reload</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看防火墙状态</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> firewall-cmd --list-all</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>所有主机必须时间一致</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 同步系统时间</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl restart chronyd</span><br><span class=\"line\">chronyc tracking</span><br><span class=\"line\"><span class=\"comment\"># 同步后系统时间显示为 UTC，而不是中国时区（CST/Asia/Shanghai）</span></span><br><span class=\"line\"><span class=\"comment\"># 设置时区为中国上海时间（CST）</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> timedatectl set-timezone Asia/Shanghai</span><br><span class=\"line\"><span class=\"comment\"># 查看时间和时区</span></span><br><span class=\"line\">timedatectl</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建集群\">创建集群</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 manager1 节点上执行如下命令来创建一个新的swarm集群</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看当前docker的swarm模式是否开启</span></span><br><span class=\"line\">docker info | grep <span class=\"string\">&quot;Swarm&quot;</span></span><br><span class=\"line\"><span class=\"comment\">## 输出， inactive 表示没有开启swarm集群</span></span><br><span class=\"line\"> Swarm: inactive</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 集群初始化</span></span><br><span class=\"line\"><span class=\"comment\"># docker swarm init --advertise-addr &lt;MANAGER-IP&gt;</span></span><br><span class=\"line\">docker swarm init --advertise-addr 10.211.55.10</span><br><span class=\"line\"><span class=\"comment\">## 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"># --advertise-addr：指定当前节点的IP地址，用于集群中其他节点发现当前节点，端口默认2377</span></span><br><span class=\"line\"><span class=\"comment\"># 这个参数是可选的，如果节点上存在多个网卡，则需要指定当前节点的IP地址</span></span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\"><span class=\"comment\"># swarm 初始化成功，当前节点成为 manager node，并自动成为集群的leader</span></span><br><span class=\"line\">Swarm initialized: current node (kp2zerd28xgz5mmglnje0jp22) is now a manager.</span><br><span class=\"line\"><span class=\"comment\"># 将一个worker node加入集群请运行下面的命令</span></span><br><span class=\"line\">To add a worker to this swarm, run the following <span class=\"built_in\">command</span>:</span><br><span class=\"line\">    <span class=\"comment\"># 这个token不需要记住，可以通过命令 `docker swarm join-token worker` 获取</span></span><br><span class=\"line\">    docker swarm <span class=\"built_in\">join</span> --token SWMTKN-1-256y3fmlkr5u76a5lor7jsboox2eztl954djhnuoj4p2x7dem4-0izbgc1xv73qulz31szmxnk3y 10.211.55.10:2377</span><br><span class=\"line\"><span class=\"comment\"># 添加一个manager node需要执行下面的命令获取 manager token</span></span><br><span class=\"line\">To add a manager to this swarm, run <span class=\"string\">&#x27;docker swarm join-token manager&#x27;</span> and follow the instructions.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 再次查看当前docker的swarm模式是否开启</span></span><br><span class=\"line\">docker info | grep Swarm</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\"> Swarm: active</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 若要查看更为详细的信息，可以直接查看 Swarm 中的信息，也可以使用如下命令查看主要信息，此时集群中只有一个节点，并且是manager节点</span></span><br><span class=\"line\">docker info --format <span class=\"string\">&#x27;&#123;&#123;json .Swarm&#125;&#125;&#x27;</span> | jq <span class=\"string\">&#x27;&#123;LocalNodeState,NodeID,NodeAddr,RemoteManagers,Nodes,Nodes,Managers,ControlAvailable&#125;&#x27;</span> | yq -P</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">LocalNodeState: active         <span class=\"comment\"># 节点状态</span></span><br><span class=\"line\">NodeID: kp2zerd28xgz5mmglnje0jp22 <span class=\"comment\"># 节点ID</span></span><br><span class=\"line\">NodeAddr: 10.211.55.10           <span class=\"comment\"># 节点IP</span></span><br><span class=\"line\">RemoteManagers: [                <span class=\"comment\"># 节点管理节点信息</span></span><br><span class=\"line\">  - NodeID: kp2zerd28xgz5mmglnje0jp22 <span class=\"comment\"># 节点管理节点ID</span></span><br><span class=\"line\">    Addr: 10.211.55.10:2377       <span class=\"comment\"># 节点管理节点地址</span></span><br><span class=\"line\">Nodes: 1                          <span class=\"comment\"># 节点数量</span></span><br><span class=\"line\">Managers: 1                       <span class=\"comment\"># 管理节点数量</span></span><br><span class=\"line\">ControlAvailable: <span class=\"literal\">true</span>            <span class=\"comment\"># 是否有控制节点</span></span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>安装 yq 工具</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">yq 是 yaml 的命令行处理工具，具体参考<a href=\"https://github.com/mikefarah/yq\">yq</a></li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载 yq 最新版本</span></span><br><span class=\"line\">VERSION=v4.45.4</span><br><span class=\"line\">ARCH=amd64</span><br><span class=\"line\">wget https://github.com/mikefarah/yq/releases/download/<span class=\"variable\">$&#123;VERSION&#125;</span>/yq_linux_<span class=\"variable\">$&#123;ARCH&#125;</span> -O /usr/local/bin/yq</span><br><span class=\"line\"><span class=\"comment\"># 添加执行权限</span></span><br><span class=\"line\"><span class=\"built_in\">chmod</span> +x /usr/local/bin/yq</span><br><span class=\"line\"><span class=\"comment\"># 验证安装</span></span><br><span class=\"line\">yq --version</span><br></pre></td></tr></table></figure>\n</div>\n<h3 id=\"添加-manager-节点\">添加 manager 节点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>获取 manager 节点的 token</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在 manager1 上运行</span></span><br><span class=\"line\">docker swarm join-token manager</span><br><span class=\"line\"><span class=\"comment\">## 输出结果</span></span><br><span class=\"line\">To add a manager to this swarm, run the following <span class=\"built_in\">command</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    docker swarm <span class=\"built_in\">join</span> --token SWMTKN-1-256y3fmlkr5u76a5lor7jsboox2eztl954djhnuoj4p2x7dem4-byc8ygc6hdoyzna0in1btp9yu 10.211.55.10:2377</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>将 manager2 和 manager3 加入 swarm 集群</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 分别在 manager2 和 manager3 上运行如下命令，</span></span><br><span class=\"line\">docker swarm <span class=\"built_in\">join</span> \\</span><br><span class=\"line\">--token SWMTKN-1-256y3fmlkr5u76a5lor7jsboox2eztl954djhnuoj4p2x7dem4-byc8ygc6hdoyzna0in1btp9yu \\</span><br><span class=\"line\">10.211.55.10:2377</span><br><span class=\"line\"><span class=\"comment\">## 如果机器上有多块网卡也需要指定ip: 如 --advertise-addr 10.211.55.11</span></span><br><span class=\"line\"><span class=\"comment\">## 运行结果</span></span><br><span class=\"line\">This node joined a swarm as a manager.</span><br></pre></td></tr></table></figure>\n<h3 id=\"添加-worker-节点\">添加 worker 节点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>获取 worker 节点的 token</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在 manager1 上运行</span></span><br><span class=\"line\">docker swarm join-token worker</span><br><span class=\"line\"><span class=\"comment\">## 输出结果</span></span><br><span class=\"line\">To add a worker to this swarm, run the following <span class=\"built_in\">command</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    docker swarm <span class=\"built_in\">join</span> --token SWMTKN-1-256y3fmlkr5u76a5lor7jsboox2eztl954djhnuoj4p2x7dem4-0izbgc1xv73qulz31szmxnk3y 10.211.55.10:2377</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>将 worker1 和 worker2 加入 swarm 集群</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 分别在 worker1 和 worker2 上运行如下命令，</span></span><br><span class=\"line\">docker swarm <span class=\"built_in\">join</span> \\</span><br><span class=\"line\">--token SWMTKN-1-256y3fmlkr5u76a5lor7jsboox2eztl954djhnuoj4p2x7dem4-0izbgc1xv73qulz31szmxnk3y \\</span><br><span class=\"line\">10.211.55.10:2377</span><br><span class=\"line\"><span class=\"comment\">## 如果机器上有多块网卡也需要指定ip: 如 --advertise-addr 10.211.55.13</span></span><br><span class=\"line\"><span class=\"comment\">## 运行结果</span></span><br><span class=\"line\">This node joined a swarm as a worker.</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看集群状态\">查看集群状态</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 manager1 上执行如下命令</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker info --format <span class=\"string\">&#x27;&#123;&#123;json .Swarm&#125;&#125;&#x27;</span> | jq <span class=\"string\">&#x27;&#123;LocalNodeState,NodeID,NodeAddr,RemoteManagers,Nodes,Nodes,Managers,ControlAvailable&#125;&#x27;</span> | yq -P</span><br><span class=\"line\"><span class=\"comment\">## 结果</span></span><br><span class=\"line\">LocalNodeState: active</span><br><span class=\"line\">NodeID: kp2zerd28xgz5mmglnje0jp22</span><br><span class=\"line\">NodeAddr: 10.211.55.10</span><br><span class=\"line\">RemoteManagers:</span><br><span class=\"line\">  - NodeID: oymi74epagdqeprah7s81tsa2</span><br><span class=\"line\">    Addr: 10.211.55.11:2377</span><br><span class=\"line\">  - NodeID: r7388xl84nczjtnf53pwh7hla</span><br><span class=\"line\">    Addr: 10.211.55.12:2377</span><br><span class=\"line\">  - NodeID: kp2zerd28xgz5mmglnje0jp22</span><br><span class=\"line\">    Addr: 10.211.55.10:2377</span><br><span class=\"line\">Nodes: 5</span><br><span class=\"line\">Managers: 3</span><br><span class=\"line\">ControlAvailable: <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"查看集群内节点信息\">查看集群内节点信息</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 任意 manager 节点上运行如下命令</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在 manager1 上运行，列出所有节点信息，只有 manager 节点支持 node 相关命令</span></span><br><span class=\"line\">docker node <span class=\"built_in\">ls</span></span><br><span class=\"line\"><span class=\"comment\">## 运行结果</span></span><br><span class=\"line\">ID                            HOSTNAME   STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION</span><br><span class=\"line\">kp2zerd28xgz5mmglnje0jp22 *   manager1   Ready     Active         Leader           26.1.3</span><br><span class=\"line\">oymi74epagdqeprah7s81tsa2     manager2   Ready     Active         Reachable        26.1.3</span><br><span class=\"line\">r7388xl84nczjtnf53pwh7hla     manager3   Ready     Active         Reachable        26.1.3</span><br><span class=\"line\">v31visfparkcsr9hswkb6v09u     worker1    Ready     Active                          26.1.3</span><br><span class=\"line\">lsxj50x8ftqw8etvz5y37xc5q     worker2    Ready     Active                          26.1.3</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>示例值</th>\n<th>中文含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>ID</strong></td>\n<td><code>kp2zerd28xgz5mmglnje0jp22</code></td>\n<td>节点的唯一 ID（在 swarm 集群中自动生成的唯一标识符）</td>\n</tr>\n<tr>\n<td><strong>HOSTNAME</strong></td>\n<td><code>manager1</code></td>\n<td>节点的主机名（即加入 swarm 集群时该节点的 <code>hostname</code>）</td>\n</tr>\n<tr>\n<td><strong>STATUS</strong></td>\n<td><code>Ready</code></td>\n<td>节点的状态：<br>• <code>Ready</code>：节点正常运行中<br>• <code>Down</code>：节点离线或无法通信<br>• <code>Paused</code>：暂停<br>• <code>Drain</code>：排空，正在迁移任务</td>\n</tr>\n<tr>\n<td><strong>AVAILABILITY</strong></td>\n<td><code>Active</code></td>\n<td>节点的可用性设置：<br>• <code>Active</code>：节点可以调度任务（默认）<br>• <code>Pause</code>：暂停调度新任务<br>• <code>Drain</code>：迁移任务并不再调度</td>\n</tr>\n<tr>\n<td><strong>MANAGER STATUS</strong></td>\n<td><code>Leader</code> / <code>Reachable</code> / 空</td>\n<td>仅适用于管理节点：<br>• <code>Leader</code>：当前 swarm 的主节点（负责协调）<br>• <code>Reachable</code>：集群中可通信的管理节点<br>• 空：表示这是一个工作节点（非管理节点）</td>\n</tr>\n<tr>\n<td><strong>ENGINE VERSION</strong></td>\n<td><code>26.1.3</code></td>\n<td>Docker 引擎的版本号（即该节点上运行的 Docker 版本）</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"docker-swarm集群管理\"><code>docker swarm</code>集群管理</h2>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>中文含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>ca</code></td>\n<td>显示和轮换 Swarm 的根证书（CA）</td>\n</tr>\n<tr>\n<td><code>init</code></td>\n<td>初始化一个新的 Swarm 集群</td>\n</tr>\n<tr>\n<td><code>join</code></td>\n<td>将当前节点加入到 Swarm 中，作为工作节点或管理节点</td>\n</tr>\n<tr>\n<td><code>join-token</code></td>\n<td>管理用于加入 Swarm 的令牌（查看或重新生成）</td>\n</tr>\n<tr>\n<td><code>leave</code></td>\n<td>当前节点离开 Swarm 集群</td>\n</tr>\n<tr>\n<td><code>unlock</code></td>\n<td>解锁被加密的 Swarm（用于恢复 Manager 节点）</td>\n</tr>\n<tr>\n<td><code>unlock-key</code></td>\n<td>管理 Swarm 的解锁密钥（查看、备份等）</td>\n</tr>\n<tr>\n<td><code>update</code></td>\n<td>更新 Swarm 集群的全局配置（如加密、日志等）</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker swarm init</code>: 初始化 Swarm 集群（只在首次创建时使用）</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker swarm init --advertise-addr 10.211.55.10</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker swarm join-token</code>:  生成加入集群的令牌</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 生成 worker 节点的令牌</span></span><br><span class=\"line\">docker swarm join-token worker</span><br><span class=\"line\"><span class=\"comment\"># 生成 manager 节点的令牌</span></span><br><span class=\"line\">docker swarm join-token manager</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker swarm join</code>: 加入 Swarm 集群（在已有 Swarm 集群中加入节点时使用）</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker swarm <span class=\"built_in\">join</span> --token &lt;token&gt; 10.211.55.10:2377</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker swarm leave</code>: 使当前节点离开 Swarm 集群（从 Swarm 集群中移除节点时使用）</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># worker 节点离开集群</span></span><br><span class=\"line\">docker swarm leave</span><br><span class=\"line\"><span class=\"comment\"># manager 节点必须先降级为 worker节点，或者加上 --force 强制离开</span></span><br><span class=\"line\">docker swarm leave --force</span><br><span class=\"line\"><span class=\"comment\"># 如果Leader节点离开集群，那么集群中的其它Manager节点，会重新选举一个新的Leader节点</span></span><br><span class=\"line\"><span class=\"comment\"># 集群中至少需要一个Manager节点，否则无法运行服务</span></span><br><span class=\"line\"><span class=\"comment\"># 节点离开swarm集群后，在 docker node ls中仍然可以看到，比如将 worker2 节点从集群中移除，其状态变为 down</span></span><br><span class=\"line\">docker node <span class=\"built_in\">ls</span></span><br><span class=\"line\">ID                            HOSTNAME   STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION</span><br><span class=\"line\">kp2zerd28xgz5mmglnje0jp22 *   manager1   Ready     Active         Leader           26.1.3</span><br><span class=\"line\">oymi74epagdqeprah7s81tsa2     manager2   Ready     Active         Reachable        26.1.3</span><br><span class=\"line\">r7388xl84nczjtnf53pwh7hla     manager3   Ready     Active         Reachable        26.1.3</span><br><span class=\"line\">v31visfparkcsr9hswkb6v09u     worker1    Ready     Active                          26.1.3</span><br><span class=\"line\">lsxj50x8ftqw8etvz5y37xc5q     worker2    Down      Active                          26.1.3</span><br><span class=\"line\"><span class=\"comment\"># 如需彻底删除需要运行</span></span><br><span class=\"line\">docker node <span class=\"built_in\">rm</span> worker2</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker swarm update</code>: 更新 Swarm 集群配置</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 开启Swarm集群锁定，只针对manager节点，manager节点重启后需要解锁才能恢复，下面的密钥不需要记住，通过`docker swarm unlock-key`命令查看</span></span><br><span class=\"line\">docker swarm update --autolock=<span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">Swarm updated.</span><br><span class=\"line\">To unlock a swarm manager after it restarts, run the `docker swarm unlock`</span><br><span class=\"line\"><span class=\"built_in\">command</span> and provide the following key:</span><br><span class=\"line\"></span><br><span class=\"line\">    SWMKEY-1-X74/FGf+SkUkJEWtYok6ZFgCDAdwt3CQpOvLPT5lra4</span><br><span class=\"line\"></span><br><span class=\"line\">Please remember to store this key <span class=\"keyword\">in</span> a password manager, since without it you</span><br><span class=\"line\">will not be able to restart the manager.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 关闭Swarm集群锁定</span></span><br><span class=\"line\">docker swarm update --autolock=<span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker swarm unlock-key</code>: 获取Swarm集群的解锁密钥，该命令可以判断Swarm集群是否被锁定</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取Swarm集群的解锁密钥</span></span><br><span class=\"line\">docker swarm unlock-key</span><br><span class=\"line\"><span class=\"comment\"># 轮换Swarm集群的解锁密钥</span></span><br><span class=\"line\">docker swarm unlock-key --rotate</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker swarm unlock</code>: 手动解锁当前 manager 节点，使其在启用 autolock 时恢复功能</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果Swarm集群设置为锁定，则重启manager2上的docker服务后将无法运行node管理命令</span></span><br><span class=\"line\">systemctl restart docker</span><br><span class=\"line\"><span class=\"comment\"># 查看节点列表</span></span><br><span class=\"line\">docker node <span class=\"built_in\">ls</span></span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">Error response from daemon: Swarm is encrypted and needs to be unlocked before it can be used. Please use <span class=\"string\">&quot;docker swarm unlock&quot;</span> to unlock it.</span><br><span class=\"line\"><span class=\"comment\"># 需要先解锁才可以运行节点管理命令</span></span><br><span class=\"line\">docker swarm unlock</span><br><span class=\"line\"><span class=\"comment\">## 会提示输入解锁密钥，解锁后就恢复正常了</span></span><br><span class=\"line\">Please enter unlock key:</span><br></pre></td></tr></table></figure>\n<h2 id=\"docker-node节点管理\"><code>docker node</code>节点管理</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>节点管理相关命令，只能在 管理节点 上执行</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>中文含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>demote</code></td>\n<td>将一个或多个管理节点降级为工作节点</td>\n</tr>\n<tr>\n<td><code>inspect</code></td>\n<td>显示一个或多个节点的详细信息</td>\n</tr>\n<tr>\n<td><code>ls</code></td>\n<td>列出 swarm 集群中的所有节点</td>\n</tr>\n<tr>\n<td><code>promote</code></td>\n<td>将一个或多个工作节点提升为管理节点</td>\n</tr>\n<tr>\n<td><code>ps</code></td>\n<td>查看一个或多个节点上正在运行的任务（默认当前节点）</td>\n</tr>\n<tr>\n<td><code>rm</code></td>\n<td>从 swarm 集群中移除一个或多个节点</td>\n</tr>\n<tr>\n<td><code>update</code></td>\n<td>更新节点的元数据（如标签、可用性等）</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker node ls</code>: 列出 swarm 集群中的所有节点</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker node <span class=\"built_in\">ls</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker node inspect &lt;node_id&gt;/&lt;hostname&gt;</code>: 查看指定节点的详细信息</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker node inspect --pretty manager1</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker node update &lt;options&gt; &lt;node_id&gt;/&lt;hostname&gt;</code>: 更新节点的元数据</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 设置节点为不可用</span></span><br><span class=\"line\">docker node update --availability drain manager1</span><br><span class=\"line\"><span class=\"comment\"># 添加标签</span></span><br><span class=\"line\">docker node update --label-add foo=bar manager1</span><br><span class=\"line\"><span class=\"comment\"># 删除标签</span></span><br><span class=\"line\">docker node update --label-rm foo manager1</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker node demote &lt;node_id&gt;/&lt;hostname&gt;</code>: 将管理节点降级为工作节点</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker node demote manager1</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker note promote &lt;node_id&gt;/&lt;hostname&gt;</code>: 将工作节点升级为管理节点</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker node promote worker1</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker node rm &lt;node_id&gt;/&lt;hostname&gt;</code>: 从 swarm 集群中移除一个节点</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker node <span class=\"built_in\">rm</span> manager1</span><br></pre></td></tr></table></figure>\n<h2 id=\"节点管理常见情况\">节点管理常见情况</h2>\n<h3 id=\"如何正确的删除一个节点\">如何正确的删除一个节点</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1.如果是 manager 节点，先将 manager 节点降级为 worker 节点</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker node demote manager1</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2.退出集群</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在要退出集群的节点上执行</span></span><br><span class=\"line\">docker swarm leave</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>3.删除节点</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker node <span class=\"built_in\">rm</span> manager1</span><br></pre></td></tr></table></figure>\n<h3 id=\"节点被退群或删除后，其上运行的service会怎样？\">节点被退群或删除后，其上运行的service会怎样？</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>用一个示例来说明，先在 manager1 节点上创建一个 service</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># --replicas 10 表示启动 10 个 nginx 容器，swarm集群有5个节点，所以启动10个nginx容器，每个节点会启动2个nginx容器</span></span><br><span class=\"line\">docker service create \\</span><br><span class=\"line\">  --name my-nginx \\</span><br><span class=\"line\">  --publish 8080:80 \\</span><br><span class=\"line\">  --replicas 10 \\</span><br><span class=\"line\">  nginx:latest</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看service状态</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker service ps my-nginx</span><br><span class=\"line\"><span class=\"comment\">## 输出结果，可以看到每个节点上都启动了2个nginx容器</span></span><br><span class=\"line\">ID             NAME          IMAGE          NODE       DESIRED STATE   CURRENT STATE                ERROR     PORTS</span><br><span class=\"line\">fciheo523fb3   my-nginx.1    nginx:latest   manager2   Running         Running about a minute ago</span><br><span class=\"line\">t9agioefr316   my-nginx.2    nginx:latest   manager2   Running         Running about a minute ago</span><br><span class=\"line\">moitlj50nunh   my-nginx.3    nginx:latest   manager3   Running         Running 2 minutes ago</span><br><span class=\"line\">x07voc2qth5q   my-nginx.4    nginx:latest   manager1   Running         Running about a minute ago</span><br><span class=\"line\">p8khdhngz0xm   my-nginx.5    nginx:latest   manager3   Running         Running 2 minutes ago</span><br><span class=\"line\">i6mieuodbrtg   my-nginx.6    nginx:latest   worker2    Running         Running about a minute ago</span><br><span class=\"line\">2yohffzzsrrl   my-nginx.7    nginx:latest   worker1    Running         Running 2 minutes ago</span><br><span class=\"line\">f3lusxoflqn2   my-nginx.8    nginx:latest   worker2    Running         Running about a minute ago</span><br><span class=\"line\">xovzfmzsjlet   my-nginx.9    nginx:latest   worker1    Running         Running 2 minutes ago</span><br><span class=\"line\">ndrz827kpu2k   my-nginx.10   nginx:latest   manager1   Running         Running about a minute ago</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这时将 worker2 从集群中退群</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在worker2节点执行</span></span><br><span class=\"line\">docker swarm leave</span><br><span class=\"line\"><span class=\"comment\"># 在manager节点查看集群节点</span></span><br><span class=\"line\">docker node <span class=\"built_in\">ls</span></span><br><span class=\"line\">ID                            HOSTNAME   STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION</span><br><span class=\"line\">kp2zerd28xgz5mmglnje0jp22 *   manager1   Ready     Active         Leader           26.1.3</span><br><span class=\"line\">oymi74epagdqeprah7s81tsa2     manager2   Ready     Active         Reachable        26.1.3</span><br><span class=\"line\">r7388xl84nczjtnf53pwh7hla     manager3   Ready     Active         Reachable        26.1.3</span><br><span class=\"line\">v31visfparkcsr9hswkb6v09u     worker1    Ready     Active                          26.1.3</span><br><span class=\"line\">x87lfn4pzorahpr9zehv9ag3f     worker2    Down      Active                          26.1.3</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>再次查看service状态</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker service ps my-nginx</span><br><span class=\"line\"><span class=\"comment\"># 输出，可以看到worker2节点上的容器已经被关闭，新的容器在其它节点上启动了，保证了service中的容器数量</span></span><br><span class=\"line\">ID             NAME             IMAGE          NODE       DESIRED STATE   CURRENT STATE            ERROR     PORTS</span><br><span class=\"line\">fciheo523fb3   my-nginx.1       nginx:latest   manager2   Running         Running 6 minutes ago</span><br><span class=\"line\">t9agioefr316   my-nginx.2       nginx:latest   manager2   Running         Running 6 minutes ago</span><br><span class=\"line\">moitlj50nunh   my-nginx.3       nginx:latest   manager3   Running         Running 6 minutes ago</span><br><span class=\"line\">x07voc2qth5q   my-nginx.4       nginx:latest   manager1   Running         Running 6 minutes ago</span><br><span class=\"line\">p8khdhngz0xm   my-nginx.5       nginx:latest   manager3   Running         Running 6 minutes ago</span><br><span class=\"line\">uz7wam5ul4aa   my-nginx.6       nginx:latest   manager2   Running         Running 43 seconds ago</span><br><span class=\"line\">i6mieuodbrtg    \\_ my-nginx.6   nginx:latest   worker2    Shutdown        Running 6 minutes ago</span><br><span class=\"line\">2yohffzzsrrl   my-nginx.7       nginx:latest   worker1    Running         Running 6 minutes ago</span><br><span class=\"line\">34km8mzg3xat   my-nginx.8       nginx:latest   manager3   Running         Running 43 seconds ago</span><br><span class=\"line\">f3lusxoflqn2    \\_ my-nginx.8   nginx:latest   worker2    Shutdown        Running 6 minutes ago</span><br><span class=\"line\">xovzfmzsjlet   my-nginx.9       nginx:latest   worker1    Running         Running 6 minutes ago</span><br><span class=\"line\">ndrz827kpu2k   my-nginx.10      nginx:latest   manager1   Running         Running 6 minutes ago</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果不退群直接删除节点呢？这次我们直接删除 worker1 节点</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除 worker1 节点</span></span><br><span class=\"line\">docker node <span class=\"built_in\">rm</span> worker1</span><br><span class=\"line\"><span class=\"comment\"># 输出，提示 worker1 节点不是 down 状态，不能删除</span></span><br><span class=\"line\"><span class=\"comment\"># Error response from daemon: rpc error: code = FailedPrecondition desc = node v31visfparkcsr9hswkb6v09u is not down and can&#x27;t be removed</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 接着我们强制删除</span></span><br><span class=\"line\">docker node <span class=\"built_in\">rm</span> -f worker1</span><br><span class=\"line\"><span class=\"comment\"># 查看节点列表</span></span><br><span class=\"line\">docker node <span class=\"built_in\">ls</span></span><br><span class=\"line\"><span class=\"comment\"># 输出，可以看到worker1节点已经删除了</span></span><br><span class=\"line\">ID                            HOSTNAME   STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION</span><br><span class=\"line\">kp2zerd28xgz5mmglnje0jp22 *   manager1   Ready     Active         Leader           26.1.3</span><br><span class=\"line\">oymi74epagdqeprah7s81tsa2     manager2   Ready     Active         Reachable        26.1.3</span><br><span class=\"line\">r7388xl84nczjtnf53pwh7hla     manager3   Ready     Active         Reachable        26.1.3</span><br><span class=\"line\">x87lfn4pzorahpr9zehv9ag3f     worker2    Down      Active                          26.1.3</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 再次查看service状态</span></span><br><span class=\"line\">docker service ps my-nginx</span><br><span class=\"line\"><span class=\"comment\">## 输出，可以看到worker1(因为worker1节点已经被删除，所以这里只会显示节点ID:v31visfparkcsr9hswkb6v09u)节点上的容器已经被关闭，新的容器在其它节点上启动了，保证了service中的容器数量</span></span><br><span class=\"line\">docker service ps my-nginx</span><br><span class=\"line\">ID             NAME             IMAGE          NODE                        DESIRED STATE   CURRENT STATE                 ERROR     PORTS</span><br><span class=\"line\">fciheo523fb3   my-nginx.1       nginx:latest   manager2                    Running         Running 12 minutes ago</span><br><span class=\"line\">t9agioefr316   my-nginx.2       nginx:latest   manager2                    Running         Running 12 minutes ago</span><br><span class=\"line\">moitlj50nunh   my-nginx.3       nginx:latest   manager3                    Running         Running 12 minutes ago</span><br><span class=\"line\">x07voc2qth5q   my-nginx.4       nginx:latest   manager1                    Running         Running 12 minutes ago</span><br><span class=\"line\">p8khdhngz0xm   my-nginx.5       nginx:latest   manager3                    Running         Running 12 minutes ago</span><br><span class=\"line\">uz7wam5ul4aa   my-nginx.6       nginx:latest   manager2                    Running         Running 6 minutes ago</span><br><span class=\"line\">i6mieuodbrtg    \\_ my-nginx.6   nginx:latest   worker2                     Shutdown        Running 12 minutes ago</span><br><span class=\"line\">3t4qvpvrzpg3   my-nginx.7       nginx:latest   manager1                    Running         Running about a minute ago</span><br><span class=\"line\">2yohffzzsrrl    \\_ my-nginx.7   nginx:latest   v31visfparkcsr9hswkb6v09u   Shutdown        Orphaned about a minute ago</span><br><span class=\"line\">34km8mzg3xat   my-nginx.8       nginx:latest   manager3                    Running         Running 6 minutes ago</span><br><span class=\"line\">f3lusxoflqn2    \\_ my-nginx.8   nginx:latest   worker2                     Shutdown        Running 12 minutes ago</span><br><span class=\"line\">4w5zfpfye3t8   my-nginx.9       nginx:latest   manager1                    Running         Running about a minute ago</span><br><span class=\"line\">xovzfmzsjlet    \\_ my-nginx.9   nginx:latest   v31visfparkcsr9hswkb6v09u   Shutdown        Orphaned about a minute ago</span><br><span class=\"line\">ndrz827kpu2k   my-nginx.10      nginx:latest   manager1                    Running         Running 12 minutes ago</span><br></pre></td></tr></table></figure>\n<h3 id=\"节点被退群或删除后是否可以重新加入集群\">节点被退群或删除后是否可以重新加入集群</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>节点被退群或删除后，可以通过 <code>docker swarm join</code> 命令重新加入集群</p>\n</li>\n<li class=\"lvl-2\">\n<p>若节点是被强制删除，而没有退群，则重新加入集群时需要先通过 <code>docker swarm leave</code> 命令退群后再加入集群</p>\n</li>\n</ul>\n<h3 id=\"如果Swarm集群设置为锁定，则重启manager节点后无法提供集群服务的解决方法\">如果Swarm集群设置为锁定，则重启manager节点后无法提供集群服务的解决方法</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 这里重启一个manager节点的docker服务</span></span><br><span class=\"line\">systemctl restart docker</span><br><span class=\"line\"><span class=\"comment\"># 查看节点列表</span></span><br><span class=\"line\">docker node <span class=\"built_in\">ls</span></span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">Error response from daemon: Swarm is encrypted and needs to be unlocked before it can be used. Please use <span class=\"string\">&quot;docker swarm unlock&quot;</span> to unlock it.</span><br><span class=\"line\"><span class=\"comment\"># 需要先解锁才可以运行节点管理命令</span></span><br><span class=\"line\">docker swarm unlock</span><br><span class=\"line\"><span class=\"comment\">## 会提示输入解锁密钥，解锁后就恢复正常了</span></span><br><span class=\"line\">Please enter unlock key:</span><br><span class=\"line\"><span class=\"comment\">## 如果忘记了密钥，可以在其它manager节点通过如下命令查看</span></span><br><span class=\"line\">docker swarm unlock-key</span><br><span class=\"line\"><span class=\"comment\"># 如果所有manager节点都重启了，你又没有记录解锁密钥，那么恭喜你，只能重新创建swarm集群了</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Swarm-集群锁定功能的作用及使用场景\">Swarm 集群锁定功能的作用及使用场景</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>作用</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>✅ 作用</th>\n<th>📋 说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>加密保护管理密钥</td>\n<td>管理器节点之间的数据（如 Raft 日志）虽然默认加密，但密钥保存在内存中。启用锁定功能后，密钥在节点重启时不会自动加载，必须手动提供解锁密钥才能恢复。</td>\n</tr>\n<tr>\n<td>防止节点被非法重启后加入集群</td>\n<td>如果攻击者获得了管理节点的物理访问权限（如重启、磁盘克隆等），锁定功能可以防止其自动控制或重新加入 Swarm 集群。</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>场景</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>场景类型</th>\n<th>具体描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>✅ 适合场景</td>\n<td>对安全性要求高的生产环境</td>\n</tr>\n<tr>\n<td></td>\n<td>部署在不可信或共享物理环境中</td>\n</tr>\n<tr>\n<td></td>\n<td>云服务器、数据中心有专人运维管理解锁过程</td>\n</tr>\n<tr>\n<td></td>\n<td>希望防止物理/远程入侵者恢复管理器角色的公司</td>\n</tr>\n<tr>\n<td>❌ 不适合场景</td>\n<td>需要自动化部署或重启的 CI/CD 系统</td>\n</tr>\n<tr>\n<td></td>\n<td>测试环境或开发集群</td>\n</tr>\n<tr>\n<td></td>\n<td>无人值守、要求高可用自动恢复的部署系统</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>总结</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th>是否推荐</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>安全性</td>\n<td>✅ 强烈推荐启用（尤其在生产环境）</td>\n</tr>\n<tr>\n<td>自动化</td>\n<td>❌ 不推荐（增加人工干预步骤）</td>\n</tr>\n<tr>\n<td>解锁方式</td>\n<td>解锁命令 + unlock key</td>\n</tr>\n<tr>\n<td>unlock key 丢失后果</td>\n<td>可能需要重建 Swarm（除非提前备份）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"docker-swarm-ca-是做什么用的？\"><code>docker swarm ca</code> 是做什么用的？</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker swarm ca</code> 命令是用来 <strong>管理 Swarm 集群中的根证书颁发机构（CA）</strong> 的工具。具体功能包括：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>子命令/参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>docker swarm ca</code></td>\n<td>查看当前 Swarm 的根 CA 公钥（PEM 格式）</td>\n</tr>\n<tr>\n<td><code>docker swarm ca --rotate</code></td>\n<td>轮换根 CA，用于安全更新</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Swarm 中的证书是干什么用的？</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>用途</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>✅ 节点身份验证</td>\n<td>每个节点加入集群时，都会收到一个由根 CA 签发的 TLS 证书，用于证明它的身份。</td>\n</tr>\n<tr>\n<td>🔐 通信加密</td>\n<td>节点之间（Manager ↔ Worker）的通信通过 TLS 进行加密。</td>\n</tr>\n<tr>\n<td>🔄 自动轮换</td>\n<td>Docker 会自动为每个节点签发短期证书（默认有效期 90 天）并定期自动轮换。</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Swarm 在后台自动管理证书，所以你不需要手动处理它们。不过，你可以在每个节点上找到它们的位置：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /var/lib/docker/swarm/certificates</span><br><span class=\"line\">tree</span><br><span class=\"line\">.</span><br><span class=\"line\">├── swarm-node.crt      <span class=\"comment\"># 节点证书</span></span><br><span class=\"line\">├── swarm-node.key      <span class=\"comment\"># 节点密钥</span></span><br><span class=\"line\">└── swarm-root-ca.crt   <span class=\"comment\"># 根CA证书</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"只让-Manager-做管理，不运行服务\">只让 Manager 做管理，不运行服务</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>节点的<code>AVAILABILITY</code>有三种：<code>active</code>、<code>pause</code>、<code>drain</code>。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>状态</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>active</code></td>\n<td>可调度，Swarm 可以在此节点上运行服务任务（默认）</td>\n</tr>\n<tr>\n<td><code>pause</code></td>\n<td>暂停调度，不会分配新任务，但保留已有任务</td>\n</tr>\n<tr>\n<td><code>drain</code></td>\n<td>排空模式，不可调度，Swarm 会将该节点上的任务迁移到其他节点，新的任务将不会分配到此节点</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果你希望 Swarm Manager 节点仅参与管理工作，而不运行服务任务（task），你可以通过 设置节点的可调度状态为“不可调度” 来实现这一目标。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 设置 manager1 节点为“不可调度”，即 排空模式</span></span><br><span class=\"line\">docker node update --availability drain manager1</span><br><span class=\"line\"><span class=\"comment\"># 查看节点状态</span></span><br><span class=\"line\">docker node <span class=\"built_in\">ls</span></span><br><span class=\"line\"><span class=\"comment\">## 输出，manager1 节点状态变为 排空</span></span><br><span class=\"line\">ID                            HOSTNAME   STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION</span><br><span class=\"line\">kp2zerd28xgz5mmglnje0jp22 *   manager1   Ready     Drain          Reachable        26.1.3</span><br><span class=\"line\">oymi74epagdqeprah7s81tsa2     manager2   Ready     Active         Reachable        26.1.3</span><br><span class=\"line\">r7388xl84nczjtnf53pwh7hla     manager3   Ready     Active         Leader           26.1.3</span><br><span class=\"line\">xkww4853bbdgv7bv8771xibob     worker1    Ready     Active                          26.1.3</span><br><span class=\"line\">hvzkh3ip5ef8gx973z1ywahbu     worker2    Ready     Active                          26.1.3</span><br><span class=\"line\"><span class=\"comment\"># 查看服务状态</span></span><br><span class=\"line\">docker service ps my-nginx</span><br><span class=\"line\"><span class=\"comment\">## 输出，可以看到 manager1 节点上的任务已经关闭，并且在其它节点上运行了任务。</span></span><br><span class=\"line\">ID             NAME             IMAGE          NODE       DESIRED STATE   CURRENT STATE                    ERROR     PORTS</span><br><span class=\"line\">23m03nj54mzo   my-nginx.1       nginx:latest   worker2    Running         Running 35 seconds ago</span><br><span class=\"line\">9xi83bnh4fus   my-nginx.2       nginx:latest   worker2    Running         Running 35 seconds ago</span><br><span class=\"line\">wos8tbk449lk   my-nginx.3       nginx:latest   manager2   Running         Running 28 seconds ago</span><br><span class=\"line\">uosmuh6bvwm0    \\_ my-nginx.3   nginx:latest   manager1   Shutdown        Shutdown 7 seconds ago</span><br><span class=\"line\">yeqhqc3f735y   my-nginx.4       nginx:latest   manager2   Running         Running about a minute ago</span><br><span class=\"line\">g8rduix7s74v   my-nginx.5       nginx:latest   worker2    Running         Running less than a second ago</span><br><span class=\"line\">wuxilgpv9f50    \\_ my-nginx.5   nginx:latest   manager1   Shutdown        Shutdown 7 seconds ago</span><br><span class=\"line\">3bxtn9boit28   my-nginx.6       nginx:latest   manager3   Running         Running 28 seconds ago</span><br><span class=\"line\">57kdggaf8sag   my-nginx.7       nginx:latest   manager2   Running         Running about a minute ago</span><br><span class=\"line\">uugi506p74s8   my-nginx.8       nginx:latest   worker1    Running         Running 28 seconds ago</span><br><span class=\"line\">yifwpqjnts9l   my-nginx.9       nginx:latest   worker1    Running         Running 28 seconds ago</span><br><span class=\"line\">yv4p6su7aom5   my-nginx.10      nginx:latest   manager3   Running         Running 28 seconds ago</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 恢复运行任务能力</span></span><br><span class=\"line\">docker node update --availability active manager1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 停止接收新的任务但保留运行中的任务</span></span><br><span class=\"line\">docker node update --availability pause manager1</span><br></pre></td></tr></table></figure>\n","content_text":"摘要 本文介绍 Docker Swarm 的 节点管理 Docker官方文档 Docker Swarm 官方文档 Docker Swarm 简介 Docker Swarm 是 Docker 官方提供的一个集群管理工具，基于 Docker Swarm 可以快速实现 Docker 集群的管理。 从 Docker v1.12 版本开始，Docker Swarm 已经包含在 Docker Engine 中，不需要单独安装。 Docker Swarm 具有服务编排、服务负载均衡、服务升级和服务失败迁移等功能。 Docker Swarm 集群中的节点分为两种类型：管理节点(Manager Node)和工作节点(Worker Node)，管理节点负责集群的管理，工作节点负责运行容器。 以下是 Docker Swarm 中 管理节点（Manager Node） 和 工作节点（Worker Node） 的对比 特性/功能 管理节点（Manager Node） 工作节点（Worker Node） 角色 负责集群管理和决策 执行分配的服务任务 是否参与服务运行 可以运行服务任务，也可以只做管理（可配置） 仅运行服务任务，不参与管理决策 集群状态维护 维护整个 Swarm 的状态（使用 Raft 协议） 不维护集群状态 调度任务 决定将服务任务分配给哪个节点 不负责调度，只执行接收到的任务 管理命令处理 接收并处理 Swarm 管理命令（如创建服务、扩缩容等） 不处理管理命令 数据一致性 需要保持一致性（至少 3 个管理节点形成高可用） 不涉及一致性 资源要求 相对较高，需要承担管理和协调开销 相对较低，专注于运行容器 可用性要求 通常配置奇数个（3、5、7…）以保障高可用 可根据需要自由扩展或缩减 节点加入方式 通过 manager token 加入 Swarm 通过 worker token 加入 Swarm 故障影响 多个管理节点故障可能影响整个 Swarm 的控制能力 部分工作节点故障通常不会影响 Swarm 的管理能力 manager 节点通常配置为奇数个，默认创建集群的节点就是 manager 节点，并且是 manager 节点中的的 Leader 节点。Leader 节点负责管理集群，Leader 节点在集群中只能有一个。当 Leader 节点故障时，Swarm 会自动从其它 manager 节点中选举出一个新的 Leader 节点。 worker 节点是运行容器的节点，不参与机器的管理和调度，不支持执行任何和集群管理相关的操作。 默认情况下，manager 节点也会参与接收运行容器的任务，但是可以通过设置来指定 manager 节点不参与接收任务。 manager 节点和 worker 节点可以通过“升级”和“降级”相互转换。 搭建Swarm集群 本教程需要五台安装了Docker且能够通过网络通信的 Linux 主机，这些主机可以是物理机、虚拟机、Amazon EC2 实例，也可以以其他方式托管。 其中三台机器是管理节点（称为manager1,manager2,manager3），另外两台是工作节点（worker1和worker2）。 IP 地址 HostName 角色类型 10.211.55.10 manager1 管理节点 10.211.55.11 manager2 管理节点 10.211.55.12 manager3 管理节点 10.211.55.13 worker1 工作节点 10.211.55.14 worker2 工作节点 所有主机上必须开启如下端口，以确保Docker Swarm 集群正常通信： 端口号 协议 用途说明 2377 TCP 管理器节点之间通信（管理指令和加入集群） 7946 TCP/UDP 节点发现和通信（集群内部发现机制） 4789 UDP 覆盖网络流量（VXLAN，用于容器间网络） 123456789101112131415# 开放 Swarm 管理节点通信端口sudo firewall-cmd --permanent --add-port=2377/tcp# 节点发现（cluster communication）sudo firewall-cmd --permanent --add-port=7946/tcpsudo firewall-cmd --permanent --add-port=7946/udp# overlay 网络流量（容器间通信）sudo firewall-cmd --permanent --add-port=4789/udp# 应用更改sudo firewall-cmd --reload# 查看防火墙状态sudo firewall-cmd --list-all 所有主机必须时间一致 12345678# 同步系统时间sudo systemctl restart chronydchronyc tracking# 同步后系统时间显示为 UTC，而不是中国时区（CST/Asia/Shanghai）# 设置时区为中国上海时间（CST）sudo timedatectl set-timezone Asia/Shanghai# 查看时间和时区timedatectl 创建集群 在 manager1 节点上执行如下命令来创建一个新的swarm集群 1234567891011121314151617181920212223242526272829303132333435363738# 查看当前docker的swarm模式是否开启docker info | grep &quot;Swarm&quot;## 输出， inactive 表示没有开启swarm集群 Swarm: inactive# 集群初始化# docker swarm init --advertise-addr &lt;MANAGER-IP&gt;docker swarm init --advertise-addr 10.211.55.10## 参数说明# --advertise-addr：指定当前节点的IP地址，用于集群中其他节点发现当前节点，端口默认2377# 这个参数是可选的，如果节点上存在多个网卡，则需要指定当前节点的IP地址## 输出# swarm 初始化成功，当前节点成为 manager node，并自动成为集群的leaderSwarm initialized: current node (kp2zerd28xgz5mmglnje0jp22) is now a manager.# 将一个worker node加入集群请运行下面的命令To add a worker to this swarm, run the following command: # 这个token不需要记住，可以通过命令 `docker swarm join-token worker` 获取 docker swarm join --token SWMTKN-1-256y3fmlkr5u76a5lor7jsboox2eztl954djhnuoj4p2x7dem4-0izbgc1xv73qulz31szmxnk3y 10.211.55.10:2377# 添加一个manager node需要执行下面的命令获取 manager tokenTo add a manager to this swarm, run &#x27;docker swarm join-token manager&#x27; and follow the instructions.# 再次查看当前docker的swarm模式是否开启docker info | grep Swarm## 输出 Swarm: active# 若要查看更为详细的信息，可以直接查看 Swarm 中的信息，也可以使用如下命令查看主要信息，此时集群中只有一个节点，并且是manager节点docker info --format &#x27;&#123;&#123;json .Swarm&#125;&#125;&#x27; | jq &#x27;&#123;LocalNodeState,NodeID,NodeAddr,RemoteManagers,Nodes,Nodes,Managers,ControlAvailable&#125;&#x27; | yq -P## 输出LocalNodeState: active # 节点状态NodeID: kp2zerd28xgz5mmglnje0jp22 # 节点IDNodeAddr: 10.211.55.10 # 节点IPRemoteManagers: [ # 节点管理节点信息 - NodeID: kp2zerd28xgz5mmglnje0jp22 # 节点管理节点ID Addr: 10.211.55.10:2377 # 节点管理节点地址Nodes: 1 # 节点数量Managers: 1 # 管理节点数量ControlAvailable: true # 是否有控制节点 安装 yq 工具 yq 是 yaml 的命令行处理工具，具体参考yq 12345678# 下载 yq 最新版本VERSION=v4.45.4ARCH=amd64wget https://github.com/mikefarah/yq/releases/download/$&#123;VERSION&#125;/yq_linux_$&#123;ARCH&#125; -O /usr/local/bin/yq# 添加执行权限chmod +x /usr/local/bin/yq# 验证安装yq --version 添加 manager 节点 获取 manager 节点的 token 123456# 在 manager1 上运行docker swarm join-token manager## 输出结果To add a manager to this swarm, run the following command: docker swarm join --token SWMTKN-1-256y3fmlkr5u76a5lor7jsboox2eztl954djhnuoj4p2x7dem4-byc8ygc6hdoyzna0in1btp9yu 10.211.55.10:2377 将 manager2 和 manager3 加入 swarm 集群 1234567# 分别在 manager2 和 manager3 上运行如下命令，docker swarm join \\--token SWMTKN-1-256y3fmlkr5u76a5lor7jsboox2eztl954djhnuoj4p2x7dem4-byc8ygc6hdoyzna0in1btp9yu \\10.211.55.10:2377## 如果机器上有多块网卡也需要指定ip: 如 --advertise-addr 10.211.55.11## 运行结果This node joined a swarm as a manager. 添加 worker 节点 获取 worker 节点的 token 123456# 在 manager1 上运行docker swarm join-token worker## 输出结果To add a worker to this swarm, run the following command: docker swarm join --token SWMTKN-1-256y3fmlkr5u76a5lor7jsboox2eztl954djhnuoj4p2x7dem4-0izbgc1xv73qulz31szmxnk3y 10.211.55.10:2377 将 worker1 和 worker2 加入 swarm 集群 1234567# 分别在 worker1 和 worker2 上运行如下命令，docker swarm join \\--token SWMTKN-1-256y3fmlkr5u76a5lor7jsboox2eztl954djhnuoj4p2x7dem4-0izbgc1xv73qulz31szmxnk3y \\10.211.55.10:2377## 如果机器上有多块网卡也需要指定ip: 如 --advertise-addr 10.211.55.13## 运行结果This node joined a swarm as a worker. 查看集群状态 在 manager1 上执行如下命令 123456789101112131415docker info --format &#x27;&#123;&#123;json .Swarm&#125;&#125;&#x27; | jq &#x27;&#123;LocalNodeState,NodeID,NodeAddr,RemoteManagers,Nodes,Nodes,Managers,ControlAvailable&#125;&#x27; | yq -P## 结果LocalNodeState: activeNodeID: kp2zerd28xgz5mmglnje0jp22NodeAddr: 10.211.55.10RemoteManagers: - NodeID: oymi74epagdqeprah7s81tsa2 Addr: 10.211.55.11:2377 - NodeID: r7388xl84nczjtnf53pwh7hla Addr: 10.211.55.12:2377 - NodeID: kp2zerd28xgz5mmglnje0jp22 Addr: 10.211.55.10:2377Nodes: 5Managers: 3ControlAvailable: true 查看集群内节点信息 在 任意 manager 节点上运行如下命令 123456789# 在 manager1 上运行，列出所有节点信息，只有 manager 节点支持 node 相关命令docker node ls## 运行结果ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS ENGINE VERSIONkp2zerd28xgz5mmglnje0jp22 * manager1 Ready Active Leader 26.1.3oymi74epagdqeprah7s81tsa2 manager2 Ready Active Reachable 26.1.3r7388xl84nczjtnf53pwh7hla manager3 Ready Active Reachable 26.1.3v31visfparkcsr9hswkb6v09u worker1 Ready Active 26.1.3lsxj50x8ftqw8etvz5y37xc5q worker2 Ready Active 26.1.3 字段名 示例值 中文含义 ID kp2zerd28xgz5mmglnje0jp22 节点的唯一 ID（在 swarm 集群中自动生成的唯一标识符） HOSTNAME manager1 节点的主机名（即加入 swarm 集群时该节点的 hostname） STATUS Ready 节点的状态：• Ready：节点正常运行中• Down：节点离线或无法通信• Paused：暂停• Drain：排空，正在迁移任务 AVAILABILITY Active 节点的可用性设置：• Active：节点可以调度任务（默认）• Pause：暂停调度新任务• Drain：迁移任务并不再调度 MANAGER STATUS Leader / Reachable / 空 仅适用于管理节点：• Leader：当前 swarm 的主节点（负责协调）• Reachable：集群中可通信的管理节点• 空：表示这是一个工作节点（非管理节点） ENGINE VERSION 26.1.3 Docker 引擎的版本号（即该节点上运行的 Docker 版本） docker swarm集群管理 命令 中文含义 ca 显示和轮换 Swarm 的根证书（CA） init 初始化一个新的 Swarm 集群 join 将当前节点加入到 Swarm 中，作为工作节点或管理节点 join-token 管理用于加入 Swarm 的令牌（查看或重新生成） leave 当前节点离开 Swarm 集群 unlock 解锁被加密的 Swarm（用于恢复 Manager 节点） unlock-key 管理 Swarm 的解锁密钥（查看、备份等） update 更新 Swarm 集群的全局配置（如加密、日志等） docker swarm init: 初始化 Swarm 集群（只在首次创建时使用） 1docker swarm init --advertise-addr 10.211.55.10 docker swarm join-token: 生成加入集群的令牌 1234# 生成 worker 节点的令牌docker swarm join-token worker# 生成 manager 节点的令牌docker swarm join-token manager docker swarm join: 加入 Swarm 集群（在已有 Swarm 集群中加入节点时使用） 1docker swarm join --token &lt;token&gt; 10.211.55.10:2377 docker swarm leave: 使当前节点离开 Swarm 集群（从 Swarm 集群中移除节点时使用） 12345678910111213141516# worker 节点离开集群docker swarm leave# manager 节点必须先降级为 worker节点，或者加上 --force 强制离开docker swarm leave --force# 如果Leader节点离开集群，那么集群中的其它Manager节点，会重新选举一个新的Leader节点# 集群中至少需要一个Manager节点，否则无法运行服务# 节点离开swarm集群后，在 docker node ls中仍然可以看到，比如将 worker2 节点从集群中移除，其状态变为 downdocker node lsID HOSTNAME STATUS AVAILABILITY MANAGER STATUS ENGINE VERSIONkp2zerd28xgz5mmglnje0jp22 * manager1 Ready Active Leader 26.1.3oymi74epagdqeprah7s81tsa2 manager2 Ready Active Reachable 26.1.3r7388xl84nczjtnf53pwh7hla manager3 Ready Active Reachable 26.1.3v31visfparkcsr9hswkb6v09u worker1 Ready Active 26.1.3lsxj50x8ftqw8etvz5y37xc5q worker2 Down Active 26.1.3# 如需彻底删除需要运行docker node rm worker2 docker swarm update: 更新 Swarm 集群配置 1234567891011121314# 开启Swarm集群锁定，只针对manager节点，manager节点重启后需要解锁才能恢复，下面的密钥不需要记住，通过`docker swarm unlock-key`命令查看docker swarm update --autolock=true## 输出Swarm updated.To unlock a swarm manager after it restarts, run the `docker swarm unlock`command and provide the following key: SWMKEY-1-X74/FGf+SkUkJEWtYok6ZFgCDAdwt3CQpOvLPT5lra4Please remember to store this key in a password manager, since without it youwill not be able to restart the manager.# 关闭Swarm集群锁定docker swarm update --autolock=false docker swarm unlock-key: 获取Swarm集群的解锁密钥，该命令可以判断Swarm集群是否被锁定 1234# 获取Swarm集群的解锁密钥docker swarm unlock-key# 轮换Swarm集群的解锁密钥docker swarm unlock-key --rotate docker swarm unlock: 手动解锁当前 manager 节点，使其在启用 autolock 时恢复功能 12345678910# 如果Swarm集群设置为锁定，则重启manager2上的docker服务后将无法运行node管理命令systemctl restart docker# 查看节点列表docker node ls## 输出Error response from daemon: Swarm is encrypted and needs to be unlocked before it can be used. Please use &quot;docker swarm unlock&quot; to unlock it.# 需要先解锁才可以运行节点管理命令docker swarm unlock## 会提示输入解锁密钥，解锁后就恢复正常了Please enter unlock key: docker node节点管理 节点管理相关命令，只能在 管理节点 上执行 命令 中文含义 demote 将一个或多个管理节点降级为工作节点 inspect 显示一个或多个节点的详细信息 ls 列出 swarm 集群中的所有节点 promote 将一个或多个工作节点提升为管理节点 ps 查看一个或多个节点上正在运行的任务（默认当前节点） rm 从 swarm 集群中移除一个或多个节点 update 更新节点的元数据（如标签、可用性等） docker node ls: 列出 swarm 集群中的所有节点 1docker node ls docker node inspect &lt;node_id&gt;/&lt;hostname&gt;: 查看指定节点的详细信息 1docker node inspect --pretty manager1 docker node update &lt;options&gt; &lt;node_id&gt;/&lt;hostname&gt;: 更新节点的元数据 123456# 设置节点为不可用docker node update --availability drain manager1# 添加标签docker node update --label-add foo=bar manager1# 删除标签docker node update --label-rm foo manager1 docker node demote &lt;node_id&gt;/&lt;hostname&gt;: 将管理节点降级为工作节点 1docker node demote manager1 docker note promote &lt;node_id&gt;/&lt;hostname&gt;: 将工作节点升级为管理节点 1docker node promote worker1 docker node rm &lt;node_id&gt;/&lt;hostname&gt;: 从 swarm 集群中移除一个节点 1docker node rm manager1 节点管理常见情况 如何正确的删除一个节点 1.如果是 manager 节点，先将 manager 节点降级为 worker 节点 1docker node demote manager1 2.退出集群 12# 在要退出集群的节点上执行docker swarm leave 3.删除节点 1docker node rm manager1 节点被退群或删除后，其上运行的service会怎样？ 用一个示例来说明，先在 manager1 节点上创建一个 service 123456# --replicas 10 表示启动 10 个 nginx 容器，swarm集群有5个节点，所以启动10个nginx容器，每个节点会启动2个nginx容器docker service create \\ --name my-nginx \\ --publish 8080:80 \\ --replicas 10 \\ nginx:latest 查看service状态 12345678910111213docker service ps my-nginx## 输出结果，可以看到每个节点上都启动了2个nginx容器ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTSfciheo523fb3 my-nginx.1 nginx:latest manager2 Running Running about a minute agot9agioefr316 my-nginx.2 nginx:latest manager2 Running Running about a minute agomoitlj50nunh my-nginx.3 nginx:latest manager3 Running Running 2 minutes agox07voc2qth5q my-nginx.4 nginx:latest manager1 Running Running about a minute agop8khdhngz0xm my-nginx.5 nginx:latest manager3 Running Running 2 minutes agoi6mieuodbrtg my-nginx.6 nginx:latest worker2 Running Running about a minute ago2yohffzzsrrl my-nginx.7 nginx:latest worker1 Running Running 2 minutes agof3lusxoflqn2 my-nginx.8 nginx:latest worker2 Running Running about a minute agoxovzfmzsjlet my-nginx.9 nginx:latest worker1 Running Running 2 minutes agondrz827kpu2k my-nginx.10 nginx:latest manager1 Running Running about a minute ago 这时将 worker2 从集群中退群 12345678910# 在worker2节点执行docker swarm leave# 在manager节点查看集群节点docker node lsID HOSTNAME STATUS AVAILABILITY MANAGER STATUS ENGINE VERSIONkp2zerd28xgz5mmglnje0jp22 * manager1 Ready Active Leader 26.1.3oymi74epagdqeprah7s81tsa2 manager2 Ready Active Reachable 26.1.3r7388xl84nczjtnf53pwh7hla manager3 Ready Active Reachable 26.1.3v31visfparkcsr9hswkb6v09u worker1 Ready Active 26.1.3x87lfn4pzorahpr9zehv9ag3f worker2 Down Active 26.1.3 再次查看service状态 123456789101112131415docker service ps my-nginx# 输出，可以看到worker2节点上的容器已经被关闭，新的容器在其它节点上启动了，保证了service中的容器数量ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTSfciheo523fb3 my-nginx.1 nginx:latest manager2 Running Running 6 minutes agot9agioefr316 my-nginx.2 nginx:latest manager2 Running Running 6 minutes agomoitlj50nunh my-nginx.3 nginx:latest manager3 Running Running 6 minutes agox07voc2qth5q my-nginx.4 nginx:latest manager1 Running Running 6 minutes agop8khdhngz0xm my-nginx.5 nginx:latest manager3 Running Running 6 minutes agouz7wam5ul4aa my-nginx.6 nginx:latest manager2 Running Running 43 seconds agoi6mieuodbrtg \\_ my-nginx.6 nginx:latest worker2 Shutdown Running 6 minutes ago2yohffzzsrrl my-nginx.7 nginx:latest worker1 Running Running 6 minutes ago34km8mzg3xat my-nginx.8 nginx:latest manager3 Running Running 43 seconds agof3lusxoflqn2 \\_ my-nginx.8 nginx:latest worker2 Shutdown Running 6 minutes agoxovzfmzsjlet my-nginx.9 nginx:latest worker1 Running Running 6 minutes agondrz827kpu2k my-nginx.10 nginx:latest manager1 Running Running 6 minutes ago 如果不退群直接删除节点呢？这次我们直接删除 worker1 节点 1234567891011121314151617181920212223242526272829303132333435# 删除 worker1 节点docker node rm worker1# 输出，提示 worker1 节点不是 down 状态，不能删除# Error response from daemon: rpc error: code = FailedPrecondition desc = node v31visfparkcsr9hswkb6v09u is not down and can&#x27;t be removed# 接着我们强制删除docker node rm -f worker1# 查看节点列表docker node ls# 输出，可以看到worker1节点已经删除了ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS ENGINE VERSIONkp2zerd28xgz5mmglnje0jp22 * manager1 Ready Active Leader 26.1.3oymi74epagdqeprah7s81tsa2 manager2 Ready Active Reachable 26.1.3r7388xl84nczjtnf53pwh7hla manager3 Ready Active Reachable 26.1.3x87lfn4pzorahpr9zehv9ag3f worker2 Down Active 26.1.3# 再次查看service状态docker service ps my-nginx## 输出，可以看到worker1(因为worker1节点已经被删除，所以这里只会显示节点ID:v31visfparkcsr9hswkb6v09u)节点上的容器已经被关闭，新的容器在其它节点上启动了，保证了service中的容器数量docker service ps my-nginxID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTSfciheo523fb3 my-nginx.1 nginx:latest manager2 Running Running 12 minutes agot9agioefr316 my-nginx.2 nginx:latest manager2 Running Running 12 minutes agomoitlj50nunh my-nginx.3 nginx:latest manager3 Running Running 12 minutes agox07voc2qth5q my-nginx.4 nginx:latest manager1 Running Running 12 minutes agop8khdhngz0xm my-nginx.5 nginx:latest manager3 Running Running 12 minutes agouz7wam5ul4aa my-nginx.6 nginx:latest manager2 Running Running 6 minutes agoi6mieuodbrtg \\_ my-nginx.6 nginx:latest worker2 Shutdown Running 12 minutes ago3t4qvpvrzpg3 my-nginx.7 nginx:latest manager1 Running Running about a minute ago2yohffzzsrrl \\_ my-nginx.7 nginx:latest v31visfparkcsr9hswkb6v09u Shutdown Orphaned about a minute ago34km8mzg3xat my-nginx.8 nginx:latest manager3 Running Running 6 minutes agof3lusxoflqn2 \\_ my-nginx.8 nginx:latest worker2 Shutdown Running 12 minutes ago4w5zfpfye3t8 my-nginx.9 nginx:latest manager1 Running Running about a minute agoxovzfmzsjlet \\_ my-nginx.9 nginx:latest v31visfparkcsr9hswkb6v09u Shutdown Orphaned about a minute agondrz827kpu2k my-nginx.10 nginx:latest manager1 Running Running 12 minutes ago 节点被退群或删除后是否可以重新加入集群 节点被退群或删除后，可以通过 docker swarm join 命令重新加入集群 若节点是被强制删除，而没有退群，则重新加入集群时需要先通过 docker swarm leave 命令退群后再加入集群 如果Swarm集群设置为锁定，则重启manager节点后无法提供集群服务的解决方法 12345678910111213# 这里重启一个manager节点的docker服务systemctl restart docker# 查看节点列表docker node ls## 输出Error response from daemon: Swarm is encrypted and needs to be unlocked before it can be used. Please use &quot;docker swarm unlock&quot; to unlock it.# 需要先解锁才可以运行节点管理命令docker swarm unlock## 会提示输入解锁密钥，解锁后就恢复正常了Please enter unlock key:## 如果忘记了密钥，可以在其它manager节点通过如下命令查看docker swarm unlock-key# 如果所有manager节点都重启了，你又没有记录解锁密钥，那么恭喜你，只能重新创建swarm集群了 Swarm 集群锁定功能的作用及使用场景 作用 ✅ 作用 📋 说明 加密保护管理密钥 管理器节点之间的数据（如 Raft 日志）虽然默认加密，但密钥保存在内存中。启用锁定功能后，密钥在节点重启时不会自动加载，必须手动提供解锁密钥才能恢复。 防止节点被非法重启后加入集群 如果攻击者获得了管理节点的物理访问权限（如重启、磁盘克隆等），锁定功能可以防止其自动控制或重新加入 Swarm 集群。 场景 场景类型 具体描述 ✅ 适合场景 对安全性要求高的生产环境 部署在不可信或共享物理环境中 云服务器、数据中心有专人运维管理解锁过程 希望防止物理/远程入侵者恢复管理器角色的公司 ❌ 不适合场景 需要自动化部署或重启的 CI/CD 系统 测试环境或开发集群 无人值守、要求高可用自动恢复的部署系统 总结 项目 是否推荐 安全性 ✅ 强烈推荐启用（尤其在生产环境） 自动化 ❌ 不推荐（增加人工干预步骤） 解锁方式 解锁命令 + unlock key unlock key 丢失后果 可能需要重建 Swarm（除非提前备份） docker swarm ca 是做什么用的？ docker swarm ca 命令是用来 管理 Swarm 集群中的根证书颁发机构（CA） 的工具。具体功能包括： 子命令/参数 说明 docker swarm ca 查看当前 Swarm 的根 CA 公钥（PEM 格式） docker swarm ca --rotate 轮换根 CA，用于安全更新 Swarm 中的证书是干什么用的？ 用途 说明 ✅ 节点身份验证 每个节点加入集群时，都会收到一个由根 CA 签发的 TLS 证书，用于证明它的身份。 🔐 通信加密 节点之间（Manager ↔ Worker）的通信通过 TLS 进行加密。 🔄 自动轮换 Docker 会自动为每个节点签发短期证书（默认有效期 90 天）并定期自动轮换。 Swarm 在后台自动管理证书，所以你不需要手动处理它们。不过，你可以在每个节点上找到它们的位置： 123456cd /var/lib/docker/swarm/certificatestree.├── swarm-node.crt # 节点证书├── swarm-node.key # 节点密钥└── swarm-root-ca.crt # 根CA证书 只让 Manager 做管理，不运行服务 节点的AVAILABILITY有三种：active、pause、drain。 状态 说明 active 可调度，Swarm 可以在此节点上运行服务任务（默认） pause 暂停调度，不会分配新任务，但保留已有任务 drain 排空模式，不可调度，Swarm 会将该节点上的任务迁移到其他节点，新的任务将不会分配到此节点 如果你希望 Swarm Manager 节点仅参与管理工作，而不运行服务任务（task），你可以通过 设置节点的可调度状态为“不可调度” 来实现这一目标。 123456789101112131415161718192021222324252627282930313233# 设置 manager1 节点为“不可调度”，即 排空模式docker node update --availability drain manager1# 查看节点状态docker node ls## 输出，manager1 节点状态变为 排空ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS ENGINE VERSIONkp2zerd28xgz5mmglnje0jp22 * manager1 Ready Drain Reachable 26.1.3oymi74epagdqeprah7s81tsa2 manager2 Ready Active Reachable 26.1.3r7388xl84nczjtnf53pwh7hla manager3 Ready Active Leader 26.1.3xkww4853bbdgv7bv8771xibob worker1 Ready Active 26.1.3hvzkh3ip5ef8gx973z1ywahbu worker2 Ready Active 26.1.3# 查看服务状态docker service ps my-nginx## 输出，可以看到 manager1 节点上的任务已经关闭，并且在其它节点上运行了任务。ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS23m03nj54mzo my-nginx.1 nginx:latest worker2 Running Running 35 seconds ago9xi83bnh4fus my-nginx.2 nginx:latest worker2 Running Running 35 seconds agowos8tbk449lk my-nginx.3 nginx:latest manager2 Running Running 28 seconds agouosmuh6bvwm0 \\_ my-nginx.3 nginx:latest manager1 Shutdown Shutdown 7 seconds agoyeqhqc3f735y my-nginx.4 nginx:latest manager2 Running Running about a minute agog8rduix7s74v my-nginx.5 nginx:latest worker2 Running Running less than a second agowuxilgpv9f50 \\_ my-nginx.5 nginx:latest manager1 Shutdown Shutdown 7 seconds ago3bxtn9boit28 my-nginx.6 nginx:latest manager3 Running Running 28 seconds ago57kdggaf8sag my-nginx.7 nginx:latest manager2 Running Running about a minute agouugi506p74s8 my-nginx.8 nginx:latest worker1 Running Running 28 seconds agoyifwpqjnts9l my-nginx.9 nginx:latest worker1 Running Running 28 seconds agoyv4p6su7aom5 my-nginx.10 nginx:latest manager3 Running Running 28 seconds ago# 恢复运行任务能力docker node update --availability active manager1# 停止接收新的任务但保留运行中的任务docker node update --availability pause manager1","summary":"摘要 本文介绍 Docker Swarm 的 节点管理 Docker官方文档 Docker Swarm 官方文档","date_published":"2025-06-09T13:30:05.000Z","tags":["技术","docker","docker"]},{"id":"https://blog.hanqunfeng.com/2025/06/06/docker-dockerfile-multi-platform/","url":"https://blog.hanqunfeng.com/2025/06/06/docker-dockerfile-multi-platform/","title":"Docker 命令 之 Dockerfile 多平台构建","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 Docker 命令 中 Dockerfile 多平台构建的使用方法</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com\">Docker官方文档</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com/engine/reference/builder/\">Dockerfile官方文档</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com/build/building/multi-platform/\">Multi-platform builds</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"什么是Dockerfile-多平台构建？\">什么是Dockerfile 多平台构建？</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Dockerfile 多平台构建，可以构建多个平台镜像，比如 arm64、amd64、arm、386 等。</p>\n</li>\n<li class=\"lvl-2\">\n<p>在没有安装 <code>docker-buildx-plugin</code> 的情况下，<code>docker build</code> 命令是不支持使用 <code>--platform</code> 构建出跨平台镜像的，其仅能构建与本机架构平台相同的镜像。</p>\n</li>\n<li class=\"lvl-2\">\n<p>要真正实现跨平台构建（multi-platform build），比如在 amd64 上构建 arm64 的镜像，需要使用 BuildKit 和 buildx 插件。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>docker-buildx-plugin</code> 是基于 BuildKit 构建的，但它本身是 Buildx 的一个实现形式，它扩展了 <code>docker build</code> 的能力，支持多平台构建（如同时构建 Linux/amd64 和 Linux/arm64等）。</p>\n</li>\n</ul>\n<h2 id=\"安装-docker-buildx-plugin\">安装 docker-buildx-plugin</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>随docker服务一起安装</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> dnf -y install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>单独安装</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> dnf -y install docker-buildx-plugin</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看版本</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker buildx version</span><br></pre></td></tr></table></figure>\n<h2 id=\"docker-buildx-基本命令\"><code>docker buildx</code> 基本命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>以下命令在后面的示例中都有使用</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>docker buildx create</code></td>\n<td>创建一个新的构建器实例</td>\n</tr>\n<tr>\n<td><code>docker buildx use</code></td>\n<td>设置当前使用的构建器</td>\n</tr>\n<tr>\n<td><code>docker buildx inspect</code></td>\n<td>查看构建器状态和支持的平台</td>\n</tr>\n<tr>\n<td><code>docker buildx build</code></td>\n<td>构建镜像（增强版），等同于 <code>docker build</code></td>\n</tr>\n<tr>\n<td><code>docker buildx ls</code></td>\n<td>列出所有构建器</td>\n</tr>\n<tr>\n<td><code>docker buildx rm</code></td>\n<td>删除构建器</td>\n</tr>\n<tr>\n<td><code>docker buildx du</code></td>\n<td>查看构建器使用的磁盘空间</td>\n</tr>\n<tr>\n<td><code>docker buildx prune</code></td>\n<td>删除构建过程中产生的缓存</td>\n</tr>\n<tr>\n<td><code>docker buildx version</code></td>\n<td>查看 Docker Buildx 的版本信息</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"要让Docker支持多平台构建，需要满足以下几个条件：\">要让Docker支持多平台构建，需要满足以下几个条件：</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Linux内核开启多处理器架构支持</p>\n</li>\n<li class=\"lvl-2\">\n<p>构建时使用基于<code>docker-container</code>驱动的Buildx实例</p>\n</li>\n<li class=\"lvl-2\">\n<p>使用<code>docker buildx build</code>命令构建镜像，构建命令必须指定<code>–platform</code>参数</p>\n</li>\n</ul>\n<h2 id=\"Linux内核开启多处理器架构支持\">Linux内核开启多处理器架构支持</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出所有构建器，默认情况下只有一个名称为&quot;default&quot;的构建器</span></span><br><span class=\"line\">docker buildx <span class=\"built_in\">ls</span></span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">NAME/NODE        DRIVER/ENDPOINT                   STATUS    BUILDKIT   PLATFORMS</span><br><span class=\"line\">default          docker</span><br><span class=\"line\"> \\_ default       \\_ default                       running   v0.13.2    linux/amd64, linux/amd64/v2, linux/amd64/v3, linux/amd64/v4, linux/386</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 开启多处理器架构支持</span></span><br><span class=\"line\">docker run --privileged --<span class=\"built_in\">rm</span> tonistiigi/binfmt --install all</span><br><span class=\"line\"><span class=\"comment\"># 这个镜像用完就可以删除了</span></span><br><span class=\"line\">docker rmi tonistiigi/binfmt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 再次列出所有构建器</span></span><br><span class=\"line\">docker buildx <span class=\"built_in\">ls</span></span><br><span class=\"line\"><span class=\"comment\">## 输出，此时可以看到PLATFORMS中有多个平台</span></span><br><span class=\"line\">NAME/NODE        DRIVER/ENDPOINT                   STATUS    BUILDKIT   PLATFORMS</span><br><span class=\"line\">default*         docker</span><br><span class=\"line\"> \\_ default       \\_ default                       running   v0.13.2    linux/amd64, linux/amd64/v2, linux/amd64/v3, linux/amd64/v4, linux/386, linux/arm64, linux/riscv64, linux/ppc64le, linux/s390x, linux/mips64le, linux/mips64, linux/loong64, linux/arm/v7, linux/arm/v6</span><br></pre></td></tr></table></figure>\n<h2 id=\"构建时使用基于docker-container驱动的Buildx实例\">构建时使用基于<code>docker-container</code>驱动的Buildx实例</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Docker 的默认构建驱动是 docker，它是运行在本地 Docker 守护进程上的，不能进行真正的多平台构建（仅能构建当前平台）。</p>\n</li>\n<li class=\"lvl-2\">\n<p>多平台构建需要使用 BuildKit 的 container 驱动，它以容器的形式运行构建器，支持虚拟化平台并行构建。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看当前默认的构建器default</span></span><br><span class=\"line\">docker buildx inspect default</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">Name:          default</span><br><span class=\"line\">Driver:        docker</span><br><span class=\"line\">Last Activity: 2025-06-06 07:42:42 +0000 UTC</span><br><span class=\"line\"></span><br><span class=\"line\">Nodes:</span><br><span class=\"line\">Name:             default</span><br><span class=\"line\">Endpoint:         default</span><br><span class=\"line\">Status:           running</span><br><span class=\"line\">BuildKit version: v0.13.2</span><br><span class=\"line\">Platforms:        linux/amd64, linux/amd64/v2, linux/amd64/v3, linux/amd64/v4, linux/386, linux/arm64, linux/riscv64, linux/ppc64le, linux/s390x, linux/mips64le, linux/mips64, linux/loong64, linux/arm/v7, linux/arm/v6</span><br><span class=\"line\">Labels:</span><br><span class=\"line\"> org.mobyproject.buildkit.worker.moby.host-gateway-ip: 172.17.0.1</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建基于 <code>docker-container</code> 驱动的Buildx实例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建并切换到名为mybuilder的构建器实例</span></span><br><span class=\"line\">docker buildx create --name mybuilder --use --driver docker-container</span><br><span class=\"line\"><span class=\"comment\"># 查看当前构建器信息，--bootstrap：查看前确保构建器已启动 ，此时看到其Driver为docker-container，这个命令第一次执行时可能会提示错误，不过不用管，再次运行就正常了</span></span><br><span class=\"line\">docker buildx inspect --bootstrap</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">Name:          mybuilder</span><br><span class=\"line\">Driver:        docker-container</span><br><span class=\"line\">……………………………………</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 此时会启动一个名称为`buildx_buildkit_mybuilder0`的容器，每创建一个构建器实例，就会启动一个名称为`buildx_buildkit_xxx`的容器，删除构建器时，其对应的容器也会被删除</span></span><br><span class=\"line\">docker ps</span><br><span class=\"line\">CONTAINER ID   IMAGE                           COMMAND                   CREATED             STATUS                       PORTS                    NAMES</span><br><span class=\"line\">0ab9cab9ec9b   moby/buildkit:buildx-stable-1   <span class=\"string\">&quot;buildkitd --allow-i…&quot;</span>   About an hour ago   Up About an hour                                      buildx_buildkit_mybuilder0</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>buildx_buildkit_xxx</code>这个容器就是一个 BuildKit 守护进程容器，它是执行 buildx 构建任务的实际工作引擎。其对应的镜像为<code>moby/buildkit:buildx-stable-1</code>，容器会在执行<code>docker buildx build</code> 或 <code>docker buildx inspect --bootstrap</code> 时启动</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>👷 执行构建任务</td>\n<td>真正执行 <code>buildx build</code> 指令里的构建过程，比如多阶段构建、缓存处理、跨平台编译等</td>\n</tr>\n<tr>\n<td>📦 拉取镜像</td>\n<td>拉取 <code>Dockerfile</code> 中的基础镜像</td>\n</tr>\n<tr>\n<td>📤 上传/导出镜像</td>\n<td>支持导出为 <code>docker image</code>, <code>tar</code>, 推送到远程 registry</td>\n</tr>\n<tr>\n<td>🪣 管理缓存</td>\n<td>管理构建缓存（中间镜像、层等）以加速后续构建</td>\n</tr>\n<tr>\n<td>🌍 支持多平台</td>\n<td>通过 QEMU 或交叉编译器支持跨平台（如构建 <code>arm64</code> 镜像）</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在国内环境使用时，如果不能科学上网，当我们在构建镜像时会提示无法拉取基础镜像，即便我们已经在<code>/etc/docker/daemon.json</code>中配置了国内的镜像源也不行，这是因为<code>docker buildx</code> 使用的是 BuildKit，它的行为不同于传统的 <code>docker build</code></p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th><code>docker build</code>（传统）</th>\n<th><code>docker buildx</code>（BuildKit）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>是否使用本地镜像缓存</td>\n<td>✅ 是</td>\n<td>⚠️ <strong>不是</strong></td>\n</tr>\n<tr>\n<td>是否需要联网拉取元数据（即使镜像已存在）</td>\n<td>否</td>\n<td>是</td>\n</tr>\n<tr>\n<td>构建网络隔离</td>\n<td>不隔离</td>\n<td>隔离构建，无法直接访问宿主镜像缓存</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>解决方法为构建器配置镜像源</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建 BuildKit 配置文件 buildkitd.toml</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &lt;&lt;<span class=\"string\">EOF &gt; buildkitd.toml</span></span><br><span class=\"line\"><span class=\"string\">[registry.&quot;docker.io&quot;]</span></span><br><span class=\"line\"><span class=\"string\">  mirrors = [&quot;https://docker.1ms.run&quot;]</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">[worker.oci]</span></span><br><span class=\"line\"><span class=\"string\">  gc = true</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建 BuildKit 构建器，并指定配置文件</span></span><br><span class=\"line\">docker buildx create --name mybuilder --use --driver docker-container --config ./buildkitd.toml</span><br><span class=\"line\">docker buildx inspect --bootstrap</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果存在同名的构建器，则删除它后再创建</span></span><br><span class=\"line\">docker buildx <span class=\"built_in\">rm</span> mybuilder</span><br><span class=\"line\">docker buildx create --name mybuilder --use --driver docker-container --config ./buildkitd.toml</span><br><span class=\"line\">docker buildx inspect --bootstrap</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看构建器列表</span></span><br><span class=\"line\">docker buildx <span class=\"built_in\">ls</span></span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">NAME/NODE        DRIVER/ENDPOINT                   STATUS    BUILDKIT   PLATFORMS</span><br><span class=\"line\">mybuilder*       docker-container</span><br><span class=\"line\"> \\_ mybuilder0    \\_ unix:///var/run/docker.sock   running   v0.21.1    linux/amd64, linux/amd64/v2, linux/amd64/v3, linux/amd64/v4, linux/arm64, linux/riscv64, linux/ppc64le, linux/s390x, linux/386, linux/mips64le, linux/mips64, linux/loong64, linux/arm/v7, linux/arm/v6</span><br><span class=\"line\">default          docker</span><br><span class=\"line\"> \\_ default       \\_ default                       running   v0.13.2    linux/amd64, linux/amd64/v2, linux/amd64/v3, linux/amd64/v4, linux/386, linux/arm64, linux/riscv64, linux/ppc64le, linux/s390x, linux/mips64le, linux/mips64, linux/loong64, linux/arm/v7, linux/arm/v6</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果要切换回默认的构建器，请执行以下命令</span></span><br><span class=\"line\">docker buildx use default</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用docker-buildx-build命令构建镜像，构建命令必须指定-platform参数\">使用<code>docker buildx build</code>命令构建镜像，构建命令必须指定<code>--platform</code>参数</h2>\n<h3 id=\"示例一：单阶段构建\">示例一：单阶段构建</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>我们依旧以一个springboot项目为例，其Dockerfile如下：</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用轻量级 Alpine 版本的 OpenJDK 17 官方镜像，适合部署 Spring Boot 应用</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> openjdk:<span class=\"number\">17</span>-alpine</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置构建时变量，默认使用构建好的 jar 文件</span></span><br><span class=\"line\"><span class=\"keyword\">ARG</span> JAR_FILE=app.jar</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置运行时环境变量</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> JAVA_OPTS=<span class=\"string\">&quot;-Xms1024M -Xmx1024M -XX:MetaspaceSize=128M -XX:MaxMetaspaceSize=128M&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> TZ=Asia/Shanghai</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 镜像元信息</span></span><br><span class=\"line\"><span class=\"keyword\">LABEL</span><span class=\"language-bash\"> maintainer=<span class=\"string\">&quot;yourname@example.com&quot;</span></span></span><br><span class=\"line\"><span class=\"keyword\">LABEL</span><span class=\"language-bash\"> version=<span class=\"string\">&quot;1.0.0&quot;</span></span></span><br><span class=\"line\"><span class=\"keyword\">LABEL</span><span class=\"language-bash\"> description=<span class=\"string\">&quot;用于部署 Spring Boot 应用的生产级镜像&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置工作目录</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 复制 Spring Boot 构建生成的 jar 包</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> <span class=\"variable\">$&#123;JAR_FILE&#125;</span> app.jar</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 声明暴露的应用端口（Spring Boot 默认是 8080）</span></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">8080</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置容器启动时的主命令（ENTRYPOINT 不会被 docker run 参数覆盖）</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> [<span class=\"string\">&quot;sh&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>, <span class=\"string\">&quot;java <span class=\"variable\">$JAVA_OPTS</span> -jar app.jar&quot;</span>]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># CMD 提供默认的运行参数，可以被 docker run 覆盖</span></span><br><span class=\"line\"><span class=\"comment\"># 这里通过 Spring Boot 参数设置启动环境和端口号</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;--spring.profiles.active=app&quot;</span>, <span class=\"string\">&quot;--server.port=8080&quot;</span>]</span></span><br><span class=\"line\"><span class=\"comment\"># 这里使用的是 ENTRYPOINT + CMD 的混合模式</span></span><br><span class=\"line\"><span class=\"comment\"># 完整命令： java $JAVA_OPTS -jar app.jar --spring.profiles.active=app --server.port=8080</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 声明一个卷挂载点，运行容器时可将该路径映射到宿主机，实现数据持久化</span></span><br><span class=\"line\"><span class=\"keyword\">VOLUME</span><span class=\"language-bash\"> [<span class=\"string\">&quot;/app/logs&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>开始构建镜像，<code>docker buildx build == docker build</code>，构建多平台架构时需要使用<code>--platform</code>指定构建平台</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># --platform inux/arm64 :构建arm64镜像</span></span><br><span class=\"line\"><span class=\"comment\"># -t &quot;app.arm64&quot; :构建后镜像名称，没有指定版本默认就是：latest</span></span><br><span class=\"line\"><span class=\"comment\"># --load :构建后加载到本地</span></span><br><span class=\"line\"><span class=\"comment\"># . :当前目录查找Dockerfile文件</span></span><br><span class=\"line\"><span class=\"comment\"># -f :如果名称不为Dockerfile，则通过该参数指定Dockerfile文件的名称</span></span><br><span class=\"line\">docker buildx build --platform linux/arm64 -t <span class=\"string\">&quot;app.arm64&quot;</span> --load .</span><br><span class=\"line\"><span class=\"comment\">## 此时会遇到如下错误</span></span><br><span class=\"line\">ERROR: failed to solve: openjdk:17-alpine: failed to resolve <span class=\"built_in\">source</span> metadata <span class=\"keyword\">for</span> docker.io/library/openjdk:17-alpine: no match <span class=\"keyword\">for</span> platform <span class=\"keyword\">in</span> manifest: not found</span><br><span class=\"line\"><span class=\"comment\">## 原因：openjdk:17-alpine 这个镜像不支持arm64平台，我们需要更换一个支持多平台的镜像</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如何查看镜像是否支持多平台呢？可以在docker hub上查看，也可以使用如下命令</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查询镜像支持的平台，不过国内依旧是不支持</span></span><br><span class=\"line\">docker buildx imagetools inspect nginx:latest |  grep Platform | <span class=\"built_in\">sort</span> | <span class=\"built_in\">uniq</span></span><br><span class=\"line\"><span class=\"comment\"># 可以在镜像名称前加上国内的镜像仓库地址进行查询，比如：</span></span><br><span class=\"line\">docker buildx imagetools inspect docker.1ms.run/nginx:latest |  grep Platform | <span class=\"built_in\">sort</span> | <span class=\"built_in\">uniq</span></span><br><span class=\"line\"><span class=\"comment\">## 输出结果</span></span><br><span class=\"line\">  Platform:    linux/386</span><br><span class=\"line\">  Platform:    linux/amd64</span><br><span class=\"line\">  Platform:    linux/arm64/v8</span><br><span class=\"line\">  Platform:    linux/arm/v5</span><br><span class=\"line\">  Platform:    linux/arm/v7</span><br><span class=\"line\">  Platform:    linux/mips64le</span><br><span class=\"line\">  Platform:    linux/ppc64le</span><br><span class=\"line\">  Platform:    linux/s390x</span><br><span class=\"line\">  Platform:    unknown/unknown</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 接着我们查看openjdk:17-alpine这个镜像</span></span><br><span class=\"line\">docker buildx imagetools inspect docker.1ms.run/openjdk:17-alpine | grep Platform | <span class=\"built_in\">sort</span> | <span class=\"built_in\">uniq</span></span><br><span class=\"line\"><span class=\"comment\">## 输出结果，其确实不支持 linux/arm64</span></span><br><span class=\"line\">  Platform:  linux/amd64</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 我们换一个openjdk镜像试试</span></span><br><span class=\"line\">docker buildx imagetools inspect docker.1ms.run/openjdk:17-slim | grep Platform | <span class=\"built_in\">sort</span> | <span class=\"built_in\">uniq</span></span><br><span class=\"line\"><span class=\"comment\">## 输出结果，可以看到这个镜像同时支持amd64和arm64架构</span></span><br><span class=\"line\">  Platform:  linux/amd64</span><br><span class=\"line\">  Platform:  linux/arm64/v8</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 也可以使用skopeo容器的方式进行查询</span></span><br><span class=\"line\">docker run --<span class=\"built_in\">rm</span> quay.io/skopeo/stable:latest inspect --raw --override-os linux docker://docker.1ms.run/openjdk:17-slim | jq -r <span class=\"string\">&#x27;.manifests[].platform | &quot;\\(.os)/\\(.architecture)/\\(.variant)&quot;&#x27;</span> | <span class=\"built_in\">sort</span> | <span class=\"built_in\">uniq</span> | sed <span class=\"string\">&#x27;s/\\/null//&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">## 输出结果</span></span><br><span class=\"line\">linux/amd64</span><br><span class=\"line\">linux/arm64/v8</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>替换支持多架构的镜像后重新构建镜像就会成功</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker buildx build --platform linux/arm64 -t <span class=\"string\">&quot;app.arm64&quot;</span> --load .</span><br><span class=\"line\">docker buildx build --platform linux/amd64 -t <span class=\"string\">&quot;app.amd64&quot;</span> --load .</span><br><span class=\"line\"><span class=\"comment\"># 列出镜像</span></span><br><span class=\"line\">docker images</span><br><span class=\"line\"><span class=\"comment\">## 输出结果</span></span><br><span class=\"line\">REPOSITORY              TAG                IMAGE ID       CREATED        SIZE</span><br><span class=\"line\">app.amd64               latest             859162438372   2 hours ago    431MB</span><br><span class=\"line\">app.arm64               latest             0058c70dd16e   2 hours ago    426MB</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看构建后镜像的架构</span></span><br><span class=\"line\">docker inspect app.amd64 | jq <span class=\"string\">&#x27;.[0].Architecture&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\"><span class=\"string\">&quot;amd64&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 我们也可以将构建后的镜像输出到本地目录</span></span><br><span class=\"line\">docker buildx build --platform linux/amd64 -t <span class=\"string\">&quot;app.amd64&quot;</span> --output <span class=\"built_in\">type</span>=docker,dest=./app.amd64.tar .</span><br><span class=\"line\"><span class=\"comment\"># 然后再将镜像导入到本地镜像仓库中</span></span><br><span class=\"line\">docker load -i app.amd64.tar</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>--load</code>和 <code>--output</code>都不支持一个镜像多种架构，要构建像<code>openjdk:17-slim</code>这种支持多架构的镜像可以使用<code>--push</code>，一步就推送到远程仓库</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 构建多架构镜像，--push 可以一步做到：多平台构建的镜像不能只保存到本地，必须推送到远程 registry 才能合并架构。</span></span><br><span class=\"line\"><span class=\"comment\"># 这里以推送到 docker hub 为例</span></span><br><span class=\"line\"><span class=\"comment\"># 登录 docker hup</span></span><br><span class=\"line\">docker login -u hanqunfeng</span><br><span class=\"line\"><span class=\"comment\"># 构建，注意这里的镜像名称要加上你的dockerhub的命名空间，--platform 指定构建的架构，可以指定多个，需要Dockerfile配置基础镜像支持对应的架构</span></span><br><span class=\"line\">docker buildx build --platform linux/amd64,linux/arm64 -t hanqunfeng/app:latest --push .</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/WdmJx0.png\" alt=\"\"></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>镜像拉取</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 拉取指定架构镜像，不指定 --platform 参数，默认拉取当前架构的镜像</span></span><br><span class=\"line\">docker pull --platform=linux/arm64 hanqunfeng/app:latest</span><br></pre></td></tr></table></figure>\n<h3 id=\"示例二：多阶段构建\">示例二：多阶段构建</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>要求每个阶段中的基础镜像都要支持多架构</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 第一阶段：获取代码</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> alpine/git AS fetcher</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /workspace/application</span></span><br><span class=\"line\"><span class=\"comment\"># 将替换为实际的Git仓库URL和分支/标签</span></span><br><span class=\"line\"><span class=\"keyword\">ARG</span> GIT_REPOSITORY=https://gitee.com/hanqunfeng/springbootweb.git</span><br><span class=\"line\"><span class=\"keyword\">ARG</span> GIT_BRANCH=master</span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> git <span class=\"built_in\">clone</span> -b <span class=\"variable\">$&#123;GIT_BRANCH&#125;</span> <span class=\"variable\">$&#123;GIT_REPOSITORY&#125;</span> .</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第二阶段：使用Maven环境进行构建</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> maven:<span class=\"number\">3.8</span>.<span class=\"number\">4</span>-openjdk-<span class=\"number\">17</span> AS builder</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /workspace/application</span></span><br><span class=\"line\"><span class=\"comment\"># 从第一阶段复制代码</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> --from=fetcher /workspace/application .</span></span><br><span class=\"line\"><span class=\"comment\"># 使用Maven清理并打包</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> mvn clean package -DskipTests</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第三阶段：创建最终的运行环境</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> openjdk:<span class=\"number\">17</span>-slim</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"comment\"># 设置运行时环境变量</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> JAVA_OPTS=<span class=\"string\">&quot;-Xms1024M -Xmx1024M -XX:MetaspaceSize=128M -XX:MaxMetaspaceSize=128M&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 将第二阶段生成的目标文件复制到这里。注意这里假设你的spring boot工程打成的jar名是target/app.jar</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> --from=builder /workspace/application/target/app.jar app.jar</span></span><br><span class=\"line\"><span class=\"comment\"># 暴露端口（如果需要的话）。请根据实际情况修改端口号</span></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">8080</span></span><br><span class=\"line\"><span class=\"comment\"># 声明一个卷挂载点，运行容器时可将该路径映射到宿主机，实现数据持久化</span></span><br><span class=\"line\"><span class=\"keyword\">VOLUME</span><span class=\"language-bash\"> [<span class=\"string\">&quot;/app/logs&quot;</span>]</span></span><br><span class=\"line\"><span class=\"comment\"># 设置容器启动时的主命令（ENTRYPOINT 不会被 docker run 参数覆盖）</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> [<span class=\"string\">&quot;sh&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>, <span class=\"string\">&quot;java <span class=\"variable\">$JAVA_OPTS</span> -jar app.jar&quot;</span>]</span></span><br><span class=\"line\"><span class=\"comment\"># CMD 提供默认的运行参数，可以被 docker run 覆盖</span></span><br><span class=\"line\"><span class=\"comment\"># 这里通过 Spring Boot 参数设置启动环境和端口号</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;--spring.profiles.active=app&quot;</span>, <span class=\"string\">&quot;--server.port=8080&quot;</span>]</span></span><br><span class=\"line\"><span class=\"comment\"># 这里使用的是 ENTRYPOINT + CMD 的混合模式</span></span><br><span class=\"line\"><span class=\"comment\"># 完整命令： java $JAVA_OPTS -jar app.jar --spring.profiles.active=app --server.port=8080</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>构建镜像</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 构建多平台镜像并发布到dockerhub</span></span><br><span class=\"line\">docker buildx build --platform linux/amd64,linux/arm64 -t hanqunfeng/springboot:latest --push .</span><br></pre></td></tr></table></figure>\n<h2 id=\"如何将构建好的多个单平台镜像发布为一个多平台镜像\">如何将构建好的多个单平台镜像发布为一个多平台镜像</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果你已经分别构建好单平台镜像，也可以用 <code>docker buildx imagetools create</code> 来合并</p>\n</li>\n<li class=\"lvl-2\">\n<p>以上面创建的两个单平台镜像为例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出镜像</span></span><br><span class=\"line\">docker images</span><br><span class=\"line\"><span class=\"comment\">## 输出结果</span></span><br><span class=\"line\">REPOSITORY              TAG                IMAGE ID       CREATED        SIZE</span><br><span class=\"line\">app.amd64               latest             859162438372   2 hours ago    431MB</span><br><span class=\"line\">app.arm64               latest             0058c70dd16e   2 hours ago    426MB</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 一定要推送单平台镜像到远程仓库，否则无法完成合并</span></span><br><span class=\"line\">docker tag app.amd64 hanqunfeng/app:amd64</span><br><span class=\"line\">docker push hanqunfeng/app:amd64</span><br><span class=\"line\"></span><br><span class=\"line\">docker tag app.arm64 hanqunfeng/app:arm64</span><br><span class=\"line\">docker push hanqunfeng/app:arm64</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 合并，创建多平台镜像指向（manifest list）</span></span><br><span class=\"line\">docker buildx imagetools create \\</span><br><span class=\"line\">  --tag hanqunfeng/app:latest \\</span><br><span class=\"line\">   hanqunfeng/app:amd64 \\</span><br><span class=\"line\">   hanqunfeng/app:arm64</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/5azhzj.png\" alt=\"\"></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果不需要单平台镜像，可以在dockerhub上删除即可。</p>\n</li>\n</ul>\n<h2 id=\"移除-BuildKit（Buildx）构建过程中产生的缓存数据\">移除 BuildKit（Buildx）构建过程中产生的缓存数据</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>BuildKit（Buildx）构建过程会产生缓存数据，包括未使用的中间镜像、构建层等。对于频繁使用 Docker 构建的开发者来说，这些缓存会逐渐占用大量磁盘空间。</p>\n</li>\n<li class=\"lvl-2\">\n<p>可以通过该命令查看缓存占用磁盘空间的大小</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker buildx <span class=\"built_in\">du</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker buildx prune</code> 是一个用于 清理 Docker Buildx 构建缓存 的命令，常用于释放磁盘空间。</p>\n</li>\n<li class=\"lvl-2\">\n<p>命令语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker buildx prune [OPTIONS]</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>OPTIONS</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-a</code>, <code>--all</code></td>\n<td><strong>包括内部/前端镜像</strong>。默认只删除无用缓存，加上该参数会清除更多缓存内容，包括可能仍可用的内容（更彻底）。</td>\n</tr>\n<tr>\n<td><code>--builder string</code></td>\n<td>指定使用哪个 builder 实例（可通过 <code>docker buildx ls</code> 查看当前有哪些 builder）。</td>\n</tr>\n<tr>\n<td><code>--filter filter</code></td>\n<td>设定清理条件，例如：<code>until=24h</code> 表示只删除 24 小时前的缓存。</td>\n</tr>\n<tr>\n<td><code>-f</code>, <code>--force</code></td>\n<td><strong>不提示确认，直接执行清理操作</strong>。常用于脚本中。</td>\n</tr>\n<tr>\n<td><code>--keep-storage bytes</code></td>\n<td>保留指定大小的缓存空间，其余删除（如：<code>--keep-storage 5GB</code>）。</td>\n</tr>\n<tr>\n<td><code>--verbose</code></td>\n<td>输出更详细的清理信息。</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除所有未使用的缓存，并跳过确认提示</span></span><br><span class=\"line\">docker buildx prune -f</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 只删除 24 小时前的缓存，保留 10GB 的缓存空间</span></span><br><span class=\"line\">docker buildx prune --filter <span class=\"string\">&quot;until=24h&quot;</span> --keep-storage 10GB</span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍 Docker 命令 中 Dockerfile 多平台构建的使用方法 Docker官方文档 Dockerfile官方文档 Multi-platform builds 什么是Dockerfile 多平台构建？ Dockerfile 多平台构建，可以构建多个平台镜像，比如 arm64、amd64、arm、386 等。 在没有安装 docker-buildx-plugin 的情况下，docker build 命令是不支持使用 --platform 构建出跨平台镜像的，其仅能构建与本机架构平台相同的镜像。 要真正实现跨平台构建（multi-platform build），比如在 amd64 上构建 arm64 的镜像，需要使用 BuildKit 和 buildx 插件。 docker-buildx-plugin 是基于 BuildKit 构建的，但它本身是 Buildx 的一个实现形式，它扩展了 docker build 的能力，支持多平台构建（如同时构建 Linux/amd64 和 Linux/arm64等）。 安装 docker-buildx-plugin 随docker服务一起安装 1sudo dnf -y install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 单独安装 1sudo dnf -y install docker-buildx-plugin 查看版本 1docker buildx version docker buildx 基本命令 以下命令在后面的示例中都有使用 命令 说明 docker buildx create 创建一个新的构建器实例 docker buildx use 设置当前使用的构建器 docker buildx inspect 查看构建器状态和支持的平台 docker buildx build 构建镜像（增强版），等同于 docker build docker buildx ls 列出所有构建器 docker buildx rm 删除构建器 docker buildx du 查看构建器使用的磁盘空间 docker buildx prune 删除构建过程中产生的缓存 docker buildx version 查看 Docker Buildx 的版本信息 要让Docker支持多平台构建，需要满足以下几个条件： Linux内核开启多处理器架构支持 构建时使用基于docker-container驱动的Buildx实例 使用docker buildx build命令构建镜像，构建命令必须指定–platform参数 Linux内核开启多处理器架构支持 123456789101112131415161718# 列出所有构建器，默认情况下只有一个名称为&quot;default&quot;的构建器docker buildx ls## 输出NAME/NODE DRIVER/ENDPOINT STATUS BUILDKIT PLATFORMSdefault docker \\_ default \\_ default running v0.13.2 linux/amd64, linux/amd64/v2, linux/amd64/v3, linux/amd64/v4, linux/386# 开启多处理器架构支持docker run --privileged --rm tonistiigi/binfmt --install all# 这个镜像用完就可以删除了docker rmi tonistiigi/binfmt# 再次列出所有构建器docker buildx ls## 输出，此时可以看到PLATFORMS中有多个平台NAME/NODE DRIVER/ENDPOINT STATUS BUILDKIT PLATFORMSdefault* docker \\_ default \\_ default running v0.13.2 linux/amd64, linux/amd64/v2, linux/amd64/v3, linux/amd64/v4, linux/386, linux/arm64, linux/riscv64, linux/ppc64le, linux/s390x, linux/mips64le, linux/mips64, linux/loong64, linux/arm/v7, linux/arm/v6 构建时使用基于docker-container驱动的Buildx实例 Docker 的默认构建驱动是 docker，它是运行在本地 Docker 守护进程上的，不能进行真正的多平台构建（仅能构建当前平台）。 多平台构建需要使用 BuildKit 的 container 驱动，它以容器的形式运行构建器，支持虚拟化平台并行构建。 123456789101112131415# 查看当前默认的构建器defaultdocker buildx inspect default# 输出Name: defaultDriver: dockerLast Activity: 2025-06-06 07:42:42 +0000 UTCNodes:Name: defaultEndpoint: defaultStatus: runningBuildKit version: v0.13.2Platforms: linux/amd64, linux/amd64/v2, linux/amd64/v3, linux/amd64/v4, linux/386, linux/arm64, linux/riscv64, linux/ppc64le, linux/s390x, linux/mips64le, linux/mips64, linux/loong64, linux/arm/v7, linux/arm/v6Labels: org.mobyproject.buildkit.worker.moby.host-gateway-ip: 172.17.0.1 创建基于 docker-container 驱动的Buildx实例 12345678910111213# 创建并切换到名为mybuilder的构建器实例docker buildx create --name mybuilder --use --driver docker-container# 查看当前构建器信息，--bootstrap：查看前确保构建器已启动 ，此时看到其Driver为docker-container，这个命令第一次执行时可能会提示错误，不过不用管，再次运行就正常了docker buildx inspect --bootstrap## 输出Name: mybuilderDriver: docker-container……………………………………# 此时会启动一个名称为`buildx_buildkit_mybuilder0`的容器，每创建一个构建器实例，就会启动一个名称为`buildx_buildkit_xxx`的容器，删除构建器时，其对应的容器也会被删除docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES0ab9cab9ec9b moby/buildkit:buildx-stable-1 &quot;buildkitd --allow-i…&quot; About an hour ago Up About an hour buildx_buildkit_mybuilder0 buildx_buildkit_xxx这个容器就是一个 BuildKit 守护进程容器，它是执行 buildx 构建任务的实际工作引擎。其对应的镜像为moby/buildkit:buildx-stable-1，容器会在执行docker buildx build 或 docker buildx inspect --bootstrap 时启动 功能 说明 👷 执行构建任务 真正执行 buildx build 指令里的构建过程，比如多阶段构建、缓存处理、跨平台编译等 📦 拉取镜像 拉取 Dockerfile 中的基础镜像 📤 上传/导出镜像 支持导出为 docker image, tar, 推送到远程 registry 🪣 管理缓存 管理构建缓存（中间镜像、层等）以加速后续构建 🌍 支持多平台 通过 QEMU 或交叉编译器支持跨平台（如构建 arm64 镜像） 在国内环境使用时，如果不能科学上网，当我们在构建镜像时会提示无法拉取基础镜像，即便我们已经在/etc/docker/daemon.json中配置了国内的镜像源也不行，这是因为docker buildx 使用的是 BuildKit，它的行为不同于传统的 docker build 特性 docker build（传统） docker buildx（BuildKit） 是否使用本地镜像缓存 ✅ 是 ⚠️ 不是 是否需要联网拉取元数据（即使镜像已存在） 否 是 构建网络隔离 不隔离 隔离构建，无法直接访问宿主镜像缓存 解决方法为构建器配置镜像源 1234567891011121314151617181920212223242526272829# 创建 BuildKit 配置文件 buildkitd.tomlcat &lt;&lt;EOF &gt; buildkitd.toml[registry.&quot;docker.io&quot;] mirrors = [&quot;https://docker.1ms.run&quot;][worker.oci] gc = trueEOF# 创建 BuildKit 构建器，并指定配置文件docker buildx create --name mybuilder --use --driver docker-container --config ./buildkitd.tomldocker buildx inspect --bootstrap# 如果存在同名的构建器，则删除它后再创建docker buildx rm mybuilderdocker buildx create --name mybuilder --use --driver docker-container --config ./buildkitd.tomldocker buildx inspect --bootstrap# 查看构建器列表docker buildx ls## 输出NAME/NODE DRIVER/ENDPOINT STATUS BUILDKIT PLATFORMSmybuilder* docker-container \\_ mybuilder0 \\_ unix:///var/run/docker.sock running v0.21.1 linux/amd64, linux/amd64/v2, linux/amd64/v3, linux/amd64/v4, linux/arm64, linux/riscv64, linux/ppc64le, linux/s390x, linux/386, linux/mips64le, linux/mips64, linux/loong64, linux/arm/v7, linux/arm/v6default docker \\_ default \\_ default running v0.13.2 linux/amd64, linux/amd64/v2, linux/amd64/v3, linux/amd64/v4, linux/386, linux/arm64, linux/riscv64, linux/ppc64le, linux/s390x, linux/mips64le, linux/mips64, linux/loong64, linux/arm/v7, linux/arm/v6# 如果要切换回默认的构建器，请执行以下命令docker buildx use default 使用docker buildx build命令构建镜像，构建命令必须指定--platform参数 示例一：单阶段构建 我们依旧以一个springboot项目为例，其Dockerfile如下： 1234567891011121314151617181920212223242526272829303132333435# 使用轻量级 Alpine 版本的 OpenJDK 17 官方镜像，适合部署 Spring Boot 应用FROM openjdk:17-alpine# 设置构建时变量，默认使用构建好的 jar 文件ARG JAR_FILE=app.jar# 设置运行时环境变量ENV JAVA_OPTS=&quot;-Xms1024M -Xmx1024M -XX:MetaspaceSize=128M -XX:MaxMetaspaceSize=128M&quot;ENV TZ=Asia/Shanghai# 镜像元信息LABEL maintainer=&quot;yourname@example.com&quot;LABEL version=&quot;1.0.0&quot;LABEL description=&quot;用于部署 Spring Boot 应用的生产级镜像&quot;# 设置工作目录WORKDIR /app# 复制 Spring Boot 构建生成的 jar 包COPY $&#123;JAR_FILE&#125; app.jar# 声明暴露的应用端口（Spring Boot 默认是 8080）EXPOSE 8080# 设置容器启动时的主命令（ENTRYPOINT 不会被 docker run 参数覆盖）ENTRYPOINT [&quot;sh&quot;, &quot;-c&quot;, &quot;java $JAVA_OPTS -jar app.jar&quot;]# CMD 提供默认的运行参数，可以被 docker run 覆盖# 这里通过 Spring Boot 参数设置启动环境和端口号CMD [&quot;--spring.profiles.active=app&quot;, &quot;--server.port=8080&quot;]# 这里使用的是 ENTRYPOINT + CMD 的混合模式# 完整命令： java $JAVA_OPTS -jar app.jar --spring.profiles.active=app --server.port=8080# 声明一个卷挂载点，运行容器时可将该路径映射到宿主机，实现数据持久化VOLUME [&quot;/app/logs&quot;] 开始构建镜像，docker buildx build == docker build，构建多平台架构时需要使用--platform指定构建平台 123456789# --platform inux/arm64 :构建arm64镜像# -t &quot;app.arm64&quot; :构建后镜像名称，没有指定版本默认就是：latest# --load :构建后加载到本地# . :当前目录查找Dockerfile文件# -f :如果名称不为Dockerfile，则通过该参数指定Dockerfile文件的名称docker buildx build --platform linux/arm64 -t &quot;app.arm64&quot; --load .## 此时会遇到如下错误ERROR: failed to solve: openjdk:17-alpine: failed to resolve source metadata for docker.io/library/openjdk:17-alpine: no match for platform in manifest: not found## 原因：openjdk:17-alpine 这个镜像不支持arm64平台，我们需要更换一个支持多平台的镜像 如何查看镜像是否支持多平台呢？可以在docker hub上查看，也可以使用如下命令 1234567891011121314151617181920212223242526272829303132# 查询镜像支持的平台，不过国内依旧是不支持docker buildx imagetools inspect nginx:latest | grep Platform | sort | uniq# 可以在镜像名称前加上国内的镜像仓库地址进行查询，比如：docker buildx imagetools inspect docker.1ms.run/nginx:latest | grep Platform | sort | uniq## 输出结果 Platform: linux/386 Platform: linux/amd64 Platform: linux/arm64/v8 Platform: linux/arm/v5 Platform: linux/arm/v7 Platform: linux/mips64le Platform: linux/ppc64le Platform: linux/s390x Platform: unknown/unknown# 接着我们查看openjdk:17-alpine这个镜像docker buildx imagetools inspect docker.1ms.run/openjdk:17-alpine | grep Platform | sort | uniq## 输出结果，其确实不支持 linux/arm64 Platform: linux/amd64# 我们换一个openjdk镜像试试docker buildx imagetools inspect docker.1ms.run/openjdk:17-slim | grep Platform | sort | uniq## 输出结果，可以看到这个镜像同时支持amd64和arm64架构 Platform: linux/amd64 Platform: linux/arm64/v8# 也可以使用skopeo容器的方式进行查询docker run --rm quay.io/skopeo/stable:latest inspect --raw --override-os linux docker://docker.1ms.run/openjdk:17-slim | jq -r &#x27;.manifests[].platform | &quot;\\(.os)/\\(.architecture)/\\(.variant)&quot;&#x27; | sort | uniq | sed &#x27;s/\\/null//&#x27;## 输出结果linux/amd64linux/arm64/v8 替换支持多架构的镜像后重新构建镜像就会成功 123456789101112131415161718docker buildx build --platform linux/arm64 -t &quot;app.arm64&quot; --load .docker buildx build --platform linux/amd64 -t &quot;app.amd64&quot; --load .# 列出镜像docker images## 输出结果REPOSITORY TAG IMAGE ID CREATED SIZEapp.amd64 latest 859162438372 2 hours ago 431MBapp.arm64 latest 0058c70dd16e 2 hours ago 426MB# 查看构建后镜像的架构docker inspect app.amd64 | jq &#x27;.[0].Architecture&#x27;## 输出&quot;amd64&quot;# 我们也可以将构建后的镜像输出到本地目录docker buildx build --platform linux/amd64 -t &quot;app.amd64&quot; --output type=docker,dest=./app.amd64.tar .# 然后再将镜像导入到本地镜像仓库中docker load -i app.amd64.tar --load和 --output都不支持一个镜像多种架构，要构建像openjdk:17-slim这种支持多架构的镜像可以使用--push，一步就推送到远程仓库 123456# 构建多架构镜像，--push 可以一步做到：多平台构建的镜像不能只保存到本地，必须推送到远程 registry 才能合并架构。# 这里以推送到 docker hub 为例# 登录 docker hupdocker login -u hanqunfeng# 构建，注意这里的镜像名称要加上你的dockerhub的命名空间，--platform 指定构建的架构，可以指定多个，需要Dockerfile配置基础镜像支持对应的架构docker buildx build --platform linux/amd64,linux/arm64 -t hanqunfeng/app:latest --push . 镜像拉取 12# 拉取指定架构镜像，不指定 --platform 参数，默认拉取当前架构的镜像docker pull --platform=linux/arm64 hanqunfeng/app:latest 示例二：多阶段构建 要求每个阶段中的基础镜像都要支持多架构 12345678910111213141516171819202122232425262728293031323334# 第一阶段：获取代码FROM alpine/git AS fetcherWORKDIR /workspace/application# 将替换为实际的Git仓库URL和分支/标签ARG GIT_REPOSITORY=https://gitee.com/hanqunfeng/springbootweb.gitARG GIT_BRANCH=masterRUN git clone -b $&#123;GIT_BRANCH&#125; $&#123;GIT_REPOSITORY&#125; .# 第二阶段：使用Maven环境进行构建FROM maven:3.8.4-openjdk-17 AS builderWORKDIR /workspace/application# 从第一阶段复制代码COPY --from=fetcher /workspace/application .# 使用Maven清理并打包RUN mvn clean package -DskipTests# 第三阶段：创建最终的运行环境FROM openjdk:17-slimWORKDIR /app# 设置运行时环境变量ENV JAVA_OPTS=&quot;-Xms1024M -Xmx1024M -XX:MetaspaceSize=128M -XX:MaxMetaspaceSize=128M&quot;# 将第二阶段生成的目标文件复制到这里。注意这里假设你的spring boot工程打成的jar名是target/app.jarCOPY --from=builder /workspace/application/target/app.jar app.jar# 暴露端口（如果需要的话）。请根据实际情况修改端口号EXPOSE 8080# 声明一个卷挂载点，运行容器时可将该路径映射到宿主机，实现数据持久化VOLUME [&quot;/app/logs&quot;]# 设置容器启动时的主命令（ENTRYPOINT 不会被 docker run 参数覆盖）ENTRYPOINT [&quot;sh&quot;, &quot;-c&quot;, &quot;java $JAVA_OPTS -jar app.jar&quot;]# CMD 提供默认的运行参数，可以被 docker run 覆盖# 这里通过 Spring Boot 参数设置启动环境和端口号CMD [&quot;--spring.profiles.active=app&quot;, &quot;--server.port=8080&quot;]# 这里使用的是 ENTRYPOINT + CMD 的混合模式# 完整命令： java $JAVA_OPTS -jar app.jar --spring.profiles.active=app --server.port=8080 构建镜像 12# 构建多平台镜像并发布到dockerhubdocker buildx build --platform linux/amd64,linux/arm64 -t hanqunfeng/springboot:latest --push . 如何将构建好的多个单平台镜像发布为一个多平台镜像 如果你已经分别构建好单平台镜像，也可以用 docker buildx imagetools create 来合并 以上面创建的两个单平台镜像为例 12345678910111213141516171819# 列出镜像docker images## 输出结果REPOSITORY TAG IMAGE ID CREATED SIZEapp.amd64 latest 859162438372 2 hours ago 431MBapp.arm64 latest 0058c70dd16e 2 hours ago 426MB# 一定要推送单平台镜像到远程仓库，否则无法完成合并docker tag app.amd64 hanqunfeng/app:amd64docker push hanqunfeng/app:amd64docker tag app.arm64 hanqunfeng/app:arm64docker push hanqunfeng/app:arm64# 合并，创建多平台镜像指向（manifest list）docker buildx imagetools create \\ --tag hanqunfeng/app:latest \\ hanqunfeng/app:amd64 \\ hanqunfeng/app:arm64 如果不需要单平台镜像，可以在dockerhub上删除即可。 移除 BuildKit（Buildx）构建过程中产生的缓存数据 BuildKit（Buildx）构建过程会产生缓存数据，包括未使用的中间镜像、构建层等。对于频繁使用 Docker 构建的开发者来说，这些缓存会逐渐占用大量磁盘空间。 可以通过该命令查看缓存占用磁盘空间的大小 1docker buildx du docker buildx prune 是一个用于 清理 Docker Buildx 构建缓存 的命令，常用于释放磁盘空间。 命令语法 1docker buildx prune [OPTIONS] OPTIONS 作用 -a, --all 包括内部/前端镜像。默认只删除无用缓存，加上该参数会清除更多缓存内容，包括可能仍可用的内容（更彻底）。 --builder string 指定使用哪个 builder 实例（可通过 docker buildx ls 查看当前有哪些 builder）。 --filter filter 设定清理条件，例如：until=24h 表示只删除 24 小时前的缓存。 -f, --force 不提示确认，直接执行清理操作。常用于脚本中。 --keep-storage bytes 保留指定大小的缓存空间，其余删除（如：--keep-storage 5GB）。 --verbose 输出更详细的清理信息。 示例 12345# 删除所有未使用的缓存，并跳过确认提示docker buildx prune -f# 只删除 24 小时前的缓存，保留 10GB 的缓存空间docker buildx prune --filter &quot;until=24h&quot; --keep-storage 10GB","summary":"摘要 本文介绍 Docker 命令 中 Dockerfile 多平台构建的使用方法 Docker官方文档 Dockerfile官方文档 Multi-platform builds","date_published":"2025-06-06T13:30:05.000Z","tags":["技术","docker","docker"]},{"id":"https://blog.hanqunfeng.com/2025/06/05/docker-remote-connection/","url":"https://blog.hanqunfeng.com/2025/06/05/docker-remote-connection/","title":"Docker 之 远程连接","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍如何远程连接Docker</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com\">Docker官方文档</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"远程连接Docker有如下三种方式\">远程连接Docker有如下三种方式</h2>\n<h3 id=\"方式一：开启-TCP（不带-TLS，仅用于内网调试）\">方式一：开启 TCP（不带 TLS，仅用于内网调试）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在docker服务端编辑 <code>/etc/docker/daemon.json</code>，加上：</p>\n</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;hosts&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;unix:///var/run/docker.sock&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;tcp://0.0.0.0:2375&quot;</span><span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此时通过<code>sudo systemctl restart docker</code>重启 Docker会启动失败，原因是systemd会在docker启动命令中添加 <code>-H fd://</code>，其含义是从 systemd 传递进来的 socket 文件描述符监听 API 请求，当 Docker 被 systemd 启动并启用 socket activation（套接字激活）时，systemd 会预先创建 socket（比如 /var/run/docker.sock），然后再启动 dockerd，并通过文件描述符（fd）把这个 socket 传递给 dockerd。此时你在 dockerd 中看到的 <code>-H fd://</code> 意思是：“不用自己打开 socket，去 systemd 那里拿吧。”</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 通过该命令可以获取 docker 的启动命令文件是 /usr/lib/systemd/system/docker.service</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl status docker</span><br><span class=\"line\"><span class=\"comment\"># 查看 /usr/lib/systemd/system/docker.service，可以看到 docker的启动命令如下，可以看到  -H fd://</span></span><br><span class=\"line\">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock</span><br><span class=\"line\"><span class=\"comment\"># 另外可以在与 docker.service 同目录下找到  docker.socket 文件，可以看到如下内容</span></span><br><span class=\"line\">ListenStream=/run/docker.sock <span class=\"comment\"># /run 目录是被软连接到 /var/run/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 总结：通过systemd 启动 docker时，如果配置了 -H fd://，则 docker 会监听 /run/docker.sock 文件，实际上也就是 /var/run/docker.sock</span></span><br><span class=\"line\"><span class=\"comment\"># 而我们在/etc/docker/daemon.json中加上的&quot;unix:///var/run/docker.sock&quot;, &quot;tcp://0.0.0.0:2375&quot;实际上就是改写docker的启动参数，这就与 systemd 启动 docker 的 `-H fd://` 参数冲突了</span></span><br><span class=\"line\"><span class=\"comment\"># 此时我们可以不使用systemd 启动 docker，而是使用 docker daemon 启动 docker</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> dockerd --containerd=/run/containerd/containerd.sock</span><br><span class=\"line\"><span class=\"comment\"># 但这样不利于 docker 的管理，因此最好的方式是禁用 `-H fd://`</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>禁用 <code>-H fd://</code>（systemd 与 daemon.json 冲突的根源）</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 方式一: 去掉 `-H fd://` 参数</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> vi /usr/lib/systemd/system/docker.service</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方式二(推荐): 创建 override.conf 文件，其作用是 覆盖 systemd 默认配置文件，只会覆盖指定的参数</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">mkdir</span> -p /etc/systemd/system/docker.service.d</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> vi /etc/systemd/system/docker.service.d/override.conf</span><br><span class=\"line\"><span class=\"comment\"># 填入</span></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">ExecStart=</span><br><span class=\"line\">ExecStart=/usr/bin/dockerd --containerd=/run/containerd/containerd.sock</span><br><span class=\"line\"><span class=\"comment\"># 这里顺便说一下，`--containerd=/run/containerd/containerd.sock` 是 docker 默认参数，</span></span><br><span class=\"line\"><span class=\"comment\"># 告诉 Docker 守护进程去连接已有的 containerd 实例，而不是自己启动一个新的。</span></span><br><span class=\"line\"><span class=\"comment\"># Docker 默认内部使用 containerd 来管理容器运行时，所以这条参数是明确指定要使用哪个 containerd 服务。</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>重启 docker daemon</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl daemon-reload</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在客户端测试连接</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker -H tcp://远程IP:2375 ps</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在客户端加入环境变量后就不需要每次都加上 -H 参数了</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># zsh 就换成 ~/.zshrc</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;export DOCKER_HOST=tcp://远程IP:2375&quot;</span>  &gt;&gt; ~/.bashrc</span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bashrc</span><br><span class=\"line\"><span class=\"comment\"># 测试</span></span><br><span class=\"line\">docker ps</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>❗不要开启无认证的 <code>tcp://0.0.0.0:2375</code> 在公网，这是裸奔的安全风险，任何人都能控制你的 Docker。</p>\n</li>\n<li class=\"lvl-2\">\n<p>✅ 推荐方式是：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">使用 <code>tcp://0.0.0.0:2376 + --tlsverify</code></li>\n<li class=\"lvl-6\">或通过 <code>ssh:// 隧道</code> 访问 Docker</li>\n</ul>\n</li>\n</ul>\n<div class=\"tips\">\n<p><em><strong>小贴士</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">通过上面的介绍你应该搞明白一件事，就是我们可以不用在 <code>/etc/docker/daemon.json</code> 中配置远程连接，而是通过 systemd 来配置，即在 <code>/usr/lib/systemd/system/docker.service</code> 或者 <code>/etc/systemd/system/docker.service.d/override.conf</code>中配置。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecStart=/usr/bin/dockerd -H unix:///var/run/docker.sock -H tcp://0.0.0.0:2375 --containerd=/run/containerd/containerd.sock</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">那么问题来了：既然 systemd 就能搞定一切，那还要 <code>/etc/docker/daemon.json</code> 有什么用？答案是：可读性、可维护性、工具兼容性更强。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th><code>daemon.json</code></th>\n<th><code>systemd ExecStart</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>语法</td>\n<td>JSON</td>\n<td>Shell 命令行</td>\n</tr>\n<tr>\n<td>适合设置</td>\n<td>Hosts、日志、registry、镜像驱动等</td>\n<td>启动命令、资源限制等</td>\n</tr>\n<tr>\n<td>可读性</td>\n<td>👍 结构化</td>\n<td>👎 较长、容易出错</td>\n</tr>\n<tr>\n<td>自动化支持</td>\n<td>👍 工具友好</td>\n<td>👎 需要 patch systemd</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"方式二：开启-TCP-TLS-安全访问（推荐用于公网）\">方式二：开启 TCP + TLS 安全访问（推荐用于公网）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建 TLS 证书，通过一个脚本实现，脚本名称 <code>generate-docker-certs.sh</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">set</span> -e</span><br><span class=\"line\"></span><br><span class=\"line\">SERVER_IP=166.189.9.114  <span class=\"comment\"># 🚨 修改为你的 Docker 服务器 IP 或域名</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;[+] 创建 CA...&quot;</span></span><br><span class=\"line\">openssl genrsa -out ca-key.pem 4096</span><br><span class=\"line\">openssl req -new -x509 -days 365 \\</span><br><span class=\"line\">  -key ca-key.pem -subj <span class=\"string\">&quot;/CN=docker-ca&quot;</span> -out ca.pem</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;[+] 创建服务器私钥...&quot;</span></span><br><span class=\"line\">openssl genrsa -out server-key.pem 4096</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;[+] 创建 OpenSSL 配置文件...&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &gt; extfile.cnf &lt;&lt;<span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">[req]</span></span><br><span class=\"line\"><span class=\"string\">distinguished_name = req_distinguished_name</span></span><br><span class=\"line\"><span class=\"string\">x509_extensions = v3_req</span></span><br><span class=\"line\"><span class=\"string\">prompt = no</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">[req_distinguished_name]</span></span><br><span class=\"line\"><span class=\"string\">CN = $&#123;SERVER_IP&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">[v3_req]</span></span><br><span class=\"line\"><span class=\"string\">keyUsage = keyEncipherment, dataEncipherment</span></span><br><span class=\"line\"><span class=\"string\">extendedKeyUsage = serverAuth</span></span><br><span class=\"line\"><span class=\"string\">subjectAltName = @alt_names</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">[alt_names]</span></span><br><span class=\"line\"><span class=\"string\">IP.1 = $&#123;SERVER_IP&#125;</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;[+] 创建服务器证书签名请求 (CSR)...&quot;</span></span><br><span class=\"line\">openssl req -new -key server-key.pem \\</span><br><span class=\"line\">  -out server.csr -config extfile.cnf</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;[+] 签发服务器证书...&quot;</span></span><br><span class=\"line\">openssl x509 -req -days 365 -<span class=\"keyword\">in</span> server.csr \\</span><br><span class=\"line\">  -CA ca.pem -CAkey ca-key.pem -CAcreateserial \\</span><br><span class=\"line\">  -out server-cert.pem -extensions v3_req -extfile extfile.cnf</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;[+] 创建客户端私钥...&quot;</span></span><br><span class=\"line\">openssl genrsa -out key.pem 4096</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;[+] 创建客户端 CSR...&quot;</span></span><br><span class=\"line\">openssl req -new -key key.pem -subj <span class=\"string\">&quot;/CN=client&quot;</span> -out client.csr</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;[+] 签发客户端证书...&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &gt; client-ext.cnf &lt;&lt;<span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">extendedKeyUsage = clientAuth</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\">openssl x509 -req -days 365 -<span class=\"keyword\">in</span> client.csr \\</span><br><span class=\"line\">  -CA ca.pem -CAkey ca-key.pem -CAcreateserial \\</span><br><span class=\"line\">  -out cert.pem -extfile client-ext.cnf</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;[✓] 所有证书生成完成！&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot; 服务器证书: server-cert.pem, server-key.pem&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot; 客户端证书: cert.pem, key.pem&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot; CA根证书:   ca.pem&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>执行脚本</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chmod</span> +x generate-docker-certs.sh</span><br><span class=\"line\">./generate-docker-certs.sh</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>将以下证书文件部署到docker服务端</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 服务端：server-cert.pem, server-key.pem, ca.pem</span></span><br><span class=\"line\"><span class=\"built_in\">cp</span> server-cert.pem /etc/docker/server-cert.pem</span><br><span class=\"line\"><span class=\"built_in\">cp</span> server-key.pem /etc/docker/server-key.pem</span><br><span class=\"line\"><span class=\"built_in\">cp</span> ca.pem /etc/docker/ca.pem</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>将以下证书文件部署到docker客户端</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cert.pem, key.pem, ca.pem</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在docker服务端编辑 <code>/etc/docker/daemon.json</code></p>\n</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;hosts&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;unix:///var/run/docker.sock&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;tcp://0.0.0.0:2376&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;tlsverify&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;tlscacert&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;/etc/docker/ca.pem&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;tlscert&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;/etc/docker/server-cert.pem&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;tlskey&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;/etc/docker/server-key.pem&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>禁用 <code>-H fd://</code>（systemd 与 daemon.json 冲突的根源）</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">mkdir</span> -p /etc/systemd/system/docker.service.d</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> vi /etc/systemd/system/docker.service.d/override.conf</span><br><span class=\"line\"><span class=\"comment\"># 填入</span></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">ExecStart=</span><br><span class=\"line\">ExecStart=/usr/bin/dockerd --containerd=/run/containerd/containerd.sock</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>重启 docker daemon</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl daemon-reload</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在客户端测试连接</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker \\</span><br><span class=\"line\">  --tlsverify \\</span><br><span class=\"line\">  --tlscacert=ca.pem \\</span><br><span class=\"line\">  --tlscert=cert.pem \\</span><br><span class=\"line\">  --tlskey=key.pem \\</span><br><span class=\"line\">  -H tcp://166.189.9.114:2376 \\</span><br><span class=\"line\">  ps</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在客户端加入环境变量后就不需要每次都加上 -H 参数 和证书参数了</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> &lt;&lt;<span class=\"string\">EOT &gt;&gt; ~/.bashrc</span></span><br><span class=\"line\"><span class=\"string\"># 远程Docker IP和端口</span></span><br><span class=\"line\"><span class=\"string\">export DOCKER_HOST=tcp://166.189.9.114:2376</span></span><br><span class=\"line\"><span class=\"string\"># 用于通过 TLS（SSL）安全连接远程 Docker 守护进程，类似于 docker --tlsverify</span></span><br><span class=\"line\"><span class=\"string\">export DOCKER_TLS_VERIFY=1</span></span><br><span class=\"line\"><span class=\"string\"># 这个目录下要有这些证书文件：ca.pem, cert.pem, key.pem</span></span><br><span class=\"line\"><span class=\"string\">export DOCKER_CERT_PATH=/path/to/certs</span></span><br><span class=\"line\"><span class=\"string\">EOT</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bashrc</span><br><span class=\"line\"><span class=\"comment\"># 测试</span></span><br><span class=\"line\">docker ps</span><br></pre></td></tr></table></figure>\n<h3 id=\"方式三：ssh-隧道访问\">方式三：ssh:// 隧道访问</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>最简单的方式就是使用 ssh 远程执行命令的方式，这种方式不需要任何配置，支持密码和证书认证，也支持指定端口，但这不是标准的远程连接docker方式，适用于偶尔访问的情况。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -i ~/.ssh/lexing-test.pem -p22 centos@166.189.9.114 <span class=\"string\">&quot;docker ps&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>基于免密认证，如何配置免密登录可以参考 <a href=\"/2023/02/28/linux-command02-ssh/\" title=\"Linux常用命令--ssh、scp与免密登录\">Linux常用命令--ssh、scp与免密登录</a></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># docker -H 远程访问 不支持在命令行直接输入密码或密钥文件，必须配置免密登录才可以，而且此时端口必须是默认的22</span></span><br><span class=\"line\"><span class=\"comment\"># 要求登录用户必须拥有docker的运行权限（加入 docker group）</span></span><br><span class=\"line\">docker -H ssh://centos@166.189.9.114 ps</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>基于<code>config</code>配置(推荐)</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">这种方式的优点是可以配置证书和端口</li>\n<li class=\"lvl-6\">在 ~/.ssh/config 中指定具体的密钥文件和端口，登录用户必须拥有docker的运行权限（加入 docker group）</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Host mydocker</span><br><span class=\"line\">HostName 166.189.9.114</span><br><span class=\"line\">User centos</span><br><span class=\"line\">Port 22</span><br><span class=\"line\">IdentityFile ~/.ssh/my_docker_key</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">测试</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker -H ssh://mydocker ps</span><br></pre></td></tr></table></figure>\n</li>\n<li class=\"lvl-2\">\n<p>添加环境变量避免每次都加上 <code>-H</code> 参数</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## 基于免密认证</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;export DOCKER_HOST=ssh://user@host&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class=\"line\"><span class=\"comment\">## 或者基于config的方式</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;export DOCKER_HOST=ssh://mydocker&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bashrc</span><br><span class=\"line\">docker ps</span><br></pre></td></tr></table></figure>\n<h2 id=\"docker-context-同时连接多个远程docker\"><code>docker context</code>: 同时连接多个远程docker</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>上面介绍的三种方式，为了简化连接，都加上了<code>DOCKER_HOST</code>环境变量，但是<code>DOCKER_HOST</code>只能配置一个，如果我们要同时连接多个远程docker服务呢，每次切换<code>DOCKER_HOST</code>环境变量太过繁琐，可以通过下面的方式为每个远程docker服务创建一个 <code>context</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># TCP</span></span><br><span class=\"line\">docker context create remote-tcp \\</span><br><span class=\"line\">    --docker <span class=\"string\">&quot;host=tcp://166.189.9.114:2375&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># TCP + TLS</span></span><br><span class=\"line\">docker context create remote-tls \\</span><br><span class=\"line\">  --docker <span class=\"string\">&quot;host=tcp://166.189.9.114:2376,ca=/path/ca.pem,cert=/path/cert.pem,key=/path/key.pem&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ssh隧道</span></span><br><span class=\"line\">docker context create remote-ssh --docker <span class=\"string\">&quot;host=ssh://mydocker&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用</span></span><br><span class=\"line\">docker context <span class=\"built_in\">ls</span> <span class=\"comment\"># 列出所有context</span></span><br><span class=\"line\">docker context use remote-ssh <span class=\"comment\"># 切换到指定的context</span></span><br><span class=\"line\">docker ps <span class=\"comment\"># 查看容器</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker context</code> 是 Docker CLI 的一个强大功能，它让你可以轻松地在 多个 Docker 后端环境之间切换，比如：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">本地 Docker（默认）</li>\n<li class=\"lvl-6\">远程主机的 Docker（通过 SSH 或 TCP/TLS）</li>\n<li class=\"lvl-6\">Docker Desktop</li>\n<li class=\"lvl-6\">Docker Swarm 或 Kubernetes（部分支持）</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>就像你用 <code>kubectl config use-context</code> 切换 Kubernetes 集群，<code>docker context</code> 也允许你在多个 Docker 后端之间切换，而无需反复设置 <code>DOCKER_HOST</code> 环境变量或写繁琐的 SSH 隧道命令。</p>\n</li>\n<li class=\"lvl-2\">\n<p>常用命令一览</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>docker context ls</code></td>\n<td>列出所有上下文</td>\n</tr>\n<tr>\n<td><code>docker context use &lt;name&gt;</code></td>\n<td>切换到指定 context</td>\n</tr>\n<tr>\n<td><code>docker context create &lt;name&gt; --docker &quot;Docker endpoint config&quot;</code></td>\n<td>创建一个新的 context</td>\n</tr>\n<tr>\n<td><code>docker context rm &lt;name&gt;</code></td>\n<td>删除 context</td>\n</tr>\n<tr>\n<td><code>docker context inspect &lt;name&gt;</code></td>\n<td>查看 context 详情</td>\n</tr>\n<tr>\n<td><code>docker context update &lt;name&gt; --docker &quot;Docker endpoint config&quot;</code></td>\n<td>更新 context 参数（Docker 24+ 支持）</td>\n</tr>\n<tr>\n<td><code>docker context show</code></td>\n<td>显示当前 context</td>\n</tr>\n<tr>\n<td><code>docker context export &lt;name&gt; &lt;file.tar&gt;</code></td>\n<td>导出 context 到tar文件</td>\n</tr>\n<tr>\n<td><code>docker context import &lt;name&gt; &lt;file.tar&gt;</code></td>\n<td>导入 context 从tar文件</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Docker endpoint config</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数名</th>\n<th>中文描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>from</code></td>\n<td>复制指定 context 名称 的 Docker 端点配置</td>\n</tr>\n<tr>\n<td><code>host</code></td>\n<td>要连接的 Docker 端点地址</td>\n</tr>\n<tr>\n<td><code>ca</code></td>\n<td>CA 签名的证书的路径</td>\n</tr>\n<tr>\n<td><code>cert</code></td>\n<td>TLS 证书文件的路径</td>\n</tr>\n<tr>\n<td><code>key</code></td>\n<td>TLS 密钥文件的路径</td>\n</tr>\n<tr>\n<td><code>skip-tls-verify</code></td>\n<td>跳过 TLS 证书验证（⚠️ 不建议用于生产环境）</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"三种远程连接-Docker-的方式及其优缺点总结\">三种远程连接 Docker 的方式及其优缺点总结</h2>\n<table>\n<thead>\n<tr>\n<th>连接方式</th>\n<th>优点</th>\n<th>缺点</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>1. SSH 方式 (<code>ssh://</code>)</strong></td>\n<td>- 配置简单，无需额外开启 Docker TCP 端口和 TLS<br>- 安全性高，基于 SSH 加密和认证<br>- 不用开放额外端口，防火墙友好<br>- 易于用 SSH 代理和密钥管理</td>\n<td>- 需要远程用户有 Docker 权限（如属于 <code>docker</code> 组）<br>- 连接速度可能受 SSH 连接影响<br>- 需要在本地安装并配置 SSH</td>\n<td>开发环境、内网管理、小规模远程操作</td>\n</tr>\n<tr>\n<td><strong>2. TCP + TLS 方式</strong></td>\n<td>- 标准的远程 Docker API 访问<br>- 支持证书认证，安全性高<br>- 可以配置多个客户端和权限控制<br>- 适合自动化脚本、CI/CD 访问</td>\n<td>- 配置较复杂，需要生成和管理 CA、服务器和客户端证书<br>- 需要开放 TCP 端口（如 2376），增加安全风险<br>- 证书配置错误容易导致连接失败</td>\n<td>生产环境、自动化集成、需要高安全认证</td>\n</tr>\n<tr>\n<td><strong>3. TCP 明文访问（无 TLS）</strong></td>\n<td>- 配置最简单，只需监听 TCP 端口<br>- 方便快速测试和调试</td>\n<td>- 极度不安全，数据明文传输<br>- 任何人都可访问 Docker API，极易被攻击<br>- 生产环境严重不建议使用</td>\n<td>仅限局域网内测试或极简环境</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍如何远程连接Docker Docker官方文档 远程连接Docker有如下三种方式 方式一：开启 TCP（不带 TLS，仅用于内网调试） 在docker服务端编辑 /etc/docker/daemon.json，加上： 123&#123; &quot;hosts&quot;: [&quot;unix:///var/run/docker.sock&quot;, &quot;tcp://0.0.0.0:2375&quot;]&#125; 此时通过sudo systemctl restart docker重启 Docker会启动失败，原因是systemd会在docker启动命令中添加 -H fd://，其含义是从 systemd 传递进来的 socket 文件描述符监听 API 请求，当 Docker 被 systemd 启动并启用 socket activation（套接字激活）时，systemd 会预先创建 socket（比如 /var/run/docker.sock），然后再启动 dockerd，并通过文件描述符（fd）把这个 socket 传递给 dockerd。此时你在 dockerd 中看到的 -H fd:// 意思是：“不用自己打开 socket，去 systemd 那里拿吧。” 123456789101112# 通过该命令可以获取 docker 的启动命令文件是 /usr/lib/systemd/system/docker.servicesudo systemctl status docker# 查看 /usr/lib/systemd/system/docker.service，可以看到 docker的启动命令如下，可以看到 -H fd://ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock# 另外可以在与 docker.service 同目录下找到 docker.socket 文件，可以看到如下内容ListenStream=/run/docker.sock # /run 目录是被软连接到 /var/run/# 总结：通过systemd 启动 docker时，如果配置了 -H fd://，则 docker 会监听 /run/docker.sock 文件，实际上也就是 /var/run/docker.sock# 而我们在/etc/docker/daemon.json中加上的&quot;unix:///var/run/docker.sock&quot;, &quot;tcp://0.0.0.0:2375&quot;实际上就是改写docker的启动参数，这就与 systemd 启动 docker 的 `-H fd://` 参数冲突了# 此时我们可以不使用systemd 启动 docker，而是使用 docker daemon 启动 dockersudo dockerd --containerd=/run/containerd/containerd.sock# 但这样不利于 docker 的管理，因此最好的方式是禁用 `-H fd://` 禁用 -H fd://（systemd 与 daemon.json 冲突的根源） 12345678910111213# 方式一: 去掉 `-H fd://` 参数sudo vi /usr/lib/systemd/system/docker.service# 方式二(推荐): 创建 override.conf 文件，其作用是 覆盖 systemd 默认配置文件，只会覆盖指定的参数sudo mkdir -p /etc/systemd/system/docker.service.dsudo vi /etc/systemd/system/docker.service.d/override.conf# 填入[Service]ExecStart=ExecStart=/usr/bin/dockerd --containerd=/run/containerd/containerd.sock# 这里顺便说一下，`--containerd=/run/containerd/containerd.sock` 是 docker 默认参数，# 告诉 Docker 守护进程去连接已有的 containerd 实例，而不是自己启动一个新的。# Docker 默认内部使用 containerd 来管理容器运行时，所以这条参数是明确指定要使用哪个 containerd 服务。 重启 docker daemon 12sudo systemctl daemon-reloadsudo systemctl restart docker 在客户端测试连接 1docker -H tcp://远程IP:2375 ps 在客户端加入环境变量后就不需要每次都加上 -H 参数了 12345# zsh 就换成 ~/.zshrcecho &quot;export DOCKER_HOST=tcp://远程IP:2375&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc# 测试docker ps ❗不要开启无认证的 tcp://0.0.0.0:2375 在公网，这是裸奔的安全风险，任何人都能控制你的 Docker。 ✅ 推荐方式是： 使用 tcp://0.0.0.0:2376 + --tlsverify 或通过 ssh:// 隧道 访问 Docker 小贴士 通过上面的介绍你应该搞明白一件事，就是我们可以不用在 /etc/docker/daemon.json 中配置远程连接，而是通过 systemd 来配置，即在 /usr/lib/systemd/system/docker.service 或者 /etc/systemd/system/docker.service.d/override.conf中配置。 1ExecStart=/usr/bin/dockerd -H unix:///var/run/docker.sock -H tcp://0.0.0.0:2375 --containerd=/run/containerd/containerd.sock 那么问题来了：既然 systemd 就能搞定一切，那还要 /etc/docker/daemon.json 有什么用？答案是：可读性、可维护性、工具兼容性更强。 项目 daemon.json systemd ExecStart 语法 JSON Shell 命令行 适合设置 Hosts、日志、registry、镜像驱动等 启动命令、资源限制等 可读性 👍 结构化 👎 较长、容易出错 自动化支持 👍 工具友好 👎 需要 patch systemd 方式二：开启 TCP + TLS 安全访问（推荐用于公网） 创建 TLS 证书，通过一个脚本实现，脚本名称 generate-docker-certs.sh 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#!/bin/bashset -eSERVER_IP=166.189.9.114 # 🚨 修改为你的 Docker 服务器 IP 或域名echo &quot;[+] 创建 CA...&quot;openssl genrsa -out ca-key.pem 4096openssl req -new -x509 -days 365 \\ -key ca-key.pem -subj &quot;/CN=docker-ca&quot; -out ca.pemecho &quot;[+] 创建服务器私钥...&quot;openssl genrsa -out server-key.pem 4096echo &quot;[+] 创建 OpenSSL 配置文件...&quot;cat &gt; extfile.cnf &lt;&lt;EOF[req]distinguished_name = req_distinguished_namex509_extensions = v3_reqprompt = no[req_distinguished_name]CN = $&#123;SERVER_IP&#125;[v3_req]keyUsage = keyEncipherment, dataEnciphermentextendedKeyUsage = serverAuthsubjectAltName = @alt_names[alt_names]IP.1 = $&#123;SERVER_IP&#125;EOFecho &quot;[+] 创建服务器证书签名请求 (CSR)...&quot;openssl req -new -key server-key.pem \\ -out server.csr -config extfile.cnfecho &quot;[+] 签发服务器证书...&quot;openssl x509 -req -days 365 -in server.csr \\ -CA ca.pem -CAkey ca-key.pem -CAcreateserial \\ -out server-cert.pem -extensions v3_req -extfile extfile.cnfecho &quot;[+] 创建客户端私钥...&quot;openssl genrsa -out key.pem 4096echo &quot;[+] 创建客户端 CSR...&quot;openssl req -new -key key.pem -subj &quot;/CN=client&quot; -out client.csrecho &quot;[+] 签发客户端证书...&quot;cat &gt; client-ext.cnf &lt;&lt;EOFextendedKeyUsage = clientAuthEOFopenssl x509 -req -days 365 -in client.csr \\ -CA ca.pem -CAkey ca-key.pem -CAcreateserial \\ -out cert.pem -extfile client-ext.cnfecho &quot;[✓] 所有证书生成完成！&quot;echoecho &quot; 服务器证书: server-cert.pem, server-key.pem&quot;echo &quot; 客户端证书: cert.pem, key.pem&quot;echo &quot; CA根证书: ca.pem&quot; 执行脚本 12chmod +x generate-docker-certs.sh./generate-docker-certs.sh 将以下证书文件部署到docker服务端 1234# 服务端：server-cert.pem, server-key.pem, ca.pemcp server-cert.pem /etc/docker/server-cert.pemcp server-key.pem /etc/docker/server-key.pemcp ca.pem /etc/docker/ca.pem 将以下证书文件部署到docker客户端 1cert.pem, key.pem, ca.pem 在docker服务端编辑 /etc/docker/daemon.json 1234567&#123; &quot;hosts&quot;: [&quot;unix:///var/run/docker.sock&quot;, &quot;tcp://0.0.0.0:2376&quot;], &quot;tlsverify&quot;: true, &quot;tlscacert&quot;: &quot;/etc/docker/ca.pem&quot;, &quot;tlscert&quot;: &quot;/etc/docker/server-cert.pem&quot;, &quot;tlskey&quot;: &quot;/etc/docker/server-key.pem&quot;&#125; 禁用 -H fd://（systemd 与 daemon.json 冲突的根源） 123456sudo mkdir -p /etc/systemd/system/docker.service.dsudo vi /etc/systemd/system/docker.service.d/override.conf# 填入[Service]ExecStart=ExecStart=/usr/bin/dockerd --containerd=/run/containerd/containerd.sock 重启 docker daemon 12sudo systemctl daemon-reloadsudo systemctl restart docker 在客户端测试连接 1234567docker \\ --tlsverify \\ --tlscacert=ca.pem \\ --tlscert=cert.pem \\ --tlskey=key.pem \\ -H tcp://166.189.9.114:2376 \\ ps 在客户端加入环境变量后就不需要每次都加上 -H 参数 和证书参数了 1234567891011cat &lt;&lt;EOT &gt;&gt; ~/.bashrc# 远程Docker IP和端口export DOCKER_HOST=tcp://166.189.9.114:2376# 用于通过 TLS（SSL）安全连接远程 Docker 守护进程，类似于 docker --tlsverifyexport DOCKER_TLS_VERIFY=1# 这个目录下要有这些证书文件：ca.pem, cert.pem, key.pemexport DOCKER_CERT_PATH=/path/to/certsEOTsource ~/.bashrc# 测试docker ps 方式三：ssh:// 隧道访问 最简单的方式就是使用 ssh 远程执行命令的方式，这种方式不需要任何配置，支持密码和证书认证，也支持指定端口，但这不是标准的远程连接docker方式，适用于偶尔访问的情况。 1ssh -i ~/.ssh/lexing-test.pem -p22 centos@166.189.9.114 &quot;docker ps&quot; 基于免密认证，如何配置免密登录可以参考 Linux常用命令--ssh、scp与免密登录 123# docker -H 远程访问 不支持在命令行直接输入密码或密钥文件，必须配置免密登录才可以，而且此时端口必须是默认的22# 要求登录用户必须拥有docker的运行权限（加入 docker group）docker -H ssh://centos@166.189.9.114 ps 基于config配置(推荐) 这种方式的优点是可以配置证书和端口 在 ~/.ssh/config 中指定具体的密钥文件和端口，登录用户必须拥有docker的运行权限（加入 docker group） 12345Host mydockerHostName 166.189.9.114User centosPort 22IdentityFile ~/.ssh/my_docker_key 测试 1docker -H ssh://mydocker ps 添加环境变量避免每次都加上 -H 参数 123456## 基于免密认证echo &quot;export DOCKER_HOST=ssh://user@host&quot; &gt;&gt; ~/.bashrc## 或者基于config的方式echo &quot;export DOCKER_HOST=ssh://mydocker&quot; &gt;&gt; ~/.bashrcsource ~/.bashrcdocker ps docker context: 同时连接多个远程docker 上面介绍的三种方式，为了简化连接，都加上了DOCKER_HOST环境变量，但是DOCKER_HOST只能配置一个，如果我们要同时连接多个远程docker服务呢，每次切换DOCKER_HOST环境变量太过繁琐，可以通过下面的方式为每个远程docker服务创建一个 context 123456789101112131415# TCPdocker context create remote-tcp \\ --docker &quot;host=tcp://166.189.9.114:2375&quot;# TCP + TLSdocker context create remote-tls \\ --docker &quot;host=tcp://166.189.9.114:2376,ca=/path/ca.pem,cert=/path/cert.pem,key=/path/key.pem&quot;# ssh隧道docker context create remote-ssh --docker &quot;host=ssh://mydocker&quot;# 使用docker context ls # 列出所有contextdocker context use remote-ssh # 切换到指定的contextdocker ps # 查看容器 docker context 是 Docker CLI 的一个强大功能，它让你可以轻松地在 多个 Docker 后端环境之间切换，比如： 本地 Docker（默认） 远程主机的 Docker（通过 SSH 或 TCP/TLS） Docker Desktop Docker Swarm 或 Kubernetes（部分支持） 就像你用 kubectl config use-context 切换 Kubernetes 集群，docker context 也允许你在多个 Docker 后端之间切换，而无需反复设置 DOCKER_HOST 环境变量或写繁琐的 SSH 隧道命令。 常用命令一览 命令 说明 docker context ls 列出所有上下文 docker context use &lt;name&gt; 切换到指定 context docker context create &lt;name&gt; --docker &quot;Docker endpoint config&quot; 创建一个新的 context docker context rm &lt;name&gt; 删除 context docker context inspect &lt;name&gt; 查看 context 详情 docker context update &lt;name&gt; --docker &quot;Docker endpoint config&quot; 更新 context 参数（Docker 24+ 支持） docker context show 显示当前 context docker context export &lt;name&gt; &lt;file.tar&gt; 导出 context 到tar文件 docker context import &lt;name&gt; &lt;file.tar&gt; 导入 context 从tar文件 Docker endpoint config 参数名 中文描述 from 复制指定 context 名称 的 Docker 端点配置 host 要连接的 Docker 端点地址 ca CA 签名的证书的路径 cert TLS 证书文件的路径 key TLS 密钥文件的路径 skip-tls-verify 跳过 TLS 证书验证（⚠️ 不建议用于生产环境） 三种远程连接 Docker 的方式及其优缺点总结 连接方式 优点 缺点 适用场景 1. SSH 方式 (ssh://) - 配置简单，无需额外开启 Docker TCP 端口和 TLS- 安全性高，基于 SSH 加密和认证- 不用开放额外端口，防火墙友好- 易于用 SSH 代理和密钥管理 - 需要远程用户有 Docker 权限（如属于 docker 组）- 连接速度可能受 SSH 连接影响- 需要在本地安装并配置 SSH 开发环境、内网管理、小规模远程操作 2. TCP + TLS 方式 - 标准的远程 Docker API 访问- 支持证书认证，安全性高- 可以配置多个客户端和权限控制- 适合自动化脚本、CI/CD 访问 - 配置较复杂，需要生成和管理 CA、服务器和客户端证书- 需要开放 TCP 端口（如 2376），增加安全风险- 证书配置错误容易导致连接失败 生产环境、自动化集成、需要高安全认证 3. TCP 明文访问（无 TLS） - 配置最简单，只需监听 TCP 端口- 方便快速测试和调试 - 极度不安全，数据明文传输- 任何人都可访问 Docker API，极易被攻击- 生产环境严重不建议使用 仅限局域网内测试或极简环境","summary":"摘要 本文介绍如何远程连接Docker Docker官方文档","date_published":"2025-06-05T13:30:05.000Z","tags":["技术","docker","docker"]},{"id":"https://blog.hanqunfeng.com/2025/06/04/docker-compose/","url":"https://blog.hanqunfeng.com/2025/06/04/docker-compose/","title":"Docker 命令 之 docker compose","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 Docker 命令 中 <code>docker compose</code> 的使用方法</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com\">Docker官方文档</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com/compose/\">docker compose</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com/reference/compose-file/\">Compose file reference</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"docker-compose-是什么？\"><code>docker compose</code> 是什么？</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Docker Compose是一个用于定义和运行多容器应用程序的工具。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Compose简化了对整个应用程序堆栈的控制，便于在单个YAML配置文件中管理服务、网络和卷。然后，通过一个命令，您从配置文件中创建并启动所有服务。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Docker Compose 的优势：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>优点</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>简化控制</td>\n<td>Docker Compose 允许在单个 YAML 文件中定义和管理多容器应用程序，简化了服务编排与协调，使环境管理和复制更容易。</td>\n</tr>\n<tr>\n<td>高效的协作</td>\n<td>配置文件易于共享，促进开发人员、运营团队和其他利益相关者之间的协作，从而提升工作流程效率和问题解决速度。</td>\n</tr>\n<tr>\n<td>快速应用程序开发</td>\n<td>Compose 利用缓存重复使用未更改服务的容器，加快环境变更速度，提高开发效率。</td>\n</tr>\n<tr>\n<td>跨环境的可移植性</td>\n<td>支持在 Compose 文件中使用变量，使配置能根据不同环境或用户进行自定义，增强了可移植性。</td>\n</tr>\n<tr>\n<td>广泛的社区和支持</td>\n<td>拥有活跃的社区，提供丰富的资源、教程和技术支持，有助于持续改进与高效排障。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"docker-compose-安装\"><code>docker compose</code> 安装</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>同docker一起安装</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装docker同时安装docker compose，这里 docker-compose-plugin 就是docker compose</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> dnf install docker-ce-3:26.1.3-1.el8 docker-ce-cli-3:26.1.3-1.el8 containerd.io docker-buildx-plugin docker-compose-plugin -y</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>单独安装</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 若安装docker时没有安装 docker-compose-plugin ，则需要单独安装</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> dnf install docker-compose-plugin -y</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看版本</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker compose version</span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>直接下载docker-compose的命令文件</strong></em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Install Docker Compose，注意通过这种方式安装的compose的使用方式为 `docker-compose`，而非标准的 `docker compose`</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> curl -L <span class=\"string\">&quot;https://github.com/docker/compose/releases/latest/download/docker-compose-<span class=\"subst\">$(uname -s)</span>-<span class=\"subst\">$(uname -m)</span>&quot;</span> -o /usr/local/bin/docker-compose</span><br><span class=\"line\"><span class=\"comment\"># Make the docker-compose command available</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">chmod</span> +x /usr/local/bin/docker-compose</span><br><span class=\"line\"><span class=\"comment\"># Check Docker Compose version</span></span><br><span class=\"line\">docker-compose version</span><br></pre></td></tr></table></figure>\n</div>\n<h2 id=\"docker-compose-命令\"><code>docker compose</code> 命令</h2>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>中文说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>attach</td>\n<td>连接到服务的运行中容器的标准输入、输出和错误流</td>\n<td><code>docker compose attach web</code></td>\n</tr>\n<tr>\n<td>build</td>\n<td>构建或重新构建服务</td>\n<td><code>docker compose build</code></td>\n</tr>\n<tr>\n<td>config</td>\n<td>解析并标准化 Compose 文件</td>\n<td><code>docker compose config</code></td>\n</tr>\n<tr>\n<td>cp</td>\n<td>在服务容器与本地文件系统之间复制文件/文件夹</td>\n<td><code>docker compose cp web:/app/file.txt ./file.txt</code></td>\n</tr>\n<tr>\n<td>create</td>\n<td>为服务创建容器，但不启动</td>\n<td><code>docker compose create</code></td>\n</tr>\n<tr>\n<td>down</td>\n<td>停止并移除容器、网络等资源</td>\n<td><code>docker compose down</code></td>\n</tr>\n<tr>\n<td>events</td>\n<td>实时接收容器事件</td>\n<td><code>docker compose events</code></td>\n</tr>\n<tr>\n<td>exec</td>\n<td>在运行中的容器中执行命令</td>\n<td><code>docker compose exec web ls /app</code></td>\n</tr>\n<tr>\n<td>images</td>\n<td>列出已创建容器所使用的镜像</td>\n<td><code>docker compose images</code></td>\n</tr>\n<tr>\n<td>kill</td>\n<td>强制停止服务容器</td>\n<td><code>docker compose kill</code></td>\n</tr>\n<tr>\n<td>logs</td>\n<td>查看服务容器的日志输出</td>\n<td><code>docker compose logs</code></td>\n</tr>\n<tr>\n<td>ls</td>\n<td>列出当前运行的 Compose 项目</td>\n<td><code>docker compose ls</code></td>\n</tr>\n<tr>\n<td>pause</td>\n<td>暂停服务容器</td>\n<td><code>docker compose pause</code></td>\n</tr>\n<tr>\n<td>port</td>\n<td>显示某端口映射的公网地址</td>\n<td><code>docker compose port web 80</code></td>\n</tr>\n<tr>\n<td>ps</td>\n<td>列出服务的容器</td>\n<td><code>docker compose ps</code></td>\n</tr>\n<tr>\n<td>pull</td>\n<td>拉取服务使用的镜像</td>\n<td><code>docker compose pull</code></td>\n</tr>\n<tr>\n<td>push</td>\n<td>推送服务镜像到仓库</td>\n<td><code>docker compose push</code></td>\n</tr>\n<tr>\n<td>restart</td>\n<td>重启服务容器</td>\n<td><code>docker compose restart</code></td>\n</tr>\n<tr>\n<td>rm</td>\n<td>移除已停止的服务容器</td>\n<td><code>docker compose rm</code></td>\n</tr>\n<tr>\n<td>run</td>\n<td>在服务上运行一次性命令</td>\n<td><code>docker compose run web echo Hello</code></td>\n</tr>\n<tr>\n<td>scale</td>\n<td>扩展服务实例数量</td>\n<td><code>docker compose up --scale web=3</code></td>\n</tr>\n<tr>\n<td>start</td>\n<td>启动已存在但已停止的服务容器</td>\n<td><code>docker compose start</code></td>\n</tr>\n<tr>\n<td>stats</td>\n<td>实时显示容器资源使用情况</td>\n<td><code>docker compose stats</code></td>\n</tr>\n<tr>\n<td>stop</td>\n<td>停止运行中的服务容器</td>\n<td><code>docker compose stop</code></td>\n</tr>\n<tr>\n<td>top</td>\n<td>显示容器内的运行进程</td>\n<td><code>docker compose top</code></td>\n</tr>\n<tr>\n<td>unpause</td>\n<td>取消暂停服务容器</td>\n<td><code>docker compose unpause</code></td>\n</tr>\n<tr>\n<td>up</td>\n<td>创建并启动服务容器</td>\n<td><code>docker compose up</code></td>\n</tr>\n<tr>\n<td>version</td>\n<td>显示 Docker Compose 版本信息</td>\n<td><code>docker compose version</code></td>\n</tr>\n<tr>\n<td>wait</td>\n<td>阻塞直到第一个服务容器停止</td>\n<td><code>docker compose wait</code></td>\n</tr>\n<tr>\n<td>watch</td>\n<td>监听服务构建上下文变更并重新构建/刷新容器</td>\n<td><code>docker compose watch</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"docker-compose-常用命令\"><code>docker compose</code> 常用命令</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动与关闭</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启动并运行，默认使用当前目录的 docker-compose.yml 文件</span></span><br><span class=\"line\">docker compose up</span><br><span class=\"line\"><span class=\"comment\"># 后台运行</span></span><br><span class=\"line\">docker compose up -d</span><br><span class=\"line\"><span class=\"comment\"># 指定compose文件</span></span><br><span class=\"line\">docker compose -f docker-compose.yml up -d</span><br><span class=\"line\"><span class=\"comment\"># 启动时重建服务，当修改了 compose 文件时</span></span><br><span class=\"line\">docker compose up --build</span><br><span class=\"line\"><span class=\"comment\"># 停止service</span></span><br><span class=\"line\">docker compose stop</span><br><span class=\"line\"><span class=\"comment\"># 强制停止service，当 stop 命令无法停止时</span></span><br><span class=\"line\">docker compose <span class=\"built_in\">kill</span></span><br><span class=\"line\"><span class=\"comment\"># 重启service</span></span><br><span class=\"line\">docker compose restart</span><br><span class=\"line\"><span class=\"comment\"># 删除service，-s 参数表示删除前先停止容器</span></span><br><span class=\"line\">docker compose <span class=\"built_in\">rm</span> -s</span><br><span class=\"line\"><span class=\"comment\"># 停止并删除service，同时删除网络，但不会删除卷</span></span><br><span class=\"line\">docker compose down</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>监控</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出当前运行的 Compose 项目</span></span><br><span class=\"line\">docker compose <span class=\"built_in\">ls</span></span><br><span class=\"line\"><span class=\"comment\"># 查看service状态，-a 显示所有service</span></span><br><span class=\"line\">docker compose ps -a</span><br><span class=\"line\"><span class=\"comment\"># 解析并标准化 compose 文件，这个命令可以检查 docker-compose.yml 文件语法是否正确，但不保证逻辑正确</span></span><br><span class=\"line\">docker compose config</span><br><span class=\"line\"><span class=\"comment\"># 查看使用的镜像</span></span><br><span class=\"line\">docker compose images</span><br><span class=\"line\"><span class=\"comment\"># 查看进程</span></span><br><span class=\"line\">docker compose top</span><br><span class=\"line\"><span class=\"comment\"># 查看service资源使用情况</span></span><br><span class=\"line\">docker compose stats</span><br><span class=\"line\"><span class=\"comment\"># 查看service日志，-f 表示持续跟踪</span></span><br><span class=\"line\">docker compose logs -f</span><br><span class=\"line\"><span class=\"comment\"># 查看指定service的日志</span></span><br><span class=\"line\">docker compose logs -f service_name</span><br><span class=\"line\"><span class=\"comment\"># 进入指定的service容器</span></span><br><span class=\"line\">docker compose <span class=\"built_in\">exec</span> service_name bash</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>升级镜像</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 先停止所有service</span></span><br><span class=\"line\">docker compose down</span><br><span class=\"line\"><span class=\"comment\"># 拉取最新镜像</span></span><br><span class=\"line\">docker compose pull</span><br><span class=\"line\"><span class=\"comment\"># 启动service</span></span><br><span class=\"line\">docker compose up -d --build</span><br></pre></td></tr></table></figure>\n<h2 id=\"docker-compose-yml-的语法\"><code>docker-compose.yml</code> 的语法</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>常用指令</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">version: <span class=\"string\">&quot;3.8&quot;</span> <span class=\"comment\"># 定义版本，表示当前使用的 docker compose 语法的版本，已过时 ，新版 Docker 会使用最新的 Compose Specification 自动解析</span></span><br><span class=\"line\">name: <span class=\"string\">&quot;project_name&quot;</span> <span class=\"comment\">#  项目名，默认 docker-compose.yml 文件所在的目录名，不推荐设置</span></span><br><span class=\"line\">services: <span class=\"comment\"># 服务列表</span></span><br><span class=\"line\">  servicename: <span class=\"comment\"># 服务名字，只能包含小写字母、数字、下划线、中划线，必须以字母或数字开头</span></span><br><span class=\"line\">    build: <span class=\"comment\"># 基于Dockerfile构建目录，如果同时设置了 image 选项，则image指定的就是构建后的镜像名称</span></span><br><span class=\"line\">    image: <span class=\"comment\"># 镜像的名字，默认从远程仓库拉取，如果配置了 build 选项，则image指定的就是构建后的镜像名称</span></span><br><span class=\"line\">    <span class=\"built_in\">command</span>: <span class=\"comment\"># 可选，如果设置，则会覆盖默认镜像里的 CMD 命令</span></span><br><span class=\"line\">    environment: <span class=\"comment\"># 可选，等价于 docker container run 里的 --env 选项设置环境变量</span></span><br><span class=\"line\">    volumes: <span class=\"comment\"># 可选，等价于 docker container run 里的 -v 选项 绑定数据卷</span></span><br><span class=\"line\">    networks: <span class=\"comment\"># 可选，等价于 docker container run 里的 --network 选项指定网络</span></span><br><span class=\"line\">    ports: <span class=\"comment\"># 可选，等价于 docker container run 里的 -p 选项指定端口映射</span></span><br><span class=\"line\">    expose: <span class=\"comment\"># 可选，指定容器暴露的端口</span></span><br><span class=\"line\">    depends_on: <span class=\"comment\"># 服务依赖的其它服务</span></span><br><span class=\"line\">    env_file: <span class=\"comment\"># 环境变量文件，生产环境更推荐这种方式</span></span><br><span class=\"line\">  servicename2:</span><br><span class=\"line\">    image:</span><br><span class=\"line\">    <span class=\"built_in\">command</span>:</span><br><span class=\"line\">    networks:</span><br><span class=\"line\">    ports:</span><br><span class=\"line\">  servicename3:</span><br><span class=\"line\">    <span class=\"comment\">#...</span></span><br><span class=\"line\"></span><br><span class=\"line\">volumes: <span class=\"comment\"># 可选，等价于 docker volume create</span></span><br><span class=\"line\">networks: <span class=\"comment\"># 可选，等价于 docker network create</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"volumes\">volumes</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>卷是由容器引擎实现的持久数据存储。Compose 为服务提供了一种中立的挂载卷的方式，并通过配置参数将卷分配给基础架构。顶级volumes声明允许您配置可在多个服务之间重复使用的命名卷。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">backend:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">example/database</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span> <span class=\"comment\"># 挂载卷映射</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db-data:/etc/data</span> <span class=\"comment\"># 挂载到容器的/etc/data目录</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">backup:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">backup-service</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db-data:/var/lib/backup/data</span> <span class=\"comment\"># 一个卷可以被多个服务使用</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">volumes:</span> <span class=\"comment\"># 存储卷配置</span></span><br><span class=\"line\">  <span class=\"attr\">db-data:</span>  <span class=\"comment\"># 创建一个名为db-data的卷，实际的网络名称是 容器组名称_这里的名称</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"volumes-的属性\">volumes 的属性</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>driver: 卷类型，默认为local，指定应使用哪个卷驱动程序。如果该驱动程序不可用，Compose 将返回错误并且不会部署该应用程序。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"attr\">db-data:</span> <span class=\"comment\"># 声明一个名为db-data的卷</span></span><br><span class=\"line\">    <span class=\"attr\">driver:</span> <span class=\"string\">local</span> <span class=\"comment\"># 指定卷类型，这个是默认值，可以不配置</span></span><br><span class=\"line\">  <span class=\"attr\">db-data2:</span> <span class=\"comment\"># 声明一个名为db-data2的卷，这是最简单的 volumes 配置</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>driver_opts: 卷类型参数，指定要传递给此卷驱动程序的选项列表（以键值对的形式）。这些选项与驱动程序相关。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"attr\">db-data:</span></span><br><span class=\"line\">    <span class=\"attr\">driver_opts:</span> <span class=\"comment\"># 卷类型参数，指定要传递给此卷驱动程序的选项列表（以键值对的形式）</span></span><br><span class=\"line\">      <span class=\"attr\">type:</span> <span class=\"string\">&quot;nfs&quot;</span> <span class=\"comment\"># 卷类型，指定应使用哪个卷驱动程序，这里是nfs</span></span><br><span class=\"line\">      <span class=\"attr\">o:</span> <span class=\"string\">&quot;addr=10.40.0.199,nolock,soft,rw&quot;</span> <span class=\"comment\"># nfs参数，addr为nfs服务器地址，nolock为不锁定文件，soft为软链接，rw为读写权限</span></span><br><span class=\"line\">      <span class=\"attr\">device:</span> <span class=\"string\">&quot;:/docker/example&quot;</span> <span class=\"comment\"># nfs挂载路径</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>external: 卷是否为外部卷，默认为false</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"attr\">db-data:</span></span><br><span class=\"line\">    <span class=\"attr\">external:</span> <span class=\"literal\">true</span> <span class=\"comment\"># true 表示不会创建，而是使用已存在的，即会去volumes中查找(docker volume ls) 容器组名称_da-data ，默认为false</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>name: 卷的名称，默认为 容器组名称_声明的名称</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"attr\">db-data:</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">db-data</span> <span class=\"comment\"># 创建一个名为db-data的卷，实际的卷名称就是 db-data，不会再加上容器组名称前缀</span></span><br><span class=\"line\">    <span class=\"attr\">external:</span> <span class=\"literal\">true</span> <span class=\"comment\"># name 属性经常与  external: true 一起使用</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>labels: 用于向卷添加元数据，可以添加任意的键值对</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"attr\">db-data:</span></span><br><span class=\"line\">    <span class=\"attr\">labels:</span></span><br><span class=\"line\">      <span class=\"attr\">com.example.description:</span> <span class=\"string\">&quot;Database volume&quot;</span></span><br><span class=\"line\">      <span class=\"attr\">com.example.department:</span> <span class=\"string\">&quot;IT/Ops&quot;</span></span><br><span class=\"line\">      <span class=\"attr\">com.example.label-with-empty-value:</span> <span class=\"string\">&quot;&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"networks\">networks</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>网络使服务能够相互通信。默认情况下，Compose 会为您的应用设置单个网络。服务的每个容器都会加入默认网络，并且该网络上的其他容器都可以访问，并且可以通过服务名称发现。顶级networks元素允许您配置可在多个服务之间重复使用的命名网络。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">frontend:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">example/webapp</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span>  <span class=\"comment\">#  网络映射</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">front-tier</span> <span class=\"comment\">#  加入front-tier网络</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">back-tier</span></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">postgres</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">backend</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">networks:</span>    <span class=\"comment\"># 网络配置</span></span><br><span class=\"line\">  <span class=\"attr\">front-tier:</span> <span class=\"comment\"># 创建一个名为front-tier的网络，实际的网络名称是 容器组名称_front-tier</span></span><br><span class=\"line\">  <span class=\"attr\">back-tier:</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果 Compose 文件未显式声明网络，Compose 将使用隐式default网络。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">some-service:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">foo</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 这个例子实际上等同于：</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">some-service:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">foo</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"attr\">default:</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">default:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"networks-的属性\">networks 的属性</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>driver: 网络类型，默认为bridge</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">gitea:</span></span><br><span class=\"line\">    <span class=\"attr\">driver:</span> <span class=\"string\">bridge</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>driver_opts: 网络类型参数，指定要传递给此网络驱动程序的选项列表（以键值对的形式）。这些选项与驱动程序相关。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">frontend:</span></span><br><span class=\"line\">    <span class=\"attr\">driver:</span> <span class=\"string\">bridge</span></span><br><span class=\"line\">    <span class=\"attr\">driver_opts:</span></span><br><span class=\"line\">      <span class=\"attr\">com.docker.network.bridge.host_binding_ipv4:</span> <span class=\"string\">&quot;127.0.0.1&quot;</span> <span class=\"comment\"># 设置容器端口绑定到主机的哪个 IP（如 &quot;127.0.0.1&quot;，绑定到本地）</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>driver_opts 常见配置项（针对 bridge 网络驱动）</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>选项键名（<code>driver_opts</code>）</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>com.docker.network.bridge.name</code></td>\n<td>指定桥接网络的名称（默认是随机生成，如 <code>br-xxxxx</code>）</td>\n</tr>\n<tr>\n<td><code>com.docker.network.bridge.enable_icc</code></td>\n<td>是否允许容器之间的通信（<code>true</code> 或 <code>false</code>）</td>\n</tr>\n<tr>\n<td><code>com.docker.network.bridge.enable_ip_masquerade</code></td>\n<td>是否启用 IP 假冒（NAT，通常用于外网访问）</td>\n</tr>\n<tr>\n<td><code>com.docker.network.bridge.host_binding_ipv4</code></td>\n<td>设置容器端口绑定到主机的哪个 IP（如 <code>&quot;127.0.0.1&quot;</code>，绑定到本地）</td>\n</tr>\n<tr>\n<td><code>com.docker.network.bridge.default_bridge</code></td>\n<td>是否将该网络设置为默认 bridge 网络（<code>true</code> 或 <code>false</code>）</td>\n</tr>\n<tr>\n<td><code>com.docker.network.driver.mtu</code></td>\n<td>设置网络的最大传输单元（MTU，例如 <code>&quot;1500&quot;</code>）</td>\n</tr>\n<tr>\n<td><code>com.docker.network.bridge.allow_non_default_bridge</code></td>\n<td>是否允许容器加入非默认的 bridge 网络（较少使用）</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>attachable: 如果为true，则允许将其它独立容器也加入到此网络。默认值为false。如果独立容器连接到此网络，它可以与同样连接到此网络的服务和其他独立容器进行通信。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">gitea:</span></span><br><span class=\"line\">    <span class=\"attr\">attachable:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>external: true 表示不会创建新的网络，回去networks中查找（docker network ls），默认为false</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">gitea:</span></span><br><span class=\"line\">    <span class=\"attr\">external:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>name: 网络名称，不会再加上容器组名称前缀</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">gitea:</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">gitea</span></span><br><span class=\"line\">    <span class=\"attr\">external:</span> <span class=\"literal\">true</span> <span class=\"comment\"># name 属性经常与  external: true 一起使用</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>labels: 用于向网络添加元数据，可以添加任意的键值对</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">mynet1:</span></span><br><span class=\"line\">    <span class=\"attr\">labels:</span></span><br><span class=\"line\">      <span class=\"attr\">com.example.description:</span> <span class=\"string\">&quot;Financial transaction network&quot;</span></span><br><span class=\"line\">      <span class=\"attr\">com.example.department:</span> <span class=\"string\">&quot;Finance&quot;</span></span><br><span class=\"line\">      <span class=\"attr\">com.example.label-with-empty-value:</span> <span class=\"string\">&quot;&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>internal: 默认情况下，Compose 提供网络的外部连接。internal当设置为 时true，可让您创建与外部隔离的网络。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">gitea:</span></span><br><span class=\"line\">    <span class=\"attr\">internal:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"services\">services</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>服务是应用程序中计算资源的抽象定义，可以独立于其他组件进行扩展或替换。服务由一组容器支持，由平台根据复制要求和布局约束运行。由于服务由容器支持，因此它们由 Docker 镜像和一组运行时参数定义。服务中的所有容器都使用这些参数以相同的方式创建。</p>\n</li>\n<li class=\"lvl-2\">\n<p>service 包含的属性非常多，具体请参考<a href=\"https://docs.docker.com/reference/compose-file/services/\">services顶级元素</a>，这里只介绍比较常用的属性，</p>\n</li>\n<li class=\"lvl-2\">\n<p>这里以<a href=\"https://docs.gitea.com/installation/install-with-docker\">Gitea</a>的<code>docker-compose.yml</code>为例</p>\n</li>\n</ul>\n<blockquote>\n<p>Gitea 是一种轻松、自托管的一体化软件开发服务。它包括 Git 托管、代码审查、团队协作、包注册表和 CI/CD。它类似于 GitHub、Bitbucket 和 GitLab。</p>\n</blockquote>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># version: &#x27;3.8&#x27; # 配置文件版本，已过时，配置上会告警但不会报错</span></span><br><span class=\"line\"><span class=\"comment\"># name: gitea # 容器组名称，默认使用所在目录的名称，不推荐使用</span></span><br><span class=\"line\"><span class=\"attr\">networks:</span> <span class=\"comment\"># 网络配置</span></span><br><span class=\"line\">  <span class=\"attr\">gitea:</span> <span class=\"comment\"># 创建一个名为gitea的网络，实际的网络名称是 gitea_gitea，即 容器组名称_这里的名称</span></span><br><span class=\"line\">    <span class=\"attr\">external:</span> <span class=\"literal\">false</span> <span class=\"comment\"># 如果为true，则表示此网络不会由compose创建，而是使用已有的网络，默认为false</span></span><br><span class=\"line\">    <span class=\"attr\">driver:</span> <span class=\"string\">bridge</span>  <span class=\"comment\"># 网络类型，默认为bridge</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">volumes:</span> <span class=\"comment\"># 存储卷配置</span></span><br><span class=\"line\">  <span class=\"attr\">gitea:</span> <span class=\"comment\"># 创建一个名为gitea的存储卷，实际的卷名称是 gitea_gitea，即 容器组名称_这里的名称</span></span><br><span class=\"line\">    <span class=\"attr\">driver:</span> <span class=\"string\">local</span> <span class=\"comment\"># 存储卷类型，默认为local</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span> <span class=\"comment\"># 服务配置，这里可以定义一组容器</span></span><br><span class=\"line\">  <span class=\"attr\">server:</span> <span class=\"comment\"># 定义一个名为server的服务，注意这个不是容器名称</span></span><br><span class=\"line\">    <span class=\"comment\"># build: . # 构建镜像，使用当前目录下的Dockerfile</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">gitea/gitea:latest</span> <span class=\"comment\"># 镜像名称</span></span><br><span class=\"line\">    <span class=\"comment\"># container_name: gitea #  容器名称，默认为 “容器组名称-服务名称-索引”，不推荐配置，因为 水平扩展(--scale) 时,容器名称不能重复</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span> <span class=\"comment\"># 定义环境变量</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">USER_UID=1000</span> <span class=\"comment\"># key=value</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">USER_GID=1000</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">DB_TYPE=mysql</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">DB_HOST=db:3306</span> <span class=\"comment\"># 这里配置的 db 就是 下面的服务名称，相同 network 下的服务名称，docker compose会自动解析为容器的ip地址</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">DB_NAME=gitea</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">DB_USER=gitea</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">DB_PASSWD=gitea</span></span><br><span class=\"line\">    <span class=\"comment\"># env_file: .gitea.env # 从 .gitea.env 文件读取环境变量，生产环境更推荐</span></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">always</span> <span class=\"comment\"># 容器启动时，自动重启</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span> <span class=\"comment\"># 网络关联</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">gitea</span> <span class=\"comment\"># 网络名称，就是上面创建的gitea网络</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span> <span class=\"comment\">#  数据卷关联</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">gitea:/data</span> <span class=\"comment\"># volume映射，数据卷名称:/容器路径</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">/etc/timezone:/etc/timezone:ro</span> <span class=\"comment\"># 路径映射，宿主机路径:/容器路径:读写权限</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">/etc/localtime:/etc/localtime:ro</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span> <span class=\"comment\"># 端口映射</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;3000:3000&quot;</span> <span class=\"comment\"># 宿主机端口:容器端口</span></span><br><span class=\"line\">    <span class=\"attr\">depends_on:</span> <span class=\"comment\"># 启动依赖，就是依赖的服务启动后才能启动本服务</span></span><br><span class=\"line\">      <span class=\"attr\">db:</span> <span class=\"comment\"># 启动db服务</span></span><br><span class=\"line\">        <span class=\"attr\">condition:</span> <span class=\"string\">service_healthy</span> <span class=\"comment\"># 服务通过健康检查，也可以配置为 service_started：服务启动，这个是默认值</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">db:</span> <span class=\"comment\"># 数据库服务</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:8</span> <span class=\"comment\"># 镜像</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span> <span class=\"comment\"># 环境变量</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MYSQL_ROOT_PASSWORD=gitea</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MYSQL_USER=gitea</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MYSQL_PASSWORD=gitea</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MYSQL_DATABASE=gitea</span></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">always</span> <span class=\"comment\"># 启动策略</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span> <span class=\"comment\"># 网络映射</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">gitea</span> <span class=\"comment\"># 映射到gitea网络</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span> <span class=\"comment\"># 卷映射</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./mysql:/var/lib/mysql</span> <span class=\"comment\"># 宿主机路径:/容器路径，这里宿主机支持相对路径</span></span><br><span class=\"line\">    <span class=\"attr\">healthcheck:</span> <span class=\"comment\"># 健康检查</span></span><br><span class=\"line\">      <span class=\"attr\">test:</span> [<span class=\"string\">&quot;CMD-SHELL&quot;</span>, <span class=\"string\">&quot;mysql -u root -pgitea&quot;</span>, <span class=\"string\">&quot;-e &#x27;SELECT 1;&#x27;&quot;</span>] <span class=\"comment\"># 执行命令，如果返回0，则健康检查通过，这里不支持上面的环境变量，test只支持  CMD-SHELL 和 CMD</span></span><br><span class=\"line\">      <span class=\"attr\">interval:</span> <span class=\"string\">10s</span> <span class=\"comment\"># 健康检查间隔</span></span><br><span class=\"line\">      <span class=\"attr\">timeout:</span> <span class=\"string\">5s</span> <span class=\"comment\"># 健康检查超时时间</span></span><br><span class=\"line\">      <span class=\"attr\">retries:</span> <span class=\"number\">3</span> <span class=\"comment\"># 健康检查重试次数</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>build</code>: 构建镜像</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">server:</span></span><br><span class=\"line\">    <span class=\"attr\">build:</span> <span class=\"string\">.</span> <span class=\"comment\"># Dockerfile的目录，“.” 表示使用当前目录下的Dockerfile</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">example/webapp</span> <span class=\"comment\"># 镜像名称，如果有build，则该名称就是build后的镜像名称，如果没有build，则就会从远程仓库拉取</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">server:</span></span><br><span class=\"line\">    <span class=\"attr\">build:</span></span><br><span class=\"line\">      <span class=\"attr\">context:</span> <span class=\"string\">./webapp</span> <span class=\"comment\"># Dockerfile的目录，默认是当前目录</span></span><br><span class=\"line\">      <span class=\"attr\">dockerfile:</span> <span class=\"string\">Dockerfile</span> <span class=\"comment\"># 构建镜像的Dockerfile名称，默认是Dockerfile</span></span><br><span class=\"line\">      <span class=\"attr\">platforms:</span> <span class=\"comment\"># 构建镜像的架构</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">linux/amd64</span> <span class=\"comment\"># 构建镜像的架构，默认是当前架构</span></span><br><span class=\"line\">      <span class=\"attr\">args:</span> <span class=\"comment\"># 构建镜像的参数</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">FOO=bar</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span> <span class=\"comment\"># 构建镜像的标签</span></span><br><span class=\"line\">        <span class=\"attr\">com.example.description:</span> <span class=\"string\">&quot;Accounting webapp&quot;</span></span><br><span class=\"line\">        <span class=\"attr\">com.example.department:</span> <span class=\"string\">&quot;Finance&quot;</span></span><br><span class=\"line\">        <span class=\"attr\">com.example.label-with-empty-value:</span> <span class=\"string\">&quot;&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>command</code>: 覆盖容器映像声明的默认命令</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">server:</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;python&quot;</span>, <span class=\"string\">&quot;app.py&quot;</span>]</span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">example/webapp</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>entrypoint</code>: 声明服务容器的默认入口点，这覆盖了服务Dockerfile中的ENTRYPOINT指令。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">server:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">example/webapp</span></span><br><span class=\"line\">    <span class=\"attr\">entrypoint:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">php</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">-d</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20100525/xdebug.so</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">-d</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">memory_limit=-1</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">vendor/bin/phpunit</span></span><br><span class=\"line\">      <span class=\"comment\"># 如果值为null，则使用图像的默认入口点。 entrypoint: null</span></span><br><span class=\"line\">      <span class=\"comment\"># 如果值是 []（空列表）或 &#x27;&#x27;（空字符串），图像声明的默认入口点被忽略，或者换句话说，被覆盖为空。 entrypoint: []</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>depends_on</code>: 服务启动依赖，就是依赖的服务启动后才能启动本服务</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">web:</span></span><br><span class=\"line\">    <span class=\"attr\">build:</span> <span class=\"string\">.</span></span><br><span class=\"line\">    <span class=\"attr\">depends_on:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db</span> <span class=\"comment\"># 短语法</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">redis</span></span><br><span class=\"line\">  <span class=\"attr\">redis:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">redis</span></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">postgres</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">web:</span></span><br><span class=\"line\">    <span class=\"attr\">build:</span> <span class=\"string\">.</span></span><br><span class=\"line\">    <span class=\"attr\">depends_on:</span></span><br><span class=\"line\">      <span class=\"attr\">db:</span>  <span class=\"comment\"># 长语法</span></span><br><span class=\"line\">        <span class=\"attr\">condition:</span> <span class=\"string\">service_healthy</span> <span class=\"comment\"># 满足的条件</span></span><br><span class=\"line\">        <span class=\"attr\">restart:</span> <span class=\"literal\">true</span>      <span class=\"comment\"># 当设置为true，Compose在更新依赖服务后重新启动此服务。</span></span><br><span class=\"line\">      <span class=\"attr\">redis:</span></span><br><span class=\"line\">        <span class=\"attr\">condition:</span> <span class=\"string\">service_started</span></span><br><span class=\"line\">  <span class=\"attr\">redis:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">redis</span></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">postgres</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## condition：设置依赖性被视为满足的条件</span></span><br><span class=\"line\"><span class=\"comment\">#   service_started：相当于之前描述的简短语法</span></span><br><span class=\"line\"><span class=\"comment\">#   service_healthy：指定在启动依赖服务之前，依赖预期为“健康”（如healthcheck所示）。</span></span><br><span class=\"line\"><span class=\"comment\">#   service_completed_successfully：指定在启动依赖服务之前，依赖项预计将运行到成功完成。</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>environment</code>: 定义环境变量</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">server:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">example/webapp</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">FOO=bar</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">BAZ=qux</span></span><br><span class=\"line\"><span class=\"comment\"># 或者</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">server:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">example/webapp</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"attr\">FOO:</span> <span class=\"string\">bar</span></span><br><span class=\"line\">      <span class=\"attr\">BAZ:</span> <span class=\"string\">qux</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>env_file</code>: 用于指定一个或多个包含要传递到容器的环境变量的文件。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">server:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">example/webapp</span></span><br><span class=\"line\">    <span class=\"attr\">env_file:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./a.env</span> <span class=\"comment\"># 列表中的文件是从上到下处理的。对于两个环境文件中指定的相同变量，列表中最后一个文件的值是有效的。</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./b.env</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">server:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">example/webapp</span></span><br><span class=\"line\">    <span class=\"attr\">env_file:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">path:</span> <span class=\"string\">./default.env</span></span><br><span class=\"line\">        <span class=\"attr\">required:</span> <span class=\"literal\">true</span> <span class=\"comment\"># default</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">path:</span> <span class=\"string\">./override.env</span></span><br><span class=\"line\">        <span class=\"attr\">required:</span> <span class=\"literal\">false</span> <span class=\"comment\"># 当required设置为false且.env文件缺失时，Compose会忽略</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>restart</code>: 定义平台在容器终止时适用的策略</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">server:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">example/webapp</span></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">&quot;no&quot;</span>            <span class=\"comment\"># 默认重启策略。在任何情况下，它都不会重新启动容器。</span></span><br><span class=\"line\">    <span class=\"comment\"># restart: always        # 策略总是重新启动容器，直到它被移除。</span></span><br><span class=\"line\">    <span class=\"comment\"># restart: on-failure    # 如果退出代码表明错误，策略将重新启动容器。</span></span><br><span class=\"line\">    <span class=\"comment\"># restart: on-failure:3  # 如果退出代码表明错误，策略将重新启动容器。但仅尝试重启3次。</span></span><br><span class=\"line\">    <span class=\"comment\"># restart: unless-stopped # 无论退出代码如何，策略都会重新启动容器，但当服务停止或删除时，策略会停止重新启动。</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>healthcheck</code>: 健康检查。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">server:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">example/webapp</span></span><br><span class=\"line\">    <span class=\"attr\">healthcheck:</span>  <span class=\"comment\"># 健康检查</span></span><br><span class=\"line\">      <span class=\"attr\">test:</span> [<span class=\"string\">&quot;CMD&quot;</span>, <span class=\"string\">&quot;curl&quot;</span>, <span class=\"string\">&quot;-f&quot;</span>, <span class=\"string\">&quot;http://localhost&quot;</span>] <span class=\"comment\"># 监控检查时执行的命令</span></span><br><span class=\"line\">      <span class=\"attr\">interval:</span> <span class=\"string\">1m30s</span> <span class=\"comment\"># 健康检查的间隔，默认值为 30s</span></span><br><span class=\"line\">      <span class=\"attr\">timeout:</span> <span class=\"string\">10s</span>    <span class=\"comment\">#  健康检查的超时时间，默认值为 30s</span></span><br><span class=\"line\">      <span class=\"attr\">retries:</span> <span class=\"number\">3</span>      <span class=\"comment\"># 健康检查的尝试次数，默认值为 3</span></span><br><span class=\"line\">      <span class=\"attr\">start_period:</span> <span class=\"string\">40s</span> <span class=\"comment\"># 启动宽限期：在此期间，失败不会计入重试次数（仅用于判断服务是否启动完毕）</span></span><br><span class=\"line\">      <span class=\"attr\">start_interval:</span> <span class=\"string\">5s</span> <span class=\"comment\"># 启动宽限期内检查的频率，本示例为在前 40 秒内每 5 秒检查一次</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>test定义Compose运行的命令来检查容器运行状况。它可以是字符串，也可以是列表。如果是列表，第一个项目必须是NONE、CMD或CMD-SHELL。如果它是一个字符串，它等同于指定CMD-SHELL后跟该字符串。</p>\n</blockquote>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">test:</span> [<span class=\"string\">&quot;CMD&quot;</span>, <span class=\"string\">&quot;curl&quot;</span>, <span class=\"string\">&quot;-f&quot;</span>, <span class=\"string\">&quot;http://localhost&quot;</span>]</span><br><span class=\"line\"><span class=\"comment\"># 使用CMD-SHELL运行配置为字符串的命令，使用容器的默认外壳（Linux的/bin/sh）。以下两种形式是等价的</span></span><br><span class=\"line\"><span class=\"attr\">test:</span> [<span class=\"string\">&quot;CMD-SHELL&quot;</span>, <span class=\"string\">&quot;curl -f http://localhost || exit 1&quot;</span>]</span><br><span class=\"line\"><span class=\"attr\">test:</span> <span class=\"string\">curl</span> <span class=\"string\">-f</span> <span class=\"string\">https://localhost</span> <span class=\"string\">||</span> <span class=\"string\">exit</span> <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>test 中的 CMD 和 CMD-SHELL 是两种不同的执行方式，它们的主要区别在于：</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th><code>CMD</code></th>\n<th><code>CMD-SHELL</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>✅ <strong>用途</strong></td>\n<td>直接执行命令（不通过 shell）</td>\n<td>通过 shell（如 <code>/bin/sh -c</code>）执行命令</td>\n</tr>\n<tr>\n<td>🧾 <strong>写法格式</strong></td>\n<td><code>[&quot;CMD&quot;, &quot;executable&quot;, &quot;arg1&quot;, &quot;arg2&quot;]</code></td>\n<td><code>[&quot;CMD-SHELL&quot;, &quot;command string&quot;]</code></td>\n</tr>\n<tr>\n<td>🔧 <strong>是否使用 shell</strong></td>\n<td>否</td>\n<td>是</td>\n</tr>\n<tr>\n<td>🧠 <strong>是否支持 shell 语法</strong></td>\n<td>❌ 否<br>（不能使用 <code>&amp;&amp;</code>、 <code>||</code>、<code>\\$VAR</code> 等）</td>\n<td>✅ 是<br>（支持管道、重定向、变量、命令组合）</td>\n</tr>\n<tr>\n<td>🛡️ <strong>安全性/可移植性</strong></td>\n<td>✅ 更安全，执行更明确</td>\n<td>⚠ 依赖容器中存在 shell（如 <code>/bin/sh</code>）</td>\n</tr>\n<tr>\n<td>⚙️ <strong>执行效率</strong></td>\n<td>✅ 稍快，因无需 shell 解析</td>\n<td>⚠ 稍慢，需通过 shell 启动</td>\n</tr>\n<tr>\n<td>📦 <strong>推荐使用场景</strong></td>\n<td>- 简单健康检查命令<br>- 安全环境<br>- 精简镜像</td>\n<td>- 需要使用逻辑控制（<code>||</code>, <code>&amp;&amp;</code>）<br>- 复杂检查逻辑</td>\n</tr>\n<tr>\n<td>📌 <strong>示例</strong></td>\n<td><code>[&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;]</code></td>\n<td><code>[&quot;CMD-SHELL&quot;, &quot;curl -f http\\://localhost || exit 1&quot;]</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>volumes</code>: 挂载数据卷。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 长语法格式</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">backend:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">example/backend</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">volume</span>   <span class=\"comment\"># 安装类型。可以是是volume、bind、tmpfs、image、npipe、cluster</span></span><br><span class=\"line\">        <span class=\"attr\">source:</span> <span class=\"string\">db-data</span> <span class=\"comment\"># 挂载的源、绑定挂载的主机上的路径、映像挂载的Docker映像引用或顶层volumes键中定义的卷名称。不适用于tmpfs支架。</span></span><br><span class=\"line\">        <span class=\"attr\">target:</span> <span class=\"string\">/data</span> <span class=\"comment\"># 容器中装载卷的路径。</span></span><br><span class=\"line\">        <span class=\"attr\">volume:</span>  <span class=\"comment\"># 配置其他卷选项</span></span><br><span class=\"line\">          <span class=\"attr\">nocopy:</span> <span class=\"literal\">true</span> <span class=\"comment\"># 在创建卷时禁用从容器复制数据的标志，默认值为false。</span></span><br><span class=\"line\">          <span class=\"attr\">subpath:</span> <span class=\"string\">sub</span> <span class=\"comment\"># 挂载卷的子目录。即 db-data/sub</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">bind</span> <span class=\"comment\"># bind 表示挂载主机上的路径</span></span><br><span class=\"line\">        <span class=\"attr\">source:</span> <span class=\"string\">/var/run/postgres/postgres.sock</span></span><br><span class=\"line\">        <span class=\"attr\">target:</span> <span class=\"string\">/var/run/postgres/postgres.sock</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">volumes:</span> <span class=\"comment\"># 声明数据卷</span></span><br><span class=\"line\">  <span class=\"attr\">db-data:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">######################################################################################</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 短语法格式</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">backend:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">example/backend</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db-data:/data</span> <span class=\"comment\"># 这种语法不支持 subpath 和 nocopy</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">/var/run/postgres/postgres.sock:/var/run/postgres/postgres.sock</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"attr\">db-data:</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>networks</code>: 配置网络。</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">some-service:</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span>  <span class=\"comment\"># 配置网络</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">some-network</span> <span class=\"comment\"># 关联网络</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">other-network</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">networks:</span> <span class=\"comment\"># 声明网络</span></span><br><span class=\"line\">  <span class=\"attr\">some-network:</span></span><br><span class=\"line\">  <span class=\"attr\">other-network:</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>cpu 和 内存限制</p>\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">backend:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">myapp:latest</span></span><br><span class=\"line\">    <span class=\"attr\">mem_limit:</span> <span class=\"string\">1g</span>           <span class=\"comment\"># 限制最多使用1GB内存</span></span><br><span class=\"line\">    <span class=\"attr\">mem_reservation:</span> <span class=\"string\">512m</span>   <span class=\"comment\"># 建议预留512MB内存</span></span><br><span class=\"line\">    <span class=\"attr\">cpus:</span> <span class=\"number\">2.0</span>               <span class=\"comment\"># 限制最多使用2个CPU核</span></span><br><span class=\"line\">    <span class=\"attr\">cpu_shares:</span> <span class=\"number\">1024</span>        <span class=\"comment\"># 默认值，表示标准优先级</span></span><br><span class=\"line\">    <span class=\"attr\">cpu_quota:</span> <span class=\"number\">100000</span>       <span class=\"comment\"># 每 100ms 容器最多可运行 100ms（=1核）, 与 cpus 不能同时设置</span></span><br><span class=\"line\">    <span class=\"attr\">cpu_period:</span> <span class=\"number\">100000</span>      <span class=\"comment\"># 调度周期为100ms, 与 cpus 不能同时设置</span></span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>cpus</code></td>\n<td>float</td>\n<td>限制容器最多使用多少 CPU（逻辑核数）；例如 <code>0.5</code> = 一半 CPU</td>\n</tr>\n<tr>\n<td><code>mem_limit</code></td>\n<td>string</td>\n<td>容器最大内存限制，支持单位：<code>b</code>、<code>k</code>、<code>m</code>、<code>g</code>（如 <code>256m</code>, <code>1g</code>）</td>\n</tr>\n<tr>\n<td><code>mem_reservation</code></td>\n<td>string</td>\n<td>容器启动时预留的内存，超过这个值不被限制（仅提示调度器）</td>\n</tr>\n<tr>\n<td><code>cpu_shares</code></td>\n<td>int</td>\n<td>CPU 权重（默认 1024），用于多个容器抢占 CPU 的优先级（仅在竞争时生效）</td>\n</tr>\n<tr>\n<td><code>cpu_quota</code></td>\n<td>int</td>\n<td>每个周期内允许使用的 CPU 时间（单位：微秒）, 与 cpus 不能同时设置</td>\n</tr>\n<tr>\n<td><code>cpu_period</code></td>\n<td>int</td>\n<td>CPU 调度周期（单位：微秒，默认 <code>100000</code>）, 与 cpus 不能同时设置</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>查看容器的 cpu 和 内存配置情况</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取容器的 cpu_quota 和 cpu_period</span></span><br><span class=\"line\">docker inspect --format=<span class=\"string\">&#x27;&#123;&#123;json .HostConfig.CpuQuota&#125;&#125; &#123;&#123;json .HostConfig.CpuPeriod&#125;&#125;&#x27;</span> &lt;container_id&gt;</span><br><span class=\"line\"><span class=\"comment\"># 获取容器的 memory_limit</span></span><br><span class=\"line\">docker inspect --format=<span class=\"string\">&#x27;&#123;&#123;json .HostConfig.Memory&#125;&#125;&#x27;</span> &lt;container_id&gt;</span><br><span class=\"line\"><span class=\"comment\"># 获取容器的 cpu_shares</span></span><br><span class=\"line\">docker inspect --format=<span class=\"string\">&#x27;&#123;&#123;json .HostConfig.CpuShares&#125;&#125;&#x27;</span> &lt;container_id&gt;</span><br><span class=\"line\"><span class=\"comment\"># 获取容器的 cpus</span></span><br><span class=\"line\">docker inspect --format=<span class=\"string\">&#x27;&#123;&#123;json .HostConfig.NanoCpus&#125;&#125;&#x27;</span> &lt;container_id&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 组合为一个json输出</span></span><br><span class=\"line\">docker inspect &lt;container_id&gt; | jq <span class=\"string\">&#x27;.[0].HostConfig | &#123;</span></span><br><span class=\"line\"><span class=\"string\">  cpus: (.NanoCpus / 1000000000),</span></span><br><span class=\"line\"><span class=\"string\">  cpu_shares: .CpuShares,</span></span><br><span class=\"line\"><span class=\"string\">  mem_limit: (.Memory / 1024 / 1024 | tostring + &quot; MB&quot;),</span></span><br><span class=\"line\"><span class=\"string\">  mem_reservation: (.MemoryReservation / 1024 / 1024 | tostring + &quot; MB&quot;),</span></span><br><span class=\"line\"><span class=\"string\">  cpu_quota: .CpuQuota,</span></span><br><span class=\"line\"><span class=\"string\">  cpu_period: .CpuPeriod</span></span><br><span class=\"line\"><span class=\"string\">&#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"docker-run-转-docker-compose\"><code>docker run</code> 转 <code>docker compose</code></h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在线工具：<a href=\"https://www.composerize.com/\">composerize</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本地安装：<a href=\"https://github.com/composerize/composerize\">composerize</a></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装命令，npm安装：https://nodejs.org/zh-cn/download</span></span><br><span class=\"line\">npm install composerize -g</span><br><span class=\"line\"><span class=\"comment\"># 运行命令</span></span><br><span class=\"line\">composerize docker run -p 80:80 -v /var/run/docker.sock:/tmp/docker.sock:ro --restart always --log-opt max-size=1g nginx</span><br><span class=\"line\"><span class=\"comment\">##  转换结果</span></span><br><span class=\"line\">name: &lt;your project name&gt;</span><br><span class=\"line\">services:</span><br><span class=\"line\">  nginx:</span><br><span class=\"line\">    ports:</span><br><span class=\"line\">      - 80:80</span><br><span class=\"line\">    volumes:</span><br><span class=\"line\">      - /var/run/docker.sock:/tmp/docker.sock:ro</span><br><span class=\"line\">    restart: always</span><br><span class=\"line\">    logging:</span><br><span class=\"line\">      options:</span><br><span class=\"line\">        max-size: 1g</span><br><span class=\"line\">    image: nginx</span><br></pre></td></tr></table></figure>\n<h2 id=\"docker-compose-编排管理工具-Dockge\"><code>docker compose</code> 编排管理工具 <code>Dockge</code></h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://dockge.kuma.pet\">Dockge</a> 是一个开源轻量级「Docker Compose 管理器」，它提供了一个漂亮、响应迅速的 Web 界面，专门面向使用 <code>docker compose</code> 的用户。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>功能模块</th>\n<th>主要描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Compose 堆栈全生命周期管理</strong></td>\n<td>可以创建、编辑、启动、停止、重启、删除基于 <code>compose.yaml</code> 文件的 Docker 堆栈</td>\n</tr>\n<tr>\n<td><strong>交互式 Compose 编辑器 + Web 终端</strong></td>\n<td>实时编辑 YAML 并查看输出，还可以直接在浏览器中操作终端</td>\n</tr>\n<tr>\n<td><strong>将 <code>docker run …</code> 命令转换为 Compose 文件</strong></td>\n<td>快速生成 <code>compose.yaml</code>，便于版本控制和结构管理</td>\n</tr>\n<tr>\n<td><strong>实时操作反馈</strong></td>\n<td>镜像拉取、堆栈启动/停止等操作均可实时查看进度</td>\n</tr>\n<tr>\n<td><strong>多主机代理支持（≥1.4.0）</strong></td>\n<td>能在单一 UI 中管理多个 Docker 主机</td>\n</tr>\n<tr>\n<td><strong>高兼容性 &amp; 安全设计</strong></td>\n<td>Compose 文件保存在本地，不会被系统托管，便于使用 CLI 或其他工具管理</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>安装</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Create directories that store your stacks and store Dockge&#x27;s stack</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> -p /opt/stacks /opt/dockge</span><br><span class=\"line\"><span class=\"built_in\">cd</span> /opt/dockge</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Download your compose.yaml</span></span><br><span class=\"line\">curl <span class=\"string\">&quot;https://dockge.kuma.pet/compose.yaml?port=5001&amp;stacksPath=%2Fopt%2Fstacks&quot;</span> --output compose.yaml</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Start the Server</span></span><br><span class=\"line\">docker compose up -d</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 浏览器访问 http://localhost:5001</span></span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍 Docker 命令 中 docker compose 的使用方法 Docker官方文档 docker compose Compose file reference docker compose 是什么？ Docker Compose是一个用于定义和运行多容器应用程序的工具。 Compose简化了对整个应用程序堆栈的控制，便于在单个YAML配置文件中管理服务、网络和卷。然后，通过一个命令，您从配置文件中创建并启动所有服务。 Docker Compose 的优势： 优点 描述 简化控制 Docker Compose 允许在单个 YAML 文件中定义和管理多容器应用程序，简化了服务编排与协调，使环境管理和复制更容易。 高效的协作 配置文件易于共享，促进开发人员、运营团队和其他利益相关者之间的协作，从而提升工作流程效率和问题解决速度。 快速应用程序开发 Compose 利用缓存重复使用未更改服务的容器，加快环境变更速度，提高开发效率。 跨环境的可移植性 支持在 Compose 文件中使用变量，使配置能根据不同环境或用户进行自定义，增强了可移植性。 广泛的社区和支持 拥有活跃的社区，提供丰富的资源、教程和技术支持，有助于持续改进与高效排障。 docker compose 安装 同docker一起安装 12# 安装docker同时安装docker compose，这里 docker-compose-plugin 就是docker composesudo dnf install docker-ce-3:26.1.3-1.el8 docker-ce-cli-3:26.1.3-1.el8 containerd.io docker-buildx-plugin docker-compose-plugin -y 单独安装 12# 若安装docker时没有安装 docker-compose-plugin ，则需要单独安装sudo dnf install docker-compose-plugin -y 查看版本 1docker compose version 直接下载docker-compose的命令文件 123456# Install Docker Compose，注意通过这种方式安装的compose的使用方式为 `docker-compose`，而非标准的 `docker compose`sudo curl -L &quot;https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose# Make the docker-compose command availablesudo chmod +x /usr/local/bin/docker-compose# Check Docker Compose versiondocker-compose version docker compose 命令 命令 中文说明 示例 attach 连接到服务的运行中容器的标准输入、输出和错误流 docker compose attach web build 构建或重新构建服务 docker compose build config 解析并标准化 Compose 文件 docker compose config cp 在服务容器与本地文件系统之间复制文件/文件夹 docker compose cp web:/app/file.txt ./file.txt create 为服务创建容器，但不启动 docker compose create down 停止并移除容器、网络等资源 docker compose down events 实时接收容器事件 docker compose events exec 在运行中的容器中执行命令 docker compose exec web ls /app images 列出已创建容器所使用的镜像 docker compose images kill 强制停止服务容器 docker compose kill logs 查看服务容器的日志输出 docker compose logs ls 列出当前运行的 Compose 项目 docker compose ls pause 暂停服务容器 docker compose pause port 显示某端口映射的公网地址 docker compose port web 80 ps 列出服务的容器 docker compose ps pull 拉取服务使用的镜像 docker compose pull push 推送服务镜像到仓库 docker compose push restart 重启服务容器 docker compose restart rm 移除已停止的服务容器 docker compose rm run 在服务上运行一次性命令 docker compose run web echo Hello scale 扩展服务实例数量 docker compose up --scale web=3 start 启动已存在但已停止的服务容器 docker compose start stats 实时显示容器资源使用情况 docker compose stats stop 停止运行中的服务容器 docker compose stop top 显示容器内的运行进程 docker compose top unpause 取消暂停服务容器 docker compose unpause up 创建并启动服务容器 docker compose up version 显示 Docker Compose 版本信息 docker compose version wait 阻塞直到第一个服务容器停止 docker compose wait watch 监听服务构建上下文变更并重新构建/刷新容器 docker compose watch docker compose 常用命令 启动与关闭 123456789101112131415161718# 启动并运行，默认使用当前目录的 docker-compose.yml 文件docker compose up# 后台运行docker compose up -d# 指定compose文件docker compose -f docker-compose.yml up -d# 启动时重建服务，当修改了 compose 文件时docker compose up --build# 停止servicedocker compose stop# 强制停止service，当 stop 命令无法停止时docker compose kill# 重启servicedocker compose restart# 删除service，-s 参数表示删除前先停止容器docker compose rm -s# 停止并删除service，同时删除网络，但不会删除卷docker compose down 监控 123456789101112131415161718# 列出当前运行的 Compose 项目docker compose ls# 查看service状态，-a 显示所有servicedocker compose ps -a# 解析并标准化 compose 文件，这个命令可以检查 docker-compose.yml 文件语法是否正确，但不保证逻辑正确docker compose config# 查看使用的镜像docker compose images# 查看进程docker compose top# 查看service资源使用情况docker compose stats# 查看service日志，-f 表示持续跟踪docker compose logs -f# 查看指定service的日志docker compose logs -f service_name# 进入指定的service容器docker compose exec service_name bash 升级镜像 123456# 先停止所有servicedocker compose down# 拉取最新镜像docker compose pull# 启动servicedocker compose up -d --build docker-compose.yml 的语法 常用指令 123456789101112131415161718192021222324version: &quot;3.8&quot; # 定义版本，表示当前使用的 docker compose 语法的版本，已过时 ，新版 Docker 会使用最新的 Compose Specification 自动解析name: &quot;project_name&quot; # 项目名，默认 docker-compose.yml 文件所在的目录名，不推荐设置services: # 服务列表 servicename: # 服务名字，只能包含小写字母、数字、下划线、中划线，必须以字母或数字开头 build: # 基于Dockerfile构建目录，如果同时设置了 image 选项，则image指定的就是构建后的镜像名称 image: # 镜像的名字，默认从远程仓库拉取，如果配置了 build 选项，则image指定的就是构建后的镜像名称 command: # 可选，如果设置，则会覆盖默认镜像里的 CMD 命令 environment: # 可选，等价于 docker container run 里的 --env 选项设置环境变量 volumes: # 可选，等价于 docker container run 里的 -v 选项 绑定数据卷 networks: # 可选，等价于 docker container run 里的 --network 选项指定网络 ports: # 可选，等价于 docker container run 里的 -p 选项指定端口映射 expose: # 可选，指定容器暴露的端口 depends_on: # 服务依赖的其它服务 env_file: # 环境变量文件，生产环境更推荐这种方式 servicename2: image: command: networks: ports: servicename3: #...volumes: # 可选，等价于 docker volume createnetworks: # 可选，等价于 docker network create volumes 卷是由容器引擎实现的持久数据存储。Compose 为服务提供了一种中立的挂载卷的方式，并通过配置参数将卷分配给基础架构。顶级volumes声明允许您配置可在多个服务之间重复使用的命名卷。 12345678910111213services: backend: image: example/database volumes: # 挂载卷映射 - db-data:/etc/data # 挂载到容器的/etc/data目录 backup: image: backup-service volumes: - db-data:/var/lib/backup/data # 一个卷可以被多个服务使用volumes: # 存储卷配置 db-data: # 创建一个名为db-data的卷，实际的网络名称是 容器组名称_这里的名称 volumes 的属性 driver: 卷类型，默认为local，指定应使用哪个卷驱动程序。如果该驱动程序不可用，Compose 将返回错误并且不会部署该应用程序。 1234volumes: db-data: # 声明一个名为db-data的卷 driver: local # 指定卷类型，这个是默认值，可以不配置 db-data2: # 声明一个名为db-data2的卷，这是最简单的 volumes 配置 driver_opts: 卷类型参数，指定要传递给此卷驱动程序的选项列表（以键值对的形式）。这些选项与驱动程序相关。 123456volumes: db-data: driver_opts: # 卷类型参数，指定要传递给此卷驱动程序的选项列表（以键值对的形式） type: &quot;nfs&quot; # 卷类型，指定应使用哪个卷驱动程序，这里是nfs o: &quot;addr=10.40.0.199,nolock,soft,rw&quot; # nfs参数，addr为nfs服务器地址，nolock为不锁定文件，soft为软链接，rw为读写权限 device: &quot;:/docker/example&quot; # nfs挂载路径 external: 卷是否为外部卷，默认为false 123volumes: db-data: external: true # true 表示不会创建，而是使用已存在的，即会去volumes中查找(docker volume ls) 容器组名称_da-data ，默认为false name: 卷的名称，默认为 容器组名称_声明的名称 1234volumes: db-data: name: db-data # 创建一个名为db-data的卷，实际的卷名称就是 db-data，不会再加上容器组名称前缀 external: true # name 属性经常与 external: true 一起使用 labels: 用于向卷添加元数据，可以添加任意的键值对 123456volumes: db-data: labels: com.example.description: &quot;Database volume&quot; com.example.department: &quot;IT/Ops&quot; com.example.label-with-empty-value: &quot;&quot; networks 网络使服务能够相互通信。默认情况下，Compose 会为您的应用设置单个网络。服务的每个容器都会加入默认网络，并且该网络上的其他容器都可以访问，并且可以通过服务名称发现。顶级networks元素允许您配置可在多个服务之间重复使用的命名网络。 1234567891011121314services: frontend: image: example/webapp networks: # 网络映射 - front-tier # 加入front-tier网络 - back-tier db: image: postgres networks: - backendnetworks: # 网络配置 front-tier: # 创建一个名为front-tier的网络，实际的网络名称是 容器组名称_front-tier back-tier: 如果 Compose 文件未显式声明网络，Compose 将使用隐式default网络。 123456789101112services: some-service: image: foo# 这个例子实际上等同于：services: some-service: image: foo networks: default: &#123;&#125;networks: default: &#123;&#125; networks 的属性 driver: 网络类型，默认为bridge 123networks: gitea: driver: bridge driver_opts: 网络类型参数，指定要传递给此网络驱动程序的选项列表（以键值对的形式）。这些选项与驱动程序相关。 12345networks: frontend: driver: bridge driver_opts: com.docker.network.bridge.host_binding_ipv4: &quot;127.0.0.1&quot; # 设置容器端口绑定到主机的哪个 IP（如 &quot;127.0.0.1&quot;，绑定到本地） driver_opts 常见配置项（针对 bridge 网络驱动） 选项键名（driver_opts） 说明 com.docker.network.bridge.name 指定桥接网络的名称（默认是随机生成，如 br-xxxxx） com.docker.network.bridge.enable_icc 是否允许容器之间的通信（true 或 false） com.docker.network.bridge.enable_ip_masquerade 是否启用 IP 假冒（NAT，通常用于外网访问） com.docker.network.bridge.host_binding_ipv4 设置容器端口绑定到主机的哪个 IP（如 &quot;127.0.0.1&quot;，绑定到本地） com.docker.network.bridge.default_bridge 是否将该网络设置为默认 bridge 网络（true 或 false） com.docker.network.driver.mtu 设置网络的最大传输单元（MTU，例如 &quot;1500&quot;） com.docker.network.bridge.allow_non_default_bridge 是否允许容器加入非默认的 bridge 网络（较少使用） attachable: 如果为true，则允许将其它独立容器也加入到此网络。默认值为false。如果独立容器连接到此网络，它可以与同样连接到此网络的服务和其他独立容器进行通信。 123networks: gitea: attachable: true external: true 表示不会创建新的网络，回去networks中查找（docker network ls），默认为false 123networks: gitea: external: true name: 网络名称，不会再加上容器组名称前缀 1234networks: gitea: name: gitea external: true # name 属性经常与 external: true 一起使用 labels: 用于向网络添加元数据，可以添加任意的键值对 123456networks: mynet1: labels: com.example.description: &quot;Financial transaction network&quot; com.example.department: &quot;Finance&quot; com.example.label-with-empty-value: &quot;&quot; internal: 默认情况下，Compose 提供网络的外部连接。internal当设置为 时true，可让您创建与外部隔离的网络。 123networks: gitea: internal: true services 服务是应用程序中计算资源的抽象定义，可以独立于其他组件进行扩展或替换。服务由一组容器支持，由平台根据复制要求和布局约束运行。由于服务由容器支持，因此它们由 Docker 镜像和一组运行时参数定义。服务中的所有容器都使用这些参数以相同的方式创建。 service 包含的属性非常多，具体请参考services顶级元素，这里只介绍比较常用的属性， 这里以Gitea的docker-compose.yml为例 Gitea 是一种轻松、自托管的一体化软件开发服务。它包括 Git 托管、代码审查、团队协作、包注册表和 CI/CD。它类似于 GitHub、Bitbucket 和 GitLab。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# version: &#x27;3.8&#x27; # 配置文件版本，已过时，配置上会告警但不会报错# name: gitea # 容器组名称，默认使用所在目录的名称，不推荐使用networks: # 网络配置 gitea: # 创建一个名为gitea的网络，实际的网络名称是 gitea_gitea，即 容器组名称_这里的名称 external: false # 如果为true，则表示此网络不会由compose创建，而是使用已有的网络，默认为false driver: bridge # 网络类型，默认为bridgevolumes: # 存储卷配置 gitea: # 创建一个名为gitea的存储卷，实际的卷名称是 gitea_gitea，即 容器组名称_这里的名称 driver: local # 存储卷类型，默认为localservices: # 服务配置，这里可以定义一组容器 server: # 定义一个名为server的服务，注意这个不是容器名称 # build: . # 构建镜像，使用当前目录下的Dockerfile image: gitea/gitea:latest # 镜像名称 # container_name: gitea # 容器名称，默认为 “容器组名称-服务名称-索引”，不推荐配置，因为 水平扩展(--scale) 时,容器名称不能重复 environment: # 定义环境变量 - USER_UID=1000 # key=value - USER_GID=1000 - DB_TYPE=mysql - DB_HOST=db:3306 # 这里配置的 db 就是 下面的服务名称，相同 network 下的服务名称，docker compose会自动解析为容器的ip地址 - DB_NAME=gitea - DB_USER=gitea - DB_PASSWD=gitea # env_file: .gitea.env # 从 .gitea.env 文件读取环境变量，生产环境更推荐 restart: always # 容器启动时，自动重启 networks: # 网络关联 - gitea # 网络名称，就是上面创建的gitea网络 volumes: # 数据卷关联 - gitea:/data # volume映射，数据卷名称:/容器路径 - /etc/timezone:/etc/timezone:ro # 路径映射，宿主机路径:/容器路径:读写权限 - /etc/localtime:/etc/localtime:ro ports: # 端口映射 - &quot;3000:3000&quot; # 宿主机端口:容器端口 depends_on: # 启动依赖，就是依赖的服务启动后才能启动本服务 db: # 启动db服务 condition: service_healthy # 服务通过健康检查，也可以配置为 service_started：服务启动，这个是默认值 db: # 数据库服务 image: mysql:8 # 镜像 environment: # 环境变量 - MYSQL_ROOT_PASSWORD=gitea - MYSQL_USER=gitea - MYSQL_PASSWORD=gitea - MYSQL_DATABASE=gitea restart: always # 启动策略 networks: # 网络映射 - gitea # 映射到gitea网络 volumes: # 卷映射 - ./mysql:/var/lib/mysql # 宿主机路径:/容器路径，这里宿主机支持相对路径 healthcheck: # 健康检查 test: [&quot;CMD-SHELL&quot;, &quot;mysql -u root -pgitea&quot;, &quot;-e &#x27;SELECT 1;&#x27;&quot;] # 执行命令，如果返回0，则健康检查通过，这里不支持上面的环境变量，test只支持 CMD-SHELL 和 CMD interval: 10s # 健康检查间隔 timeout: 5s # 健康检查超时时间 retries: 3 # 健康检查重试次数 build: 构建镜像 1234services: server: build: . # Dockerfile的目录，“.” 表示使用当前目录下的Dockerfile image: example/webapp # 镜像名称，如果有build，则该名称就是build后的镜像名称，如果没有build，则就会从远程仓库拉取 12345678910111213services: server: build: context: ./webapp # Dockerfile的目录，默认是当前目录 dockerfile: Dockerfile # 构建镜像的Dockerfile名称，默认是Dockerfile platforms: # 构建镜像的架构 - linux/amd64 # 构建镜像的架构，默认是当前架构 args: # 构建镜像的参数 - FOO=bar labels: # 构建镜像的标签 com.example.description: &quot;Accounting webapp&quot; com.example.department: &quot;Finance&quot; com.example.label-with-empty-value: &quot;&quot; command: 覆盖容器映像声明的默认命令 1234services: server: command: [&quot;python&quot;, &quot;app.py&quot;] image: example/webapp entrypoint: 声明服务容器的默认入口点，这覆盖了服务Dockerfile中的ENTRYPOINT指令。 123456789101112services: server: image: example/webapp entrypoint: - php - -d - zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20100525/xdebug.so - -d - memory_limit=-1 - vendor/bin/phpunit # 如果值为null，则使用图像的默认入口点。 entrypoint: null # 如果值是 []（空列表）或 &#x27;&#x27;（空字符串），图像声明的默认入口点被忽略，或者换句话说，被覆盖为空。 entrypoint: [] depends_on: 服务启动依赖，就是依赖的服务启动后才能启动本服务 12345678910services: web: build: . depends_on: - db # 短语法 - redis redis: image: redis db: image: postgres 12345678910111213141516171819services: web: build: . depends_on: db: # 长语法 condition: service_healthy # 满足的条件 restart: true # 当设置为true，Compose在更新依赖服务后重新启动此服务。 redis: condition: service_started redis: image: redis db: image: postgres## condition：设置依赖性被视为满足的条件# service_started：相当于之前描述的简短语法# service_healthy：指定在启动依赖服务之前，依赖预期为“健康”（如healthcheck所示）。# service_completed_successfully：指定在启动依赖服务之前，依赖项预计将运行到成功完成。 environment: 定义环境变量 12345678910111213services: server: image: example/webapp environment: - FOO=bar - BAZ=qux# 或者services: server: image: example/webapp environment: FOO: bar BAZ: qux env_file: 用于指定一个或多个包含要传递到容器的环境变量的文件。 123456services: server: image: example/webapp env_file: - ./a.env # 列表中的文件是从上到下处理的。对于两个环境文件中指定的相同变量，列表中最后一个文件的值是有效的。 - ./b.env 12345678services: server: image: example/webapp env_file: - path: ./default.env required: true # default - path: ./override.env required: false # 当required设置为false且.env文件缺失时，Compose会忽略 restart: 定义平台在容器终止时适用的策略 12345678services: server: image: example/webapp restart: &quot;no&quot; # 默认重启策略。在任何情况下，它都不会重新启动容器。 # restart: always # 策略总是重新启动容器，直到它被移除。 # restart: on-failure # 如果退出代码表明错误，策略将重新启动容器。 # restart: on-failure:3 # 如果退出代码表明错误，策略将重新启动容器。但仅尝试重启3次。 # restart: unless-stopped # 无论退出代码如何，策略都会重新启动容器，但当服务停止或删除时，策略会停止重新启动。 healthcheck: 健康检查。 12345678910services: server: image: example/webapp healthcheck: # 健康检查 test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;] # 监控检查时执行的命令 interval: 1m30s # 健康检查的间隔，默认值为 30s timeout: 10s # 健康检查的超时时间，默认值为 30s retries: 3 # 健康检查的尝试次数，默认值为 3 start_period: 40s # 启动宽限期：在此期间，失败不会计入重试次数（仅用于判断服务是否启动完毕） start_interval: 5s # 启动宽限期内检查的频率，本示例为在前 40 秒内每 5 秒检查一次 test定义Compose运行的命令来检查容器运行状况。它可以是字符串，也可以是列表。如果是列表，第一个项目必须是NONE、CMD或CMD-SHELL。如果它是一个字符串，它等同于指定CMD-SHELL后跟该字符串。 1234test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;]# 使用CMD-SHELL运行配置为字符串的命令，使用容器的默认外壳（Linux的/bin/sh）。以下两种形式是等价的test: [&quot;CMD-SHELL&quot;, &quot;curl -f http://localhost || exit 1&quot;]test: curl -f https://localhost || exit 1 test 中的 CMD 和 CMD-SHELL 是两种不同的执行方式，它们的主要区别在于： 项目 CMD CMD-SHELL ✅ 用途 直接执行命令（不通过 shell） 通过 shell（如 /bin/sh -c）执行命令 🧾 写法格式 [&quot;CMD&quot;, &quot;executable&quot;, &quot;arg1&quot;, &quot;arg2&quot;] [&quot;CMD-SHELL&quot;, &quot;command string&quot;] 🔧 是否使用 shell 否 是 🧠 是否支持 shell 语法 ❌ 否（不能使用 &amp;&amp;、 ||、\\$VAR 等） ✅ 是（支持管道、重定向、变量、命令组合） 🛡️ 安全性/可移植性 ✅ 更安全，执行更明确 ⚠ 依赖容器中存在 shell（如 /bin/sh） ⚙️ 执行效率 ✅ 稍快，因无需 shell 解析 ⚠ 稍慢，需通过 shell 启动 📦 推荐使用场景 - 简单健康检查命令- 安全环境- 精简镜像 - 需要使用逻辑控制（||, &amp;&amp;）- 复杂检查逻辑 📌 示例 [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;] [&quot;CMD-SHELL&quot;, &quot;curl -f http\\://localhost || exit 1&quot;] volumes: 挂载数据卷。 123456789101112131415161718192021222324252627282930# 长语法格式services: backend: image: example/backend volumes: - type: volume # 安装类型。可以是是volume、bind、tmpfs、image、npipe、cluster source: db-data # 挂载的源、绑定挂载的主机上的路径、映像挂载的Docker映像引用或顶层volumes键中定义的卷名称。不适用于tmpfs支架。 target: /data # 容器中装载卷的路径。 volume: # 配置其他卷选项 nocopy: true # 在创建卷时禁用从容器复制数据的标志，默认值为false。 subpath: sub # 挂载卷的子目录。即 db-data/sub - type: bind # bind 表示挂载主机上的路径 source: /var/run/postgres/postgres.sock target: /var/run/postgres/postgres.sockvolumes: # 声明数据卷 db-data:####################################################################################### 短语法格式services: backend: image: example/backend volumes: - db-data:/data # 这种语法不支持 subpath 和 nocopy - /var/run/postgres/postgres.sock:/var/run/postgres/postgres.sockvolumes: db-data: networks: 配置网络。 123456789services: some-service: networks: # 配置网络 - some-network # 关联网络 - other-networknetworks: # 声明网络 some-network: other-network: cpu 和 内存限制 123456789services: backend: image: myapp:latest mem_limit: 1g # 限制最多使用1GB内存 mem_reservation: 512m # 建议预留512MB内存 cpus: 2.0 # 限制最多使用2个CPU核 cpu_shares: 1024 # 默认值，表示标准优先级 cpu_quota: 100000 # 每 100ms 容器最多可运行 100ms（=1核）, 与 cpus 不能同时设置 cpu_period: 100000 # 调度周期为100ms, 与 cpus 不能同时设置 字段名 类型 说明 cpus float 限制容器最多使用多少 CPU（逻辑核数）；例如 0.5 = 一半 CPU mem_limit string 容器最大内存限制，支持单位：b、k、m、g（如 256m, 1g） mem_reservation string 容器启动时预留的内存，超过这个值不被限制（仅提示调度器） cpu_shares int CPU 权重（默认 1024），用于多个容器抢占 CPU 的优先级（仅在竞争时生效） cpu_quota int 每个周期内允许使用的 CPU 时间（单位：微秒）, 与 cpus 不能同时设置 cpu_period int CPU 调度周期（单位：微秒，默认 100000）, 与 cpus 不能同时设置 查看容器的 cpu 和 内存配置情况 123456789101112131415161718# 获取容器的 cpu_quota 和 cpu_perioddocker inspect --format=&#x27;&#123;&#123;json .HostConfig.CpuQuota&#125;&#125; &#123;&#123;json .HostConfig.CpuPeriod&#125;&#125;&#x27; &lt;container_id&gt;# 获取容器的 memory_limitdocker inspect --format=&#x27;&#123;&#123;json .HostConfig.Memory&#125;&#125;&#x27; &lt;container_id&gt;# 获取容器的 cpu_sharesdocker inspect --format=&#x27;&#123;&#123;json .HostConfig.CpuShares&#125;&#125;&#x27; &lt;container_id&gt;# 获取容器的 cpusdocker inspect --format=&#x27;&#123;&#123;json .HostConfig.NanoCpus&#125;&#125;&#x27; &lt;container_id&gt;# 组合为一个json输出docker inspect &lt;container_id&gt; | jq &#x27;.[0].HostConfig | &#123; cpus: (.NanoCpus / 1000000000), cpu_shares: .CpuShares, mem_limit: (.Memory / 1024 / 1024 | tostring + &quot; MB&quot;), mem_reservation: (.MemoryReservation / 1024 / 1024 | tostring + &quot; MB&quot;), cpu_quota: .CpuQuota, cpu_period: .CpuPeriod&#125;&#x27; docker run 转 docker compose 在线工具：composerize 本地安装：composerize 1234567891011121314151617# 安装命令，npm安装：https://nodejs.org/zh-cn/downloadnpm install composerize -g# 运行命令composerize docker run -p 80:80 -v /var/run/docker.sock:/tmp/docker.sock:ro --restart always --log-opt max-size=1g nginx## 转换结果name: &lt;your project name&gt;services: nginx: ports: - 80:80 volumes: - /var/run/docker.sock:/tmp/docker.sock:ro restart: always logging: options: max-size: 1g image: nginx docker compose 编排管理工具 Dockge Dockge 是一个开源轻量级「Docker Compose 管理器」，它提供了一个漂亮、响应迅速的 Web 界面，专门面向使用 docker compose 的用户。 功能模块 主要描述 Compose 堆栈全生命周期管理 可以创建、编辑、启动、停止、重启、删除基于 compose.yaml 文件的 Docker 堆栈 交互式 Compose 编辑器 + Web 终端 实时编辑 YAML 并查看输出，还可以直接在浏览器中操作终端 将 docker run … 命令转换为 Compose 文件 快速生成 compose.yaml，便于版本控制和结构管理 实时操作反馈 镜像拉取、堆栈启动/停止等操作均可实时查看进度 多主机代理支持（≥1.4.0） 能在单一 UI 中管理多个 Docker 主机 高兼容性 &amp; 安全设计 Compose 文件保存在本地，不会被系统托管，便于使用 CLI 或其他工具管理 安装 1234567891011# Create directories that store your stacks and store Dockge&#x27;s stackmkdir -p /opt/stacks /opt/dockgecd /opt/dockge# Download your compose.yamlcurl &quot;https://dockge.kuma.pet/compose.yaml?port=5001&amp;stacksPath=%2Fopt%2Fstacks&quot; --output compose.yaml# Start the Serverdocker compose up -d# 浏览器访问 http://localhost:5001","summary":"摘要 本文介绍 Docker 命令 中 docker compose 的使用方法 Docker官方文档 docker compose Compose file reference","date_published":"2025-06-04T13:30:05.000Z","tags":["技术","docker","docker"]},{"id":"https://blog.hanqunfeng.com/2025/05/28/docker-command-network/","url":"https://blog.hanqunfeng.com/2025/05/28/docker-command-network/","title":"Docker 命令 之 网络(Network)","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 Docker 命令 中 网络管理 相关命令</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com\">Docker官方文档</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"什么是Network-网络\">什么是Network(网络)?</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 Docker 中，<strong>网络（Network）</strong> 是容器之间通信、容器与外部通信的重要机制。Docker 提供了一套灵活的网络模型，使得你可以自由配置容器的网络环境以适配不同场景。</p>\n</li>\n<li class=\"lvl-2\">\n<p>安装docker时，会自动在宿主机上安装一个 <code>docker0</code> 网络设备，它是一个网桥设备，用于 Docker 各容器及宿主机的网络通信。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看宿主机网卡信息，可以找到docker0</span></span><br><span class=\"line\">$ ip addr</span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class=\"line\">    inet 127.0.0.1/8 scope host lo</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">    inet6 ::1/128 scope host</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 9001 qdisc mq state UP group default qlen 1000</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/ether 0a:6b:88:11:66:39 brd ff:ff:ff:ff:ff:ff</span><br><span class=\"line\">    inet 10.250.0.205/24 brd 10.250.0.255 scope global dynamic noprefixroute eth0</span><br><span class=\"line\">       valid_lft 3076sec preferred_lft 3076sec</span><br><span class=\"line\">    inet6 fe80::86b:88ff:fe11:6639/64 scope <span class=\"built_in\">link</span></span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/ether 02:42:d6:d5:09:b1 brd ff:ff:ff:ff:ff:ff</span><br><span class=\"line\">    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">    inet6 fe80::42:d6ff:fed5:9b1/64 scope <span class=\"built_in\">link</span></span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\"><span class=\"comment\">## 说明</span></span><br><span class=\"line\">eth0 宿主机的ip地址是 10.250.0.205</span><br><span class=\"line\">docker0 本身的ip地址是 172.17.0.1</span><br><span class=\"line\">docker0 的子网掩码是 255.255.0.0</span><br><span class=\"line\">docker0 的广播地址是 172.17.255.255</span><br><span class=\"line\">docker0 可以为容器分配的ip地址范围是 172.17.0.2-172.17.255.254，总计65534个ip地址</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>既然docker0是一个网桥设备，我们可以通过如下命令来查看网桥的详细信息：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ brctl show</span><br><span class=\"line\"><span class=\"comment\">## 输出结果</span></span><br><span class=\"line\">brctl show</span><br><span class=\"line\">bridge name\t    bridge <span class=\"built_in\">id</span>\t\t      STP enabled\t    interfaces</span><br><span class=\"line\">docker0\t\t    8000.0242d6d509b1\t        no</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动docker服务后，docker就为我们自动创建了三个网络，可以通过如下命令查看</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker network <span class=\"built_in\">ls</span></span><br><span class=\"line\">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class=\"line\">4182e112bf34   bridge    bridge    <span class=\"built_in\">local</span></span><br><span class=\"line\">958daf8a8a0d   host      host      <span class=\"built_in\">local</span></span><br><span class=\"line\">4674a17c6617   none      null      <span class=\"built_in\">local</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里<code>NAME</code>为<code>bridge</code>的网络就是与<code>docker0</code>设备相对应的网络，其也是docker<code>默认</code>的网络，如果创建的容器没有指定网络，那么容器就会加入这个 <code>bridge</code> 网络。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#  启动一个容器，没有指定网络</span></span><br><span class=\"line\">docker run -itd --name ap1 alpine</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 此时在宿主机上查看网卡信息，会看到多出一个设备</span></span><br><span class=\"line\">ip addr</span><br><span class=\"line\"><span class=\"comment\">## 输出结果</span></span><br><span class=\"line\">10: vethc0e0cc3@if9: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/ether c6:0d:02:c8:<span class=\"built_in\">df</span>:a4 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class=\"line\">    inet6 fe80::c40d:2ff:fec8:dfa4/64 scope <span class=\"built_in\">link</span></span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看容器的网卡信息</span></span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> -it ap1 ip addr</span><br><span class=\"line\"><span class=\"comment\">## 输出结果</span></span><br><span class=\"line\">9: eth0@if10: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UP</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff</span><br><span class=\"line\">    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 此时聪明的你已经发现了：宿主机的网卡与容器的网卡是成对出现的，并且基于序号进行关联</span></span><br><span class=\"line\">宿主机: 10 : veth c0e0cc3 @ <span class=\"keyword\">if</span> 9  <span class=\"comment\"># 序号 10 与 容器后缀的 10 匹配，veth 是虚拟网卡，c0e0cc3 是随机字符串，if 是 interface</span></span><br><span class=\"line\">容器:    9 : eth0         @ <span class=\"keyword\">if</span> 10 <span class=\"comment\"># 序号 9 与宿主机的后缀 9 匹配，eth0 是容器的网卡，if 是 interface</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 此时查看宿主机的网桥信息</span></span><br><span class=\"line\">brctl show</span><br><span class=\"line\"><span class=\"comment\">## 输出结果，可以在 interfaces 中看到 vethc0e0cc3，说明 vethc0e0cc3 已经加入到网桥中</span></span><br><span class=\"line\">bridge name\t  bridge <span class=\"built_in\">id</span>\t\t      STP enabled\t  interfaces</span><br><span class=\"line\">docker0\t\t   8000.0242d6d509b1\t      no\t\t  vethc0e0cc3</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看网络中的容器信息，这里 jq 是 json 格式化，可以通过 dnf install jq -y 安装</span></span><br><span class=\"line\">docker network inspect bridge --format <span class=\"string\">&#x27;&#123;&#123;json .Containers&#125;&#125;&#x27;</span> | jq</span><br><span class=\"line\"><span class=\"comment\">## 输出结果</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;c2436a1d750cc3de3a6f8ab8a693af25b3371aa8f7f168d5561538dcd4a8ff2d&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;Name&quot;</span>: <span class=\"string\">&quot;ap1&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;EndpointID&quot;</span>: <span class=\"string\">&quot;75469fddbbdeb8b7a328c1a1c3cc7070bb1a3e102f5fb97cc332dcbc22829af5&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;MacAddress&quot;</span>: <span class=\"string\">&quot;02:42:ac:11:00:02&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;IPv4Address&quot;</span>: <span class=\"string\">&quot;172.17.0.2/16&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;IPv6Address&quot;</span>: <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取容器的 IP 地址</span></span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> ap1 hostname -i</span><br><span class=\"line\"><span class=\"comment\">## 输出结果</span></span><br><span class=\"line\">172.17.0.2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 相同网络设备下的容器可以通过 IP 地址通信</span></span><br><span class=\"line\"><span class=\"comment\"># 我们再创建一个容器，并查看能否正常通信</span></span><br><span class=\"line\">docker run -itd --name ap2 alpine</span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> -it ap2 ping 172.17.0.2</span><br><span class=\"line\"><span class=\"comment\">## 输出结果，说明可以通过IP地址通信</span></span><br><span class=\"line\">PING 172.17.0.2 (172.17.0.2): 56 data bytes</span><br><span class=\"line\">64 bytes from 172.17.0.2: <span class=\"built_in\">seq</span>=0 ttl=64 time=0.137 ms</span><br><span class=\"line\">64 bytes from 172.17.0.2: <span class=\"built_in\">seq</span>=1 ttl=64 time=0.084 ms</span><br><span class=\"line\">64 bytes from 172.17.0.2: <span class=\"built_in\">seq</span>=2 ttl=64 time=0.081 ms</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看网络中的容器</span></span><br><span class=\"line\">docker network inspect bridge --format <span class=\"string\">&#x27;&#123;&#123;json .Containers&#125;&#125;&#x27;</span> | jq</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;9d3ed5be1916b14ec9befe3649c08cc9de247c595de248600f8ef8d0fc16c5cb&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;Name&quot;</span>: <span class=\"string\">&quot;ap2&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;EndpointID&quot;</span>: <span class=\"string\">&quot;35615a7ec10842401ad8c40187c792555b5089551a8eca39ddff6734aeba549e&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;MacAddress&quot;</span>: <span class=\"string\">&quot;02:42:ac:11:00:03&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;IPv4Address&quot;</span>: <span class=\"string\">&quot;172.17.0.3/16&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;IPv6Address&quot;</span>: <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;c2436a1d750cc3de3a6f8ab8a693af25b3371aa8f7f168d5561538dcd4a8ff2d&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;Name&quot;</span>: <span class=\"string\">&quot;ap1&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;EndpointID&quot;</span>: <span class=\"string\">&quot;75469fddbbdeb8b7a328c1a1c3cc7070bb1a3e102f5fb97cc332dcbc22829af5&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;MacAddress&quot;</span>: <span class=\"string\">&quot;02:42:ac:11:00:02&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;IPv4Address&quot;</span>: <span class=\"string\">&quot;172.17.0.2/16&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;IPv6Address&quot;</span>: <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 测试是否可以通过容器名称访问</span></span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> -it ap2 ping ap1</span><br><span class=\"line\"><span class=\"comment\">## 输出，不可以通过容器名称访问</span></span><br><span class=\"line\">ping: bad address <span class=\"string\">&#x27;ap1&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">## 如果希望通过容器名称访问，我们可以通过 docker network create 创建一个新的网络</span></span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>如果没有安装 brctl，可以通过如下方式安装</strong></em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># centos7:</span></span><br><span class=\"line\">yum install bridge-utils -y</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># centos8: 不支持yum源安装，需要手动编译安装</span></span><br><span class=\"line\"><span class=\"comment\"># 下载源码安装，目前最新版本为1.7.1</span></span><br><span class=\"line\">wget https://mirrors.edge.kernel.org/pub/linux/utils/net/bridge-utils/bridge-utils-1.7.1.tar.gz</span><br><span class=\"line\">tar -zxvf bridge-utils-1.7.1.tar.gz</span><br><span class=\"line\"><span class=\"built_in\">cd</span> bridge-utils-1.7.1</span><br><span class=\"line\"><span class=\"comment\"># 需要先安装编译所需的工具和依赖</span></span><br><span class=\"line\">dnf install autoconf automake libtool make -y</span><br><span class=\"line\"><span class=\"comment\"># 因为源码目录中没有 configure 文件（但有 configure.ac），所以需要先运行如下命令生成 configure 文件</span></span><br><span class=\"line\">autoreconf -i</span><br><span class=\"line\"><span class=\"comment\"># 配置</span></span><br><span class=\"line\">./configure</span><br><span class=\"line\"><span class=\"comment\"># 编译 且 安装</span></span><br><span class=\"line\">make &amp;&amp; make install</span><br><span class=\"line\"><span class=\"comment\"># 添加到环境变量</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;export PATH=<span class=\"variable\">$PATH</span>:/usr/local/sbin&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bashrc</span><br><span class=\"line\">brctl --version</span><br><span class=\"line\"><span class=\"comment\">## 输出结果</span></span><br><span class=\"line\">bridge-utils, 1.7</span><br></pre></td></tr></table></figure>\n</div>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Docker 默认的 bridge 网络和 Linux 内核中的 docker0 网桥是一一对应的关系。bridge 是 Docker 对网络的命名，而 docker0 是内核中网桥的名字。<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/wjWiNA.png\" alt=\"\"></p>\n</li>\n<li class=\"lvl-2\">\n<p>docker0负责给连接其上的容器分配ip地址，并且是每个容器的默认网关。当容器需要访问外网时，会通过docker0转到宿主机的eth0上，所以只要宿主机可以访问外网，那么容器也可以访问外网。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看宿主机的路由表</span></span><br><span class=\"line\">$ route -n</span><br><span class=\"line\">Kernel IP routing table</span><br><span class=\"line\">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class=\"line\">0.0.0.0         10.250.0.1      0.0.0.0         UG    100    0        0 eth0</span><br><span class=\"line\">10.250.0.0      0.0.0.0         255.255.255.0   U     100    0        0 eth0</span><br><span class=\"line\">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看ap1容器的路由表</span></span><br><span class=\"line\">$ docker <span class=\"built_in\">exec</span> -it ap1 route -n</span><br><span class=\"line\">Kernel IP routing table</span><br><span class=\"line\">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class=\"line\">0.0.0.0         172.17.0.1      0.0.0.0         UG    0      0        0 eth0</span><br><span class=\"line\">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Docker Container 的 bridge 桥接模式可以参考下图<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/32fupw.png\" alt=\"\"></p>\n</li>\n</ul>\n<h2 id=\"docker-network-相关命令\"><code>docker network</code> 相关命令</h2>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能说明</th>\n<th>示例</th>\n<th>示例输出（简略）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>docker network ls</code></td>\n<td>列出所有 Docker 网络</td>\n<td><code>docker network ls</code></td>\n<td><code>bridge</code>, <code>host</code>, <code>none</code> 等网络名称</td>\n</tr>\n<tr>\n<td><code>docker network inspect &lt;网络名&gt;</code></td>\n<td>查看指定网络的详细信息（如 IP 范围、连接容器等）</td>\n<td><code>docker network inspect bridge</code></td>\n<td>显示 JSON，含子网、网关、容器等信息</td>\n</tr>\n<tr>\n<td><code>docker network create &lt;网络名&gt;</code></td>\n<td>创建自定义网络（默认桥接）</td>\n<td><code>docker network create my-net</code></td>\n<td><code>my-net</code> 网络 ID</td>\n</tr>\n<tr>\n<td><code>docker network rm &lt;网络名&gt;</code></td>\n<td>删除网络（不能有容器连接）</td>\n<td><code>docker network rm my-net</code></td>\n<td>成功删除无提示，失败会有错误信息</td>\n</tr>\n<tr>\n<td><code>docker network connect &lt;网络名&gt; &lt;容器名&gt;</code></td>\n<td>将一个容器连接到指定网络</td>\n<td><code>docker network connect my-net my-container</code></td>\n<td>无输出，容器连接成功</td>\n</tr>\n<tr>\n<td><code>docker network disconnect &lt;网络名&gt; &lt;容器名&gt;</code></td>\n<td>将容器从网络中断开连接</td>\n<td><code>docker network disconnect my-net my-container</code></td>\n<td>无输出，断开成功</td>\n</tr>\n<tr>\n<td><code>docker network prune</code></td>\n<td>删除所有未使用的网络（慎用）</td>\n<td><code>docker network prune</code></td>\n<td>会提示是否确认，清理未使用网络</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"docker-network-create-创建网络\"><code>docker network create</code> : 创建网络</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker network create [OPTIONS] NETWORK_NAME</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>常用参数说明表</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>--driver</code> 或 <code>-d</code></td>\n<td>指定网络驱动类型，如 <code>bridge</code>, <code>overlay</code>, <code>macvlan</code>, <code>host</code>, <code>none</code></td>\n<td><code>--driver bridge</code></td>\n</tr>\n<tr>\n<td><code>--subnet</code></td>\n<td>指定子网地址范围（CIDR）</td>\n<td><code>--subnet 192.168.100.0/24</code></td>\n</tr>\n<tr>\n<td><code>--gateway</code></td>\n<td>指定网关 IP 地址</td>\n<td><code>--gateway 192.168.100.1</code></td>\n</tr>\n<tr>\n<td><code>--ip-range</code></td>\n<td>指定可分配的 IP 范围</td>\n<td><code>--ip-range 192.168.100.0/25</code></td>\n</tr>\n<tr>\n<td><code>--aux-address</code></td>\n<td>保留某些 IP 地址不被分配</td>\n<td><code>--aux-address=&quot;reserved=192.168.100.254&quot;</code></td>\n</tr>\n<tr>\n<td><code>--internal</code></td>\n<td>创建一个内部网络（不能访问外部）</td>\n<td><code>--internal</code></td>\n</tr>\n<tr>\n<td><code>--attachable</code></td>\n<td>创建可供单独容器连接的网络（Swarm 中）</td>\n<td><code>--attachable</code></td>\n</tr>\n<tr>\n<td><code>--label</code></td>\n<td>添加标签</td>\n<td><code>--label env=dev</code></td>\n</tr>\n<tr>\n<td><code>--opt</code></td>\n<td>提供自定义驱动选项</td>\n<td><code>--opt encrypted=true</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>--driver</code> 或 <code>-d</code> : 常见的 Docker 网络驱动类型</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>含义</th>\n<th>是否支持端口映射</th>\n<th>特点与应用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>bridge</code>（默认）</td>\n<td>默认的桥接网络，容器通过虚拟网桥连接，共享宿主机的网络接口。</td>\n<td>✅ 是</td>\n<td>默认模式，适用于单主机部署、多个容器需要互通的场景。可映射端口对外访问。</td>\n</tr>\n<tr>\n<td><code>host</code></td>\n<td>容器与宿主机共用网络命名空间，容器直接使用宿主机的 IP 和端口。</td>\n<td>❌ 否</td>\n<td>无网络隔离，性能高，适用于高性能、低延迟场景（如游戏服务器）。</td>\n</tr>\n<tr>\n<td><code>none</code></td>\n<td>容器没有网络接口，完全隔离。</td>\n<td>❌ 否</td>\n<td>用于安全性或测试网络不可达场景。</td>\n</tr>\n<tr>\n<td><code>macvlan</code></td>\n<td>为容器分配独立 MAC 和 IP，容器像物理主机一样出现在局域网中。</td>\n<td>✅ 是（少见）</td>\n<td>适用于容器必须直接暴露在物理网络中的场景（如 DHCP 服务、ARP 广播）。</td>\n</tr>\n<tr>\n<td><code>ipvlan</code>（高级）</td>\n<td>类似 macvlan，但不使用虚拟 MAC 地址。</td>\n<td>✅ 是（少见）</td>\n<td>高级网络方案，适用于对网络拓扑精细控制的场景。</td>\n</tr>\n<tr>\n<td><code>overlay</code></td>\n<td>用于多主机之间容器通信，需要 Docker Swarm 支持。</td>\n<td>✅ 是（Swarm）</td>\n<td>跨主机部署服务的必要手段，适合容器编排平台（如 Swarm、Kubernetes）。</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>前面我们说过，Docker会自动创建三个网络，即：bridge、host、none。对于单台宿主机的场景，绝大多数情况下我们都只会使用bridge网络。</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建一个名为my-network的网络</span></span><br><span class=\"line\">$ docker network create my-network</span><br><span class=\"line\"><span class=\"comment\"># 等同于，因为默认的网络驱动为bridge</span></span><br><span class=\"line\">$ docker network create --driver bridge my-network</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看网络，可以看到新建的网络的驱动为bridge</span></span><br><span class=\"line\">$ docker network <span class=\"built_in\">ls</span> -f name=my-network</span><br><span class=\"line\">NETWORK ID     NAME         DRIVER    SCOPE</span><br><span class=\"line\">c2dbe1686790   my-network   bridge    <span class=\"built_in\">local</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看宿主机的网桥信息</span></span><br><span class=\"line\">$ brctl show</span><br><span class=\"line\"><span class=\"comment\">## 输出，可以看到此时有一个网桥设备 br-c2dbe1686790，br: bridge，c2dbe1686790：network id</span></span><br><span class=\"line\">bridge name\t      bridge <span class=\"built_in\">id</span>\t\t          STP enabled\t    interfaces</span><br><span class=\"line\">br-c2dbe1686790\t      8000.02425be81fae\t          no</span><br><span class=\"line\">docker0\t\t      8000.0242d6d509b1\t          no\t\t    vethc0e0cc3</span><br><span class=\"line\">\t\t\t\t\t\t\t            vethf4b7577</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看宿主机的网卡</span></span><br><span class=\"line\">$ ip addr</span><br><span class=\"line\"><span class=\"comment\">## 输出，br-c2dbe1686790 网卡名称，其IP网段为 172.18.0.1/16</span></span><br><span class=\"line\">13: br-c2dbe1686790: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/ether 02:42:5b:e8:1f:ae brd ff:ff:ff:ff:ff:ff</span><br><span class=\"line\">    inet 172.18.0.1/16 brd 172.18.255.255 scope global br-c2dbe1686790</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动两个容器并添加到my-network网络中</span></span><br><span class=\"line\">$ docker run -itd --network my-network --name a1 alpine</span><br><span class=\"line\">$ docker run -itd --network my-network --name a2 alpine</span><br><span class=\"line\"></span><br><span class=\"line\">$ ip addr</span><br><span class=\"line\"><span class=\"comment\">## 输出,可以看到两个容器都添加到了my-network网络中</span></span><br><span class=\"line\">bridge name\t      bridge <span class=\"built_in\">id</span>\t\t        STP enabled\t    interfaces</span><br><span class=\"line\">br-c2dbe1686790\t\t8000.02425be81fae\t    no\t\t    veth094946c</span><br><span class=\"line\">\t\t\t\t\t\t\t            vetha2ba68a</span><br><span class=\"line\">docker0\t\t        8000.0242d6d509b1\t    no\t\t    vethc0e0cc3</span><br><span class=\"line\">\t\t\t\t\t\t\t            vethf4b7577</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 测试连通性，可以看到 a1可以ping通 a2，反过来 a2也可以ping通 a1</span></span><br><span class=\"line\">$ docker <span class=\"built_in\">exec</span> -it a1 ping a2</span><br><span class=\"line\">PING a2 (172.18.0.4): 56 data bytes</span><br><span class=\"line\">64 bytes from 172.18.0.4: <span class=\"built_in\">seq</span>=0 ttl=64 time=2.127 ms</span><br><span class=\"line\">64 bytes from 172.18.0.4: <span class=\"built_in\">seq</span>=1 ttl=64 time=0.119 ms</span><br><span class=\"line\"></span><br><span class=\"line\">$ docker ps</span><br><span class=\"line\">CONTAINER ID   IMAGE     COMMAND     CREATED         STATUS         PORTS     NAMES</span><br><span class=\"line\">e0fb0614591e   alpine    <span class=\"string\">&quot;/bin/sh&quot;</span>   4 minutes ago   Up 4 minutes             a2</span><br><span class=\"line\">fc6e9477d2b7   alpine    <span class=\"string\">&quot;/bin/sh&quot;</span>   4 minutes ago   Up 4 minutes             a1</span><br><span class=\"line\">9d3ed5be1916   alpine    <span class=\"string\">&quot;/bin/sh&quot;</span>   4 hours ago     Up 4 hours               ap2</span><br><span class=\"line\">c2436a1d750c   alpine    <span class=\"string\">&quot;/bin/sh&quot;</span>   4 hours ago     Up 4 hours               ap1</span><br><span class=\"line\"><span class=\"comment\"># 不同网络中的容器之间不能相互ping通</span></span><br><span class=\"line\"><span class=\"comment\">## 通过容器名称无法ping通</span></span><br><span class=\"line\">$ docker <span class=\"built_in\">exec</span> -it a1 ping ap1</span><br><span class=\"line\">ping: bad address <span class=\"string\">&#x27;ap1&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">## 通过ap1容器IP也无法ping通，这就实现了不同网络中的网络隔离</span></span><br><span class=\"line\">$ docker <span class=\"built_in\">exec</span> -it a1 ping 172.17.0.2</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果创建网络时没有指定子网，则从<code>docker0</code>的<code>172.17.0.0/16</code>往后排，比如我们上面创建的<code>my-network</code>，其子网就是<code>172.18.0.0/16</code>，如下命令创建一个bridge网络，并指定子网、网关等信息</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker network create \\</span><br><span class=\"line\">  --driver bridge \\</span><br><span class=\"line\">  --subnet 192.168.50.0/24 \\</span><br><span class=\"line\">  --gateway 192.168.50.1 \\</span><br><span class=\"line\">  my-custom-net</span><br></pre></td></tr></table></figure>\n<h4 id=\"bridge-总结\"><code>bridge</code> 总结</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>默认创建的 <code>docker0</code> 网络，是一个桥接网络，在 docker network 中的名称为 <code>bridge</code>，该网络下的容器可以通过IP地址相互访问，但不能通过容器名称访问</p>\n</li>\n<li class=\"lvl-2\">\n<p>通过<code>docker network create &lt;网络名称&gt;</code>创建的网络也是一个桥接网络，在这个网络下，容器可以通过IP地址相互访问，也能通过容器名称访问。</p>\n</li>\n</ul>\n<h3 id=\"docker-network-ls-列出所有网络\"><code>docker network ls</code> : 列出所有网络</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出所有网络</span></span><br><span class=\"line\">$ docker network <span class=\"built_in\">ls</span></span><br><span class=\"line\"><span class=\"comment\"># 输出指定的信息</span></span><br><span class=\"line\">$ docker network <span class=\"built_in\">ls</span> --format <span class=\"string\">&quot;table &#123;&#123;.ID&#125;&#125;\\t&#123;&#123;.Name&#125;&#125;\\t&#123;&#123;.Scope&#125;&#125;&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 输出json格式</span></span><br><span class=\"line\">$ docker network <span class=\"built_in\">ls</span> --format <span class=\"string\">&quot;json&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 过滤</span></span><br><span class=\"line\">$ docker network <span class=\"built_in\">ls</span> -f <span class=\"string\">&quot;driver=bridge&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 不截断输出</span></span><br><span class=\"line\">$ docker network <span class=\"built_in\">ls</span> --no-trunc</span><br><span class=\"line\"><span class=\"comment\"># 只显示network id</span></span><br><span class=\"line\">$ docker network <span class=\"built_in\">ls</span> -q</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-network-inspect-查看网络详情\"><code>docker network inspect</code> : 查看网络详情</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看名称为bridge网络详情</span></span><br><span class=\"line\">$ docker network inspect bridge</span><br><span class=\"line\"><span class=\"comment\"># 查看当前网络下有哪些容器</span></span><br><span class=\"line\">$ docker network inspect bridge --format <span class=\"string\">&quot;&#123;&#123;.Containers&#125;&#125;&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 输出json格式</span></span><br><span class=\"line\">$ docker network inspect bridge --format <span class=\"string\">&quot;json&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-network-prune-清理没用的网络\"><code>docker network prune</code> : 清理没用的网络</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除所有未使用的网络</span></span><br><span class=\"line\">$ docker network prune</span><br><span class=\"line\"><span class=\"comment\"># 删除所有未使用的网络，无需确认</span></span><br><span class=\"line\">$ docker network prune -f</span><br><span class=\"line\"><span class=\"comment\"># 清理24小时内未使用的网络</span></span><br><span class=\"line\">$ docker network prune --filter <span class=\"string\">&quot;until=24h&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-network-rm-删除网络\"><code>docker network rm</code> : 删除网络</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除指定的网络</span></span><br><span class=\"line\">$ docker network <span class=\"built_in\">rm</span> &lt;network-name&gt;</span><br><span class=\"line\"><span class=\"comment\"># 删除所有网络</span></span><br><span class=\"line\">$ docker network <span class=\"built_in\">rm</span> $(docker network <span class=\"built_in\">ls</span> -q)</span><br><span class=\"line\"><span class=\"comment\"># 删除所有bridge网络，这里要注意，docker默认创建的3个网络是删除不掉的</span></span><br><span class=\"line\">$ docker network <span class=\"built_in\">rm</span> $(docker network <span class=\"built_in\">ls</span> -q -f driver=bridge)</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-network-connect-将容器连接到网络\"><code>docker network connect</code> : 将容器连接到网络</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将容器连接到网络，如果容器启动时忘记连接网络，这里可以手动添加</span></span><br><span class=\"line\">$ docker network connect &lt;network-name&gt; &lt;container-name&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-network-disconnect-将容器从网络断开\"><code>docker network disconnect</code> : 将容器从网络断开</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker network disconnect &lt;network-name&gt; &lt;container-name&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"本文总结\">本文总结</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>容器与网络是多对多的关系，即一个网络可以有多个容器，一个容器也可以连接到多个网络。</p>\n</li>\n<li class=\"lvl-2\">\n<p>docker0 是 docker 默认创建的网络，不指定网络的情况下所有容器都连接到 docker0 网络。</p>\n</li>\n<li class=\"lvl-2\">\n<p>docker0 是 bridge 网络，该网络中的容器之间可以通过 IP 互相访问，但不能通过容器名称访问。</p>\n</li>\n<li class=\"lvl-2\">\n<p>自建的 bridge 网络中的容器可以通过容器名称（或容器ID，但不常用）访问。</p>\n</li>\n<li class=\"lvl-2\">\n<p>不同的 bridge 网络中的容器不能互相访问。</p>\n</li>\n</ul>\n<h2 id=\"link-vs-network\"><code>--link</code> vs <code>--network</code></h2>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th><code>--link</code></th>\n<th><code>--network</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>功能</td>\n<td>将一个容器链接到另一个容器，并设置环境变量和主机名映射</td>\n<td>将容器加入到一个自定义网络中，实现灵活、隔离的网络通信</td>\n</tr>\n<tr>\n<td>是否推荐</td>\n<td>❌ 不推荐（已废弃）</td>\n<td>✅ 推荐使用</td>\n</tr>\n<tr>\n<td>网络隔离</td>\n<td>基于默认 <code>bridge</code> 网络，隔离性差</td>\n<td>可以创建自定义网络（bridge、overlay 等），隔离性强</td>\n</tr>\n<tr>\n<td>可扩展性</td>\n<td>只适用于已运行的容器，连接固定</td>\n<td>支持多个容器，灵活组合和动态扩展</td>\n</tr>\n<tr>\n<td>DNS 支持</td>\n<td>仅设置环境变量，不支持自动 DNS</td>\n<td>自定义网络中支持容器名称作为 DNS 名称</td>\n</tr>\n<tr>\n<td>生命周期</td>\n<td>一方容器关闭，另一方仍保存过时链接</td>\n<td>网络存在即可，容器生命周期不互相影响</td>\n</tr>\n<tr>\n<td>安全性</td>\n<td>所有容器共享 bridge，容易相互访问</td>\n<td>自定义网络间默认隔离，安全性更好</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 Docker 命令 中 网络管理 相关命令 Docker官方文档 什么是Network(网络)? 在 Docker 中，网络（Network） 是容器之间通信、容器与外部通信的重要机制。Docker 提供了一套灵活的网络模型，使得你可以自由配置容器的网络环境以适配不同场景。 安装docker时，会自动在宿主机上安装一个 docker0 网络设备，它是一个网桥设备，用于 Docker 各容器及宿主机的网络通信。 123456789101112131415161718192021222324252627# 查看宿主机网卡信息，可以找到docker0$ ip addr# 输出1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 9001 qdisc mq state UP group default qlen 1000 link/ether 0a:6b:88:11:66:39 brd ff:ff:ff:ff:ff:ff inet 10.250.0.205/24 brd 10.250.0.255 scope global dynamic noprefixroute eth0 valid_lft 3076sec preferred_lft 3076sec inet6 fe80::86b:88ff:fe11:6639/64 scope link valid_lft forever preferred_lft forever3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default link/ether 02:42:d6:d5:09:b1 brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever inet6 fe80::42:d6ff:fed5:9b1/64 scope link valid_lft forever preferred_lft forever## 说明eth0 宿主机的ip地址是 10.250.0.205docker0 本身的ip地址是 172.17.0.1docker0 的子网掩码是 255.255.0.0docker0 的广播地址是 172.17.255.255docker0 可以为容器分配的ip地址范围是 172.17.0.2-172.17.255.254，总计65534个ip地址 既然docker0是一个网桥设备，我们可以通过如下命令来查看网桥的详细信息： 12345$ brctl show## 输出结果brctl showbridge name bridge id STP enabled interfacesdocker0 8000.0242d6d509b1 no 启动docker服务后，docker就为我们自动创建了三个网络，可以通过如下命令查看 12345$ docker network lsNETWORK ID NAME DRIVER SCOPE4182e112bf34 bridge bridge local958daf8a8a0d host host local4674a17c6617 none null local 这里NAME为bridge的网络就是与docker0设备相对应的网络，其也是docker默认的网络，如果创建的容器没有指定网络，那么容器就会加入这个 bridge 网络。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# 启动一个容器，没有指定网络docker run -itd --name ap1 alpine# 此时在宿主机上查看网卡信息，会看到多出一个设备ip addr## 输出结果10: vethc0e0cc3@if9: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default link/ether c6:0d:02:c8:df:a4 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet6 fe80::c40d:2ff:fec8:dfa4/64 scope link valid_lft forever preferred_lft forever# 查看容器的网卡信息docker exec -it ap1 ip addr## 输出结果9: eth0@if10: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UP link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever## 此时聪明的你已经发现了：宿主机的网卡与容器的网卡是成对出现的，并且基于序号进行关联宿主机: 10 : veth c0e0cc3 @ if 9 # 序号 10 与 容器后缀的 10 匹配，veth 是虚拟网卡，c0e0cc3 是随机字符串，if 是 interface容器: 9 : eth0 @ if 10 # 序号 9 与宿主机的后缀 9 匹配，eth0 是容器的网卡，if 是 interface# 此时查看宿主机的网桥信息brctl show## 输出结果，可以在 interfaces 中看到 vethc0e0cc3，说明 vethc0e0cc3 已经加入到网桥中bridge name bridge id STP enabled interfacesdocker0 8000.0242d6d509b1 no vethc0e0cc3# 查看网络中的容器信息，这里 jq 是 json 格式化，可以通过 dnf install jq -y 安装docker network inspect bridge --format &#x27;&#123;&#123;json .Containers&#125;&#125;&#x27; | jq## 输出结果&#123; &quot;c2436a1d750cc3de3a6f8ab8a693af25b3371aa8f7f168d5561538dcd4a8ff2d&quot;: &#123; &quot;Name&quot;: &quot;ap1&quot;, &quot;EndpointID&quot;: &quot;75469fddbbdeb8b7a328c1a1c3cc7070bb1a3e102f5fb97cc332dcbc22829af5&quot;, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;, &quot;IPv4Address&quot;: &quot;172.17.0.2/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125;&#125;# 获取容器的 IP 地址docker exec ap1 hostname -i## 输出结果172.17.0.2# 相同网络设备下的容器可以通过 IP 地址通信# 我们再创建一个容器，并查看能否正常通信docker run -itd --name ap2 alpinedocker exec -it ap2 ping 172.17.0.2## 输出结果，说明可以通过IP地址通信PING 172.17.0.2 (172.17.0.2): 56 data bytes64 bytes from 172.17.0.2: seq=0 ttl=64 time=0.137 ms64 bytes from 172.17.0.2: seq=1 ttl=64 time=0.084 ms64 bytes from 172.17.0.2: seq=2 ttl=64 time=0.081 ms# 查看网络中的容器docker network inspect bridge --format &#x27;&#123;&#123;json .Containers&#125;&#125;&#x27; | jq&#123; &quot;9d3ed5be1916b14ec9befe3649c08cc9de247c595de248600f8ef8d0fc16c5cb&quot;: &#123; &quot;Name&quot;: &quot;ap2&quot;, &quot;EndpointID&quot;: &quot;35615a7ec10842401ad8c40187c792555b5089551a8eca39ddff6734aeba549e&quot;, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:03&quot;, &quot;IPv4Address&quot;: &quot;172.17.0.3/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125;, &quot;c2436a1d750cc3de3a6f8ab8a693af25b3371aa8f7f168d5561538dcd4a8ff2d&quot;: &#123; &quot;Name&quot;: &quot;ap1&quot;, &quot;EndpointID&quot;: &quot;75469fddbbdeb8b7a328c1a1c3cc7070bb1a3e102f5fb97cc332dcbc22829af5&quot;, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;, &quot;IPv4Address&quot;: &quot;172.17.0.2/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125;&#125;# 测试是否可以通过容器名称访问docker exec -it ap2 ping ap1## 输出，不可以通过容器名称访问ping: bad address &#x27;ap1&#x27;## 如果希望通过容器名称访问，我们可以通过 docker network create 创建一个新的网络 如果没有安装 brctl，可以通过如下方式安装 12345678910111213141516171819202122# centos7:yum install bridge-utils -y# centos8: 不支持yum源安装，需要手动编译安装# 下载源码安装，目前最新版本为1.7.1wget https://mirrors.edge.kernel.org/pub/linux/utils/net/bridge-utils/bridge-utils-1.7.1.tar.gztar -zxvf bridge-utils-1.7.1.tar.gzcd bridge-utils-1.7.1# 需要先安装编译所需的工具和依赖dnf install autoconf automake libtool make -y# 因为源码目录中没有 configure 文件（但有 configure.ac），所以需要先运行如下命令生成 configure 文件autoreconf -i# 配置./configure# 编译 且 安装make &amp;&amp; make install# 添加到环境变量echo &quot;export PATH=$PATH:/usr/local/sbin&quot; &gt;&gt; ~/.bashrcsource ~/.bashrcbrctl --version## 输出结果bridge-utils, 1.7 Docker 默认的 bridge 网络和 Linux 内核中的 docker0 网桥是一一对应的关系。bridge 是 Docker 对网络的命名，而 docker0 是内核中网桥的名字。 docker0负责给连接其上的容器分配ip地址，并且是每个容器的默认网关。当容器需要访问外网时，会通过docker0转到宿主机的eth0上，所以只要宿主机可以访问外网，那么容器也可以访问外网。 1234567891011121314# 查看宿主机的路由表$ route -nKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface0.0.0.0 10.250.0.1 0.0.0.0 UG 100 0 0 eth010.250.0.0 0.0.0.0 255.255.255.0 U 100 0 0 eth0172.17.0.0 0.0.0.0 255.255.0.0 U 0 0 0 docker0# 查看ap1容器的路由表$ docker exec -it ap1 route -nKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface0.0.0.0 172.17.0.1 0.0.0.0 UG 0 0 0 eth0172.17.0.0 0.0.0.0 255.255.0.0 U 0 0 0 eth0 Docker Container 的 bridge 桥接模式可以参考下图 docker network 相关命令 命令 功能说明 示例 示例输出（简略） docker network ls 列出所有 Docker 网络 docker network ls bridge, host, none 等网络名称 docker network inspect &lt;网络名&gt; 查看指定网络的详细信息（如 IP 范围、连接容器等） docker network inspect bridge 显示 JSON，含子网、网关、容器等信息 docker network create &lt;网络名&gt; 创建自定义网络（默认桥接） docker network create my-net my-net 网络 ID docker network rm &lt;网络名&gt; 删除网络（不能有容器连接） docker network rm my-net 成功删除无提示，失败会有错误信息 docker network connect &lt;网络名&gt; &lt;容器名&gt; 将一个容器连接到指定网络 docker network connect my-net my-container 无输出，容器连接成功 docker network disconnect &lt;网络名&gt; &lt;容器名&gt; 将容器从网络中断开连接 docker network disconnect my-net my-container 无输出，断开成功 docker network prune 删除所有未使用的网络（慎用） docker network prune 会提示是否确认，清理未使用网络 docker network create : 创建网络 语法 1docker network create [OPTIONS] NETWORK_NAME 常用参数说明表 参数 说明 示例 --driver 或 -d 指定网络驱动类型，如 bridge, overlay, macvlan, host, none --driver bridge --subnet 指定子网地址范围（CIDR） --subnet 192.168.100.0/24 --gateway 指定网关 IP 地址 --gateway 192.168.100.1 --ip-range 指定可分配的 IP 范围 --ip-range 192.168.100.0/25 --aux-address 保留某些 IP 地址不被分配 --aux-address=&quot;reserved=192.168.100.254&quot; --internal 创建一个内部网络（不能访问外部） --internal --attachable 创建可供单独容器连接的网络（Swarm 中） --attachable --label 添加标签 --label env=dev --opt 提供自定义驱动选项 --opt encrypted=true --driver 或 -d : 常见的 Docker 网络驱动类型 类型 含义 是否支持端口映射 特点与应用场景 bridge（默认） 默认的桥接网络，容器通过虚拟网桥连接，共享宿主机的网络接口。 ✅ 是 默认模式，适用于单主机部署、多个容器需要互通的场景。可映射端口对外访问。 host 容器与宿主机共用网络命名空间，容器直接使用宿主机的 IP 和端口。 ❌ 否 无网络隔离，性能高，适用于高性能、低延迟场景（如游戏服务器）。 none 容器没有网络接口，完全隔离。 ❌ 否 用于安全性或测试网络不可达场景。 macvlan 为容器分配独立 MAC 和 IP，容器像物理主机一样出现在局域网中。 ✅ 是（少见） 适用于容器必须直接暴露在物理网络中的场景（如 DHCP 服务、ARP 广播）。 ipvlan（高级） 类似 macvlan，但不使用虚拟 MAC 地址。 ✅ 是（少见） 高级网络方案，适用于对网络拓扑精细控制的场景。 overlay 用于多主机之间容器通信，需要 Docker Swarm 支持。 ✅ 是（Swarm） 跨主机部署服务的必要手段，适合容器编排平台（如 Swarm、Kubernetes）。 前面我们说过，Docker会自动创建三个网络，即：bridge、host、none。对于单台宿主机的场景，绝大多数情况下我们都只会使用bridge网络。 示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# 创建一个名为my-network的网络$ docker network create my-network# 等同于，因为默认的网络驱动为bridge$ docker network create --driver bridge my-network# 查看网络，可以看到新建的网络的驱动为bridge$ docker network ls -f name=my-networkNETWORK ID NAME DRIVER SCOPEc2dbe1686790 my-network bridge local# 查看宿主机的网桥信息$ brctl show## 输出，可以看到此时有一个网桥设备 br-c2dbe1686790，br: bridge，c2dbe1686790：network idbridge name bridge id STP enabled interfacesbr-c2dbe1686790 8000.02425be81fae nodocker0 8000.0242d6d509b1 no vethc0e0cc3 vethf4b7577# 查看宿主机的网卡$ ip addr## 输出，br-c2dbe1686790 网卡名称，其IP网段为 172.18.0.1/1613: br-c2dbe1686790: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default link/ether 02:42:5b:e8:1f:ae brd ff:ff:ff:ff:ff:ff inet 172.18.0.1/16 brd 172.18.255.255 scope global br-c2dbe1686790 valid_lft forever preferred_lft forever# 启动两个容器并添加到my-network网络中$ docker run -itd --network my-network --name a1 alpine$ docker run -itd --network my-network --name a2 alpine$ ip addr## 输出,可以看到两个容器都添加到了my-network网络中bridge name bridge id STP enabled interfacesbr-c2dbe1686790 8000.02425be81fae no veth094946c vetha2ba68adocker0 8000.0242d6d509b1 no vethc0e0cc3 vethf4b7577# 测试连通性，可以看到 a1可以ping通 a2，反过来 a2也可以ping通 a1$ docker exec -it a1 ping a2PING a2 (172.18.0.4): 56 data bytes64 bytes from 172.18.0.4: seq=0 ttl=64 time=2.127 ms64 bytes from 172.18.0.4: seq=1 ttl=64 time=0.119 ms$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESe0fb0614591e alpine &quot;/bin/sh&quot; 4 minutes ago Up 4 minutes a2fc6e9477d2b7 alpine &quot;/bin/sh&quot; 4 minutes ago Up 4 minutes a19d3ed5be1916 alpine &quot;/bin/sh&quot; 4 hours ago Up 4 hours ap2c2436a1d750c alpine &quot;/bin/sh&quot; 4 hours ago Up 4 hours ap1# 不同网络中的容器之间不能相互ping通## 通过容器名称无法ping通$ docker exec -it a1 ping ap1ping: bad address &#x27;ap1&#x27;## 通过ap1容器IP也无法ping通，这就实现了不同网络中的网络隔离$ docker exec -it a1 ping 172.17.0.2 如果创建网络时没有指定子网，则从docker0的172.17.0.0/16往后排，比如我们上面创建的my-network，其子网就是172.18.0.0/16，如下命令创建一个bridge网络，并指定子网、网关等信息 12345$ docker network create \\ --driver bridge \\ --subnet 192.168.50.0/24 \\ --gateway 192.168.50.1 \\ my-custom-net bridge 总结 默认创建的 docker0 网络，是一个桥接网络，在 docker network 中的名称为 bridge，该网络下的容器可以通过IP地址相互访问，但不能通过容器名称访问 通过docker network create &lt;网络名称&gt;创建的网络也是一个桥接网络，在这个网络下，容器可以通过IP地址相互访问，也能通过容器名称访问。 docker network ls : 列出所有网络 123456789101112# 列出所有网络$ docker network ls# 输出指定的信息$ docker network ls --format &quot;table &#123;&#123;.ID&#125;&#125;\\t&#123;&#123;.Name&#125;&#125;\\t&#123;&#123;.Scope&#125;&#125;&quot;# 输出json格式$ docker network ls --format &quot;json&quot;# 过滤$ docker network ls -f &quot;driver=bridge&quot;# 不截断输出$ docker network ls --no-trunc# 只显示network id$ docker network ls -q docker network inspect : 查看网络详情 123456# 查看名称为bridge网络详情$ docker network inspect bridge# 查看当前网络下有哪些容器$ docker network inspect bridge --format &quot;&#123;&#123;.Containers&#125;&#125;&quot;# 输出json格式$ docker network inspect bridge --format &quot;json&quot; docker network prune : 清理没用的网络 123456# 删除所有未使用的网络$ docker network prune# 删除所有未使用的网络，无需确认$ docker network prune -f# 清理24小时内未使用的网络$ docker network prune --filter &quot;until=24h&quot; docker network rm : 删除网络 123456# 删除指定的网络$ docker network rm &lt;network-name&gt;# 删除所有网络$ docker network rm $(docker network ls -q)# 删除所有bridge网络，这里要注意，docker默认创建的3个网络是删除不掉的$ docker network rm $(docker network ls -q -f driver=bridge) docker network connect : 将容器连接到网络 12# 将容器连接到网络，如果容器启动时忘记连接网络，这里可以手动添加$ docker network connect &lt;network-name&gt; &lt;container-name&gt; docker network disconnect : 将容器从网络断开 1$ docker network disconnect &lt;network-name&gt; &lt;container-name&gt; 本文总结 容器与网络是多对多的关系，即一个网络可以有多个容器，一个容器也可以连接到多个网络。 docker0 是 docker 默认创建的网络，不指定网络的情况下所有容器都连接到 docker0 网络。 docker0 是 bridge 网络，该网络中的容器之间可以通过 IP 互相访问，但不能通过容器名称访问。 自建的 bridge 网络中的容器可以通过容器名称（或容器ID，但不常用）访问。 不同的 bridge 网络中的容器不能互相访问。 --link vs --network 项目 --link --network 功能 将一个容器链接到另一个容器，并设置环境变量和主机名映射 将容器加入到一个自定义网络中，实现灵活、隔离的网络通信 是否推荐 ❌ 不推荐（已废弃） ✅ 推荐使用 网络隔离 基于默认 bridge 网络，隔离性差 可以创建自定义网络（bridge、overlay 等），隔离性强 可扩展性 只适用于已运行的容器，连接固定 支持多个容器，灵活组合和动态扩展 DNS 支持 仅设置环境变量，不支持自动 DNS 自定义网络中支持容器名称作为 DNS 名称 生命周期 一方容器关闭，另一方仍保存过时链接 网络存在即可，容器生命周期不互相影响 安全性 所有容器共享 bridge，容易相互访问 自定义网络间默认隔离，安全性更好","summary":"摘要 本文介绍 Docker 命令 中 网络管理 相关命令 Docker官方文档","date_published":"2025-05-28T13:40:05.000Z","tags":["技术","docker","docker"]},{"id":"https://blog.hanqunfeng.com/2025/05/28/docker-command-volume/","url":"https://blog.hanqunfeng.com/2025/05/28/docker-command-volume/","title":"Docker 命令 之 数据卷(Volume)","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 Docker 命令 中 数据卷管理 相关命令</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com\">Docker官方文档</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"什么是Volume-数据卷\">什么是Volume(数据卷)?</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Volume 是由 Docker 管理的特殊目录，位于宿主机文件系统中(<code>/var/lib/docker/volumes/</code>)，用于存储和共享容器的数据。</p>\n</li>\n<li class=\"lvl-2\">\n<p>当容器被删除后，容器内的文件系统也会一起删除，但挂载在 Volume 中的数据不会丢失，可供多个容器共享。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Volume 的特点</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数据持久化</td>\n<td>即使容器删除，数据仍保留在卷中</td>\n</tr>\n<tr>\n<td>多容器共享访问</td>\n<td>多个容器可以挂载同一个卷，实现数据共享</td>\n</tr>\n<tr>\n<td>不依赖容器路径</td>\n<td>卷与容器生命周期解耦，支持灵活的容器重建和升级</td>\n</tr>\n<tr>\n<td>管理简便</td>\n<td>可用 <code>docker volume</code> 命令进行查看、创建、删除等操作</td>\n</tr>\n<tr>\n<td>安全隔离</td>\n<td>Docker 管理的路径比绑定挂载更安全</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"docker-volume-相关命令\"><code>docker volume</code> 相关命令</h2>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>docker volume create</code></td>\n<td>创建一个新的卷，名称可选（不指定会自动生成）</td>\n<td><code>docker volume create myvolume</code></td>\n</tr>\n<tr>\n<td><code>docker volume ls</code></td>\n<td>列出所有已存在的卷</td>\n<td><code>docker volume ls</code></td>\n</tr>\n<tr>\n<td><code>docker volume inspect &lt;name&gt;</code></td>\n<td>查看指定卷的详细信息，包括挂载点、驱动等</td>\n<td><code>docker volume inspect myvolume</code></td>\n</tr>\n<tr>\n<td><code>docker volume rm &lt;name&gt;</code></td>\n<td>删除一个卷（前提是没有容器正在使用该卷）</td>\n<td><code>docker volume rm myvolume</code></td>\n</tr>\n<tr>\n<td><code>docker volume prune</code></td>\n<td>删除所有未被使用的卷（会有确认提示）</td>\n<td><code>docker volume prune</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"docker-volume-create-创建一个新的卷\"><code>docker volume create</code> : 创建一个新的卷</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker volume create [OPTIONS] [VOLUME]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>参数详解</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-d, --driver string</code></td>\n<td>指定卷驱动程序，默认是 <code>local</code>（本地存储）</td>\n<td><code>-d local</code> 或 第三方驱动名称(需要安装第三方插件)</td>\n</tr>\n<tr>\n<td><code>--label list</code></td>\n<td>给卷添加标签（元数据），可用于分类、过滤</td>\n<td><code>--label env=prod</code></td>\n</tr>\n<tr>\n<td><code>-o, --opt map</code></td>\n<td>设置驱动的特定选项，格式为 <code>key=value</code>，多个选项可重复使用</td>\n<td><code>-o type=tmpfs -o device=tmpfs</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建一个默认卷（local 驱动）</span></span><br><span class=\"line\">docker volume create myvolume</span><br><span class=\"line\"><span class=\"comment\"># 也可以在启动容器的时候创建默认数据卷，如下命令，若 myvolume 卷不存在，则会自动创建</span></span><br><span class=\"line\">docker run -d -v myvolume:/data nginx</span><br><span class=\"line\">docker run -d --mount <span class=\"built_in\">type</span>=volume,<span class=\"built_in\">source</span>=myvolume,target=/data nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建一个带有标签的卷</span></span><br><span class=\"line\">docker volume create --label <span class=\"built_in\">env</span>=dev --label team=backend myvolume</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建匿名卷（不指定名称）</span></span><br><span class=\"line\">docker volume create</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用 tmpfs 类型卷（只存于内存中，不落盘）,适用于高速读写但不需要持久化的数据</span></span><br><span class=\"line\">docker volume create \\</span><br><span class=\"line\">  -d <span class=\"built_in\">local</span> \\            <span class=\"comment\"># 指定驱动程序为 local</span></span><br><span class=\"line\">  -o <span class=\"built_in\">type</span>=tmpfs \\       <span class=\"comment\"># 指定底层文件系统类型为 tmpfs（内存文件系统）</span></span><br><span class=\"line\">  -o device=tmpfs \\     <span class=\"comment\"># 设置挂载设备为 tmpfs，用于与 type=tmpfs 配合</span></span><br><span class=\"line\">  -o o=size=100m \\      <span class=\"comment\"># 设置 tmpfs 的最大容量为 100MB</span></span><br><span class=\"line\">  mytmpfs               <span class=\"comment\"># 卷的名称，可通过 docker volume ls 查看</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建一个自定义驱动的卷（如 nfs）</span></span><br><span class=\"line\">docker volume create \\</span><br><span class=\"line\">  -d <span class=\"built_in\">local</span> \\                    <span class=\"comment\"># 默认驱动程序为 local</span></span><br><span class=\"line\">  -o <span class=\"built_in\">type</span>=nfs \\                 <span class=\"comment\"># 底层文件系统类型为 nfs</span></span><br><span class=\"line\">  -o o=addr=192.168.1.100,rw \\  <span class=\"comment\"># 设置 nfs 的地址和读写权限，若只读为 ro</span></span><br><span class=\"line\">  -o device=:/path/to/share \\   <span class=\"comment\"># 挂载设备为 nfs，格式为：nfs://192.168.1.100:/path/to/share</span></span><br><span class=\"line\">  mynfs                         <span class=\"comment\"># 卷的名称，可通过 docker volume ls 查看</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建的数据卷会保存在 <code>/var/lib/docker/volumes/</code> 目录下，比如我们创建了一个卷 myvolume，那么该卷会保存在 <code>/var/lib/docker/volumes/myvolume/_data</code> 目录下</p>\n</li>\n</ul>\n<h3 id=\"docker-volume-ls-列出所有已存在的卷\"><code>docker volume ls</code> : 列出所有已存在的卷</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出所有卷</span></span><br><span class=\"line\">docker volume <span class=\"built_in\">ls</span></span><br><span class=\"line\"><span class=\"comment\"># 列出所有卷的ID</span></span><br><span class=\"line\">docker volume <span class=\"built_in\">ls</span> -q</span><br><span class=\"line\"><span class=\"comment\"># 列出指定驱动的卷</span></span><br><span class=\"line\">docker volume <span class=\"built_in\">ls</span> -f driver=<span class=\"built_in\">local</span></span><br><span class=\"line\"><span class=\"comment\"># 列出指定标签的卷</span></span><br><span class=\"line\">docker volume <span class=\"built_in\">ls</span> -f label=<span class=\"built_in\">env</span>=dev</span><br><span class=\"line\"><span class=\"comment\"># 列出所有未使用的卷，包括匿名卷和命名卷</span></span><br><span class=\"line\">docker volume <span class=\"built_in\">ls</span> -f dangling=<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-volume-inspect-name-查看指定卷的详细信息\"><code>docker volume inspect &lt;name&gt;</code> : 查看指定卷的详细信息</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出指定卷的详细信息</span></span><br><span class=\"line\">docker volume inspect myvolume</span><br><span class=\"line\"><span class=\"comment\"># 列出指定卷的详细信息，并使用json格式输出</span></span><br><span class=\"line\">docker volume inspect -f json myvolume</span><br><span class=\"line\"><span class=\"comment\"># 列出指定卷的挂载点</span></span><br><span class=\"line\">docker volume inspect myvolume --format <span class=\"string\">&quot;&#123;&#123;.Mountpoint&#125;&#125;&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-volume-prune-删除所有未被容器使用的卷\"><code>docker volume prune</code> : 删除所有未被容器使用的卷</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除所有未被使用的匿名数据卷，会提示确认</span></span><br><span class=\"line\">docker volume prune</span><br><span class=\"line\"><span class=\"comment\"># 删除所有未被使用的数据卷，会提示确认</span></span><br><span class=\"line\">docker volume prune -a</span><br><span class=\"line\"><span class=\"comment\"># 删除所有未被使用的卷，无需确认立刻删除</span></span><br><span class=\"line\">docker volume prune -a -f</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>匿名卷 vs 命名卷</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">匿名卷：没有名称，只在 <code>docker run -v /container/path</code> 时自动创建；</li>\n<li class=\"lvl-4\">命名卷：有名称，例如 <code>docker run -v mydata:/container/path</code>；</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"docker-volume-rm-name-删除数据卷\"><code>docker volume rm &lt;name&gt;</code> : 删除数据卷</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除指定数据卷</span></span><br><span class=\"line\">docker volume <span class=\"built_in\">rm</span> myvolume</span><br><span class=\"line\"><span class=\"comment\"># 删除所有数据卷</span></span><br><span class=\"line\">docker volume <span class=\"built_in\">rm</span> $(docker volume <span class=\"built_in\">ls</span> -q)</span><br><span class=\"line\"><span class=\"comment\"># 删除所有未使用的数据卷</span></span><br><span class=\"line\">docker volume <span class=\"built_in\">rm</span> $(docker volume <span class=\"built_in\">ls</span> -qf dangling=<span class=\"literal\">true</span>)</span><br><span class=\"line\"><span class=\"comment\"># 删除所有未使用的数据卷，无需确认</span></span><br><span class=\"line\">docker volume <span class=\"built_in\">rm</span> $(docker volume <span class=\"built_in\">ls</span> -qf dangling=<span class=\"literal\">true</span>) -f</span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍 Docker 命令 中 数据卷管理 相关命令 Docker官方文档 什么是Volume(数据卷)? Volume 是由 Docker 管理的特殊目录，位于宿主机文件系统中(/var/lib/docker/volumes/)，用于存储和共享容器的数据。 当容器被删除后，容器内的文件系统也会一起删除，但挂载在 Volume 中的数据不会丢失，可供多个容器共享。 Volume 的特点 特性 说明 数据持久化 即使容器删除，数据仍保留在卷中 多容器共享访问 多个容器可以挂载同一个卷，实现数据共享 不依赖容器路径 卷与容器生命周期解耦，支持灵活的容器重建和升级 管理简便 可用 docker volume 命令进行查看、创建、删除等操作 安全隔离 Docker 管理的路径比绑定挂载更安全 docker volume 相关命令 命令 作用说明 示例 docker volume create 创建一个新的卷，名称可选（不指定会自动生成） docker volume create myvolume docker volume ls 列出所有已存在的卷 docker volume ls docker volume inspect &lt;name&gt; 查看指定卷的详细信息，包括挂载点、驱动等 docker volume inspect myvolume docker volume rm &lt;name&gt; 删除一个卷（前提是没有容器正在使用该卷） docker volume rm myvolume docker volume prune 删除所有未被使用的卷（会有确认提示） docker volume prune docker volume create : 创建一个新的卷 语法 1docker volume create [OPTIONS] [VOLUME] 参数详解 选项 说明 示例 -d, --driver string 指定卷驱动程序，默认是 local（本地存储） -d local 或 第三方驱动名称(需要安装第三方插件) --label list 给卷添加标签（元数据），可用于分类、过滤 --label env=prod -o, --opt map 设置驱动的特定选项，格式为 key=value，多个选项可重复使用 -o type=tmpfs -o device=tmpfs 示例 12345678910111213141516171819202122232425262728# 创建一个默认卷（local 驱动）docker volume create myvolume# 也可以在启动容器的时候创建默认数据卷，如下命令，若 myvolume 卷不存在，则会自动创建docker run -d -v myvolume:/data nginxdocker run -d --mount type=volume,source=myvolume,target=/data nginx# 创建一个带有标签的卷docker volume create --label env=dev --label team=backend myvolume# 创建匿名卷（不指定名称）docker volume create# 使用 tmpfs 类型卷（只存于内存中，不落盘）,适用于高速读写但不需要持久化的数据docker volume create \\ -d local \\ # 指定驱动程序为 local -o type=tmpfs \\ # 指定底层文件系统类型为 tmpfs（内存文件系统） -o device=tmpfs \\ # 设置挂载设备为 tmpfs，用于与 type=tmpfs 配合 -o o=size=100m \\ # 设置 tmpfs 的最大容量为 100MB mytmpfs # 卷的名称，可通过 docker volume ls 查看# 创建一个自定义驱动的卷（如 nfs）docker volume create \\ -d local \\ # 默认驱动程序为 local -o type=nfs \\ # 底层文件系统类型为 nfs -o o=addr=192.168.1.100,rw \\ # 设置 nfs 的地址和读写权限，若只读为 ro -o device=:/path/to/share \\ # 挂载设备为 nfs，格式为：nfs://192.168.1.100:/path/to/share mynfs # 卷的名称，可通过 docker volume ls 查看 创建的数据卷会保存在 /var/lib/docker/volumes/ 目录下，比如我们创建了一个卷 myvolume，那么该卷会保存在 /var/lib/docker/volumes/myvolume/_data 目录下 docker volume ls : 列出所有已存在的卷 12345678910# 列出所有卷docker volume ls# 列出所有卷的IDdocker volume ls -q# 列出指定驱动的卷docker volume ls -f driver=local# 列出指定标签的卷docker volume ls -f label=env=dev# 列出所有未使用的卷，包括匿名卷和命名卷docker volume ls -f dangling=true docker volume inspect &lt;name&gt; : 查看指定卷的详细信息 123456# 列出指定卷的详细信息docker volume inspect myvolume# 列出指定卷的详细信息，并使用json格式输出docker volume inspect -f json myvolume# 列出指定卷的挂载点docker volume inspect myvolume --format &quot;&#123;&#123;.Mountpoint&#125;&#125;&quot; docker volume prune : 删除所有未被容器使用的卷 123456# 删除所有未被使用的匿名数据卷，会提示确认docker volume prune# 删除所有未被使用的数据卷，会提示确认docker volume prune -a# 删除所有未被使用的卷，无需确认立刻删除docker volume prune -a -f 匿名卷 vs 命名卷 匿名卷：没有名称，只在 docker run -v /container/path 时自动创建； 命名卷：有名称，例如 docker run -v mydata:/container/path； docker volume rm &lt;name&gt; : 删除数据卷 12345678# 删除指定数据卷docker volume rm myvolume# 删除所有数据卷docker volume rm $(docker volume ls -q)# 删除所有未使用的数据卷docker volume rm $(docker volume ls -qf dangling=true)# 删除所有未使用的数据卷，无需确认docker volume rm $(docker volume ls -qf dangling=true) -f","summary":"摘要 本文介绍 Docker 命令 中 数据卷管理 相关命令 Docker官方文档","date_published":"2025-05-28T13:30:05.000Z","tags":["技术","docker","docker"]},{"id":"https://blog.hanqunfeng.com/2025/05/27/docker-command-container/","url":"https://blog.hanqunfeng.com/2025/05/27/docker-command-container/","title":"Docker 命令 之 容器(Container)","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 Docker 命令 中 容器管理 相关命令</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com\">Docker官方文档</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"容器的生命周期\">容器的生命周期</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>容器可能处于以下几种状态：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-5\">初建（created）</li>\n<li class=\"lvl-5\">运行（running）</li>\n<li class=\"lvl-5\">暂停（paused）</li>\n<li class=\"lvl-5\">停止（stopped）</li>\n<li class=\"lvl-5\">删除（deleted）</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>各生命周期之间的转换关系如图所示：<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/19n9NJ.png\" alt=\"\"></p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>命令/情况</th>\n<th>说明</th>\n<th>容器状态变更</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>docker create</code></td>\n<td>创建容器后，不立即启动运行，容器进入初建状态</td>\n<td>初建状态</td>\n</tr>\n<tr>\n<td><code>docker run</code></td>\n<td>创建容器，并立即启动运行，进入运行状态</td>\n<td>初建 → 运行</td>\n</tr>\n<tr>\n<td><code>docker start</code></td>\n<td>启动已创建的容器，容器转为运行状态</td>\n<td>停止 → 运行</td>\n</tr>\n<tr>\n<td><code>docker stop</code></td>\n<td>停止正在运行的容器，容器转入停止状态</td>\n<td>运行 → 停止</td>\n</tr>\n<tr>\n<td><code>docker kill</code></td>\n<td>强制终止容器，相当于“断电”，容易丢失数据，不建议轻易使用</td>\n<td>运行 → 停止（非正常）</td>\n</tr>\n<tr>\n<td><code>docker restart</code></td>\n<td>重启容器，容器重新进入运行状态</td>\n<td>运行 → 停止 → 运行</td>\n</tr>\n<tr>\n<td><code>docker pause</code></td>\n<td>暂停容器内所有进程，容器进入暂停状态</td>\n<td>运行 → 暂停</td>\n</tr>\n<tr>\n<td><code>docker unpause</code></td>\n<td>取消暂停状态，容器恢复运行</td>\n<td>暂停 → 运行</td>\n</tr>\n<tr>\n<td><code>docker rm</code></td>\n<td>删除容器，容器转入删除状态</td>\n<td>任意 → 删除</td>\n</tr>\n<tr>\n<td>Killed by out-of-memory (OOM)</td>\n<td>宿主机内存耗尽，容器被系统终止，此为非计划终止；建议杀死内存占用最高的容器</td>\n<td>运行 → 停止（异常）</td>\n</tr>\n<tr>\n<td>Container process exited</td>\n<td>容器进程异常终止后，进入“是否重启”判断流程：是则执行 <code>start</code> 进入运行；否则保持停止状态</td>\n<td>异常 → 停止或运行</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"docker-container-容器管理\"><code>docker container</code> : 容器管理</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker container --help</code></p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n<th>别名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>attach</td>\n<td>将本地的标准输入、输出和错误流附加到一个正在运行的容器上</td>\n<td>docker attach</td>\n</tr>\n<tr>\n<td>commit</td>\n<td>根据容器的更改创建一个新的镜像</td>\n<td>docker commit</td>\n</tr>\n<tr>\n<td>cp</td>\n<td>在容器和本地文件系统之间复制文件/文件夹</td>\n<td>docker cp</td>\n</tr>\n<tr>\n<td>create</td>\n<td>创建一个新的容器</td>\n<td>docker create</td>\n</tr>\n<tr>\n<td>diff</td>\n<td>检查容器文件系统上的文件或目录的更改</td>\n<td>docker diff</td>\n</tr>\n<tr>\n<td>exec</td>\n<td>在正在运行的容器中执行命令</td>\n<td>docker exec</td>\n</tr>\n<tr>\n<td>export</td>\n<td>将容器的文件系统导出为 tar 归档文件</td>\n<td>docker export</td>\n</tr>\n<tr>\n<td>inspect</td>\n<td>显示一个或多个容器的详细信息</td>\n<td>可以使用 <code>docker inspect</code></td>\n</tr>\n<tr>\n<td>kill</td>\n<td>终止一个或多个正在运行的容器</td>\n<td>docker kill</td>\n</tr>\n<tr>\n<td>logs</td>\n<td>获取容器的日志</td>\n<td>docker logs</td>\n</tr>\n<tr>\n<td>ls</td>\n<td>列出容器</td>\n<td>docker ps</td>\n</tr>\n<tr>\n<td>pause</td>\n<td>暂停一个或多个容器内的所有进程</td>\n<td>docker pause</td>\n</tr>\n<tr>\n<td>port</td>\n<td>列出容器的端口映射或特定的端口映射</td>\n<td>docker port</td>\n</tr>\n<tr>\n<td>prune</td>\n<td>删除所有已停止的容器</td>\n<td></td>\n</tr>\n<tr>\n<td>rename</td>\n<td>重命名一个容器</td>\n<td>docker rename</td>\n</tr>\n<tr>\n<td>restart</td>\n<td>重启一个或多个容器</td>\n<td>docker restart</td>\n</tr>\n<tr>\n<td>rm</td>\n<td>删除一个或多个容器</td>\n<td>docker rm</td>\n</tr>\n<tr>\n<td>run</td>\n<td>根据镜像创建并运行一个新容器</td>\n<td>docker run</td>\n</tr>\n<tr>\n<td>start</td>\n<td>启动一个或多个已停止的容器</td>\n<td>docker start</td>\n</tr>\n<tr>\n<td>stats</td>\n<td>实时显示容器资源使用统计信息</td>\n<td>docker stats</td>\n</tr>\n<tr>\n<td>stop</td>\n<td>停止一个或多个正在运行的容器</td>\n<td>docker stop</td>\n</tr>\n<tr>\n<td>top</td>\n<td>显示容器中运行的进程</td>\n<td>docker top</td>\n</tr>\n<tr>\n<td>unpause</td>\n<td>取消暂停一个或多个容器内的所有进程</td>\n<td>docker unpause</td>\n</tr>\n<tr>\n<td>update</td>\n<td>更新一个或多个容器的配置</td>\n<td>docker update</td>\n</tr>\n<tr>\n<td>wait</td>\n<td>阻塞直到一个或多个容器停止，然后打印其退出代码</td>\n<td>docker wait</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>运行 <code>docker container COMMAND --help</code> 可获取某个命令的更多信息。</p>\n</li>\n</ul>\n<h3 id=\"docker-create-创建容器，但不启动\"><code>docker create</code> : 创建容器，但不启动</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker create \\</span><br><span class=\"line\">    --name my-container \\ <span class=\"comment\"># 容器名</span></span><br><span class=\"line\">    -e MY_ENV_VAR=my-value \\ <span class=\"comment\"># 设置环境变量</span></span><br><span class=\"line\">    -p 80:80 \\ <span class=\"comment\"># 映射端口，格式：宿主机端口:容器端口</span></span><br><span class=\"line\">    -v /path/to/my/dir:/path/in/container \\ <span class=\"comment\"># 映射目录，格式：宿主机目录:容器目录，都必须是绝对路径</span></span><br><span class=\"line\">    --restart always \\ <span class=\"comment\"># 设置重启策略</span></span><br><span class=\"line\">    nginx:latest \\ <span class=\"comment\"># 镜像名，镜像不存在时会自动下载</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker create</code> 与 <code>docker run</code> 的参数基本一致，具体查看下面 <code>docker run</code> 中的介绍。</p>\n</li>\n</ul>\n<h3 id=\"docker-start-启动一个容器\"><code>docker start</code> : 启动一个容器</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动一个容器，容器必须已经创建，并且处于停止状态。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 语法：docker start &lt;container_id|container_name&gt;</span></span><br><span class=\"line\">$ docker start my-container</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-run-创建并启动一个容器\"><code>docker run</code> : 创建并启动一个容器</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>相当于<code>docker create</code> + <code>docker start</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>常用参数说明</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-d</code>, <code>--detach</code></td>\n<td>后台运行容器（即“守护态”），<code>run</code>独有</td>\n<td><code>docker run -d nginx</code></td>\n</tr>\n<tr>\n<td><code>-it</code></td>\n<td>交互式运行容器并分配终端（常用于调试）</td>\n<td><code>docker run -it ubuntu bash</code></td>\n</tr>\n<tr>\n<td><code>--name</code></td>\n<td>指定容器名称</td>\n<td><code>docker run --name my-nginx nginx</code></td>\n</tr>\n<tr>\n<td><code>--rm</code></td>\n<td>容器退出时自动删除</td>\n<td><code>docker run --rm ubuntu</code></td>\n</tr>\n<tr>\n<td><code>-p</code>, <code>--publish</code></td>\n<td>端口映射（宿主机:容器）</td>\n<td><code>docker run -p 8080:80 nginx</code></td>\n</tr>\n<tr>\n<td><code>-P</code>, <code>--publish-all</code></td>\n<td>自动随机映射容器内部所有暴露端口到宿主机端口</td>\n<td><code>docker run -P nginx</code></td>\n</tr>\n<tr>\n<td><code>-v</code>, <code>--volume</code></td>\n<td>挂载卷（宿主机目录:容器目录）</td>\n<td><code>docker run -v /data:/app/data myapp</code></td>\n</tr>\n<tr>\n<td><code>--mount</code></td>\n<td>更灵活的挂载方式（推荐新项目使用）</td>\n<td><code>docker run --mount type=bind,source=/host,target=/container nginx</code></td>\n</tr>\n<tr>\n<td><code>--env</code>, <code>-e</code></td>\n<td>设置环境变量</td>\n<td><code>docker run -e ENV=prod myapp</code></td>\n</tr>\n<tr>\n<td><code>--env-file</code></td>\n<td>从文件中加载多个环境变量</td>\n<td><code>docker run --env-file .env myapp</code></td>\n</tr>\n<tr>\n<td><code>--network</code></td>\n<td>设置容器使用的网络模式</td>\n<td><code>docker run --network host myapp</code></td>\n</tr>\n<tr>\n<td><code>--restart</code></td>\n<td>设置容器的自动重启策略</td>\n<td><code>docker run --restart=always myapp</code></td>\n</tr>\n<tr>\n<td><code>--privileged</code></td>\n<td>给予容器更多的权限（如访问 host 设备）</td>\n<td><code>docker run --privileged myapp</code></td>\n</tr>\n<tr>\n<td><code>--entrypoint</code></td>\n<td>覆盖镜像默认的 ENTRYPOINT</td>\n<td><code>docker run --entrypoint /bin/bash myapp</code></td>\n</tr>\n<tr>\n<td><code>-u</code>, <code>--user</code></td>\n<td>指定容器内运行的用户（格式：UID 或 UID:GID）</td>\n<td><code>docker run --user 1000:1000 myapp</code></td>\n</tr>\n<tr>\n<td><code>-c</code>, <code>--cpu-shares</code></td>\n<td>设置 CPU 权重（相对值）</td>\n<td><code>docker run --cpu-shares=512 myapp</code></td>\n</tr>\n<tr>\n<td><code>-m</code>, <code>--memory</code></td>\n<td>限制容器最大内存（如 <code>512m</code>, <code>1g</code>）</td>\n<td><code>docker run --memory=512m myapp</code></td>\n</tr>\n<tr>\n<td><code>-h</code>,<code> --hostname</code></td>\n<td>设置容器主机名</td>\n<td><code>docker run -h myhost myapp</code></td>\n</tr>\n<tr>\n<td><code>--link</code>(更推荐使用 <code>--network</code>)</td>\n<td>创建链接到其他容器</td>\n<td><code>docker run --link myapp:app myapp2</code></td>\n</tr>\n<tr>\n<td><code>--cpus</code></td>\n<td>限制容器使用的CPU核数</td>\n<td><code>docker run --cpus=&quot;1.5&quot;</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>-p</code>, <code>--publish</code> 端口映射</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -p [主机IP:]主机端口:容器端口[/协议]</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>示例</th>\n<th>含义说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-p 8080:80</code></td>\n<td>将主机的 8080 端口映射到容器的 80 端口（默认 TCP）</td>\n</tr>\n<tr>\n<td><code>-p 127.0.0.1:8080:80</code></td>\n<td>仅将主机本地 IP（127.0.0.1）的 8080 映射到容器的 80 端口（外部无法访问）</td>\n</tr>\n<tr>\n<td><code>-p 8080:80/tcp</code></td>\n<td>显式指定协议为 TCP（等同于不加 <code>/tcp</code>）</td>\n</tr>\n<tr>\n<td><code>-p 8080:80/udp</code></td>\n<td>映射 UDP 协议端口（如 DNS 服务等）</td>\n</tr>\n<tr>\n<td><code>-p 8080</code></td>\n<td>宿主机随机端口映射到容器的8080端口</td>\n</tr>\n<tr>\n<td><code>-p 3000-3006:4000-4006</code></td>\n<td><strong>范围映射</strong>，不能映射非对称范围（如 3000-3006:4000-4006），只能一一对应</td>\n</tr>\n<tr>\n<td>多个 <code>-p</code></td>\n<td>可以多次使用 <code>-p</code>，映射多个端口。例如：<code>-p 80:80 -p 443:443</code></td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>-v, --volume</code> 数据卷映射</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -v &lt;本地路径&gt;:&lt;容器路径&gt;[:权限]</span><br><span class=\"line\">  <span class=\"comment\"># &lt;本地路径&gt;\t主机上的路径（绝对路径，或命名卷），目录不存在会自动创建</span></span><br><span class=\"line\">  <span class=\"comment\"># &lt;容器路径&gt;\t容器内的路径，目录不存在会自动创建</span></span><br><span class=\"line\">  <span class=\"comment\"># [:权限]\t可选：ro（只读） 或 rw（读写，默认）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\"><span class=\"comment\"># 挂载本地目录到容器</span></span><br><span class=\"line\">docker run -v /data:/app/data myapp</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 挂载为只读</span></span><br><span class=\"line\">docker run -v /data:/app/data:ro myapp</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 挂载多个数据卷</span></span><br><span class=\"line\">docker run -v /data1:/app/data1 -v /data2:/app/data2 myapp</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用命名卷</span></span><br><span class=\"line\">docker volume create mydata</span><br><span class=\"line\">docker run -v mydata:/app/data myapp</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>--mount</code> 挂载卷</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># --mount 是 Docker 推荐使用的 现代挂载方式，功能和 -v（或 --volume）类似，但语法更清晰、结构更规范，适用于卷（volume）、绑定挂载（bind）和临时挂载（tmpfs）。</span></span><br><span class=\"line\">docker run --mount <span class=\"built_in\">type</span>=&lt;类型&gt;,<span class=\"built_in\">source</span>=&lt;主机路径或卷名&gt;,target=&lt;容器路径&gt;[,<span class=\"built_in\">readonly</span>]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>三种挂载类型对比</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>类型 (<code>type</code>)</th>\n<th>用途</th>\n<th>示例 <code>source</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>volume</code></td>\n<td>使用 Docker 管理的卷</td>\n<td>卷名，如 <code>mydata</code></td>\n</tr>\n<tr>\n<td><code>bind</code></td>\n<td>挂载宿主机的实际路径</td>\n<td>绝对路径，如 <code>/home/user/app/config</code></td>\n</tr>\n<tr>\n<td><code>tmpfs</code></td>\n<td>挂载内存中的临时文件系统</td>\n<td>无需指定 <code>source</code></td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用命名卷挂载（推荐方式）,这里 --target 指定容器内的挂载点，也可以替换为 --destination</span></span><br><span class=\"line\">docker run --mount <span class=\"built_in\">type</span>=volume,<span class=\"built_in\">source</span>=mydata,target=/app/data myapp</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用本地路径挂载（绑定挂载）,source指定的本地路径必须存在</span></span><br><span class=\"line\">docker run --mount <span class=\"built_in\">type</span>=<span class=\"built_in\">bind</span>,<span class=\"built_in\">source</span>=/home/user/app/config,target=/app/config myapp</span><br><span class=\"line\"><span class=\"comment\"># 只读挂载，readonly 可以简写为 ro</span></span><br><span class=\"line\">docker run --mount <span class=\"built_in\">type</span>=<span class=\"built_in\">bind</span>,<span class=\"built_in\">source</span>=/home/user/app/config,target=/app/config,<span class=\"built_in\">readonly</span> myapp</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用内存中的临时文件系统挂载，数据不会持久化，只存储在容器运行时的内存中</span></span><br><span class=\"line\">docker run --mount <span class=\"built_in\">type</span>=tmpfs,target=/app/tmpfs myapp</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>--link</code> 容器间链接</p>\n</li>\n</ul>\n<blockquote>\n<p>用于在容器之间建立连接，使一个容器可以通过另一个容器的名称访问其网络信息（如 IP、环境变量等）。<br>\n注意：<code>--link</code> 已被弃用，建议使用 <code>--network</code> 来实现容器间链接。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --<span class=\"built_in\">link</span> &lt;目标容器名&gt;:&lt;别名&gt; &lt;其他参数&gt; &lt;镜像名&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 示例</span></span><br><span class=\"line\"><span class=\"comment\"># 场景：一个 web 容器想要连接另一个运行中的 db 容器</span></span><br><span class=\"line\"><span class=\"comment\"># 先启动数据库容器</span></span><br><span class=\"line\">docker run -d --name db mysql</span><br><span class=\"line\"><span class=\"comment\"># 启动 web 容器并连接到 db 容器</span></span><br><span class=\"line\">docker run -it --<span class=\"built_in\">rm</span> --name web --<span class=\"built_in\">link</span> db:mydb ubuntu bash</span><br><span class=\"line\"><span class=\"comment\"># 在 web 容器中，现在你可以用 mydb 来访问 db 容器，但反过来 db 容器无法访问 web 容器</span></span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> web ping mydb</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 改用 --network 实现</span></span><br><span class=\"line\">docker network create mynet</span><br><span class=\"line\">docker run -d --name db --network mynet mysql</span><br><span class=\"line\">docker run -it --<span class=\"built_in\">rm</span> --name web --network mynet ubuntu bash</span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> web ping db</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>--network</code> 网络模式类型</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>含义</th>\n<th>特点/适用场景</th>\n<th>是否允许端口映射</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>bridge</code></td>\n<td>默认网络类型（用户自定义或 Docker 默认桥接网络）</td>\n<td>容器通过虚拟网桥连接，可相互通信；适用于单主机部署</td>\n<td>✅ 是</td>\n</tr>\n<tr>\n<td><code>host</code></td>\n<td>容器与宿主机共享网络栈</td>\n<td>没有网络隔离，容器使用宿主机的 IP 和端口，性能高，适合对网络要求高的服务</td>\n<td>❌ 否</td>\n</tr>\n<tr>\n<td><code>none</code></td>\n<td>容器没有网络接口</td>\n<td>完全隔离；适用于需要完全控制网络的场景或测试网络不可达性</td>\n<td>❌ 否</td>\n</tr>\n<tr>\n<td><code>&lt;user-defined&gt;</code></td>\n<td>用户自定义的网络名称，通过 <code>docker network create</code> 创建</td>\n<td>支持容器名称互解析（DNS），适合多容器通信场景，如 Docker Compose</td>\n<td>✅ 是</td>\n</tr>\n<tr>\n<td><code>container:&lt;name|id&gt;</code></td>\n<td>与另一个容器共享网络命名空间</td>\n<td>两个容器共享 IP 和端口，适用于主-辅容器模式，如 sidecar 容器共享主容器网络</td>\n<td>❌ 否</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用默认 bridge 网络</span></span><br><span class=\"line\">docker run -p 8080:80 --network bridge --name my-nginx nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 与宿主机共享网络，不能使用-p</span></span><br><span class=\"line\">docker run --network host nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 不使用任何网络，不能使用-p</span></span><br><span class=\"line\">docker run --network none nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用已创建的自定义网络，相同网络命名空间下的容器，可以通过容器 名称或ID 互相访问</span></span><br><span class=\"line\">docker network create nginx_net</span><br><span class=\"line\">docker run -p 8080:80 --network nginx_net nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 与另一个容器共享网络命名空间，不能使用-p，并且此时新启动的容器占用的端口不能与要连接的容器端口一致，否则将启动失败</span></span><br><span class=\"line\">docker run --network container:my-nginx busybox</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>--restart</code> 重启策略</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>策略</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>no</code>（默认）</td>\n<td>容器退出后不会自动重启</td>\n</tr>\n<tr>\n<td><code>always</code></td>\n<td>无论退出状态码如何，容器总是自动重启</td>\n</tr>\n<tr>\n<td><code>unless-stopped</code></td>\n<td>容器总是自动重启，除非用户手动停止它</td>\n</tr>\n<tr>\n<td><code>on-failure[:N]</code></td>\n<td>仅在容器非 0 状态码退出时自动重启（可选设置最大重启次数 N）</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 容器非正常退出时自动重启</span></span><br><span class=\"line\">docker run --restart on-failure my-app</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 最多重启 5 次</span></span><br><span class=\"line\">docker run --restart on-failure:5 my-app</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 总是重启（即使你重启 Docker 服务后）</span></span><br><span class=\"line\">docker run --restart always my-app</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 除非手动停止，否则一直重启</span></span><br><span class=\"line\">docker run --restart unless-stopped my-app</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>--cpu-shares</code> : 设置容器的 CPU 相对权重，即在 CPU 资源竞争时的相对优先级，默认值为 1024。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 容器1，权重 1024（默认）</span></span><br><span class=\"line\">docker run -d --name c1 --cpu-shares 1024 nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 容器2，权重 512（优先级低）</span></span><br><span class=\"line\">docker run -d --name c2 --cpu-shares 512 nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 说明：</span></span><br><span class=\"line\">  <span class=\"comment\"># c1的权重1024，c2的权重512,不是绝对限制，而是分配比例</span></span><br><span class=\"line\">  <span class=\"comment\"># 该权重表示容器在 CPU 竞争下，权重越高则优先级越高，会尽可能使用 CPU 资源。</span></span><br><span class=\"line\">  <span class=\"comment\"># 如果这两个容器都运行在 CPU 忙碌的环境下(只有在 多容器共享 CPU 且竞争资源 的情况下才生效)：</span></span><br><span class=\"line\">    <span class=\"comment\"># c1 将获得大约 2/3 的 CPU 时间</span></span><br><span class=\"line\">    <span class=\"comment\"># c2 将获得大约 1/3 的 CPU 时间</span></span><br><span class=\"line\">  <span class=\"comment\"># 如果系统 CPU 空闲，所有容器都可以使用 100% 的 CPU。</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>docker run</code> 示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启动一个nginx 容器</span></span><br><span class=\"line\">docker run -d -p 80:80 --name nginx nginx</span><br><span class=\"line\"><span class=\"comment\"># 替换nginx镜像默认的启动命令，nginx 镜像默认启动 nginx 服务，此命令会改为执行 nginx -v 显示版本号</span></span><br><span class=\"line\">docker run --name test_nginx --entrypoint <span class=\"string\">&quot;&quot;</span> nginx nginx -v</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 执行脚本或命令，这里添加 --rm 参数，表示运行结束后自动删除容器，这里是安装 ping 命令</span></span><br><span class=\"line\">docker run --<span class=\"built_in\">rm</span> ubuntu bash -c <span class=\"string\">&quot;apt update &amp;&amp; apt install -y iputils-ping&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 交互式执行 shell 命令，执行命令后会进入容器的shell</span></span><br><span class=\"line\">docker run --<span class=\"built_in\">rm</span> -it ubuntu /bin/bash</span><br><span class=\"line\"><span class=\"comment\"># 这样也可以，因为 ubuntu 的默认启动命令是 /bin/bash</span></span><br><span class=\"line\">docker run --<span class=\"built_in\">rm</span> -it ubuntu</span><br><span class=\"line\"><span class=\"comment\"># 转到后台运行</span></span><br><span class=\"line\">docker run --<span class=\"built_in\">rm</span> -itd ubuntu</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-stop-停止容器，容器优雅退出\"><code>docker stop</code> : 停止容器，容器优雅退出</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 停止容器，通过容器名称</span></span><br><span class=\"line\">docker stop test_nginx</span><br><span class=\"line\"><span class=\"comment\"># 停止容器，通过容器ID</span></span><br><span class=\"line\">docker stop 5d7c0c5d5c0c</span><br><span class=\"line\"><span class=\"comment\"># 停止所有正在运行的容器</span></span><br><span class=\"line\">docker stop $(docker ps -q)</span><br><span class=\"line\"><span class=\"comment\"># 等待5秒后强制关闭</span></span><br><span class=\"line\">docker stop -t 5 test_nginx</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-kill-强制停止容器\"><code>docker kill</code> : 强制停止容器</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当容器完全卡死、挂起、不响应 <code>stop</code> 命令时使用</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">kill</span> test_nginx</span><br><span class=\"line\">docker <span class=\"built_in\">kill</span> 5d7c0c5d5c0c</span><br><span class=\"line\">docker <span class=\"built_in\">kill</span> $(docker ps -q)</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-restart-重启容器\"><code>docker restart</code> : 重启容器</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker restart test_nginx</span><br><span class=\"line\">docker restart 5d7c0c5d5c0c</span><br><span class=\"line\">docker restart $(docker ps -q)</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-pause-暂停容器\"><code>docker pause</code> : 暂停容器</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>暂停后宿主机将不再为容器分配CPU时间片，但内存依然有效，你可以理解为此时为容器保存了快照</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pause test_nginx</span><br><span class=\"line\">docker pause 5d7c0c5d5c0c</span><br><span class=\"line\">docker pause $(docker ps -q)</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-unpause-恢复容器\"><code>docker unpause</code> : 恢复容器</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker unpause test_nginx</span><br><span class=\"line\">docker unpause 5d7c0c5d5c0c</span><br><span class=\"line\">docker unpause $(docker ps -q)</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-ps-查看容器列表\"><code>docker ps</code> : 查看容器列表</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 显示所有正在运行的容器</span></span><br><span class=\"line\">docker ps</span><br><span class=\"line\"><span class=\"comment\"># 显示所有容器</span></span><br><span class=\"line\">docker ps -a</span><br><span class=\"line\"><span class=\"comment\"># 显示所有正在运行的容器的ID</span></span><br><span class=\"line\">docker ps -q</span><br><span class=\"line\"><span class=\"comment\"># 不截断输出，此时 COMMAND 列会显示完整的命令</span></span><br><span class=\"line\">docker ps -notrunc</span><br><span class=\"line\"><span class=\"comment\"># 显示最近创建的5条容器</span></span><br><span class=\"line\">docker ps -n 5</span><br><span class=\"line\"><span class=\"comment\"># 过滤器，显示状态为exited的容器</span></span><br><span class=\"line\">docker ps -a --filter <span class=\"string\">&quot;status=exited&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 指定模板，只显示 ID 和 Names</span></span><br><span class=\"line\">docker ps --format <span class=\"string\">&quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Names&#125;&#125;&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-inspect-查看容器信息\"><code>docker inspect</code> : 查看容器信息</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看容器信息</span></span><br><span class=\"line\">docker inspect &lt;container_id&gt;</span><br><span class=\"line\"><span class=\"comment\"># 获取容器名称</span></span><br><span class=\"line\">docker inspect --format=<span class=\"string\">&#x27;&#123;&#123;.Name&#125;&#125;&#x27;</span> &lt;container_id | container_name&gt;</span><br><span class=\"line\"><span class=\"comment\"># 获取容器镜像</span></span><br><span class=\"line\">docker inspect --format=<span class=\"string\">&#x27;&#123;&#123;.Config.Image&#125;&#125;&#x27;</span> &lt;container_id | container_name&gt;</span><br><span class=\"line\"><span class=\"comment\"># 获取容器环境变量</span></span><br><span class=\"line\">docker inspect --format=<span class=\"string\">&#x27;&#123;&#123;.Config.Env&#125;&#125;&#x27;</span> &lt;container_id | container_name&gt;</span><br><span class=\"line\"><span class=\"comment\"># 获取容器状态，前面的 json 表示输出为 json 格式</span></span><br><span class=\"line\">docker inspect --format=<span class=\"string\">&#x27;&#123;&#123;json .State&#125;&#125;&#x27;</span> &lt;container_id | container_name&gt;</span><br><span class=\"line\"><span class=\"comment\"># 获取容器内存限制</span></span><br><span class=\"line\">docker inspect --format=<span class=\"string\">&#x27;&#123;&#123;.HostConfig.Memory&#125;&#125;&#x27;</span> &lt;container_id | container_name&gt;</span><br><span class=\"line\"><span class=\"comment\"># 获取容器label</span></span><br><span class=\"line\">docker inspect --format=<span class=\"string\">&#x27;&#123;&#123;json .Config.Labels&#125;&#125;&#x27;</span> &lt;container_id | container_name&gt;</span><br><span class=\"line\"><span class=\"comment\"># 获取容器的网络信息</span></span><br><span class=\"line\">docker inspect --format=<span class=\"string\">&#x27;&#123;&#123;json .NetworkSettings&#125;&#125;&#x27;</span> &lt;container_id | container_name&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-logs-获取容器日志\"><code>docker logs</code> : 获取容器日志</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取容器日志</span></span><br><span class=\"line\">docker logs &lt;container_id | container_name&gt;</span><br><span class=\"line\"><span class=\"comment\"># 获取容器实时日志</span></span><br><span class=\"line\">docker logs -f &lt;container_id | container_name&gt;</span><br><span class=\"line\"><span class=\"comment\"># 获取容器最新的 10 行日志</span></span><br><span class=\"line\">docker logs -n 10 &lt;container_id | container_name&gt;</span><br><span class=\"line\"><span class=\"comment\"># 获取容器的带时间戳的日志</span></span><br><span class=\"line\">docker logs -t &lt;container_id | container_name&gt;</span><br><span class=\"line\"><span class=\"comment\"># 获取容器的日志，从 1 小时前开始</span></span><br><span class=\"line\">docker logs --since 1h &lt;container_id | container_name&gt;</span><br><span class=\"line\"><span class=\"comment\"># 获取容器的日志，直到 1 小时前</span></span><br><span class=\"line\">docker logs --<span class=\"keyword\">until</span> 1h &lt;container_id | container_name&gt;</span><br><span class=\"line\"><span class=\"comment\"># 获取容器的详细日志</span></span><br><span class=\"line\">docker logs --details &lt;container_id | container_name&gt;</span><br><span class=\"line\"><span class=\"comment\"># 获取容器的日志，从 2 小时前开始，直到 1 小时前</span></span><br><span class=\"line\">docker logs --since 2h --<span class=\"keyword\">until</span> 1h &lt;container_id | container_name&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-exec-在已经运行的容器中执行命令\"><code>docker exec</code> : 在已经运行的容器中执行命令</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在已经运行的容器中执行命令</span></span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> &lt;container_id | container_name&gt; &lt;<span class=\"built_in\">command</span>&gt;</span><br><span class=\"line\"><span class=\"comment\"># 进入容器shell</span></span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> -it &lt;container_id | container_name&gt; bash</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-rename-重命名容器\"><code>docker rename</code> : 重命名容器</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker rename &lt;old_container_name&gt; &lt;new_container_name&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-cp-容器与宿主机间复制文件\"><code>docker cp</code> : 容器与宿主机间复制文件</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 宿主机 -&gt; 容器</span></span><br><span class=\"line\"><span class=\"comment\"># docker cp &lt;host_path&gt; &lt;container_id | container_name&gt;:&lt;container_path&gt;</span></span><br><span class=\"line\">docker <span class=\"built_in\">cp</span> ./docker-command-container.md nginx:/tmp</span><br><span class=\"line\"><span class=\"comment\"># 容器 -&gt; 宿主机</span></span><br><span class=\"line\"><span class=\"comment\"># docker cp &lt;container_id | container_name&gt;:&lt;container_path&gt; &lt;host_path&gt;</span></span><br><span class=\"line\">docker <span class=\"built_in\">cp</span> nginx:/tmp/docker-command-container.md ./</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-rm-删除容器\"><code>docker rm</code> : 删除容器</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除指定容器</span></span><br><span class=\"line\">docker <span class=\"built_in\">rm</span> &lt;container_id | container_name&gt;</span><br><span class=\"line\"><span class=\"comment\"># 删除所有容器</span></span><br><span class=\"line\">docker <span class=\"built_in\">rm</span> $(docker ps -aq)</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-container-prune-删除所有停止的容器\"><code>docker container prune</code> : 删除所有停止的容器</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container prune</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-update-更新容器配置\"><code>docker update</code> : 更新容器配置</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 更新指定容器的CPU核数和内存大小</span></span><br><span class=\"line\">docker update --cpus=2 --memory=2g &lt;container_id | container_name&gt;</span><br><span class=\"line\"><span class=\"comment\"># 更新指定容器自动重启</span></span><br><span class=\"line\">docker update --restart=always &lt;container_id | container_name&gt;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>并不是所有的配置都支持更新，update 命令只支持如下配置，基本上也就只能调一下cpu和内存，以及自动重启策略，所以制作容器时一定要做好规划。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数名</th>\n<th>说明</th>\n<th>示例值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>--blkio-weight</code></td>\n<td>设置 Block IO 的相对权重，范围是 10 到 1000，设置为 0 表示禁用（默认值为 0）</td>\n<td><code>--blkio-weight=500</code></td>\n</tr>\n<tr>\n<td><code>--cpu-period</code></td>\n<td>设置 CPU CFS（完全公平调度器）的周期限制（单位：微秒）</td>\n<td><code>--cpu-period=100000</code></td>\n</tr>\n<tr>\n<td><code>--cpu-quota</code></td>\n<td>设置 CPU CFS 的配额限制（单位：微秒）</td>\n<td><code>--cpu-quota=50000</code></td>\n</tr>\n<tr>\n<td><code>--cpu-rt-period</code></td>\n<td>设置实时 CPU 的调度周期（单位：微秒）</td>\n<td><code>--cpu-rt-period=1000000</code></td>\n</tr>\n<tr>\n<td><code>--cpu-rt-runtime</code></td>\n<td>设置实时 CPU 的运行时间限制（单位：微秒）</td>\n<td><code>--cpu-rt-runtime=950000</code></td>\n</tr>\n<tr>\n<td><code>-c</code>, <code>--cpu-shares</code></td>\n<td>设置 CPU 共享权重，默认值为 1024</td>\n<td><code>--cpu-shares=512</code></td>\n</tr>\n<tr>\n<td><code>--cpus</code></td>\n<td>限制容器使用的 CPU 数量（支持小数）</td>\n<td><code>--cpus=1.5</code></td>\n</tr>\n<tr>\n<td><code>--cpuset-cpus</code></td>\n<td>指定容器可以在哪些 CPU 上运行（如 0-3、0,1）</td>\n<td><code>--cpuset-cpus=&quot;0,1&quot;</code></td>\n</tr>\n<tr>\n<td><code>--cpuset-mems</code></td>\n<td>指定容器可以使用哪些内存节点（如 0-3、0,1），适用于 NUMA 系统</td>\n<td><code>--cpuset-mems=&quot;0&quot;</code></td>\n</tr>\n<tr>\n<td><code>-m</code>, <code>--memory</code></td>\n<td>设置内存限制（例如 512m、2g）</td>\n<td><code>--memory=1g</code></td>\n</tr>\n<tr>\n<td><code>--memory-reservation</code></td>\n<td>设置内存软限制（低于 <code>--memory</code> 的值时，允许系统在压力较小时回收）</td>\n<td><code>--memory-reservation=512m</code></td>\n</tr>\n<tr>\n<td><code>--memory-swap</code></td>\n<td>设置 swap 限制（内存 + swap 总和），设为 -1 表示无限制</td>\n<td><code>--memory-swap=2g</code></td>\n</tr>\n<tr>\n<td><code>--pids-limit</code></td>\n<td>设置容器的最大进程数量，设为 -1 表示无限制</td>\n<td><code>--pids-limit=100</code></td>\n</tr>\n<tr>\n<td><code>--restart</code></td>\n<td>设置容器退出后的重启策略</td>\n<td><code>--restart=always</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"docker-stats-显示容器的实时资源使用情况\"><code>docker stats</code> : 显示容器的实时资源使用情况</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 显示所有容器的实时资源使用情况</span></span><br><span class=\"line\">docker stats</span><br><span class=\"line\"><span class=\"comment\">## 输出</span></span><br><span class=\"line\">CONTAINER ID   NAME         CPU %     MEM USAGE / LIMIT     MEM %     NET I/O           BLOCK I/O     PIDS</span><br><span class=\"line\">15caf520e3a5   nginx        0.00%     10.22MiB / 7.752GiB   0.13%     6.38kB / 2.61kB   0B / 28.7kB   13</span><br><span class=\"line\">b680087420b8   dockge       0.01%     199.5MiB / 7.752GiB   2.51%     6.44kB / 1.48kB   94.8MB / 0B   24</span><br><span class=\"line\">861dd9c1475f   remote-api   0.00%     4.188MiB / 7.752GiB   0.05%     2.77kB / 126B     3.31MB / 0B   1</span><br><span class=\"line\"><span class=\"comment\">### CONTAINER ID 与 NAME：容器 ID 与名称。</span></span><br><span class=\"line\"><span class=\"comment\">### CPU % 与 MEM %：容器使用的 CPU 和内存的百分比。</span></span><br><span class=\"line\"><span class=\"comment\">### MEM USAGE / LIMIT：容器正在使用的总内存，以及允许使用的内存总量。</span></span><br><span class=\"line\"><span class=\"comment\">### NET I/O：容器通过其网络接口发送和接收的数据量。</span></span><br><span class=\"line\"><span class=\"comment\">### BLOCK I/O：容器从主机上的块设备读取和写入的数据量。</span></span><br><span class=\"line\"><span class=\"comment\">### PIDs：容器创建的进程或线程数。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 列出所有容器的资源使用情况，包括运行和停止的</span></span><br><span class=\"line\">docker stats -a</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 展示当前状态就直接退出了，不再实时更新。</span></span><br><span class=\"line\">docker stats --no-stream</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定输出模板，这里加不加 table 都可以</span></span><br><span class=\"line\">docker stats --no-stream --format <span class=\"string\">&quot;table &#123;&#123;.Name&#125;&#125;\\t&#123;&#123;.CPUPerc&#125;&#125;\\t&#123;&#123;.MemUsage&#125;&#125;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出json格式</span></span><br><span class=\"line\">docker stats --no-stream --format json</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定容器</span></span><br><span class=\"line\">docker stats &lt;container_id | container_name&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-top-查看正在运行的进程\"><code>docker top</code> :  查看正在运行的进程</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># docker top &lt;container_id | container_name&gt; [ps options]</span></span><br><span class=\"line\">docker top nginx</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-port-列出指定的容器的端口映射\"><code>docker port</code> : 列出指定的容器的端口映射</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># docker port &lt;container_id | container_name&gt;</span></span><br><span class=\"line\">$ docker port nginx</span><br><span class=\"line\">80/tcp -&gt; 0.0.0.0:8081</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-diff-列出容器运行时对文件系统的修改\"><code>docker diff</code> : 列出容器运行时对文件系统的修改</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># docker diff &lt;container_id | container_name&gt;</span></span><br><span class=\"line\">$ docker diff nginx</span><br><span class=\"line\">C /root</span><br><span class=\"line\">A /root/.bash_history</span><br><span class=\"line\">C /run</span><br><span class=\"line\">A /run/nginx.pid</span><br><span class=\"line\">C /tmp</span><br><span class=\"line\">A /tmp/demo.py</span><br><span class=\"line\">C /var</span><br><span class=\"line\">C /var/cache</span><br><span class=\"line\">C /var/cache/nginx</span><br><span class=\"line\">A /var/cache/nginx/client_temp</span><br><span class=\"line\">A /var/cache/nginx/fastcgi_temp</span><br><span class=\"line\">A /var/cache/nginx/proxy_temp</span><br><span class=\"line\">A /var/cache/nginx/scgi_temp</span><br><span class=\"line\">A /var/cache/nginx/uwsgi_temp</span><br><span class=\"line\">C /etc</span><br><span class=\"line\">C /etc/nginx</span><br><span class=\"line\">C /etc/nginx/conf.d</span><br><span class=\"line\">C /etc/nginx/conf.d/default.conf</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>前缀含义说明：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>标志</th>\n<th>含义</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>A</code></td>\n<td><strong>Added（新增）</strong></td>\n<td>文件或目录是容器运行后新增的</td>\n</tr>\n<tr>\n<td><code>C</code></td>\n<td><strong>Changed（修改）</strong></td>\n<td>文件或目录是已有的，但内容或元数据（如权限、时间戳等）被修改了</td>\n</tr>\n<tr>\n<td><code>D</code></td>\n<td><strong>Deleted（删除）</strong></td>\n<td>文件或目录是存在于原镜像中的，但在容器中被删除</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"docker-commit-从容器创建一个新的镜像\"><code>docker commit</code> : 从容器创建一个新的镜像</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># docker commit &lt;container_id | container_name&gt; [image_name[:tag]]</span></span><br><span class=\"line\">docker commit nginx nginx:v1.0</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-export-导出容器内容为-tar-文件\"><code>docker export</code> : 导出容器内容为 tar 文件</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">export</span> nginx &gt; nginx.tar</span><br><span class=\"line\">dcoker <span class=\"built_in\">export</span> -o nginx.tar nginx</span><br><span class=\"line\">docker <span class=\"built_in\">export</span> nginx | gzip &gt; nginx.tar.gz</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Docker Export / Save / Commit 命令对比与导入方式一览表</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>操作对象</th>\n<th>输出内容</th>\n<th>是否包含历史层（镜像层）</th>\n<th>是否保留元数据（标签、命令等）</th>\n<th>典型用途</th>\n<th>导入命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>docker export</code></td>\n<td><strong>容器</strong></td>\n<td>容器的文件系统（tar 归档）</td>\n<td>❌ 否</td>\n<td>❌ 否</td>\n<td>备份容器文件系统或迁移容器状态</td>\n<td><code>docker import &lt;tar&gt; &lt;image:tag&gt;</code></td>\n</tr>\n<tr>\n<td><code>docker save</code></td>\n<td><strong>镜像</strong></td>\n<td>镜像的完整内容（含所有层的 tar）</td>\n<td>✅ 是</td>\n<td>✅ 是</td>\n<td>分发或备份镜像</td>\n<td><code>docker load &lt; &lt;tar&gt;</code></td>\n</tr>\n<tr>\n<td><code>docker commit</code></td>\n<td><strong>容器</strong></td>\n<td>创建一个新的镜像</td>\n<td>✅ 是（但只一层）</td>\n<td>✅ 是</td>\n<td>将当前容器状态打包成新镜像</td>\n<td>不适用（直接生成镜像）</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍 Docker 命令 中 容器管理 相关命令 Docker官方文档 容器的生命周期 容器可能处于以下几种状态： 初建（created） 运行（running） 暂停（paused） 停止（stopped） 删除（deleted） 各生命周期之间的转换关系如图所示： 命令/情况 说明 容器状态变更 docker create 创建容器后，不立即启动运行，容器进入初建状态 初建状态 docker run 创建容器，并立即启动运行，进入运行状态 初建 → 运行 docker start 启动已创建的容器，容器转为运行状态 停止 → 运行 docker stop 停止正在运行的容器，容器转入停止状态 运行 → 停止 docker kill 强制终止容器，相当于“断电”，容易丢失数据，不建议轻易使用 运行 → 停止（非正常） docker restart 重启容器，容器重新进入运行状态 运行 → 停止 → 运行 docker pause 暂停容器内所有进程，容器进入暂停状态 运行 → 暂停 docker unpause 取消暂停状态，容器恢复运行 暂停 → 运行 docker rm 删除容器，容器转入删除状态 任意 → 删除 Killed by out-of-memory (OOM) 宿主机内存耗尽，容器被系统终止，此为非计划终止；建议杀死内存占用最高的容器 运行 → 停止（异常） Container process exited 容器进程异常终止后，进入“是否重启”判断流程：是则执行 start 进入运行；否则保持停止状态 异常 → 停止或运行 docker container : 容器管理 docker container --help 命令 说明 别名 attach 将本地的标准输入、输出和错误流附加到一个正在运行的容器上 docker attach commit 根据容器的更改创建一个新的镜像 docker commit cp 在容器和本地文件系统之间复制文件/文件夹 docker cp create 创建一个新的容器 docker create diff 检查容器文件系统上的文件或目录的更改 docker diff exec 在正在运行的容器中执行命令 docker exec export 将容器的文件系统导出为 tar 归档文件 docker export inspect 显示一个或多个容器的详细信息 可以使用 docker inspect kill 终止一个或多个正在运行的容器 docker kill logs 获取容器的日志 docker logs ls 列出容器 docker ps pause 暂停一个或多个容器内的所有进程 docker pause port 列出容器的端口映射或特定的端口映射 docker port prune 删除所有已停止的容器 rename 重命名一个容器 docker rename restart 重启一个或多个容器 docker restart rm 删除一个或多个容器 docker rm run 根据镜像创建并运行一个新容器 docker run start 启动一个或多个已停止的容器 docker start stats 实时显示容器资源使用统计信息 docker stats stop 停止一个或多个正在运行的容器 docker stop top 显示容器中运行的进程 docker top unpause 取消暂停一个或多个容器内的所有进程 docker unpause update 更新一个或多个容器的配置 docker update wait 阻塞直到一个或多个容器停止，然后打印其退出代码 docker wait 运行 docker container COMMAND --help 可获取某个命令的更多信息。 docker create : 创建容器，但不启动 1234567$ docker create \\ --name my-container \\ # 容器名 -e MY_ENV_VAR=my-value \\ # 设置环境变量 -p 80:80 \\ # 映射端口，格式：宿主机端口:容器端口 -v /path/to/my/dir:/path/in/container \\ # 映射目录，格式：宿主机目录:容器目录，都必须是绝对路径 --restart always \\ # 设置重启策略 nginx:latest \\ # 镜像名，镜像不存在时会自动下载 docker create 与 docker run 的参数基本一致，具体查看下面 docker run 中的介绍。 docker start : 启动一个容器 启动一个容器，容器必须已经创建，并且处于停止状态。 12# 语法：docker start &lt;container_id|container_name&gt;$ docker start my-container docker run : 创建并启动一个容器 相当于docker create + docker start 常用参数说明 参数 说明 示例 -d, --detach 后台运行容器（即“守护态”），run独有 docker run -d nginx -it 交互式运行容器并分配终端（常用于调试） docker run -it ubuntu bash --name 指定容器名称 docker run --name my-nginx nginx --rm 容器退出时自动删除 docker run --rm ubuntu -p, --publish 端口映射（宿主机:容器） docker run -p 8080:80 nginx -P, --publish-all 自动随机映射容器内部所有暴露端口到宿主机端口 docker run -P nginx -v, --volume 挂载卷（宿主机目录:容器目录） docker run -v /data:/app/data myapp --mount 更灵活的挂载方式（推荐新项目使用） docker run --mount type=bind,source=/host,target=/container nginx --env, -e 设置环境变量 docker run -e ENV=prod myapp --env-file 从文件中加载多个环境变量 docker run --env-file .env myapp --network 设置容器使用的网络模式 docker run --network host myapp --restart 设置容器的自动重启策略 docker run --restart=always myapp --privileged 给予容器更多的权限（如访问 host 设备） docker run --privileged myapp --entrypoint 覆盖镜像默认的 ENTRYPOINT docker run --entrypoint /bin/bash myapp -u, --user 指定容器内运行的用户（格式：UID 或 UID:GID） docker run --user 1000:1000 myapp -c, --cpu-shares 设置 CPU 权重（相对值） docker run --cpu-shares=512 myapp -m, --memory 限制容器最大内存（如 512m, 1g） docker run --memory=512m myapp -h, --hostname 设置容器主机名 docker run -h myhost myapp --link(更推荐使用 --network) 创建链接到其他容器 docker run --link myapp:app myapp2 --cpus 限制容器使用的CPU核数 docker run --cpus=&quot;1.5&quot; -p, --publish 端口映射 1docker run -p [主机IP:]主机端口:容器端口[/协议] 示例 含义说明 -p 8080:80 将主机的 8080 端口映射到容器的 80 端口（默认 TCP） -p 127.0.0.1:8080:80 仅将主机本地 IP（127.0.0.1）的 8080 映射到容器的 80 端口（外部无法访问） -p 8080:80/tcp 显式指定协议为 TCP（等同于不加 /tcp） -p 8080:80/udp 映射 UDP 协议端口（如 DNS 服务等） -p 8080 宿主机随机端口映射到容器的8080端口 -p 3000-3006:4000-4006 范围映射，不能映射非对称范围（如 3000-3006:4000-4006），只能一一对应 多个 -p 可以多次使用 -p，映射多个端口。例如：-p 80:80 -p 443:443 -v, --volume 数据卷映射 123456789101112131415161718docker run -v &lt;本地路径&gt;:&lt;容器路径&gt;[:权限] # &lt;本地路径&gt; 主机上的路径（绝对路径，或命名卷），目录不存在会自动创建 # &lt;容器路径&gt; 容器内的路径，目录不存在会自动创建 # [:权限] 可选：ro（只读） 或 rw（读写，默认）# 示例# 挂载本地目录到容器docker run -v /data:/app/data myapp# 挂载为只读docker run -v /data:/app/data:ro myapp# 挂载多个数据卷docker run -v /data1:/app/data1 -v /data2:/app/data2 myapp# 使用命名卷docker volume create mydatadocker run -v mydata:/app/data myapp --mount 挂载卷 12# --mount 是 Docker 推荐使用的 现代挂载方式，功能和 -v（或 --volume）类似，但语法更清晰、结构更规范，适用于卷（volume）、绑定挂载（bind）和临时挂载（tmpfs）。docker run --mount type=&lt;类型&gt;,source=&lt;主机路径或卷名&gt;,target=&lt;容器路径&gt;[,readonly] 三种挂载类型对比 类型 (type) 用途 示例 source volume 使用 Docker 管理的卷 卷名，如 mydata bind 挂载宿主机的实际路径 绝对路径，如 /home/user/app/config tmpfs 挂载内存中的临时文件系统 无需指定 source 12345678910# 使用命名卷挂载（推荐方式）,这里 --target 指定容器内的挂载点，也可以替换为 --destinationdocker run --mount type=volume,source=mydata,target=/app/data myapp# 使用本地路径挂载（绑定挂载）,source指定的本地路径必须存在docker run --mount type=bind,source=/home/user/app/config,target=/app/config myapp# 只读挂载，readonly 可以简写为 rodocker run --mount type=bind,source=/home/user/app/config,target=/app/config,readonly myapp# 使用内存中的临时文件系统挂载，数据不会持久化，只存储在容器运行时的内存中docker run --mount type=tmpfs,target=/app/tmpfs myapp --link 容器间链接 用于在容器之间建立连接，使一个容器可以通过另一个容器的名称访问其网络信息（如 IP、环境变量等）。 注意：--link 已被弃用，建议使用 --network 来实现容器间链接。 12345678910111213141516docker run --link &lt;目标容器名&gt;:&lt;别名&gt; &lt;其他参数&gt; &lt;镜像名&gt;## 示例# 场景：一个 web 容器想要连接另一个运行中的 db 容器# 先启动数据库容器docker run -d --name db mysql# 启动 web 容器并连接到 db 容器docker run -it --rm --name web --link db:mydb ubuntu bash# 在 web 容器中，现在你可以用 mydb 来访问 db 容器，但反过来 db 容器无法访问 web 容器docker exec web ping mydb## 改用 --network 实现docker network create mynetdocker run -d --name db --network mynet mysqldocker run -it --rm --name web --network mynet ubuntu bashdocker exec web ping db --network 网络模式类型 类型 含义 特点/适用场景 是否允许端口映射 bridge 默认网络类型（用户自定义或 Docker 默认桥接网络） 容器通过虚拟网桥连接，可相互通信；适用于单主机部署 ✅ 是 host 容器与宿主机共享网络栈 没有网络隔离，容器使用宿主机的 IP 和端口，性能高，适合对网络要求高的服务 ❌ 否 none 容器没有网络接口 完全隔离；适用于需要完全控制网络的场景或测试网络不可达性 ❌ 否 &lt;user-defined&gt; 用户自定义的网络名称，通过 docker network create 创建 支持容器名称互解析（DNS），适合多容器通信场景，如 Docker Compose ✅ 是 container:&lt;name|id&gt; 与另一个容器共享网络命名空间 两个容器共享 IP 和端口，适用于主-辅容器模式，如 sidecar 容器共享主容器网络 ❌ 否 123456789101112131415# 使用默认 bridge 网络docker run -p 8080:80 --network bridge --name my-nginx nginx# 与宿主机共享网络，不能使用-pdocker run --network host nginx# 不使用任何网络，不能使用-pdocker run --network none nginx# 使用已创建的自定义网络，相同网络命名空间下的容器，可以通过容器 名称或ID 互相访问docker network create nginx_netdocker run -p 8080:80 --network nginx_net nginx# 与另一个容器共享网络命名空间，不能使用-p，并且此时新启动的容器占用的端口不能与要连接的容器端口一致，否则将启动失败docker run --network container:my-nginx busybox --restart 重启策略 策略 含义 no（默认） 容器退出后不会自动重启 always 无论退出状态码如何，容器总是自动重启 unless-stopped 容器总是自动重启，除非用户手动停止它 on-failure[:N] 仅在容器非 0 状态码退出时自动重启（可选设置最大重启次数 N） 1234567891011# 容器非正常退出时自动重启docker run --restart on-failure my-app# 最多重启 5 次docker run --restart on-failure:5 my-app# 总是重启（即使你重启 Docker 服务后）docker run --restart always my-app# 除非手动停止，否则一直重启docker run --restart unless-stopped my-app --cpu-shares : 设置容器的 CPU 相对权重，即在 CPU 资源竞争时的相对优先级，默认值为 1024。 12345678910111213# 容器1，权重 1024（默认）docker run -d --name c1 --cpu-shares 1024 nginx# 容器2，权重 512（优先级低）docker run -d --name c2 --cpu-shares 512 nginx## 说明： # c1的权重1024，c2的权重512,不是绝对限制，而是分配比例 # 该权重表示容器在 CPU 竞争下，权重越高则优先级越高，会尽可能使用 CPU 资源。 # 如果这两个容器都运行在 CPU 忙碌的环境下(只有在 多容器共享 CPU 且竞争资源 的情况下才生效)： # c1 将获得大约 2/3 的 CPU 时间 # c2 将获得大约 1/3 的 CPU 时间 # 如果系统 CPU 空闲，所有容器都可以使用 100% 的 CPU。 docker run 示例 12345678910111213# 启动一个nginx 容器docker run -d -p 80:80 --name nginx nginx# 替换nginx镜像默认的启动命令，nginx 镜像默认启动 nginx 服务，此命令会改为执行 nginx -v 显示版本号docker run --name test_nginx --entrypoint &quot;&quot; nginx nginx -v# 执行脚本或命令，这里添加 --rm 参数，表示运行结束后自动删除容器，这里是安装 ping 命令docker run --rm ubuntu bash -c &quot;apt update &amp;&amp; apt install -y iputils-ping&quot;# 交互式执行 shell 命令，执行命令后会进入容器的shelldocker run --rm -it ubuntu /bin/bash# 这样也可以，因为 ubuntu 的默认启动命令是 /bin/bashdocker run --rm -it ubuntu# 转到后台运行docker run --rm -itd ubuntu docker stop : 停止容器，容器优雅退出 12345678# 停止容器，通过容器名称docker stop test_nginx# 停止容器，通过容器IDdocker stop 5d7c0c5d5c0c# 停止所有正在运行的容器docker stop $(docker ps -q)# 等待5秒后强制关闭docker stop -t 5 test_nginx docker kill : 强制停止容器 当容器完全卡死、挂起、不响应 stop 命令时使用 123docker kill test_nginxdocker kill 5d7c0c5d5c0cdocker kill $(docker ps -q) docker restart : 重启容器 123docker restart test_nginxdocker restart 5d7c0c5d5c0cdocker restart $(docker ps -q) docker pause : 暂停容器 暂停后宿主机将不再为容器分配CPU时间片，但内存依然有效，你可以理解为此时为容器保存了快照 123docker pause test_nginxdocker pause 5d7c0c5d5c0cdocker pause $(docker ps -q) docker unpause : 恢复容器 123docker unpause test_nginxdocker unpause 5d7c0c5d5c0cdocker unpause $(docker ps -q) docker ps : 查看容器列表 1234567891011121314# 显示所有正在运行的容器docker ps# 显示所有容器docker ps -a# 显示所有正在运行的容器的IDdocker ps -q# 不截断输出，此时 COMMAND 列会显示完整的命令docker ps -notrunc# 显示最近创建的5条容器docker ps -n 5# 过滤器，显示状态为exited的容器docker ps -a --filter &quot;status=exited&quot;# 指定模板，只显示 ID 和 Namesdocker ps --format &quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Names&#125;&#125;&quot; docker inspect : 查看容器信息 12345678910111213141516# 查看容器信息docker inspect &lt;container_id&gt;# 获取容器名称docker inspect --format=&#x27;&#123;&#123;.Name&#125;&#125;&#x27; &lt;container_id | container_name&gt;# 获取容器镜像docker inspect --format=&#x27;&#123;&#123;.Config.Image&#125;&#125;&#x27; &lt;container_id | container_name&gt;# 获取容器环境变量docker inspect --format=&#x27;&#123;&#123;.Config.Env&#125;&#125;&#x27; &lt;container_id | container_name&gt;# 获取容器状态，前面的 json 表示输出为 json 格式docker inspect --format=&#x27;&#123;&#123;json .State&#125;&#125;&#x27; &lt;container_id | container_name&gt;# 获取容器内存限制docker inspect --format=&#x27;&#123;&#123;.HostConfig.Memory&#125;&#125;&#x27; &lt;container_id | container_name&gt;# 获取容器labeldocker inspect --format=&#x27;&#123;&#123;json .Config.Labels&#125;&#125;&#x27; &lt;container_id | container_name&gt;# 获取容器的网络信息docker inspect --format=&#x27;&#123;&#123;json .NetworkSettings&#125;&#125;&#x27; &lt;container_id | container_name&gt; docker logs : 获取容器日志 12345678910111213141516# 获取容器日志docker logs &lt;container_id | container_name&gt;# 获取容器实时日志docker logs -f &lt;container_id | container_name&gt;# 获取容器最新的 10 行日志docker logs -n 10 &lt;container_id | container_name&gt;# 获取容器的带时间戳的日志docker logs -t &lt;container_id | container_name&gt;# 获取容器的日志，从 1 小时前开始docker logs --since 1h &lt;container_id | container_name&gt;# 获取容器的日志，直到 1 小时前docker logs --until 1h &lt;container_id | container_name&gt;# 获取容器的详细日志docker logs --details &lt;container_id | container_name&gt;# 获取容器的日志，从 2 小时前开始，直到 1 小时前docker logs --since 2h --until 1h &lt;container_id | container_name&gt; docker exec : 在已经运行的容器中执行命令 1234# 在已经运行的容器中执行命令docker exec &lt;container_id | container_name&gt; &lt;command&gt;# 进入容器shelldocker exec -it &lt;container_id | container_name&gt; bash docker rename : 重命名容器 1docker rename &lt;old_container_name&gt; &lt;new_container_name&gt; docker cp : 容器与宿主机间复制文件 123456# 宿主机 -&gt; 容器# docker cp &lt;host_path&gt; &lt;container_id | container_name&gt;:&lt;container_path&gt;docker cp ./docker-command-container.md nginx:/tmp# 容器 -&gt; 宿主机# docker cp &lt;container_id | container_name&gt;:&lt;container_path&gt; &lt;host_path&gt;docker cp nginx:/tmp/docker-command-container.md ./ docker rm : 删除容器 1234# 删除指定容器docker rm &lt;container_id | container_name&gt;# 删除所有容器docker rm $(docker ps -aq) docker container prune : 删除所有停止的容器 1docker container prune docker update : 更新容器配置 1234# 更新指定容器的CPU核数和内存大小docker update --cpus=2 --memory=2g &lt;container_id | container_name&gt;# 更新指定容器自动重启docker update --restart=always &lt;container_id | container_name&gt; 并不是所有的配置都支持更新，update 命令只支持如下配置，基本上也就只能调一下cpu和内存，以及自动重启策略，所以制作容器时一定要做好规划。 参数名 说明 示例值 --blkio-weight 设置 Block IO 的相对权重，范围是 10 到 1000，设置为 0 表示禁用（默认值为 0） --blkio-weight=500 --cpu-period 设置 CPU CFS（完全公平调度器）的周期限制（单位：微秒） --cpu-period=100000 --cpu-quota 设置 CPU CFS 的配额限制（单位：微秒） --cpu-quota=50000 --cpu-rt-period 设置实时 CPU 的调度周期（单位：微秒） --cpu-rt-period=1000000 --cpu-rt-runtime 设置实时 CPU 的运行时间限制（单位：微秒） --cpu-rt-runtime=950000 -c, --cpu-shares 设置 CPU 共享权重，默认值为 1024 --cpu-shares=512 --cpus 限制容器使用的 CPU 数量（支持小数） --cpus=1.5 --cpuset-cpus 指定容器可以在哪些 CPU 上运行（如 0-3、0,1） --cpuset-cpus=&quot;0,1&quot; --cpuset-mems 指定容器可以使用哪些内存节点（如 0-3、0,1），适用于 NUMA 系统 --cpuset-mems=&quot;0&quot; -m, --memory 设置内存限制（例如 512m、2g） --memory=1g --memory-reservation 设置内存软限制（低于 --memory 的值时，允许系统在压力较小时回收） --memory-reservation=512m --memory-swap 设置 swap 限制（内存 + swap 总和），设为 -1 表示无限制 --memory-swap=2g --pids-limit 设置容器的最大进程数量，设为 -1 表示无限制 --pids-limit=100 --restart 设置容器退出后的重启策略 --restart=always docker stats : 显示容器的实时资源使用情况 12345678910111213141516171819202122232425262728# 显示所有容器的实时资源使用情况docker stats## 输出CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS15caf520e3a5 nginx 0.00% 10.22MiB / 7.752GiB 0.13% 6.38kB / 2.61kB 0B / 28.7kB 13b680087420b8 dockge 0.01% 199.5MiB / 7.752GiB 2.51% 6.44kB / 1.48kB 94.8MB / 0B 24861dd9c1475f remote-api 0.00% 4.188MiB / 7.752GiB 0.05% 2.77kB / 126B 3.31MB / 0B 1### CONTAINER ID 与 NAME：容器 ID 与名称。### CPU % 与 MEM %：容器使用的 CPU 和内存的百分比。### MEM USAGE / LIMIT：容器正在使用的总内存，以及允许使用的内存总量。### NET I/O：容器通过其网络接口发送和接收的数据量。### BLOCK I/O：容器从主机上的块设备读取和写入的数据量。### PIDs：容器创建的进程或线程数。# 列出所有容器的资源使用情况，包括运行和停止的docker stats -a# 展示当前状态就直接退出了，不再实时更新。docker stats --no-stream# 指定输出模板，这里加不加 table 都可以docker stats --no-stream --format &quot;table &#123;&#123;.Name&#125;&#125;\\t&#123;&#123;.CPUPerc&#125;&#125;\\t&#123;&#123;.MemUsage&#125;&#125;&quot;# 输出json格式docker stats --no-stream --format json# 指定容器docker stats &lt;container_id | container_name&gt; docker top : 查看正在运行的进程 12# docker top &lt;container_id | container_name&gt; [ps options]docker top nginx docker port : 列出指定的容器的端口映射 123# docker port &lt;container_id | container_name&gt;$ docker port nginx80/tcp -&gt; 0.0.0.0:8081 docker diff : 列出容器运行时对文件系统的修改 1234567891011121314151617181920# docker diff &lt;container_id | container_name&gt;$ docker diff nginxC /rootA /root/.bash_historyC /runA /run/nginx.pidC /tmpA /tmp/demo.pyC /varC /var/cacheC /var/cache/nginxA /var/cache/nginx/client_tempA /var/cache/nginx/fastcgi_tempA /var/cache/nginx/proxy_tempA /var/cache/nginx/scgi_tempA /var/cache/nginx/uwsgi_tempC /etcC /etc/nginxC /etc/nginx/conf.dC /etc/nginx/conf.d/default.conf 前缀含义说明： 标志 含义 说明 A Added（新增） 文件或目录是容器运行后新增的 C Changed（修改） 文件或目录是已有的，但内容或元数据（如权限、时间戳等）被修改了 D Deleted（删除） 文件或目录是存在于原镜像中的，但在容器中被删除 docker commit : 从容器创建一个新的镜像 12# docker commit &lt;container_id | container_name&gt; [image_name[:tag]]docker commit nginx nginx:v1.0 docker export : 导出容器内容为 tar 文件 123docker export nginx &gt; nginx.tardcoker export -o nginx.tar nginxdocker export nginx | gzip &gt; nginx.tar.gz Docker Export / Save / Commit 命令对比与导入方式一览表 命令 操作对象 输出内容 是否包含历史层（镜像层） 是否保留元数据（标签、命令等） 典型用途 导入命令 docker export 容器 容器的文件系统（tar 归档） ❌ 否 ❌ 否 备份容器文件系统或迁移容器状态 docker import &lt;tar&gt; &lt;image:tag&gt; docker save 镜像 镜像的完整内容（含所有层的 tar） ✅ 是 ✅ 是 分发或备份镜像 docker load &lt; &lt;tar&gt; docker commit 容器 创建一个新的镜像 ✅ 是（但只一层） ✅ 是 将当前容器状态打包成新镜像 不适用（直接生成镜像）","summary":"摘要 本文介绍 Docker 命令 中 容器管理 相关命令 Docker官方文档","date_published":"2025-05-27T13:30:05.000Z","tags":["技术","docker","docker"]},{"id":"https://blog.hanqunfeng.com/2025/05/26/docker-dockerfile/","url":"https://blog.hanqunfeng.com/2025/05/26/docker-dockerfile/","title":"Docker 命令 之 Dockerfile","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍 Docker 命令 中 Dockerfile 的使用方法</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com\">Docker官方文档</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.docker.com/engine/reference/builder/\">Dockerfile官方文档</a></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Dockerfile-是什么？\">Dockerfile 是什么？</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Docker可以通过读取 <code>Dockerfile</code> 中的指令来自动构建镜像。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>Dockerfile</code> 是一个文本文档，其中包含用户可以在命令行上调用以组装镜像的所有指令。</p>\n</li>\n<li class=\"lvl-2\">\n<p>可以在Dockerfile中使用的指令：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>中文描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>ADD</strong></td>\n<td>将本地或远程的文件/目录添加到镜像中，支持自动解压 <code>.tar</code> 文件和使用 URL 下载远程资源。通常推荐使用 <code>COPY</code>，除非需要这些高级功能。</td>\n</tr>\n<tr>\n<td><strong>ARG</strong></td>\n<td>定义构建阶段使用的变量，可在 <code>docker build</code> 命令中通过 <code>--build-arg</code> 传入，变量仅在构建时有效，不会保留在最终镜像中。</td>\n</tr>\n<tr>\n<td><strong>CMD</strong></td>\n<td>指定容器默认执行的命令和参数，容器运行时若未指定命令，则使用该指令设置的命令。如果配置了多个<code>CMD</code>，则只有最后一个生效。和<code>ENTRYPOINT</code>共同使用时，作为传递给<code>ENTRYPOINT</code>的参数。可被 <code>docker run</code> 提供的命令覆盖。</td>\n</tr>\n<tr>\n<td><strong>COPY</strong></td>\n<td>将构建上下文中的文件或目录复制到镜像中。相比 <code>ADD</code> 更简单、安全，推荐优先使用。</td>\n</tr>\n<tr>\n<td><strong>ENTRYPOINT</strong></td>\n<td>指定容器启动时的主命令，不容易被 <code>docker run</code> 中的命令覆盖。可与 <code>CMD</code> 配合使用，用于提供默认参数。</td>\n</tr>\n<tr>\n<td><strong>ENV</strong></td>\n<td>设置环境变量，变量将在构建和容器运行时均可使用。例如：配置应用参数或系统路径等。</td>\n</tr>\n<tr>\n<td><strong>EXPOSE</strong></td>\n<td>声明容器运行时将开放的端口，仅用于文档说明或与容器编排工具配合，不会自动进行端口映射。</td>\n</tr>\n<tr>\n<td><strong>FROM</strong></td>\n<td>指定基础镜像，是 Dockerfile 的起点。也可以用于多阶段构建，通过多次使用 <code>FROM</code> 指令创建多个构建阶段。</td>\n</tr>\n<tr>\n<td><strong>HEALTHCHECK</strong></td>\n<td>定义容器健康检查命令，用于定期检测容器内部服务的健康状态，可结合容器编排系统实现故障自动恢复。</td>\n</tr>\n<tr>\n<td><strong>LABEL</strong></td>\n<td>为镜像添加键值对形式的元数据，例如版本、维护者、用途说明等，方便镜像管理与自动化处理。</td>\n</tr>\n<tr>\n<td><strong>MAINTAINER</strong></td>\n<td>（已弃用）用于指定镜像维护者信息，推荐改用 <code>LABEL</code> 来设置作者信息。</td>\n</tr>\n<tr>\n<td><strong>ONBUILD</strong></td>\n<td>定义一个触发指令，当当前镜像作为基础镜像被其他 Dockerfile 使用时自动执行。常用于基础镜像的预设行为。</td>\n</tr>\n<tr>\n<td><strong>RUN</strong></td>\n<td>执行一条命令并提交结果作为新镜像层，常用于安装软件包、复制文件、设置权限等构建操作。</td>\n</tr>\n<tr>\n<td><strong>SHELL</strong></td>\n<td>更改 Dockerfile 中后续 <code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code> 等指令的默认 shell（如使用 <code>sh</code> 或 <code>powershell</code>）。</td>\n</tr>\n<tr>\n<td><strong>STOPSIGNAL</strong></td>\n<td>设置容器终止时发送的系统信号（如 <code>SIGTERM</code>），用于优雅关闭应用。</td>\n</tr>\n<tr>\n<td><strong>USER</strong></td>\n<td>设置执行后续命令时所使用的用户和用户组，增强容器的安全性，避免使用 root 权限。</td>\n</tr>\n<tr>\n<td><strong>VOLUME</strong></td>\n<td>定义容器内的挂载点，用于持久化数据或与宿主机/其他容器共享数据。运行容器时可指定挂载路径。</td>\n</tr>\n<tr>\n<td><strong>WORKDIR</strong></td>\n<td>设置工作目录，相当于执行 <code>cd</code>，用于简化后续命令中的路径。若目录不存在则自动创建。</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>构建阶段指令：FROM, ARG, ENV, COPY, ADD, RUN, WORKDIR, LABEL, USER, SHELL, ONBUILD</p>\n</li>\n<li class=\"lvl-2\">\n<p>启动配置指令：CMD, ENTRYPOINT, HEALTHCHECK, EXPOSE, VOLUME, STOPSIGNAL</p>\n</li>\n</ul>\n<h2 id=\"Dockerfile-指令介绍\">Dockerfile 指令介绍</h2>\n<h3 id=\"FROM\">FROM</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>FROM 指令用于指定基础镜像（base image），是每一个 Dockerfile 中必须的第一条指令。所有后续指令都是基于这个基础镜像构建的。</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM &lt;image&gt;[:&lt;tag&gt;] [AS &lt;stage-name&gt;]</span><br><span class=\"line\"><span class=\"comment\"># 说明：</span></span><br><span class=\"line\"><span class=\"comment\">#   &lt;image&gt;：镜像名称（可以是本地已有的，也可以是从 Docker Hub 或其他镜像仓库拉取的）</span></span><br><span class=\"line\"><span class=\"comment\">#   [:&lt;tag&gt;]：镜像标签（可选，默认是 latest）</span></span><br><span class=\"line\"><span class=\"comment\">#   [AS &lt;stage-name&gt;]：为该构建阶段指定名称，用于多阶段构建</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用最新版本的镜像（默认标签是 latest）</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> node</span><br><span class=\"line\"><span class=\"comment\"># 使用指定的标签</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> node:<span class=\"number\">16.13</span>.<span class=\"number\">2</span>-alpine</span><br><span class=\"line\"><span class=\"comment\"># 使用私有镜像仓库</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> private.registry.com/my-image:latest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用多阶段构建</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> golang:<span class=\"number\">1.20</span> AS builder</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> go build -o myapp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> alpine:latest</span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> --from=builder /app/myapp /usr/local/bin/myapp</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> [<span class=\"string\">&quot;myapp&quot;</span>]</span></span><br><span class=\"line\"><span class=\"comment\">## 这里用了两个阶段：</span></span><br><span class=\"line\"><span class=\"comment\">###   builder 阶段用来编译应用；</span></span><br><span class=\"line\"><span class=\"comment\">###   alpine 阶段用来打包最终镜像，只包含编译好的二进制文件，减少体积。</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"WORKDIR\">WORKDIR</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>WORKDIR 指定了工作目录，即后续所有指令（如 RUN、CMD、ENTRYPOINT、COPY、ADD 等）所运行的当前路径（working directory）。</p>\n</li>\n<li class=\"lvl-2\">\n<p>如果目录不存在，Docker 会自动创建它。</p>\n</li>\n<li class=\"lvl-2\">\n<p>每个 WORKDIR 都会创建一层镜像（layer），所以不要重复设置无意义的路径。</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WORKDIR &lt;path&gt;</span><br><span class=\"line\"><span class=\"comment\"># 说明：</span></span><br><span class=\"line\"><span class=\"comment\">#   &lt;path&gt;：要切换的工作目录，可以是绝对路径或相对路径。</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 设置绝对路径</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 连续设置多个工作目录（逐层嵌套）</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /var</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> www</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> html</span></span><br><span class=\"line\"><span class=\"comment\"># 等同于:</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /var/www/html</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 避免在 RUN cd some_dir 后继续执行依赖路径的命令，因为 Docker 每一条指令都是新的 shell 实例，cd 不会跨指令保留，应该改用 WORKDIR。</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">cd</span> some_dir  <span class=\"comment\"># 错误</span></span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> some_dir <span class=\"comment\"># 正确</span></span></span><br></pre></td></tr></table></figure>\n<h3 id=\"ARG\">ARG</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ARG 用于在 构建镜像时（build-time）传入参数。这些参数只在 构建阶段有效，不会出现在最终镜像中，也不会在容器运行时被保留。</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ARG &lt;name&gt;[=&lt;default_value&gt;]</span><br><span class=\"line\"><span class=\"comment\"># 说明：</span></span><br><span class=\"line\"><span class=\"comment\">#   &lt;name&gt;：参数名称</span></span><br><span class=\"line\"><span class=\"comment\">#   [=&lt;default_value&gt;]：参数的默认值，如果未传入参数，则使用默认值，如果为设置default_value，则构建镜像时必须传递参数，--build-arg</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 定义一个参数，在构建镜像时必须传入参数，--build-arg APP_ENV=development</span></span><br><span class=\"line\"><span class=\"keyword\">ARG</span> APP_ENV</span><br><span class=\"line\"><span class=\"comment\"># 带默认值的 ARG</span></span><br><span class=\"line\"><span class=\"keyword\">ARG</span> APP_ENV=development</span><br><span class=\"line\"><span class=\"comment\"># 使用参数</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">echo</span> <span class=\"string\">&quot;当前环境：<span class=\"variable\">$&#123;APP_ENV&#125;</span>&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 与 FROM 一起用（从 Docker 17.05 起）</span></span><br><span class=\"line\"><span class=\"keyword\">ARG</span> BASE=ubuntu</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> $&#123;BASE&#125;:<span class=\"number\">22.04</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"ENV\">ENV</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ENV 指令用于在镜像构建过程中定义环境变量（Environment Variables）。这些变量可以在之后的构建步骤（比如 RUN、CMD 等）中使用，也会在容器运行时生效。</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 两种语法</span></span><br><span class=\"line\">ENV &lt;key&gt; &lt;value&gt;</span><br><span class=\"line\">ENV &lt;key&gt;=&lt;value&gt; ...</span><br><span class=\"line\"><span class=\"comment\"># 说明：</span></span><br><span class=\"line\"><span class=\"comment\">#   &lt;key&gt;：环境变量的名称</span></span><br><span class=\"line\"><span class=\"comment\">#   &lt;value&gt;：环境变量的值</span></span><br><span class=\"line\"><span class=\"comment\"># 如果定义多个变量，推荐使用 key=value 的形式。</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 定义一个环境变量</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> APP_ENV=production</span><br><span class=\"line\"><span class=\"comment\"># 定义多个变量</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> APP_PORT=<span class=\"number\">8080</span> NODE_ENV=production</span><br><span class=\"line\"><span class=\"comment\"># 使用多行格式（提高可读性）</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> PATH=<span class=\"string\">&quot;/usr/local/bin:$&#123;PATH&#125;&quot;</span> \\</span><br><span class=\"line\">    LANG=<span class=\"string\">&quot;en_US.UTF-8&quot;</span> \\</span><br><span class=\"line\">    TZ=<span class=\"string\">&quot;Asia/Shanghai&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 也可以分开定义</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> PATH=<span class=\"string\">&quot;/usr/local/bin:$PATH&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> LANG=<span class=\"string\">&quot;en_US.UTF-8&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> TZ=<span class=\"string\">&quot;Asia/Shanghai&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>注意：ENV 指令定义的环境变量在构建阶段和运行阶段都会生效，但运行阶段会覆盖构建阶段定义的变量。</p>\n</li>\n</ul>\n<h3 id=\"LABEL\">LABEL</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>LABEL 用于为镜像添加元数据标签，以 <code>key=value</code> 的形式存在。这些标签可以是作者信息、版本描述、用途说明、构建时间等。</p>\n</li>\n<li class=\"lvl-2\">\n<p>旧的 <code>MAINTAINER</code> 指令现在已被废弃，推荐使用 <code>LABEL</code> 来代替。</p>\n</li>\n<li class=\"lvl-2\">\n<p>每个 LABEL 都会创建一层镜像（layer），推荐一次设置多个。</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LABEL &lt;key&gt;=&lt;value&gt; [&lt;key&gt;=&lt;value&gt;...]</span><br><span class=\"line\"><span class=\"comment\"># 说明：</span></span><br><span class=\"line\"><span class=\"comment\">#   &lt;key&gt;：标签的键</span></span><br><span class=\"line\"><span class=\"comment\">#   &lt;value&gt;：标签的值</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 添加一个标签</span></span><br><span class=\"line\"><span class=\"keyword\">LABEL</span><span class=\"language-bash\"> maintainer=<span class=\"string\">&quot;yourname@example.com&quot;</span></span></span><br><span class=\"line\"><span class=\"comment\"># 换行格式（推荐）,以下标签符合 OCI（Open Container Initiative） 镜像规范</span></span><br><span class=\"line\"><span class=\"keyword\">LABEL</span><span class=\"language-bash\"> \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    org.opencontainers.image.title=<span class=\"string\">&quot;MyApp&quot;</span> \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    org.opencontainers.image.description=<span class=\"string\">&quot;演示项目&quot;</span> \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    org.opencontainers.image.version=<span class=\"string\">&quot;1.0.0&quot;</span> \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    org.opencontainers.image.authors=<span class=\"string\">&quot;zhangsan@example.com&quot;</span></span></span><br></pre></td></tr></table></figure>\n<h3 id=\"USER\">USER</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>USER 指令用于指定后续指令（如 RUN、CMD、ENTRYPOINT、COPY 等）以哪个用户身份来执行。</p>\n</li>\n<li class=\"lvl-2\">\n<p>默认情况下，Docker 容器中的命令以 root 用户运行，这虽然灵活但不安全。使用 USER 可以让我们切换到普通用户，从而提升容器的安全性，防止潜在的权限滥用。</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">USER &lt;user&gt;[:&lt;group&gt;]</span><br><span class=\"line\"><span class=\"comment\"># 说明：</span></span><br><span class=\"line\"><span class=\"comment\">#   &lt;user&gt;：用户名或 UID</span></span><br><span class=\"line\"><span class=\"comment\">#   [:&lt;group&gt;]：可选，用户组名或 GID</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 设置用户</span></span><br><span class=\"line\"><span class=\"keyword\">USER</span> appuser</span><br><span class=\"line\"><span class=\"comment\"># 设置用户组</span></span><br><span class=\"line\"><span class=\"keyword\">USER</span> appuser:appgroup</span><br><span class=\"line\"><span class=\"comment\"># 使用 UID 和 GID</span></span><br><span class=\"line\"><span class=\"keyword\">USER</span> <span class=\"number\">1000</span>:<span class=\"number\">1000</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果基础镜像中没有你想要的用户，需要在 Dockerfile 中手动创建</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建用户和组</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> groupadd -r appgroup &amp;&amp; useradd -r -g appgroup appuser</span></span><br><span class=\"line\"><span class=\"comment\"># 切换用户</span></span><br><span class=\"line\"><span class=\"keyword\">USER</span> appuser</span><br></pre></td></tr></table></figure>\n<h3 id=\"ADD\">ADD</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ADD 用于将本地文件或目录、远程文件（URL） 或 压缩包 复制到镜像中的指定位置。</p>\n</li>\n<li class=\"lvl-2\">\n<p>它的功能类似于 COPY，但比 COPY 多几个功能（解压、拉取远程文件等）。</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADD &lt;src&gt;... &lt;dest&gt;</span><br><span class=\"line\"><span class=\"comment\"># 说明：</span></span><br><span class=\"line\"><span class=\"comment\">#   &lt;src&gt;：要复制的文件或目录，可以是本地文件、远程 URL、压缩包等</span></span><br><span class=\"line\"><span class=\"comment\">#   &lt;dest&gt;：目标路径</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 从本地文件复制</span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"language-bash\"> app.jar /app.jar</span></span><br><span class=\"line\"><span class=\"comment\"># 复制多个</span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"language-bash\"> app1.jar app2.jar /app/</span></span><br><span class=\"line\"><span class=\"comment\"># 通配符</span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"language-bash\"> static-assets/*.html /app/public/</span></span><br><span class=\"line\"><span class=\"comment\"># 从远程 URL 复制</span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"language-bash\"> https://example.com/app.jar /app.jar</span></span><br><span class=\"line\"><span class=\"comment\"># 从压缩包中复制</span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"language-bash\"> static-assets.tar.gz /app/public/</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>最佳实践是优先使用 COPY，只有在需要 ADD 的额外功能时才使用它。</p>\n</li>\n</ul>\n<h3 id=\"COPY\">COPY</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>COPY 指令用于将主机上的文件或目录复制到镜像的文件系统中。它是构建镜像过程中最常用的数据引入方式之一。</p>\n</li>\n<li class=\"lvl-2\">\n<p>与 ADD 类似，但功能更简单、明确、安全</p>\n</li>\n<li class=\"lvl-2\">\n<p>推荐优先使用 COPY，除非你确实需要 ADD 提供的自动解压或远程下载功能。</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">COPY &lt;src&gt;... &lt;dest&gt;</span><br><span class=\"line\"><span class=\"comment\"># 说明：</span></span><br><span class=\"line\"><span class=\"comment\">#   &lt;src&gt;：要复制的文件或目录</span></span><br><span class=\"line\"><span class=\"comment\">#   &lt;dest&gt;：目标路径</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 复制单个文件</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> app.jar /app.jar</span></span><br><span class=\"line\"><span class=\"comment\"># 复制多个文件</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> app1.jar app2.jar /app/</span></span><br><span class=\"line\"><span class=\"comment\"># 复制目录</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> static-assets/ /app/public/</span></span><br><span class=\"line\"><span class=\"comment\"># 通配符</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> static-assets/*.html /app/public/</span></span><br><span class=\"line\"><span class=\"comment\"># 设置目标文件属主属组</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> --<span class=\"built_in\">chown</span>=appuser:appgroup app.jar /app.jar</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"RUN\">RUN</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>RUN 指令用于在镜像构建阶段执行命令，结果会被打包进镜像层中。</p>\n</li>\n<li class=\"lvl-2\">\n<p>它可以用于安装依赖、编译代码、运行命令等。</p>\n</li>\n<li class=\"lvl-2\">\n<p>每一条 RUN 指令会创建一层镜像（layer）,合并多个命令成一条 RUN，可以减少镜像层数（例如使用 &amp;&amp; 串联）。</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 第一种格式：实际运行的是：/bin/sh -c &quot;&lt;命令字符串&gt;&quot;</span></span><br><span class=\"line\">RUN &lt;命令字符串&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第二种格式</span></span><br><span class=\"line\">RUN [<span class=\"string\">&quot;可执行文件&quot;</span>, <span class=\"string\">&quot;参数1&quot;</span>, <span class=\"string\">&quot;参数2&quot;</span>, ...]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 命令字符串</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get update &amp;&amp; apt-get install -y curl</span></span><br><span class=\"line\"><span class=\"comment\"># 构建多个命令(用 &amp;&amp; 串联)</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get update &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    apt-get install -y python3 &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    <span class=\"built_in\">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 可执行文件参数</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> [<span class=\"string\">&quot;/bin/sh&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>, <span class=\"string\">&quot;curl https://example.com/app.jar &gt; app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"CMD\">CMD</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>CMD 用于指定容器启动时默认执行的命令及其参数。</p>\n</li>\n<li class=\"lvl-2\">\n<p>如果用户在运行容器时没有手动指定其他命令，Docker 就会使用 CMD 提供的内容。</p>\n</li>\n<li class=\"lvl-2\">\n<p>它可以定义多个，但只有最后一个会被使用。</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Shell 形式（字符串）</span></span><br><span class=\"line\">CMD <span class=\"built_in\">command</span> param1 param2</span><br><span class=\"line\"><span class=\"comment\"># 等价于 /bin/sh -c &quot;command param1 param2&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Exec 形式（数组）</span></span><br><span class=\"line\">CMD [<span class=\"string\">&quot;executable&quot;</span>, <span class=\"string\">&quot;param1&quot;</span>, <span class=\"string\">&quot;param2&quot;</span>, ...]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 简单 shell 命令</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Hello from container&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Exec 形式</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;npm&quot;</span>, <span class=\"string\">&quot;start&quot;</span>]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 作为 ENTRYPOINT 的参数</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> [<span class=\"string\">&quot;python3&quot;</span>, <span class=\"string\">&quot;app.py&quot;</span>]</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;--host=0.0.0.0&quot;</span>, <span class=\"string\">&quot;--port=8080&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>用户可以覆盖 CMD：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run &lt;myapp&gt; npm run <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"ENTRYPOINT\">ENTRYPOINT</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ENTRYPOINT 定义容器启动时执行的主命令，相比 CMD，它不容易被覆盖，更适合制作“专用型”容器（如 nginx、python 脚本等）。</p>\n</li>\n<li class=\"lvl-2\">\n<p>你可以把 ENTRYPOINT 理解为容器的“主程序”，而 CMD 是为它提供的默认“命令行参数”。</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Shell 形式（字符串）</span></span><br><span class=\"line\">ENTRYPOINT <span class=\"built_in\">command</span> param1 param2</span><br><span class=\"line\"><span class=\"comment\">#  等价于 /bin/sh -c &quot;command param1 param2&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Exec 形式（数组）</span></span><br><span class=\"line\">ENTRYPOINT [<span class=\"string\">&quot;executable&quot;</span>, <span class=\"string\">&quot;param1&quot;</span>, <span class=\"string\">&quot;param2&quot;</span>, ...]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 简单 shell 命令</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Hello from container&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Exec 形式</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> [<span class=\"string\">&quot;npm&quot;</span>, <span class=\"string\">&quot;start&quot;</span>]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 结合 CMD 使用</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> [<span class=\"string\">&quot;python3&quot;</span>, <span class=\"string\">&quot;app.py&quot;</span>]</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;--host=0.0.0.0&quot;</span>, <span class=\"string\">&quot;--port=8080&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"EXPOSE\">EXPOSE</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>EXPOSE 用于声明容器将会监听的端口，让使用该镜像的人知道应该对外开放哪些端口。</p>\n</li>\n<li class=\"lvl-2\">\n<p>⚠️ 注意：EXPOSE 并不会真的开放端口，只是“声明”这个容器监听了这些端口。</p>\n</li>\n<li class=\"lvl-2\">\n<p>要让端口真正暴露出来，还需要在运行容器时加上 <code>-p</code> 或 <code>--publish</code> 参数。</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</span><br><span class=\"line\"><span class=\"comment\"># 说明：</span></span><br><span class=\"line\"><span class=\"comment\">#   &lt;port&gt;：端口号，可以是单个端口号，也可以是范围（如 8080-8085）</span></span><br><span class=\"line\"><span class=\"comment\">#   &lt;protocol&gt;：协议，可以是 tcp 或 udp，默认为 tcp</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">8080</span></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">8080</span>/udp</span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">8080</span>-<span class=\"number\">8085</span></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">8080</span> <span class=\"number\">8081</span> <span class=\"number\">8082</span> <span class=\"number\">8083</span> <span class=\"number\">8084</span> <span class=\"number\">8085</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"VOLUME\">VOLUME</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>VOLUME 指令用于声明一个或多个容器中的挂载点（mount point），用于持久化数据或与宿主机/其他容器共享数据。</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VOLUME [<span class=\"string\">&quot;/path/in/container&quot;</span>, ...]</span><br><span class=\"line\"><span class=\"comment\"># 路径必须是容器内部的绝对路径</span></span><br><span class=\"line\"><span class=\"comment\"># 可以一次声明一个，也可以是多个。</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 声明一个挂载点</span></span><br><span class=\"line\"><span class=\"keyword\">VOLUME</span><span class=\"language-bash\"> /app/public</span></span><br><span class=\"line\"><span class=\"comment\"># 声明多个挂载点</span></span><br><span class=\"line\"><span class=\"keyword\">VOLUME</span><span class=\"language-bash\"> [<span class=\"string\">&quot;/app/public&quot;</span>, <span class=\"string\">&quot;/app/logs&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当容器运行时，可以将镜像中声明的挂载点映射到宿主机上，从而实现持久化数据。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -v /host/path:/app/public myimage</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果你没有手动绑定挂载，Docker 会自动创建一个匿名卷，卷的内容默认保存在宿主机的 <code>/var/lib/docker/volumes</code> 下。</p>\n</li>\n</ul>\n<h3 id=\"HEALTHCHECK\">HEALTHCHECK</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>HEALTHCHECK 用来定义容器运行时的健康检查命令，定期检测容器内服务的状态，帮助编排工具（Docker Swarm、Kubernetes 等）判断容器是否健康。</p>\n</li>\n<li class=\"lvl-2\">\n<p>如果健康检查失败，Docker 会将容器标记为 unhealthy，便于自动重启或替换。</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HEALTHCHECK &lt;options&gt; CMD &lt;<span class=\"built_in\">command</span>&gt;</span><br><span class=\"line\"><span class=\"comment\"># 说明：</span></span><br><span class=\"line\"><span class=\"comment\"># &lt;options&gt;：可选项，用于设置健康检查的选项，如超时时间、重试次数等。</span></span><br><span class=\"line\"><span class=\"comment\"># &lt;command&gt;：健康检查命令，可以是任何有效的 shell 命令。</span></span><br><span class=\"line\">            <span class=\"comment\"># 必须返回退出码:</span></span><br><span class=\"line\">              <span class=\"comment\"># 0 表示健康</span></span><br><span class=\"line\">              <span class=\"comment\"># 1 表示不健康</span></span><br><span class=\"line\">              <span class=\"comment\"># 2 表示未知</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>可选参数（OPTIONS）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>--interval=DURATION</code></td>\n<td>两次健康检查之间的时间间隔</td>\n<td>30s</td>\n</tr>\n<tr>\n<td><code>--timeout=DURATION</code></td>\n<td>单次检测命令的超时时间</td>\n<td>30s</td>\n</tr>\n<tr>\n<td><code>--start-period=DURATION</code></td>\n<td>容器启动后，开始健康检查前的等待时间</td>\n<td>0s</td>\n</tr>\n<tr>\n<td><code>--retries=N</code></td>\n<td>连续失败几次后判定容器不健康</td>\n<td>3</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用 curl 检测 Web 服务是否响应</span></span><br><span class=\"line\"><span class=\"keyword\">HEALTHCHECK</span><span class=\"language-bash\"> --interval=5s --<span class=\"built_in\">timeout</span>=3s --retries=3 CMD curl -f http://localhost:8080/health || <span class=\"built_in\">exit</span> 1</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>运行容器后，可以用命令查看健康状态</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果镜像中有健康检查，可以查看容器状态（STATUS）</span></span><br><span class=\"line\">docker ps</span><br><span class=\"line\">  <span class=\"comment\"># STATUS 列会显示：</span></span><br><span class=\"line\">  <span class=\"comment\">#   healthy</span></span><br><span class=\"line\">  <span class=\"comment\">#   unhealthy</span></span><br><span class=\"line\">  <span class=\"comment\">#   starting（启动中）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看更详细的信息</span></span><br><span class=\"line\">docker inspect --format=<span class=\"string\">&#x27;&#123;&#123;json .State.Health&#125;&#125;&#x27;</span> &lt;container-id&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"SHELL\">SHELL</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>SHELL 指令用来自定义后续 RUN、CMD 和 ENTRYPOINT 指令所使用的默认 shell 程序和参数。</p>\n</li>\n<li class=\"lvl-2\">\n<p>默认情况下：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">在 Linux 镜像中，Docker 使用 /bin/sh -c</li>\n<li class=\"lvl-4\">在 Windows 镜像中，使用 cmd /S /C</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>使用 SHELL，你可以替换为其他 shell，如 Bash、PowerShell、zsh 等。</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SHELL [<span class=\"string\">&quot;executable&quot;</span>, <span class=\"string\">&quot;param1&quot;</span>, <span class=\"string\">&quot;param2&quot;</span>, ...]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 切换到 bash</span></span><br><span class=\"line\"><span class=\"keyword\">SHELL</span><span class=\"language-bash\"> [<span class=\"string\">&quot;bash&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 多次切换</span></span><br><span class=\"line\"><span class=\"keyword\">SHELL</span><span class=\"language-bash\"> [<span class=\"string\">&quot;/bin/bash&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>]</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Hello from Bash&quot;</span> <span class=\"comment\"># 在 Bash 中执行</span></span></span><br><span class=\"line\"><span class=\"keyword\">SHELL</span><span class=\"language-bash\"> [<span class=\"string\">&quot;/bin/sh&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>]</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Now back to sh&quot;</span> <span class=\"comment\">#  在 sh 中执行</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Windows</span></span><br><span class=\"line\"><span class=\"keyword\">SHELL</span><span class=\"language-bash\"> [<span class=\"string\">&quot;powershell&quot;</span>, <span class=\"string\">&quot;-Command&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"STOPSIGNAL\">STOPSIGNAL</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>STOPSIGNAL 指定当容器收到 <code>docker stop</code> 命令时，发送给容器主进程的信号类型。</p>\n</li>\n<li class=\"lvl-2\">\n<p>默认情况下，Docker 会向容器的主进程发送 <code>SIGTERM</code> 信号，让它有机会优雅地退出（在超时时未退出则发 <code>SIGKILL</code> 强制终止）。</p>\n</li>\n<li class=\"lvl-2\">\n<p>默认情况，大多数程序（如 nginx），不需要设置（默认 SIGTERM）</p>\n</li>\n<li class=\"lvl-2\">\n<p>但有些程序可能需要使用不同的信号，比如 SIGINT、SIGHUP，这时你可以通过 STOPSIGNAL 来修改。</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">STOPSIGNAL &lt;signal&gt;</span><br><span class=\"line\"><span class=\"comment\"># 说明：</span></span><br><span class=\"line\"><span class=\"comment\"># 其中 &lt;signal&gt; 可以是：</span></span><br><span class=\"line\"><span class=\"comment\">#   信号名称，例如：SIGTERM、SIGKILL、SIGINT、SIGHUP</span></span><br><span class=\"line\"><span class=\"comment\">#   或信号编号，例如：15（等价于 SIGTERM）</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 这是默认行为，不写也一样。</span></span><br><span class=\"line\"><span class=\"keyword\">STOPSIGNAL</span> SIGTERM</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 修改为 SIGINT</span></span><br><span class=\"line\"><span class=\"keyword\">STOPSIGNAL</span> SIGINT</span><br></pre></td></tr></table></figure>\n<h3 id=\"ONBUILD\">ONBUILD</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ONBUILD 用于定义延迟执行的构建指令，即这些命令不会在当前 Dockerfile 构建时执行，而是在 以当前镜像为基础的子镜像中构建时触发执行。</p>\n</li>\n<li class=\"lvl-2\">\n<p>它的典型用途是：构建一个“通用基础镜像”，让使用者在自己的 Dockerfile 中 FROM 它时自动继承一些操作（比如 COPY、RUN 等）。</p>\n</li>\n<li class=\"lvl-2\">\n<p>ONBUILD 是一种设计模式，方便基础镜像作者预先定义“未来子镜像构建时一定要执行的步骤”，而不是在基础镜像中“硬编码”那些步骤。</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ONBUILD &lt;INSTRUCTION&gt;</span><br><span class=\"line\"><span class=\"comment\"># 说明：</span></span><br><span class=\"line\"><span class=\"comment\"># &lt;INSTRUCTION&gt;：必须是一个合法的 Dockerfile 指令，如 RUN、COPY、ADD、CMD 等（但不能是 FROM, ONBUILD, HEALTHCHECK 等）。</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 基础镜像中使用 ONBUILD</span></span><br><span class=\"line\"><span class=\"comment\"># 文件：Dockerfile.base</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> node:<span class=\"number\">18</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"keyword\">ONBUILD</span> <span class=\"keyword\">COPY</span><span class=\"language-bash\"> . /app</span></span><br><span class=\"line\"><span class=\"keyword\">ONBUILD</span> <span class=\"keyword\">RUN</span><span class=\"language-bash\"> npm install</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 构建基础镜像</span></span><br><span class=\"line\">docker build -t my-node-base -f Dockerfile.base .</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用基础镜像构建子镜像</span></span><br><span class=\"line\"><span class=\"comment\"># 文件：Dockerfile（子镜像）</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> my-node-base</span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;node&quot;</span>, <span class=\"string\">&quot;index.js&quot;</span>]</span></span><br><span class=\"line\"><span class=\"comment\"># 构建子镜像时，等于自动插入了：</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . /app</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> npm install</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ONBUILD 是一种“构建钩子”机制</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">ONBUILD 可以理解成“钩子”或“触发器”：\n<ul class=\"lvl-4\">\n<li class=\"lvl-6\">在基础镜像构建时不执行</li>\n<li class=\"lvl-6\">但当某人以这个基础镜像为起点写自己的 Dockerfile，并构建时，这些 ONBUILD 里的指令自动插入执行</li>\n</ul>\n</li>\n<li class=\"lvl-4\">这样：\n<ul class=\"lvl-4\">\n<li class=\"lvl-6\">基础镜像只负责定义环境（node、npm版本、系统依赖等），保持轻量</li>\n<li class=\"lvl-6\">下游项目可以不用写重复的代码复制和安装指令，自动继承基础镜像预定义的构建步骤</li>\n<li class=\"lvl-6\">代码复制和依赖安装在下游镜像构建时执行，使用自己的上下文（也就是项目代码）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p><code>ONBUILD</code> 总结</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>⏱ 延迟执行</td>\n<td>构建基础镜像时不会执行，在子镜像构建时触发</td>\n</tr>\n<tr>\n<td>✅ 支持指令</td>\n<td>例如 <code>RUN</code>, <code>COPY</code>, <code>ADD</code>, <code>CMD</code>, <code>WORKDIR</code>, <code>ENV</code> 等</td>\n</tr>\n<tr>\n<td>❌ 不支持</td>\n<td><code>FROM</code>, <code>ONBUILD</code>, <code>HEALTHCHECK</code>, <code>SHELL</code>, <code>STOPSIGNAL</code></td>\n</tr>\n<tr>\n<td>👎 不推荐滥用</td>\n<td>会隐藏构建行为，降低可维护性</td>\n</tr>\n<tr>\n<td>✅ 推荐场景</td>\n<td>团队共享模板、构建“标准开发镜像”</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Dockerfile-哪些-指令-会创建新的层\">Dockerfile 哪些 指令 会创建新的层</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当 Dockerfile 中创建新层的指令内容发生变化时，使用 <code>--no-cache</code> 选项可以确保这些变更被正确应用。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ADD</td>\n<td>从 <src> 复制文件并自动解压（如果是一个 tar 文件）到容器的 <dest> 路径。</td>\n</tr>\n<tr>\n<td>COPY</td>\n<td>从 <src> 复制文件到容器的 <dest> 路径，不会自动解压。</td>\n</tr>\n<tr>\n<td>RUN</td>\n<td>执行任意命令并在容器中做出更改。每条 RUN 指令都会创建一个新的层。</td>\n</tr>\n<tr>\n<td>ENV</td>\n<td>设置环境变量。每一行 ENV 指令都会创建一个新的层。</td>\n</tr>\n<tr>\n<td>WORKDIR</td>\n<td>设置工作目录。每一行 WORKDIR 指令都会创建一个新的层。</td>\n</tr>\n<tr>\n<td>VOLUME</td>\n<td>创建一个挂载点。每一行 VOLUME 指令都会创建一个新的层。</td>\n</tr>\n<tr>\n<td>LABEL</td>\n<td>添加元数据标签。每一行 LABEL 指令都会创建一个新的层。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Dockerfile-示例-Spring-Boot-应用\">Dockerfile 示例: Spring Boot 应用</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>目录结构</p>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">springbootweb/</span><br><span class=\"line\">├── Dockerfile</span><br><span class=\"line\">├── target/</span><br><span class=\"line\">│   └── app.jar</span><br><span class=\"line\">├── <span class=\"type\">static</span>-assets.tar.gz</span><br><span class=\"line\">└── ...</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Dockerfile: 注意 Dockerfile 中所有关键字都要求大写</p>\n</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用轻量级 Alpine 版本的 OpenJDK 17 官方镜像，适合部署 Spring Boot 应用</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> openjdk:<span class=\"number\">17</span>-alpine</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置构建时变量，默认使用构建好的 jar 文件</span></span><br><span class=\"line\"><span class=\"keyword\">ARG</span> JAR_FILE=target/app.jar</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置运行时环境变量</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> JAVA_OPTS=<span class=\"string\">&quot;-Xms1024M -Xmx1024M -XX:MetaspaceSize=128M -XX:MaxMetaspaceSize=128M&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> TZ=Asia/Shanghai</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 镜像元信息</span></span><br><span class=\"line\"><span class=\"keyword\">LABEL</span><span class=\"language-bash\"> maintainer=<span class=\"string\">&quot;yourname@example.com&quot;</span></span></span><br><span class=\"line\"><span class=\"keyword\">LABEL</span><span class=\"language-bash\"> version=<span class=\"string\">&quot;1.0.0&quot;</span></span></span><br><span class=\"line\"><span class=\"keyword\">LABEL</span><span class=\"language-bash\"> description=<span class=\"string\">&quot;用于部署 Spring Boot 应用的生产级镜像&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置工作目录</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例 RUN：安装 curl（用于容器健康检查或调试）</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apk add --no-cache curl</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 复制 Spring Boot 构建生成的 jar 包</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> <span class=\"variable\">$&#123;JAR_FILE&#125;</span> app.jar</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 解压静态资源到容器中（ADD 可以自动解压 tar.gz）</span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"language-bash\"> static-assets.tar.gz /app/public/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 声明暴露的应用端口（Spring Boot 默认是 8080）</span></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">8080</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 容器健康检查：访问 actuator 健康端点</span></span><br><span class=\"line\"><span class=\"keyword\">HEALTHCHECK</span><span class=\"language-bash\"> --interval=30s --<span class=\"built_in\">timeout</span>=5s --retries=3 \\</span></span><br><span class=\"line\"><span class=\"language-bash\">  CMD curl -f http://localhost:8080/app/actuator/health || <span class=\"built_in\">exit</span> 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 容器终止时优雅关闭（Java 推荐 SIGTERM）</span></span><br><span class=\"line\"><span class=\"keyword\">STOPSIGNAL</span> SIGTERM</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置容器启动时的主命令（ENTRYPOINT 不会被 docker run 参数覆盖）</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> [<span class=\"string\">&quot;sh&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>, <span class=\"string\">&quot;java <span class=\"variable\">$JAVA_OPTS</span> -jar app.jar&quot;</span>]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># CMD 提供默认的运行参数，可以被 docker run 覆盖</span></span><br><span class=\"line\"><span class=\"comment\"># 这里通过 Spring Boot 参数设置启动环境和端口号</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;--spring.profiles.active=app&quot;</span>, <span class=\"string\">&quot;--server.port=8080&quot;</span>]</span></span><br><span class=\"line\"><span class=\"comment\"># 这里使用的是 ENTRYPOINT + CMD 的混合模式</span></span><br><span class=\"line\"><span class=\"comment\"># 完整命令： java $JAVA_OPTS -jar app.jar --spring.profiles.active=app --server.port=8080</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 声明一个卷挂载点，运行容器时可将该路径映射到宿主机，实现数据持久化</span></span><br><span class=\"line\"><span class=\"keyword\">VOLUME</span><span class=\"language-bash\"> [<span class=\"string\">&quot;/app/logs&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>构建镜像</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 构建镜像时用 --build-arg 指定构建参数，如果需要多个，就配置多个 --build-arg</span></span><br><span class=\"line\">docker build --build-arg JAR_FILE=target/app.jar -t springbootweb:latest .</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>运行容器</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d --name springbootweb \\</span><br><span class=\"line\">  -p 8080:8080 \\</span><br><span class=\"line\">  -e JAVA_OPTS=<span class=\"string\">&quot;-Xms512m -Xmx1024m&quot;</span> \\</span><br><span class=\"line\">  -v /home/centos/logs/app/:/app/logs \\</span><br><span class=\"line\">  springbootweb:latest</span><br></pre></td></tr></table></figure>\n<h2 id=\"Dockerfile-示例-多阶段构建\">Dockerfile 示例: 多阶段构建</h2>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 第一阶段：获取代码</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> alpine/git AS fetcher</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /workspace/application</span></span><br><span class=\"line\"><span class=\"comment\"># 将替换为实际的Git仓库URL和分支/标签</span></span><br><span class=\"line\"><span class=\"keyword\">ARG</span> GIT_REPOSITORY=https://gitee.com/hanqunfeng/springbootweb.git</span><br><span class=\"line\"><span class=\"keyword\">ARG</span> GIT_BRANCH=master</span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> git <span class=\"built_in\">clone</span> -b <span class=\"variable\">$&#123;GIT_BRANCH&#125;</span> <span class=\"variable\">$&#123;GIT_REPOSITORY&#125;</span> .</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第二阶段：使用Maven环境进行构建</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> maven:<span class=\"number\">3.8</span>.<span class=\"number\">4</span>-openjdk-<span class=\"number\">17</span> AS builder</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /workspace/application</span></span><br><span class=\"line\"><span class=\"comment\"># 从第一阶段复制代码</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> --from=fetcher /workspace/application .</span></span><br><span class=\"line\"><span class=\"comment\"># 使用Maven清理并打包</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> mvn clean package -DskipTests</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第三阶段：创建最终的运行环境</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> openjdk:<span class=\"number\">17</span>-alpine</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"comment\"># 设置运行时环境变量</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> JAVA_OPTS=<span class=\"string\">&quot;-Xms1024M -Xmx1024M -XX:MetaspaceSize=128M -XX:MaxMetaspaceSize=128M&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 将第二阶段生成的目标文件复制到这里。注意这里假设你的spring boot工程打成的jar名是target/app.jar</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> --from=builder /workspace/application/target/app.jar app.jar</span></span><br><span class=\"line\"><span class=\"comment\"># 暴露端口（如果需要的话）。请根据实际情况修改端口号</span></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">8080</span></span><br><span class=\"line\"><span class=\"comment\"># 声明一个卷挂载点，运行容器时可将该路径映射到宿主机，实现数据持久化</span></span><br><span class=\"line\"><span class=\"keyword\">VOLUME</span><span class=\"language-bash\"> [<span class=\"string\">&quot;/app/logs&quot;</span>]</span></span><br><span class=\"line\"><span class=\"comment\"># 设置容器启动时的主命令（ENTRYPOINT 不会被 docker run 参数覆盖）</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> [<span class=\"string\">&quot;sh&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>, <span class=\"string\">&quot;java <span class=\"variable\">$JAVA_OPTS</span> -jar app.jar&quot;</span>]</span></span><br><span class=\"line\"><span class=\"comment\"># CMD 提供默认的运行参数，可以被 docker run 覆盖</span></span><br><span class=\"line\"><span class=\"comment\"># 这里通过 Spring Boot 参数设置启动环境和端口号</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;--spring.profiles.active=app&quot;</span>, <span class=\"string\">&quot;--server.port=8080&quot;</span>]</span></span><br><span class=\"line\"><span class=\"comment\"># 这里使用的是 ENTRYPOINT + CMD 的混合模式</span></span><br><span class=\"line\"><span class=\"comment\"># 完整命令： java $JAVA_OPTS -jar app.jar --spring.profiles.active=app --server.port=8080</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>构建镜像</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 构建镜像，--no-cache 表示不使用缓存，每次构建都会重新构建</span></span><br><span class=\"line\">docker build --no-cache -t app:latest .</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>运行容器</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d --name app \\</span><br><span class=\"line\">  -p 8080:8080 \\</span><br><span class=\"line\">  -e JAVA_OPTS=<span class=\"string\">&quot;-Xms512m -Xmx1024m&quot;</span> \\</span><br><span class=\"line\">  -v /home/centos/logs/app/:/app/logs \\</span><br><span class=\"line\">  app:latest</span><br></pre></td></tr></table></figure>\n<h2 id=\"Dockerfile-语法检测\">Dockerfile 语法检测</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在线检查：<a href=\"https://hadolint.github.io/hadolint/\">Dockerfile Linter</a></p>\n</li>\n<li class=\"lvl-2\">\n<p>本地检查：<a href=\"https://github.com/hadolint/hadolint\">Haskell Dockerfile Linter</a>，可以安装命令，也可以通过docker运行</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装命令</span></span><br><span class=\"line\">wget -O /usr/local/bin/hadolint https://github.com/hadolint/hadolint/releases/latest/download/hadolint-Linux-x86_64</span><br><span class=\"line\"><span class=\"built_in\">chmod</span> +x /usr/local/bin/hadolint</span><br><span class=\"line\">hadolint --version</span><br><span class=\"line\"><span class=\"comment\"># 检查</span></span><br><span class=\"line\">hadolint Dockerfile</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># docker 运行</span></span><br><span class=\"line\">docker run --<span class=\"built_in\">rm</span> -i hadolint/hadolint &lt; Dockerfile</span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍 Docker 命令 中 Dockerfile 的使用方法 Docker官方文档 Dockerfile官方文档 Dockerfile 是什么？ Docker可以通过读取 Dockerfile 中的指令来自动构建镜像。 Dockerfile 是一个文本文档，其中包含用户可以在命令行上调用以组装镜像的所有指令。 可以在Dockerfile中使用的指令： 指令 中文描述 ADD 将本地或远程的文件/目录添加到镜像中，支持自动解压 .tar 文件和使用 URL 下载远程资源。通常推荐使用 COPY，除非需要这些高级功能。 ARG 定义构建阶段使用的变量，可在 docker build 命令中通过 --build-arg 传入，变量仅在构建时有效，不会保留在最终镜像中。 CMD 指定容器默认执行的命令和参数，容器运行时若未指定命令，则使用该指令设置的命令。如果配置了多个CMD，则只有最后一个生效。和ENTRYPOINT共同使用时，作为传递给ENTRYPOINT的参数。可被 docker run 提供的命令覆盖。 COPY 将构建上下文中的文件或目录复制到镜像中。相比 ADD 更简单、安全，推荐优先使用。 ENTRYPOINT 指定容器启动时的主命令，不容易被 docker run 中的命令覆盖。可与 CMD 配合使用，用于提供默认参数。 ENV 设置环境变量，变量将在构建和容器运行时均可使用。例如：配置应用参数或系统路径等。 EXPOSE 声明容器运行时将开放的端口，仅用于文档说明或与容器编排工具配合，不会自动进行端口映射。 FROM 指定基础镜像，是 Dockerfile 的起点。也可以用于多阶段构建，通过多次使用 FROM 指令创建多个构建阶段。 HEALTHCHECK 定义容器健康检查命令，用于定期检测容器内部服务的健康状态，可结合容器编排系统实现故障自动恢复。 LABEL 为镜像添加键值对形式的元数据，例如版本、维护者、用途说明等，方便镜像管理与自动化处理。 MAINTAINER （已弃用）用于指定镜像维护者信息，推荐改用 LABEL 来设置作者信息。 ONBUILD 定义一个触发指令，当当前镜像作为基础镜像被其他 Dockerfile 使用时自动执行。常用于基础镜像的预设行为。 RUN 执行一条命令并提交结果作为新镜像层，常用于安装软件包、复制文件、设置权限等构建操作。 SHELL 更改 Dockerfile 中后续 RUN、CMD、ENTRYPOINT 等指令的默认 shell（如使用 sh 或 powershell）。 STOPSIGNAL 设置容器终止时发送的系统信号（如 SIGTERM），用于优雅关闭应用。 USER 设置执行后续命令时所使用的用户和用户组，增强容器的安全性，避免使用 root 权限。 VOLUME 定义容器内的挂载点，用于持久化数据或与宿主机/其他容器共享数据。运行容器时可指定挂载路径。 WORKDIR 设置工作目录，相当于执行 cd，用于简化后续命令中的路径。若目录不存在则自动创建。 构建阶段指令：FROM, ARG, ENV, COPY, ADD, RUN, WORKDIR, LABEL, USER, SHELL, ONBUILD 启动配置指令：CMD, ENTRYPOINT, HEALTHCHECK, EXPOSE, VOLUME, STOPSIGNAL Dockerfile 指令介绍 FROM FROM 指令用于指定基础镜像（base image），是每一个 Dockerfile 中必须的第一条指令。所有后续指令都是基于这个基础镜像构建的。 语法 12345FROM &lt;image&gt;[:&lt;tag&gt;] [AS &lt;stage-name&gt;]# 说明：# &lt;image&gt;：镜像名称（可以是本地已有的，也可以是从 Docker Hub 或其他镜像仓库拉取的）# [:&lt;tag&gt;]：镜像标签（可选，默认是 latest）# [AS &lt;stage-name&gt;]：为该构建阶段指定名称，用于多阶段构建 示例 12345678910111213141516171819# 使用最新版本的镜像（默认标签是 latest）FROM node# 使用指定的标签FROM node:16.13.2-alpine# 使用私有镜像仓库FROM private.registry.com/my-image:latest# 使用多阶段构建FROM golang:1.20 AS builderWORKDIR /appCOPY . .RUN go build -o myappFROM alpine:latestCOPY --from=builder /app/myapp /usr/local/bin/myappENTRYPOINT [&quot;myapp&quot;]## 这里用了两个阶段：### builder 阶段用来编译应用；### alpine 阶段用来打包最终镜像，只包含编译好的二进制文件，减少体积。 WORKDIR WORKDIR 指定了工作目录，即后续所有指令（如 RUN、CMD、ENTRYPOINT、COPY、ADD 等）所运行的当前路径（working directory）。 如果目录不存在，Docker 会自动创建它。 每个 WORKDIR 都会创建一层镜像（layer），所以不要重复设置无意义的路径。 语法 123WORKDIR &lt;path&gt;# 说明：# &lt;path&gt;：要切换的工作目录，可以是绝对路径或相对路径。 示例 12345678910111213# 设置绝对路径WORKDIR /app# 连续设置多个工作目录（逐层嵌套）WORKDIR /varWORKDIR wwwWORKDIR html# 等同于:WORKDIR /var/www/html# 避免在 RUN cd some_dir 后继续执行依赖路径的命令，因为 Docker 每一条指令都是新的 shell 实例，cd 不会跨指令保留，应该改用 WORKDIR。RUN cd some_dir # 错误WORKDIR some_dir # 正确 ARG ARG 用于在 构建镜像时（build-time）传入参数。这些参数只在 构建阶段有效，不会出现在最终镜像中，也不会在容器运行时被保留。 语法 1234ARG &lt;name&gt;[=&lt;default_value&gt;]# 说明：# &lt;name&gt;：参数名称# [=&lt;default_value&gt;]：参数的默认值，如果未传入参数，则使用默认值，如果为设置default_value，则构建镜像时必须传递参数，--build-arg 示例 12345678910# 定义一个参数，在构建镜像时必须传入参数，--build-arg APP_ENV=developmentARG APP_ENV# 带默认值的 ARGARG APP_ENV=development# 使用参数RUN echo &quot;当前环境：$&#123;APP_ENV&#125;&quot;# 与 FROM 一起用（从 Docker 17.05 起）ARG BASE=ubuntuFROM $&#123;BASE&#125;:22.04 ENV ENV 指令用于在镜像构建过程中定义环境变量（Environment Variables）。这些变量可以在之后的构建步骤（比如 RUN、CMD 等）中使用，也会在容器运行时生效。 语法 1234567# 两种语法ENV &lt;key&gt; &lt;value&gt;ENV &lt;key&gt;=&lt;value&gt; ...# 说明：# &lt;key&gt;：环境变量的名称# &lt;value&gt;：环境变量的值# 如果定义多个变量，推荐使用 key=value 的形式。 示例 123456789101112# 定义一个环境变量ENV APP_ENV=production# 定义多个变量ENV APP_PORT=8080 NODE_ENV=production# 使用多行格式（提高可读性）ENV PATH=&quot;/usr/local/bin:$&#123;PATH&#125;&quot; \\ LANG=&quot;en_US.UTF-8&quot; \\ TZ=&quot;Asia/Shanghai&quot;# 也可以分开定义ENV PATH=&quot;/usr/local/bin:$PATH&quot;ENV LANG=&quot;en_US.UTF-8&quot;ENV TZ=&quot;Asia/Shanghai&quot; 注意：ENV 指令定义的环境变量在构建阶段和运行阶段都会生效，但运行阶段会覆盖构建阶段定义的变量。 LABEL LABEL 用于为镜像添加元数据标签，以 key=value 的形式存在。这些标签可以是作者信息、版本描述、用途说明、构建时间等。 旧的 MAINTAINER 指令现在已被废弃，推荐使用 LABEL 来代替。 每个 LABEL 都会创建一层镜像（layer），推荐一次设置多个。 语法 1234LABEL &lt;key&gt;=&lt;value&gt; [&lt;key&gt;=&lt;value&gt;...]# 说明：# &lt;key&gt;：标签的键# &lt;value&gt;：标签的值 示例 12345678# 添加一个标签LABEL maintainer=&quot;yourname@example.com&quot;# 换行格式（推荐）,以下标签符合 OCI（Open Container Initiative） 镜像规范LABEL \\ org.opencontainers.image.title=&quot;MyApp&quot; \\ org.opencontainers.image.description=&quot;演示项目&quot; \\ org.opencontainers.image.version=&quot;1.0.0&quot; \\ org.opencontainers.image.authors=&quot;zhangsan@example.com&quot; USER USER 指令用于指定后续指令（如 RUN、CMD、ENTRYPOINT、COPY 等）以哪个用户身份来执行。 默认情况下，Docker 容器中的命令以 root 用户运行，这虽然灵活但不安全。使用 USER 可以让我们切换到普通用户，从而提升容器的安全性，防止潜在的权限滥用。 语法 1234USER &lt;user&gt;[:&lt;group&gt;]# 说明：# &lt;user&gt;：用户名或 UID# [:&lt;group&gt;]：可选，用户组名或 GID 示例 123456# 设置用户USER appuser# 设置用户组USER appuser:appgroup# 使用 UID 和 GIDUSER 1000:1000 如果基础镜像中没有你想要的用户，需要在 Dockerfile 中手动创建 1234# 创建用户和组RUN groupadd -r appgroup &amp;&amp; useradd -r -g appgroup appuser# 切换用户USER appuser ADD ADD 用于将本地文件或目录、远程文件（URL） 或 压缩包 复制到镜像中的指定位置。 它的功能类似于 COPY，但比 COPY 多几个功能（解压、拉取远程文件等）。 语法 1234ADD &lt;src&gt;... &lt;dest&gt;# 说明：# &lt;src&gt;：要复制的文件或目录，可以是本地文件、远程 URL、压缩包等# &lt;dest&gt;：目标路径 示例 12345678910# 从本地文件复制ADD app.jar /app.jar# 复制多个ADD app1.jar app2.jar /app/# 通配符ADD static-assets/*.html /app/public/# 从远程 URL 复制ADD https://example.com/app.jar /app.jar# 从压缩包中复制ADD static-assets.tar.gz /app/public/ 最佳实践是优先使用 COPY，只有在需要 ADD 的额外功能时才使用它。 COPY COPY 指令用于将主机上的文件或目录复制到镜像的文件系统中。它是构建镜像过程中最常用的数据引入方式之一。 与 ADD 类似，但功能更简单、明确、安全 推荐优先使用 COPY，除非你确实需要 ADD 提供的自动解压或远程下载功能。 语法 1234COPY &lt;src&gt;... &lt;dest&gt;# 说明：# &lt;src&gt;：要复制的文件或目录# &lt;dest&gt;：目标路径 示例 12345678910# 复制单个文件COPY app.jar /app.jar# 复制多个文件COPY app1.jar app2.jar /app/# 复制目录COPY static-assets/ /app/public/# 通配符COPY static-assets/*.html /app/public/# 设置目标文件属主属组COPY --chown=appuser:appgroup app.jar /app.jar RUN RUN 指令用于在镜像构建阶段执行命令，结果会被打包进镜像层中。 它可以用于安装依赖、编译代码、运行命令等。 每一条 RUN 指令会创建一层镜像（layer）,合并多个命令成一条 RUN，可以减少镜像层数（例如使用 &amp;&amp; 串联）。 语法 12345# 第一种格式：实际运行的是：/bin/sh -c &quot;&lt;命令字符串&gt;&quot;RUN &lt;命令字符串&gt;# 第二种格式RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;, ...] 示例 12345678910# 命令字符串RUN apt-get update &amp;&amp; apt-get install -y curl# 构建多个命令(用 &amp;&amp; 串联)RUN apt-get update &amp;&amp; \\ apt-get install -y python3 &amp;&amp; \\ rm -rf /var/lib/apt/lists/*# 可执行文件参数RUN [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;curl https://example.com/app.jar &gt; app.jar&quot;] CMD CMD 用于指定容器启动时默认执行的命令及其参数。 如果用户在运行容器时没有手动指定其他命令，Docker 就会使用 CMD 提供的内容。 它可以定义多个，但只有最后一个会被使用。 语法 1234567# Shell 形式（字符串）CMD command param1 param2# 等价于 /bin/sh -c &quot;command param1 param2&quot;# Exec 形式（数组）CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;, ...] 示例 123456789# 简单 shell 命令CMD echo &quot;Hello from container&quot;# Exec 形式CMD [&quot;npm&quot;, &quot;start&quot;]# 作为 ENTRYPOINT 的参数ENTRYPOINT [&quot;python3&quot;, &quot;app.py&quot;]CMD [&quot;--host=0.0.0.0&quot;, &quot;--port=8080&quot;] 用户可以覆盖 CMD： 1docker run &lt;myapp&gt; npm run test ENTRYPOINT ENTRYPOINT 定义容器启动时执行的主命令，相比 CMD，它不容易被覆盖，更适合制作“专用型”容器（如 nginx、python 脚本等）。 你可以把 ENTRYPOINT 理解为容器的“主程序”，而 CMD 是为它提供的默认“命令行参数”。 语法 123456# Shell 形式（字符串）ENTRYPOINT command param1 param2# 等价于 /bin/sh -c &quot;command param1 param2&quot;# Exec 形式（数组）ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;, ...] 示例 123456789# 简单 shell 命令ENTRYPOINT echo &quot;Hello from container&quot;# Exec 形式ENTRYPOINT [&quot;npm&quot;, &quot;start&quot;]# 结合 CMD 使用ENTRYPOINT [&quot;python3&quot;, &quot;app.py&quot;]CMD [&quot;--host=0.0.0.0&quot;, &quot;--port=8080&quot;] EXPOSE EXPOSE 用于声明容器将会监听的端口，让使用该镜像的人知道应该对外开放哪些端口。 ⚠️ 注意：EXPOSE 并不会真的开放端口，只是“声明”这个容器监听了这些端口。 要让端口真正暴露出来，还需要在运行容器时加上 -p 或 --publish 参数。 语法 1234EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]# 说明：# &lt;port&gt;：端口号，可以是单个端口号，也可以是范围（如 8080-8085）# &lt;protocol&gt;：协议，可以是 tcp 或 udp，默认为 tcp 示例 1234EXPOSE 8080EXPOSE 8080/udpEXPOSE 8080-8085EXPOSE 8080 8081 8082 8083 8084 8085 VOLUME VOLUME 指令用于声明一个或多个容器中的挂载点（mount point），用于持久化数据或与宿主机/其他容器共享数据。 语法： 123VOLUME [&quot;/path/in/container&quot;, ...]# 路径必须是容器内部的绝对路径# 可以一次声明一个，也可以是多个。 示例 1234# 声明一个挂载点VOLUME /app/public# 声明多个挂载点VOLUME [&quot;/app/public&quot;, &quot;/app/logs&quot;] 当容器运行时，可以将镜像中声明的挂载点映射到宿主机上，从而实现持久化数据。 1docker run -v /host/path:/app/public myimage 如果你没有手动绑定挂载，Docker 会自动创建一个匿名卷，卷的内容默认保存在宿主机的 /var/lib/docker/volumes 下。 HEALTHCHECK HEALTHCHECK 用来定义容器运行时的健康检查命令，定期检测容器内服务的状态，帮助编排工具（Docker Swarm、Kubernetes 等）判断容器是否健康。 如果健康检查失败，Docker 会将容器标记为 unhealthy，便于自动重启或替换。 语法 12345678HEALTHCHECK &lt;options&gt; CMD &lt;command&gt;# 说明：# &lt;options&gt;：可选项，用于设置健康检查的选项，如超时时间、重试次数等。# &lt;command&gt;：健康检查命令，可以是任何有效的 shell 命令。 # 必须返回退出码: # 0 表示健康 # 1 表示不健康 # 2 表示未知 可选参数（OPTIONS） 参数 说明 默认值 --interval=DURATION 两次健康检查之间的时间间隔 30s --timeout=DURATION 单次检测命令的超时时间 30s --start-period=DURATION 容器启动后，开始健康检查前的等待时间 0s --retries=N 连续失败几次后判定容器不健康 3 示例 12# 使用 curl 检测 Web 服务是否响应HEALTHCHECK --interval=5s --timeout=3s --retries=3 CMD curl -f http://localhost:8080/health || exit 1 运行容器后，可以用命令查看健康状态 123456789# 如果镜像中有健康检查，可以查看容器状态（STATUS）docker ps # STATUS 列会显示： # healthy # unhealthy # starting（启动中）# 查看更详细的信息docker inspect --format=&#x27;&#123;&#123;json .State.Health&#125;&#125;&#x27; &lt;container-id&gt; SHELL SHELL 指令用来自定义后续 RUN、CMD 和 ENTRYPOINT 指令所使用的默认 shell 程序和参数。 默认情况下： 在 Linux 镜像中，Docker 使用 /bin/sh -c 在 Windows 镜像中，使用 cmd /S /C 使用 SHELL，你可以替换为其他 shell，如 Bash、PowerShell、zsh 等。 语法 1SHELL [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;, ...] 示例 123456789101112# 切换到 bashSHELL [&quot;bash&quot;, &quot;-c&quot;]# 多次切换SHELL [&quot;/bin/bash&quot;, &quot;-c&quot;]RUN echo &quot;Hello from Bash&quot; # 在 Bash 中执行SHELL [&quot;/bin/sh&quot;, &quot;-c&quot;]RUN echo &quot;Now back to sh&quot; # 在 sh 中执行# WindowsSHELL [&quot;powershell&quot;, &quot;-Command&quot;] STOPSIGNAL STOPSIGNAL 指定当容器收到 docker stop 命令时，发送给容器主进程的信号类型。 默认情况下，Docker 会向容器的主进程发送 SIGTERM 信号，让它有机会优雅地退出（在超时时未退出则发 SIGKILL 强制终止）。 默认情况，大多数程序（如 nginx），不需要设置（默认 SIGTERM） 但有些程序可能需要使用不同的信号，比如 SIGINT、SIGHUP，这时你可以通过 STOPSIGNAL 来修改。 语法 12345STOPSIGNAL &lt;signal&gt;# 说明：# 其中 &lt;signal&gt; 可以是：# 信号名称，例如：SIGTERM、SIGKILL、SIGINT、SIGHUP# 或信号编号，例如：15（等价于 SIGTERM） 示例 12345# 这是默认行为，不写也一样。STOPSIGNAL SIGTERM# 修改为 SIGINTSTOPSIGNAL SIGINT ONBUILD ONBUILD 用于定义延迟执行的构建指令，即这些命令不会在当前 Dockerfile 构建时执行，而是在 以当前镜像为基础的子镜像中构建时触发执行。 它的典型用途是：构建一个“通用基础镜像”，让使用者在自己的 Dockerfile 中 FROM 它时自动继承一些操作（比如 COPY、RUN 等）。 ONBUILD 是一种设计模式，方便基础镜像作者预先定义“未来子镜像构建时一定要执行的步骤”，而不是在基础镜像中“硬编码”那些步骤。 语法 123ONBUILD &lt;INSTRUCTION&gt;# 说明：# &lt;INSTRUCTION&gt;：必须是一个合法的 Dockerfile 指令，如 RUN、COPY、ADD、CMD 等（但不能是 FROM, ONBUILD, HEALTHCHECK 等）。 示例 1234567891011121314151617# 基础镜像中使用 ONBUILD# 文件：Dockerfile.baseFROM node:18WORKDIR /appONBUILD COPY . /appONBUILD RUN npm install# 构建基础镜像docker build -t my-node-base -f Dockerfile.base .# 使用基础镜像构建子镜像# 文件：Dockerfile（子镜像）FROM my-node-baseCMD [&quot;node&quot;, &quot;index.js&quot;]# 构建子镜像时，等于自动插入了：COPY . /appRUN npm install ONBUILD 是一种“构建钩子”机制 ONBUILD 可以理解成“钩子”或“触发器”： 在基础镜像构建时不执行 但当某人以这个基础镜像为起点写自己的 Dockerfile，并构建时，这些 ONBUILD 里的指令自动插入执行 这样： 基础镜像只负责定义环境（node、npm版本、系统依赖等），保持轻量 下游项目可以不用写重复的代码复制和安装指令，自动继承基础镜像预定义的构建步骤 代码复制和依赖安装在下游镜像构建时执行，使用自己的上下文（也就是项目代码） ONBUILD 总结 特性 说明 ⏱ 延迟执行 构建基础镜像时不会执行，在子镜像构建时触发 ✅ 支持指令 例如 RUN, COPY, ADD, CMD, WORKDIR, ENV 等 ❌ 不支持 FROM, ONBUILD, HEALTHCHECK, SHELL, STOPSIGNAL 👎 不推荐滥用 会隐藏构建行为，降低可维护性 ✅ 推荐场景 团队共享模板、构建“标准开发镜像” Dockerfile 哪些 指令 会创建新的层 当 Dockerfile 中创建新层的指令内容发生变化时，使用 --no-cache 选项可以确保这些变更被正确应用。 指令 描述 ADD 从 复制文件并自动解压（如果是一个 tar 文件）到容器的 路径。 COPY 从 复制文件到容器的 路径，不会自动解压。 RUN 执行任意命令并在容器中做出更改。每条 RUN 指令都会创建一个新的层。 ENV 设置环境变量。每一行 ENV 指令都会创建一个新的层。 WORKDIR 设置工作目录。每一行 WORKDIR 指令都会创建一个新的层。 VOLUME 创建一个挂载点。每一行 VOLUME 指令都会创建一个新的层。 LABEL 添加元数据标签。每一行 LABEL 指令都会创建一个新的层。 Dockerfile 示例: Spring Boot 应用 目录结构 1234567springbootweb/├── Dockerfile├── target/│ └── app.jar├── static-assets.tar.gz└── ... Dockerfile: 注意 Dockerfile 中所有关键字都要求大写 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 使用轻量级 Alpine 版本的 OpenJDK 17 官方镜像，适合部署 Spring Boot 应用FROM openjdk:17-alpine# 设置构建时变量，默认使用构建好的 jar 文件ARG JAR_FILE=target/app.jar# 设置运行时环境变量ENV JAVA_OPTS=&quot;-Xms1024M -Xmx1024M -XX:MetaspaceSize=128M -XX:MaxMetaspaceSize=128M&quot;ENV TZ=Asia/Shanghai# 镜像元信息LABEL maintainer=&quot;yourname@example.com&quot;LABEL version=&quot;1.0.0&quot;LABEL description=&quot;用于部署 Spring Boot 应用的生产级镜像&quot;# 设置工作目录WORKDIR /app# 示例 RUN：安装 curl（用于容器健康检查或调试）RUN apk add --no-cache curl# 复制 Spring Boot 构建生成的 jar 包COPY $&#123;JAR_FILE&#125; app.jar# 解压静态资源到容器中（ADD 可以自动解压 tar.gz）ADD static-assets.tar.gz /app/public/# 声明暴露的应用端口（Spring Boot 默认是 8080）EXPOSE 8080# 容器健康检查：访问 actuator 健康端点HEALTHCHECK --interval=30s --timeout=5s --retries=3 \\ CMD curl -f http://localhost:8080/app/actuator/health || exit 1# 容器终止时优雅关闭（Java 推荐 SIGTERM）STOPSIGNAL SIGTERM# 设置容器启动时的主命令（ENTRYPOINT 不会被 docker run 参数覆盖）ENTRYPOINT [&quot;sh&quot;, &quot;-c&quot;, &quot;java $JAVA_OPTS -jar app.jar&quot;]# CMD 提供默认的运行参数，可以被 docker run 覆盖# 这里通过 Spring Boot 参数设置启动环境和端口号CMD [&quot;--spring.profiles.active=app&quot;, &quot;--server.port=8080&quot;]# 这里使用的是 ENTRYPOINT + CMD 的混合模式# 完整命令： java $JAVA_OPTS -jar app.jar --spring.profiles.active=app --server.port=8080# 声明一个卷挂载点，运行容器时可将该路径映射到宿主机，实现数据持久化VOLUME [&quot;/app/logs&quot;] 构建镜像 12# 构建镜像时用 --build-arg 指定构建参数，如果需要多个，就配置多个 --build-argdocker build --build-arg JAR_FILE=target/app.jar -t springbootweb:latest . 运行容器 12345docker run -d --name springbootweb \\ -p 8080:8080 \\ -e JAVA_OPTS=&quot;-Xms512m -Xmx1024m&quot; \\ -v /home/centos/logs/app/:/app/logs \\ springbootweb:latest Dockerfile 示例: 多阶段构建 12345678910111213141516171819202122232425262728293031323334# 第一阶段：获取代码FROM alpine/git AS fetcherWORKDIR /workspace/application# 将替换为实际的Git仓库URL和分支/标签ARG GIT_REPOSITORY=https://gitee.com/hanqunfeng/springbootweb.gitARG GIT_BRANCH=masterRUN git clone -b $&#123;GIT_BRANCH&#125; $&#123;GIT_REPOSITORY&#125; .# 第二阶段：使用Maven环境进行构建FROM maven:3.8.4-openjdk-17 AS builderWORKDIR /workspace/application# 从第一阶段复制代码COPY --from=fetcher /workspace/application .# 使用Maven清理并打包RUN mvn clean package -DskipTests# 第三阶段：创建最终的运行环境FROM openjdk:17-alpineWORKDIR /app# 设置运行时环境变量ENV JAVA_OPTS=&quot;-Xms1024M -Xmx1024M -XX:MetaspaceSize=128M -XX:MaxMetaspaceSize=128M&quot;# 将第二阶段生成的目标文件复制到这里。注意这里假设你的spring boot工程打成的jar名是target/app.jarCOPY --from=builder /workspace/application/target/app.jar app.jar# 暴露端口（如果需要的话）。请根据实际情况修改端口号EXPOSE 8080# 声明一个卷挂载点，运行容器时可将该路径映射到宿主机，实现数据持久化VOLUME [&quot;/app/logs&quot;]# 设置容器启动时的主命令（ENTRYPOINT 不会被 docker run 参数覆盖）ENTRYPOINT [&quot;sh&quot;, &quot;-c&quot;, &quot;java $JAVA_OPTS -jar app.jar&quot;]# CMD 提供默认的运行参数，可以被 docker run 覆盖# 这里通过 Spring Boot 参数设置启动环境和端口号CMD [&quot;--spring.profiles.active=app&quot;, &quot;--server.port=8080&quot;]# 这里使用的是 ENTRYPOINT + CMD 的混合模式# 完整命令： java $JAVA_OPTS -jar app.jar --spring.profiles.active=app --server.port=8080 构建镜像 12# 构建镜像，--no-cache 表示不使用缓存，每次构建都会重新构建docker build --no-cache -t app:latest . 运行容器 12345docker run -d --name app \\ -p 8080:8080 \\ -e JAVA_OPTS=&quot;-Xms512m -Xmx1024m&quot; \\ -v /home/centos/logs/app/:/app/logs \\ app:latest Dockerfile 语法检测 在线检查：Dockerfile Linter 本地检查：Haskell Dockerfile Linter，可以安装命令，也可以通过docker运行 123456789# 安装命令wget -O /usr/local/bin/hadolint https://github.com/hadolint/hadolint/releases/latest/download/hadolint-Linux-x86_64chmod +x /usr/local/bin/hadolinthadolint --version# 检查hadolint Dockerfile# docker 运行docker run --rm -i hadolint/hadolint &lt; Dockerfile","summary":"摘要 本文介绍 Docker 命令 中 Dockerfile 的使用方法 Docker官方文档 Dockerfile官方文档","date_published":"2025-05-26T13:30:05.000Z","tags":["技术","docker","docker"]}]}