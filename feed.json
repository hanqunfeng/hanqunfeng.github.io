{"version":"https://jsonfeed.org/version/1","name":"飘逸峰的博客","home_page_url":"https://blog.hanqunfeng.com","feed_url":"https://blog.hanqunfeng.com/feed.json","author":{"name":"飘逸峰"},"items":[{"id":"https://blog.hanqunfeng.com/2023/05/25/java-concurrency10-BlockingQueue/","url":"https://blog.hanqunfeng.com/2023/05/25/java-concurrency10-BlockingQueue/","title":"Java并发编程--BlockingQueue","content_html":"<div class=\"hbe hbe-container\" id=\"hexo-blog-encrypt\" data-wpm=\"Oh, this is an invalid password. Check and try again, please.\" data-whm=\"OOPS, these decrypted content may changed, but you can still have a look.\">\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"98b018283d04732afd5bc9c5590f9c6e1b7baccf22761146995bb9c9a4369290\">83e4f756d680019cc75bb3d7e0230dd0b412a416fdea7528d7e9580f6601b2f16c3b74a5d9a5a1da5dd61984e78f0c846a143ecfd5bba379448319807926070c9261aa0fe10bb6f9896ce6f30c9802b7817ce47b5373bb66b6065433067a6176900f891b25ad8f0512f52d29ee75cd3ca8a32a796d253fa17c333d3f711ccbe24f46b73c4094a1d22189cb0a8a140cbd5a088bdb5087c3152c50047f9ab29a03520922ed1473037268b711b17e5d1379d53a4bb76ca4a83340902391de7e7ec1f38c9c8e03327ae25b45f0257dbcf824e46957a2eacb1e308b8fa8472f1b83a8bcc9a8160e981abcb3d1ba30e909ba4fba3980a0c31df7579dc87d797917337ca479a51c09ace72470072c706db76b4621711ab30673bc24149caeac1aa693d644b7692e450c13b7001eac4bd41390809513a1655a130eb440b409ae493deab0672f6807dc5a972d68746e21fe07cad0015a48f47ba88ec7783c353f9d7d333c2dcea3bc8c97a40e5466f0a5aa369c1e3847c1a7a69dda3164b71f49973f30e36e190eb60a806d1c5ea611ddf61e90662860e9f69ad3b89eacb54e7593f925c888789630a77e54c1b76f26163e3e3f286c79d0ca49c845af705deecbed52de6bf77e11dba37461f4adec200886d8ccef97801bc21c2a184a11526e81658baa8482b417f6e2b2a7f1680f18a8b9d54a093e8a2a95523879bef658d040be5ac1b76fb4fab5fdac9bc549ed8d3a97c7514aac148d18eefd093f4c3be32cdde36dba49d50f182a5b9524754252a35b87e69c29f4c208b23d956794403aa7b64cc0294ce7ad147246f8b73ff2dead1a9ffb42fbe28225d4a092417d2f75c5d79b4ba74073d830f27fe86a8af8fc7b103bedc7d2d67c8f230d835305c9e4f385b2324c1b388e6f5f7ebe30ec698ed566bdc70e14d7c15e432cf84a057c5b167716edc065a35e1ba6a88b261d46acbf43aa81fb3c227ce0044c8dc715c806896104f94ae9d7cd42cd3255e2991c71b2cd4bae2591f4f0ed84a8e4750db164e394cc3b7948d8a4c8d5c1482171a5f38e12a56ef416afd326766f9920c368e7c20eea2a32bf02abcd83d9ef84007aa4d1c55a2657162ebb7ccc3509097b914ed6e9ba8fbad114b1834e67e4b4715f3b3e236232e31f145f6e4414913ed297a8a39f9cbcca2f939cf65932b7b3d525cb4677b7d58b608cbb03846ffffec4adb7b2151b88fea005c51e53c05db1b28266b75fe1b55d306638ee6818854adfc4a3f3eab850b5d2d569bcb69a57e2cb29338f7a7d6560cdc9e5cff4422a9f8c1cfc95df0db54304d49d4869e9518a177d495750e7a6424377cbdb9477521c0fec9ffa354e4f9566351fbc722d6249a74c46b541d6f4593cc1e6635bef88ba48de4c2e85a6bf9a8bb0fd9da4857f21e0218c15075c660830c4a044a01a2ad7cf7d2e4a87bc789b2f2454e80e0ed72aef3c3d19070f04218df44f4ca11a083c5e8fd548aaafbaf7ae70fc62e5c618363bb3082e9ac6e760243f257c2f0b0224cf15fe312603c0fa81d9f79e0033e79ea9fad0b9afff0fbee56de193caad1e9077460bcb21198bb326cfa754a4ccfdc138b375e3c70541957e5665d33766672e9cb72a3a8b8b9fe494d87a3cfd26881cd0b17818658e4c423701313db70d8766210287dc8465108f2c9996d1ef6c948ab9890c2bcb7c2d370da76ffbf27d611e2d12119023f14129d5f52e32fe7d7e2fe7a7878b31481093f0d68df50f68473042d5164699288d3a99d9985c5e0fbec11fd12a8e849a4c130779ff1c8667ebbc5a5416a23138ed901c5aef969d2798e80a34be011ea61b6b32e12f555fea75e71d0ec86b1d7d977b91c05faf66f2b9622985b9c7033f056ce6f28efbb275366c907cef920bc76b8adea8d4897d239d1177f2a5777b869048df2bba775fa572876eedf15fb74336d78799cd348540161c1c6b9b51c0886f2f6583ff2201756cfbd31077e0bfdbfa99ef0eb03dcb95f4c74f262a7e7b35779b1dca6f33b226358a5e715b517b9cc38b5d2a36815ee4542721700adde7c8eab9a4d30537af69b546d3c5ce92394399078d427add8bc1e1a1908f8305e39af128d05fcc6ddbd68bdfb892247d5df0a44d4a6108043fc6c681bba47a32e06f83df57c5b819c1ec835c17b0f90d6fb79d8b814c259b04790af6f9977089df3d176d77fc6606645d0e44f548f960ffa525970ef2805c2acf0c8efb399496f5f89fe1a2bdfb662ee3419fa84068d5dbec5a1193a9e8e9d3d8d4ba7665c3022eb51ac47b36caba1d3210cacba2ed2b0945e2816d035059436669f16c2f7cadd506ea0df0cececc9055d0e1f2b8470e34f698b3d2bd4db05ea2917fac43cf17c1f6428e510f05315fc65b597cab7e38bae06e1ba921ef674766ca6f38444fe5fc7103d95a4cf062fe2c3d1dd95aecfc2b7368e7e52b9be97ac904f4d8c0b45232ae0723e025405e2ec097a520fff8ec9b16df1b5417af0c04ad80f94a2251d2a0cd7b967617012a2c7b933326d3da1a412bded92eb4276709bccde039d17b30f30dc8708887ce853317cd94ca8009895aec314d8e1931e12cb7b02c932d340a5a287a937e77cc8a5ba9ec42bcdb4bb06f8b11b1d639316f6633bbb73e33509224cc4cf45d23516c85a596472fd74e6fb5395447de3efdef0fa22f8a03cc98d00c484c38ed4b17e6d5f2e6fe4f5b28b4bd262b32b898142f334067c2c6100efd2a9853ddaeb8da57c3b4082bcdd43980c80dce47dca13a6b95c78a9166f58fdd06b87e32da3a446a82187a1ceb02bd33f301e6e7552d2297538904473ebe83a707ee1286b5ba25b3d9409b7230daa80ce2a6906cc7466da175c9dbce34b8a775ccfe55ced6eba3af158b8b1a7916b984869a575733e5c6ef2b3357bc80f6caf9b41cb8090a2636e7a02c68d83666e661000440cafbdcb97fc4a67f1ddbe90bfd98eeb7e3ebb193b8157a91b956e8689a22180a3563777e129c8f53cf060233587ee8241f3bbafd76bf54a7851cdcb31fef73dc2b1e0995056397d6c29c8ddd72c9644fb5c8bce5a513f70079808ec01bbf02585b8c0f38247d67682038b4f1c869dad326cdbe4b6ee2f9900e345b1d10fc82da3452280c98b0a730dfb1ceed8529b8bcfda4bb93d489252b1db06ff49115dabe6db73a9248fd48cf015d9c0e40e9272a05cc25333c550c14cceb8658b24a6d39adf95f33cd85bcde04e25f91926ec8b06ced533207419e9943f8492191b396b93bdb8bc1002b54c81d63e7652560364e59c942b50d1473aa41e298ac7ac3d0ac887fdabcac36caea8592dee0171636cb8950291208f14abd8191f55117bfcbb517622b63f360f3b8beb4133a04dc207f2bc4ae28c2d897da9a08da15aefe5f1a6f567b4187c307609ef7e6c38e033c64f332191e26fe0cbccd339700b8ada4ce7665d8f002ca013bedcf2bc72a2f288f29a90122bce91bd686b21f8a957e28e96f4a958338400f9d47cd4ebfe37715180e77a6c3df34b8e5703489507d03bd4c102d3a08463ebf97a4d14d56408f4c0c027803ffc0f6afd478d7bf862e51ccef6ccaf6315b5c79f49ad9f60280b043bdcc5449987d5cdf2fe6bec8c1aee4e50f0d9f9ec9c91f9c4e49bce058d2588dabdf37281dd0e9996ae127b4892f0055a710db0523ec09964b69717583607d0231ffde1a917e50495db1fab56b46c57c51e691fc25cccd01bba6eedfd9e998fc3cfa63d23bdadee54b7dc62c3acee57ceb98d7c330685040e68256de3dfef820a0e69af93d0d286b54914d7c3728d7603c12f208163419114d6fc7f35ee30efea56ad3bbd744a6036c6b54f283c4f435e4647ef0d2fcb7df60a4cbab059f31cb64b0fbfe87e9a2495e4ed8ec37f515eee8662b4d0101d5ad8b4523c7c31a485dfe9ad896ad072bd6fe4e0720ae3ffe7f42de0a8c6bf61670eff5bd241e3ecb918094f92df5e791219849f8148b3153fe81224b8a834661653608e3a62896a81bee475a40344518f03d24926d526e06a130341138305bfc4c87ba36c4f814f8f412b64993fa07ce145755e554dfbb096a7b1f5249dae5ba3f19123a1b89a703367faed910b21d91f0ad485ff57f320802f049c65d52aa681a3d2e9f04e99b0e0c2c65c6ef0b5444cbb5f9271a4382a3d046cc5fd4b849d408150b233cd90138306cd314c4a0553dd7fcc82758c271f22e64593e9bd9271355c94e5d1144833bdf73d0daa83b13030799f8727ffe503ef997bca8026083e80b4f322442c6ac17d9b283fc66288fe0e6b6c8dd5bc0278cb60ca3ee35a84cf7e7b7353becb5540e32b7fe6125c6a557dda4ec458c8818b6724538d08669eb2b38cd5160b31f7b91d85f9281ee3cc5d90cdcba8a3441a6f7f66016e680996d026be97770eca9f6b4204b1da4d20bf8e66c91fec9c091a677fca7ae68df44b63ad0631eb080238b27ddd5903ab93f2d6d7785dc4416557868f6ec091694c58e0aaaf1412a0bcaf88ec55f41a6fdf9ff77332e4cefe280453d1b3458d6836cb6c0bb24d9403c10197d9c73180a6cc8201f6f2162c50efbb1c7a00a3938fcc16ec5ae86d0da6941b6b30932f1737567199fe135740d75d79dd06847aa65e6c25443bfaa6ab3045ece4f69a7871e23eea87fbb0d9516772220b8727b3eb1c33c914e76df7658bcc6f9b52ac6ccc2dcd0f32f07a39b5aaca061b56e21e2e9fd5260a08b84d1847054bae3a98a870c9df0c2dc36c1a16645435ed2b290749d36a831e0a0558768b63d513028bb4b35993c6618d525445cd4cd9de25e935ddca4ad8a644cc50d88617e5514fecb31dc443cfc272038e0b7e2f06a94ad762921487aae3590c104a6bb8fe48576e4b30e81424c4741ecaa7dbddea03d80d679b97a86947020905cac63ef156b52775260693ac2511c1b691a996490d78ac2aeb865d0ddd343f24185ffa39cb5e730e5c7e600710297b616c036e163bfbd59ecfc75e3ef8d54e0448850b0095abec1b4b5bb6eb2c41020dd43f776addd783b93b04dba7a7ce5cd3e92a3360c0bbbb4533f891d8a098e9adbd38e0e8fadfbd3f4b90ac54a77b81ca06ae922dc2d15a74748f62e82ec14af79d767cfce92a9c58af17103cc86991fa1a3514a176e072a17776e8b7822083198311266fe5578c6b8b8006199e5b87aea66522e6258d79d5ac2d29b32264e0312f0326ea45e6cd201c53fe0559e00814854461be8645177c728bc609cad8674ffacf3146a97dc9ab4e627b1ca9714744ab0d809d4c678b3d4977690e5b5c88538fe4412431855a633909fa96faac2f8934cf81e372116af5a271840fe1ce38dc05d591e262616de187b378d026f33c67bb543075e703c1dd2a3205beefd57e580f51f5ede218e27ad89ca9ae3dc4035affd9b8e174306b480b2dd323ea0a852eecc8348fa049149db4c0a50248337d2f6e890acc9b41cdf6c12af46cc241365cdf50d29c0f996a0acb311ea042c5716e3661175d6bfded61b16c64052647c24c237b45e0d523665c38986c56ea2c8ac76ee165f82ea3c191f19434742bce404cef2d5c05bd46c64df7996e8f9d130d91bbd2e66089b9670b5e55559317d5588fbe6e61df3afba261285a8e25fd026aca8f06d88d4a3b8f01ec3e464cc7a73a32d7b50784feba1fed04723c47c14cc239c765923b204fef80399431aa727568336253516601353dc8f864f5754b5ba91fcd71c6ca95e65c6b13a6920b79f23c7e74d0cf1e76611b5e78720d5e1beabffd4c53d218b04839c066ee5ffc99c0e8ad95b5bf439f8b1c12080c7dbc08a0f7309754f5ad9e83b7d04b8fca44d84774e6c1abd771059bf9813cd88c2cb7e50ef4eba15212ed21b7f24e768d94526f783c81d4b7d11ef721ce29cbb7222ee76445fe3e5952717b1bf38df4655ba96f04a75eb37d2acdbaa06842deea344082fca771c2b9a906339e1bc9689b79febef103fed77c1d2dee8077df24505d4042d507d09ff8919a7bb534447acb36026db882bbcfed0a582b8e4aef5184a1916a45a7394dca56425687488cd408ed8fae9119ba0b40e0f831215a0115dbf768117845a7353348faa34fe9e577870213fca8360fcecb235ffb35d9774106d4459a7d21e9944d2d4a1aeb69c95d90f403e14f0e9d48d134d398548c374187d024e1f73372a492e54e7971f3b74275402002bf5d7ef6690b122faf05f2fd5c25c7631b3864f3eb63d57b2d266792159237e89cbe2b77701b75497575c7c16abcf7656577330d0f3e26b9793af2189dd1332acb4d06f7f4a7e47c12fd7e2a72c0d1662168b4013398fcb1b5be5990ca5e12ef2a58d63556ca4ac8137745c8ec37e344fd874e278c9aa93fca6217a86901ee78a8d8710763c6b80964fbbc75c399255b22149d4ef42ed6f12db51b2a5cfef4918062c8ce1d94abc04fd526f3ad306376162c4972d0b7c19f79a932b59cbec91d27ceaec647e8d36081c8f68fb9b529a1c74c30e36eb1dd7c4b800efe8fef829f9613ce45efacc0b21b4f57de2aec98442f3e735e908ba408e9672aad7f7627f3466656eaa23da48ceee4a36a5361b062f7105e28f174bff46e88d81b927bd6e175770851efd7e3381a4a182d7604d20e0cdb5ebe0093778f19939b1f3bde080cb302dd5fef9d0c0fac105aca6a35bb08e603f38e1d426262ce85b4dd8b44c032b45faddf3c25a1c70150919c6f14bab78255e782a8d7b7f712e0918f85204aefd4220e647101681b94d84908463b0f7c523e80d8f7569d0f3f961f3d3086a7419667529259a89f802dfcfcb1ed9bddae03b57e411d13eb7cfb0d3d948849e8a919e705f20082d577c7b4bb0d6a6af11241f2ab4f8f4845ccffc7ccf3c9033c320451b1dc29eae59d32151dfef2f19ba2b5dbaa4385d26aebe84e5ed4b06697faabe55bac6c3be8535d3029cf2d04e2ce986c6b7499b2235911684303406d14b32a11667e62183334e257a8b991b5700dc7e3cba64e557ee13e74ba5fd92a45cbc88dc431974dd1cdb31bf8fd016f7a5797a7df1bf882d705b0b96d5ba6f815d848bf80f6658509bec75850616d4518992e6439eda72aea120e1252ef719b920a08d1aa79bde4c8c622a7f9032dc180ecdec18b77150ad1a008f34c07241a2d38af4bfce43256418ca1899130e2646438601ca689f0399a6c77ee612e7042f17f8ed7270669d24d38076a2d5cb52b968c2db158e8b3067a2f6144d0b75a793619db0be8ca9e2458437d9430a778d62c2a9274a261d98491d9e449f559766141fbe4c337b0d602bc364759ac3ec2d895cd29302d47a44871457657f8d12b9ca006e48739f35b130836e0b291222986f163d9612400438f0e33ac5b65ec5e024aee0fb60d885152328559a77c9440e8941503f358eeac99ab50d00f3a938d11b4065300696d4671ffa52d2bf2112fd2bd04ed4b1f39480d2eaf8c829c54ab5651090068ebf59c0efc2f9aef80698374c452c80175cd0c796c64046a860d91b49f01fc67a08af5df3effb19390388e0320a577c8b450a54c292ddb172c5f91b7c7f6eef6f74afda5a520efa39b7bca7237c3479bd694e35995f2c4cb4503ec240375ba0dd04f77eb770ffbffd7fbf636da05224065a3574c0e068535cd741c437b89d8f8769540c0eee8c2c80d32d2de5f486554d0226ea0ded16cb8fb3d85be1d48cd1a86da472f99b1ca6c848901fcbe4708ccad7f9de0eea1dc165dae1e9b12b4c04b15127edc20b0554a9b728e8efb1ee7780b34a97a61c9f50bedf0d8a6598d8f4d7e587dfaff720215c9dcfb5184bd9fad32a9cdfdf01b18c849ca0951ef18d8fbf146d7d0e30c15989e0f1ab9bb5e8b7beb46424e8948582f3c4c488cb22d587082a4a5d3ea1720447ae23649509013c1da44e55f184391c52d762e8bd6ad3303fc91cc0c3cc3270b0dbd482a4033d72b0a382927243db223f4bc8ae4b0d61498b8469da193df0c55ace28f81b5d7d54c7987975f253609616807164888a3221b292b81584089e89ae397eb875d691dbdde28335aec96804106914fa8e2f8d5daf250acfac5b52653ccd160ab4734b41f50b74a1ce8034112a635a6ee2395c3213769f3d528f15001b982c4aad0ac89e0bb66fb53d2604a98d3e81b43631930590a74a8be60feb2deeb6ca64fa9341d23080e20768306849ea69432cb86445af3574ddb9461254b5c570e3664425ecf8d70c47e5c8762bf8aff7f9a83004e7ae3d5b9a69b363588742de1d0ba71fdfb2df1c4ff39c538c6e094aa0018405498119bc909bbe18dd54c7db151ce8ff10f357acfe6f6a8fe5cdf28bd5afdf7744e157834df1aed0af8aa680a5987ee232a3b086ab66b2c26ff91adaa0d2ac96babd7dae860ca419335183ab52d2cc0e94d1597420d711339e58f8078d5688ee51233aca80ca65a0e8ac8525bb8c54d2c2c80bf83bae040d93c51877a675fd73516926e83311be28121b7e935cd7b2f3fdd38f00f91d04ce2e99f8e25c4f3705f0d7420642c9e5f6d4cdabbdbf4be6afe9bb967294c4bf5c23d77ddb5cb8e1c41856101ac0d00b2bc144d4c7ac014c71e82c139c4c856fc91760a4eb984f1d07ff1a7e81fe9ab62fdee61b70fcd4fc2534f9f2d3728b6d685d791e34f2a0528c1ea1f486b3b94be8e2b9ed11bad8b3013a26a347958228031d9b00683194d5d3a2f64734c97e11b25c9cb4aa87743bb5c598c5aef7b05e2e0d1a98e4aa15c3282305bee9244c00128f5794ff2ab656251d2c30d39479744dd8e86f49231dfe838fe20f631e0154bd99972b99230d0d65fb2db2cc09dfd0232dc1f6f99d4d72317d20d0c4ceddf35d927f7ff1acf9ef1ca5fadd2ac1e1b99cff0ec84cbd84fce2a1fcfd77cc00daecea057cb7278b73ce92ac4149dc52580e4f3479ebfdcc2906e08f5e29b87145b4f5f65364a640242c6929d8ef97191d5f3bf020409ad857b411d44bff18697a2e77e1d84dde5c49f304ddf1fd1b9df91737f76da00a9f8f88b8e274b4f932a7d7bc21086740f8defcdc4c80b807dc0309581e3c735e6118006eea9fa228d39b001ccc9d485282c2a23fac2b7fdaf0504dad6c9db94c78b0eaf3a5c99360ad593f395485d9936fc7faa167aeb8e54beb3418ce193318460157bcf99b3f15fbf21b73349c4236429759b14900d53143f76fbdf3c6bf147e45114234e1c26ce5dd0ba7b90dbfd2a8c54815efae7cab2b6887e9aa224a2984b42c1c7244f0f752c6c6ab9b442594e6433cb8a3537b7914eb3481d666570ad0c6dafca2cf58122a71e940280799b7f1d9c544bc4d87cf40cb2fbb762f4b7d1f9c29b839a53ec766ae1ba8106485acecfbf14e4131db4735d74dd622134f48b21d455cc591dbfc67cf93462177abf73830150ce6431c15c5c9d474580be586cd24f4d1340ee4dd4fb197196419f70821064e84549937b99b1bbeb93254b8e0dacd15b7d55743dea61b28716904e7943753962007d0147873ec23893dc3e150887ed8ceaf3e83d2b90797888ea95c35c69f623d71299690e2901c544cfa7c459f0767bbab68afa83ef3716076bc63bcca788883d93958b68524e39c0d1b07bb1abdb2b2893517bc12dfbb96537923ae6064d33f664a5cf6c83e784242c26dc12a82871938ce5accd26f35cff648e0ee3489879f9b129ff3a2468c75a0cb18649ada8fc640a0a40d0176c997d28a040480edb5a7a84860f714872f2362c22e8c2b74f4dfa4f77d82bb9b0b0a1fe5b5f1c313caff857fdfecc6a4eddae24713caaf633b5b4157234fdc13cf071b4a1e20b7594513804de8d5471e0430ae7c6ce474debaa3ed8bae74cef9352b9fc0c3248c22b063b730a7de7eadb3f372646e31ca110549fd57e7b78b24700aebcb84125fbfc2f9951be187e17f0337c190b4a1be1eedff2e677df2282435ca3e42bc20fa1ff59bc56777ccc145a303678b4f12b3c1f178e158f2259705a2345d91c7bd57c86af5efe459e78891f7094496835ecdc8a78b9736ccca7ce45549ce7f23348f2da5fbacebeac6e2e787b35fdbc616de857affc0b7d7d8c2e4f932da807dfb6bc1a9ebfdc1a1328e9e6a210d4a064367c74050c98f066dd691a9b927ef829d99754432024627f078a2fd3066c48145b6ad5d437d1d14ae00035609e23ef741ae974596186edcb518a41a7b6efe50f3569a37ad5718965ade12affe36eeaea65d7c1798082a09c41fd043c8235fdf66bfe90e4cdeae6d996c5fc3922192468183de66cf2beae5690132db0ea6d80fa85c8857458fd472592800f9ba87c47feacebd782c501c11c5d1cb4032f0209675f0c405969c28580d5564fef081446089bac5dac8d7158761420b82b2a4a8f79644d80008025302b2e4c34f1a3747f3f69de72526d0695943e36b72814b19ce7045bcda20b9b874a7bd5d7de9b60037c287aad342d2713682fcc0f1aa5e4a1f01b2d5636266c2b825b2fa755a75b339dfd300e6121a7b8913f8c349cb7ab16c9e4027989edff835f0b3540ace209602aeccde27739100311be21e8aac2eb6160b2e7f3632e8b8eb0e5b5494d9dafe69b09ead8559ce04dda3fe99d942d7720b9118328562848b3c68ca97388fa857c35ba00135322f02f9ab54f6eed6d60ca4d70ce5ec40cd342941ceb2b1923b541bdb2302dea7201f97c0dee2e0aa57143c8cdc48613a9b3c9e7c1276baa8635adcf8e06126f5f3506991b26f0323c26af2958dfc26e23789c5abaeb5f943236e1ca87ec86e6ec8199f590d76b0b2ef4b14ab0e4ccbfee4e1fcb1f66b3f4c398b06c526cef7c9c88340dc41f407329633a4e9250c451b9e0ac0d28d5686ec8b3038ebf2796e3796e5958fdd3415df127ddf6f81d108c1818b443b3fc43c75b52a0a10b6ef10ce06b645566b69383113927e9b9c753445229547be177ea7de522e37973acb70cb0aa6091c2db4322bbd46c544f0f23daedd35baf474ba58169321e147d1cb5b2e97f2783a7835b7b8f389114a82c551befbdebfd0da4b67336afd1017c0f848fc7a1ba41236fbc18c452a56f4a84711190a1e94509f9672b2db194acd767c3ea46071c4a8491d173c4c136856792d2cf5afe2ea790e48e9b1285c80ad75704faac724a40addd76bf357872c7ec233fcc7dc896b4712737cd906e42f6f609c002bdae700e3cfa72abaa4daaf32b51bae4a58dc8ce7331f52786dff41e7584e38e608096bc1f5ad529964d8c5ddd51e2c6d39ba94583377ff831ffc52c7e4fe8f3e35418e547e28321cf4de20770a599ff2af10d90ff898c73415041302948f531975d5c1d1fec27c969d6a42dbc3faa0e9869ac99d3a07dd6bba3a1eaa86543814684c55dc2ae601d45155f1d2df14be1d5b45379a8e3ccb4418dc5a8761475844b53cc1d53d8ad3d23eb10fcfcb56fe0977dcfd5211111515b1d0c0c227bc648e5941adfa885e5ac62cffebb618ea7112b0015e38c0b621bb8a1148f7a465d5f90a4a405b8a10b3f66a000c4039dec96bdfce07d9670ebfa75d728fcd38ca8bd822c95c87e61ec4ea2ff5b8d3a9f9a56487a89e1219afbcfd440c5e9f5f7ddc2c40e73872b97dd61b91dbb9f4d7f97da0de225c7c802c017059f3b5b3b239fd1807da678c341a8cc225bd089a63870a05c4528e28f8e0780834640ba4eca86b3a68c6ff7db0e9b2f2206eb9ee73ba35fdc389d51786ff7912fc7a5ec863c2bbcd8c826811e824f3e62c29db2acc1b7227fe64b906b43db77edb4a1711e4c00e34336ec77e3548db736b2b223908c126eac5f51ff196d824bbebd85303a7a452700368eaf872fa101dede9162dab2e3bae54a172230114d381a120ea4406337bfe28c137bee7e706d33388d1bb1ff55d3c57d7609eded270bca475ba2f9af6754a77d98f836e5bca17029f095c33efe754fe57850cb0740a066720802625eb0cce66e1da1fc6758c6fad550b258be31c734ff490ecb37e399f89b4a61f580505c6782f0fceb08b1af5c920c81914fb194efa091fc866dfe2532ad918f74ace4499f35f482abf9c62e031852f7ef79a6161bd86f0d4fbeb7aee0ad04b2bafe361a144b42dc94a50f30bb020b8f457dd1bf2868fe848c42b927a4e54850cf413d04eb4a6ccff29152877074a747f214ad8098496587475baa275546c7de824593bffe55e17d850046ca34b65ef398dc7ee10173022b452c3c3aba3bf0e00193d3a702d11c6bf66762e736a3fa180e78b7f8da3b7b139eccd88df6359c88cd4299b3e0ca10c57bbe580c0a0adbf8e328237e012c1e495a8098aa96ed9206062f7939618dd29a0a80b42ae59c882fb290242d7bf7d131d8f4fa28f3c7b37ebfeab132681a8a2c88cecdecb27525110a171e32e581bbb95235a3ebc61e76cafb88abf536bfe3c5d35327ac27a37181d8da1f51dbc127e2824b9fb4447d2815c1c414f2de76ad9a199b82b7d5c934872e341d4a2e9f7886a8bc536e9e79c3998b6411a5014ddd7f6992a72ea842eee4f615a985069fd6e472319b0cd3c505af6c210b6fe81b34e85ab0fb0ebb17cd3dd718b88174c93b6c5a9786a271b8924ab95f71a8f35b09799c3498f9c59b1d43726e2e1004564f4ce14d7b36788ccae6e25273cc007e4cb59f8e925c59dd305f37a43be199d7869c3ebfe0f6d913900f81cd271ba62fca8e4dded7df0b4977ad6abdc3711c777461007d0849f39cfbc0e206d2ef235e929eda937d7402de46d7d3a8fcc010635fbdef83a0a6cc1fa6d9e54aa0e5f17a03e4b6d49aa9172c01f7587c14dda63f64bf16c4641ea72104fe4d9f91d7d87a4021f5e0ab634e4327e70dd632acf3e3e4da7193ff20d5a69771ac99a434923c763940f35cac6391ff8f88c741e178884edd02b84e69ec37e6fbf5e7a5a107298a2293f8c81438c553716be35d6c88dfedfce756d4dfdd08e88fdea7ff4fcfc2ab800a12bf8107d4f86c99a91b3ed409d3a7194c9ff22de7e4bf326b974439f4a6fd31ddc4c601d4f48933f3cd2952a79e449dafcbf70553e72f368e21735943c18a2b28ff383884f5b08025c2e9efce38bacab184abdb1d6f7688d1456d40f1eff2b55348f3b2b13546bf6410c9e400c827b0a87ab388167b8bee0d132a7632046cdd55569ad2aa27be1cee8f18e23f413567d59ec9172bbed7511ef32ac36eef51b8a77b24cf71fdac678e05df72ab8c8a4210a43e659ee5f388d3b49fad7b90f2798310a8ed21b3290d17008696a29d65aec7962e71652fc73c7b0fdb642339f894f9269738dc08e9b57106dedbf863154874f6c9ad622a837e06a9ae137e0f6a68e6764df34a77c34cde04095004c0aaf34b362dc52c70683e5b58ddeb5d376ff50caecb5a93b8442e8189e827b0332509305179d8a01049bc1c5b483062b537f9c00b0474d8035b58d881ba7fdb3179363db3d9e858abc1a05458452221c30829ea5daf442bde8f0dffa23385cdc9264bab0dd02763fd2ba50c4085b7c2020079906481414d194945ac5188a54f0e90164ee573f9465670b1da3f3afcfd4a3038c9c311f6a063e50979d4b36e4548d270031e8bd724368311d520145e8c30ee6870359bf637a18ba4889f88ecad4f23e0e87cf365a8bf0fd1462aca4a08ac0fe370068892d44e99b143658285b424be53c957c52e198a2b56559e296631e997ab208c78494a8a61ec9e1f49ae2594251af410ce44293077929f45529c86c418e147954ec3a153a0001202c1c6395f31bf2818ce9040b617085183b9c4233492dcb525cca4ce85d2893c3c02d449bc1d6b557ecb44fe69f9bd96c144c0dbb534cb9d2faba34c2ce559993a05464c3f47337086a35e4445b28d444967116f3a5d240142dcbab1342728114785b1ccdeeb1eac4d8bdf4f5a207c61e0dca255f72da8c06e120de2f0139b30688bd5e34cd69b9889e30b8fee9a2664063db0f15e7d701194a24a38b9c1f7b9d2a267296daab44463b1afa544f083eba4c954cdd55c721c5f409fabba38e89c6de6ea877bf08d0d19e875b05abbcb059995133cc694456673fa80f1cb3816eb0239f3f134069474da3ec63c7440b2b82e87b16425e0b9604555cdb955c09f9a6b554212e4ce16da0b3d207a9c3613c9da6c90fd4cf90cc769c3830bcd0091edeb75c3b445fcb087effaea13ee40b51cbd1b1ba3c902b6a2d9000734aac06ec9836c8b4caccbee1365cbc396af0ca15d733184c2bbd6474f2b3daf507e30b402a8b126b2e91b8ce6b41feea63ee711b7b45b6cee7299d710d6cd20ab988efb3389ccacab521ff33506d6849d8cecfe44b99aa3a17cd067e1fc00728aab47e494838f837dcbcf579686d6af5cad119d7523566a136ff648e045bc2b30bc9342b1d00e1493a2cf8b2332c0934079b7d47001366e6dde90542b11840e20b14fc86ebed6a655e19124a5739ee31823633cc7a122550c79c48ad55da818c8d53c8f1a2e653614f0a4efa4c50f677b6411125d67d0108a24b9f124e321cb175a45f7691a32328c0e4b7eee3994d2b8fafe5f584c261473a093f9d256bb934c513b7813123c9f467979f8082454f199f5d6f139d731d235dafb9c020dd997fe21e908d0f07e7de0e6f717d48cd7f12027be99dd90045d7959feb32fd665e74fa5120ab45f59ba6575f68aeb092925db63eafc8762974d561b760d50d56c5bbeb8d899a0cf1184d2c4b6cd20f2a3f72d36f9a3ed6d44377c9b0b488e9e6fa62501e8621a27799a150782b0d439624e450a7422194541cb0821642727512dbd61b4f7952044e7242e0229be5e44e6832b992d8321a212147c89840df90c58208ec929cccefc21cb324fab41c97c58406a63b9638af124b633791c3ff1fd6e006217f5c8225f67157b68ed093a39fbba55d10bc47073868024f692bde3eee618d6e261816213d2ea5b092492da8c9864f08a6d9f6166bef810298dd7cb849dc2aba15cf06ae83e3fb328ebe16d81b1a056bf7fa2292fc92b0a98de72a1470e1de7c632b2d838abee81e576178a4551e7553bb979b3403d5e9cff6a8360ea4c913cf60b81adced693037ac5879cb910a110c6072a11bf78aabd115c8dc5389895cb69ae09242e66eb4fb60249518c0d18aebd9836c267138810f0d694ae032b5ad6a15e4812e80db88fd20a3c2bba344aa132de1a9878eb449782fe3170e176dd144b0c068fd0d0a6ae93d848340cce16167926e3d82794fced5fea0ebdcdae406fa7df213121fe8f907b32be6d3bce926af5d649da14b0f5667d9a03a44a62717186d82b0a27ddbd283edf9c09b6ab842f35e8989cc73ebe36116c676c75825fb99b00acfa1bf677e7609bce6ac0e6749c4587d360c07dd787b08603a08c0ad695b7b2afa7d6e1f8295dafc508acef07c80421b2cb78037d0be52d29230f9ec8e080dcc295d408a38a0051ad232277fe45b1c7e89a69d19b6e5e03c81884a39c6486155bd0b61ba28c3d08cb9f9b09838fa6aa6aa50e66d550a48bbb90213dc5c68f901a1859a5c5221c753d269a1f451a2480f171ab829644b1642891cc6f9f09fbc972b238bad842c0fb67a7d088ef783df41e7ebe532ec9107c40c2e535b12b6b39950bcf1ee8ebe64ba4284d60efe28ea1ecbb944469c0dfa61cfda2aaff2ee68614d59536387569303b7e0a4429a7a3af78d7c6223e1c9f8c5e24d3ee86d2e90511a9e2cb8f1c43ee035a29ad66b19c24bad987f67e82c1a781dad4636e2309a5c2bee8a65ba188d36859a04af764b2432c1ed44e3ac8c69dbeb36c6aa544ff0c5ada2f29600bc7d946bcc3c0ee140661d5a8a8759a46a405b10dd1cd23d03244b0297f5eff710dc97d6b466fa4c6549e21ac1dc339941785b87b6b8e60ddb63a23ba12b14a9a9b8bc4931a280c124d4c23822127d08977af5dbaf68026915ed1ec026783b6c72c830f4ed2ef13cbb91af57c9dc8cb676db84b42db829398eba3d53fcd69170be073fd0e607353a8368ecc7c7ee10491cdab329ca33457e218095347ef7cb60545f446aadd3a5d1f26e2d8095efd848bfb417b6c4d8e6d1cd0d88e6af2e7a0e1b98bccc3665c81b1a42b2c64910e717f4f6e07714caa067dc669a14759447b1b61707b48ade0c7bc364f08d2efd458933b09ef4b2b14be10f644cf7b0d7c1701ad8f71b72e96db743f761132b3f0357cac9ef7599532791a39a4858de3cd669b028590d8b8c78bc9c64d143143775c3febbd58e75a0f0647a93da42e7b00ff8bdc07ea8d624373bf128d9ea6a0f5f5f971075ebbfba8059fd1f574013674040c1147f2e178fb362b3639facf10691e5364fcc4391dced64dbb09b921ff821c73144513a006ddd401c79f1d608c9606e74efa729fbbec8b9bb3f4bfd4dbd23b9e7e994b48a5f69545bbb8fb6fd5b631a7579404d4fbe07387dc661a1d3c3d30f21c5fcb57900ffa5db5256c42fae4ca7d30f8e1939fcb8231b3738dc06a2e3eddcf545660f974b0159c3aeba022a7658b9c156982969327f817c61f248b271da0e49b1e1d54e115284e121f0639a2054e6a7398ef255dff0c45f4bc2424edc26703d82e5a9db14483b788c070ec83092577ca82ae7b7da375f0e63512f56b399dd8659f28aeb5cc29dda0e5b44b641eebbdb8f3a8098b3ec98fe4a92dffb3eb835aa5d157198af4d9631a585cdef60a89295e1f5c9a21ddb59413a35aafcf734a88b65bf621bf39c81452264196dd93622c1302cdcab1bb76cd66693a536e882edcaaf1929cfbe21be3399798fe6462a5a6a20ea73dfb9f59e838df8a1ba25e144c73fa27de1c2a2b70b36d3f66a51ef8a606677c7463753dd18f25417b70ce024e7c01eae4d40590a309edf250554309ee156dcbbd0e7ba3845fd4c880ff9e01ff6ef9e3d547eb01cb7fec164b525a694b4bac30fcb2f7fdcf1b2466bd56f391b63340d652bcd6b08ccd1f8b75efad3890c6c3ed5b4a9b6358a45fcff93cd3f309b50ee0ab66e3bc01e8e5a8119f0be6409be2c9bf81db20c018cfead696e6fa5f6eb0088cd693a795d97c16f62d2986a285693e28b3f5dff122a366d420f94817b05761e73e4c2f1f70a6054b96680d10670071d32f19e4beebd0d80873a2a9c900caa57d33a6808daee9ce6ac8f27ce9b016fff010b692f2b6421256fcd7872e40de4242fe59683500a955f0d2c67db713cdf79ac36f055b876475cd209b3441639932441955e0c9258a1cee97a8d90a1f2c8a9505f448168199b184d7e0cf29c6fe0dfe70b52fa53715a456494b522a08c969e188dd4e534c4f8eff62686bda23508572e6f3db9e9a045ac1eae506edc1895d9d658c2131ab5b4e7279c6c4e8d5344a742a4fb1f54cf9f9d131b525a591416b4674ba2392b45c17b87a5534d293e211ef8fffdf1a1d9a174d7eabbab580a2563de17ef1902e8573de04e1b3e881c34b92a55ead4c784100829e2b8cd403d8da8d40314d022b977bdf5a35d8f8f14c43fb42e81e2f7b318ec3827a03b1a002b3a166505b21657649879097b9fd4fe1467570b73ae9b0453a786b66ddcda89748225cb8e3c0ffc1a3d0b1ffb4681aa84cc93b6e81ddd46a639cf5eab70a167516cb6e15fb70b3b56e78671e1d430677d2259f640f6e6247d6a80d0e0c56ed34993b9cf5ca0932f33397d353153bdb63c2fe32f1380d0b3f8d3e05589e17a141e37d4e7e856245fb3529a2229e097dad832bca93f427fac6327d85e22898048e0274b6d2dfced9ba7c64ebf9d8c238859e7e2a22c71c0cad17feae733da92cd1d62d379c762628e29781b6db1954b8c8583940b38e12309a1ae107c47914c45d1089defe1bb37ab0fd078748c7d24322cbee4a180eb9a4b0be57f3bbc0df7214ffaa9c0f22e6b6e085291b8087223b77136be7243df991230741918cf42709a09eec1bc293b8483db8efd30aa378767ec0c42ee89465f454df599b4775a6416506b00647a71b8de0691581cc4e2729984d804b3d626dfd8d9a9a50d0c913e0865a6826284b511dc5c923fdf448eb8470a76a7bbd38264aa739a0c99700c9127a35dfc8abd83034bb5dea2fc7e43534253b16e44df601a0858a1bf66c2d0c5a1018f82b5d0cd95fb51305c1c29afc123574d0e685bfeb0d8276edfc973fc4e61957f68da92acc1f45ffb93c4057abc8eb1981a89cf3d8f5bae99b5dc53faa74c2b6c474d31b2abec06babd0057633b07fc7338eb10ad6b4c2d8bc7a23fe6300cbf1ee9ae99e03526f8c2815b0975e973f2ee7e53d29586ef29e470a24af4ae1a61353cd79151a5c858e1218140d29916137993524b5c87fe5f0d309be4837c9e9b46d1010c5e223bc21e34841aa44807134a94cb4450a817c74cf5751971711f2859b86f7149c815813e80d7c81388d3d6d7fc7fd918d85fbf1493a1a252452cd9c489c4514adb7ed7e9424bda2b98611bce7c2ad6eabc438d2fdd1bb58d8d91ea10bcfa57208e7567660af5448ae19a8239643c1d42e6c26fce4d3095192f867415b71fe18a9613bc1188b9d7d271b8398f32b43588239265904dafebc67aef78b52e1e1d00fbe795167d3c66717ecbd3ef716626f2e352660053e39b3c43857c4dbadef1a56b8640d02485d82d1c3fa27d740526bbb8991dd25e5258307a396a2b2ceb0d91e939ce9a1691ab70a82130158e94f209565a2dffb860610f195e8f7f769f930a4db4acaf5d943b7e55d97e140b70ab8248fd065cd12ae927cfd11583f74155ae1f634c02df3b7a4e3ad0210d07c32e2fbfc4eaaa1b8b74c22147191e2d7fe306a5ead2331078e94fa74ab29ca0bed1a3fdb11efef4418eb88e1249787e987b0225aa3ccf5eee43b587e11b1f2ad607d93dd7da21c5bbccd6c5c57dddf3691c4c07823feab54f8f650da1a407b107193b5767fb81e135af97473f27bf5bad5b6e1aae0ababdfa6f2850ab1d5bb79014e5af88f5ae8e480dc1fa7fe83314545b116f70a7d9365678f87ae09a45e7deeb5ca732589485550412f7ae3a2e746ef3bb4c3157b7ff2aaa6bdd8cdf400d8917cf495a2e9ce959ad47fa3ede04ed244c3f0f4ed74a3d0f8c6c27aa2d757d7a5f88a7a1157bf67437d172870ad7171423f42228a56bc9b497e7c5362ee2e956b34bcaa18983417e2ee66aa10461ac01214585bdf88678062a2aead6027af0d49b6eda06d4cba19d7986585e96ae35d9823af4738f277ac540bc288f09c58645e1e059a8112b1845e8bdd37d85345223236099ad5a4017b7dd3df7b28cbf77412cd09d9c01529ed38e1621c6a3234b7a078df9a877b3688135a7976ce330f0d47055039428f904ba4efdcb410df6bdfa0c28ea45dbf942f61fb300b160f4eb2481e932784db2a7550c8eac38ce21c097d9d0fbf88f898433de46c755870523794e8028dff09745b023943c358e73f17cca338e2a19afaa2b015051d2ce83b602c89570f0ab4d295dd6d8dc29b12072eb9365f609d0ea236f076ac82edc23fda3c1349e5a3c06b149dc93dd5e2f09d0097b40437ac014a6d304846bd6515c7f6c5797ddd23e2394c0f7406d07d43dd7d7f49f549beb17408fcb44e18ece0405f2eeb84ab4f99d83f7f1e2fa4a1f0fc70c0187e18caff7782f26bd11b481660f2d447bcfe46f42c145848b84f255e4e27bbc90511283c8524d549a487e2dbe8788a8fa6d6c35692d9a4d158337783ea1f4309d19ef54e812d2c3afab6155e70508cca5f6624dba39a40bb64d5cce88d52a14fc7a836ab5ce9d66f349791283a029606b2c5cf40e635bdb6891e84551b8b726570bb0d283fd427e8d9e7340e10806e58187afa5efaacbfb382435e6b90d809524535104d2f93aac73427352da22c0eba785f936bc434fb8f24f3b8b6b03dad89597b4ac7ba8d154f8d9dbe55b8a021ddf4008aebea026ad905615992367ac66f495a3ebaac3bc9159f4eccd9a45cb88fc18e0e23660ed50ed7d434d07d2414bdca22c67fa5b4cd163e6ab2ea52003abafcd66a18fe78f33ad6567b438b6ce22d793e72473936c6f1320632402d9ec9e037ec2a93e624fa20e93281fbd3c9e174bd50587ec9dd7ad3f589cacc7190e2bcb4f8d077c57d8903aca973bd9f7397382a030628062869c415a5ce4d25f21b6fe646d350f853007e95bfa6f6e7316a5909eff3a8b168bbed89d3221a2890d05f6577443f984c563f70f4142618d9fc4780e1db5efae799ab4720ea1e8fbdf351044d9c27583715a57e6601f702863231f988bb5915c3b3c1abdc6bfe5fb7f2132c230323e35e68adf159a6b3ccd1cbd78f9581952008e1034e09d4c7239b9e9e6c22e43cdfb3d00079a2ad2013b36f977f75a9ac998445f7b80782cbf984c853b1720c50575488399bd765b0b4139fd63294645e49c5fcf146daf4ddb7759b4516404eb51182c8653256e275a92b49373cdd05c0a694d81d113a44323d51e2626ef4f2d3866f672268248c82a47914cf3e806d551cc857ae88c28bfa5d9c83ed08e36e07cd160ca6970ab872a0b794899ddaedc9d69dddbff9dca3a4af60ad04a51d46aed1f09891b5feac67c3f1fbe898a7c5220edb2cdc57bca03f58a8991793a94a546cb70ca7bf963566c962dc29c218057b8af52765f1fc3b7cf10a95e55d59bb357e226836674c4f77100eeb845c8efd196d80f7ebccc42009efa041b7d27d3d0c04d30853b3683bf76d5fac8e9f93a27303c028e35f8270ae72d5c3bf6f37947ed8584b6f222e398dc7acafe5e95165e2b675b5d7fe54fc13c7cc53ca7fefcc9fa0e2ec83e461d98390a27765fea91b4ca165c341ad23d94e2cbace19c3c27a62c8666f2ecbd211aa78ff372e0fabd6fe61085d8bbf0d5175ee74a17803d2195c3c71b05afc6afe9630b43b6c356cd34065729306bd4d80c28fd99989de84de26a3657341e4c895e7e0c4eafc84fee5b819af53dc8a10d037de5331f2d22b11b80e126593efa74e50f156aac0bce066102a3a388586dc5ab084b6bbd21ca7d088f7e54ac49f2792df89ba64d5ddbba125f259de87ea1a5bbacd94a23959f3e673725493afda3e33ccf3a39e5966230d4ac05d474a6d6749297cadb1ca223122c8af837bb7f5b01288aaf0194041a2ae8258315d52a4970074435944f756bdd98078055f2685c6b1130784c596c7c0f9e898eeb2e8f19b3773fe2f18d6d0157b57b5888517294d955ccfe241cf35dec98a39aaf91def454806a7cf8cf1cf440efc1d8abafb2fe57d82967d579807989cc6c67dea990c2e0a9cf941773edef636b635754a62537b3bc6d2b60d4eb89847a04ee2c4d678dcb2a2d45ac935022be7ba20504e34d7eb1acff5371843b8466d3005bdd4b131cdb0911d31e7563b34f142104dab954822c6b02c38426d50cde1ee9a5f76d1540529f068ef6909dc0536bbf3a6ba0ce6ae4353a2211b35ed1be9d4e1fef83ca7ced069623ee40b91c7090c27c9ec5da0fd75814a993e3fde69a07627a04e9c7a8fcc9bad54d2963e1cd467a82a9e1a80736289f4951e8cbcf826936a6b95b10e8fe064194d724d8331e93df3d586d0d937e863abb03d7a0bfb3d01edc0f37ebba4678377862f3967636d92e35f448490e0eb3009f4e52ba5794cc651104aaf9553a50a111d1befcaf4844a75b062eac43aeba179edeb9faa0cbe37a418f3164a73c5bcd3b64e8732b090c511d937dca31284ab6d5a328fda267b883361bcde88336b9a220ccf3c30419f571ff9df026bdd4179f353e70a05f2781e360bd9c4b316671fe7067413c7e790d79990e4f672512a1e5c9e16db07dbd198f5c091683d5744aa8db6c8d771f6ab41793be688ad1d1135a6133feb5d6976af4ad0fdcaec04e9f28581ee90a446ccfbe9639cc014565f546b5d7af09e510ae32cab087ae081435a693b8678dccd3de87cc7a39f7c5a21c55ec7e577b5471b27089271b9d6590f1cbb4813075285d65addaa0edd4aa3fd5f6f1de58417fa4a6de95360dca8dce94916a5aa4df3954cd6d4824b8371a7baa2e36d5abe7cbae5506642836635e35c143de9652aaab9fb4934ce8a883da2f1a54e94bc727d03d65ea20a07b4953d2fccbb38343a3d2e1f5a132477998de77c12170e7ef1eb2e17bfa7d6540c4706cb406ee291d3fecdbcad84e4cb5e115e351e652d312257054eed7de0fd2e57a36b40056fd1f70b3d6c6f6715d4290bc6bcad3eaf0f9ced4f92878954565a5f65c722d0614089e85edf02c2b310a3144ad00c10441a5c8136f2d7d3fe5860f41cd20877f03b072f79a3a4d12efc205a9defd55c5a1ae4bdf6d9583ac6ffc12c89486caebf4403988bc52e59cb62cc413f06a59b82437d6a4cdb877e1812362796486400a74aa08adc091acc6eee6c2dab0c8ae01dfe308251441071fb1a628c9835fc4a1594bb092c4b8a0fc0bb0259841243715aa356ff6c1e9f60e21818d2dff01acd177f63b22edf754a9a08348808eb1abbcf9bac2f67e098d4cd97ff2d9e879e8f50d1f9a3958bbb1dd3c20f101c925718d6ac0ea58c7a9bee821a01676a760a5a40aabe85b3d224e84ea531c1363e50bf0a4fab87d87ea67a0372d90ead53197b28b2629ce5f234c1c9a3aeb8631bcbccf8fc1ca477caf788dfc531cab6d00a8e147ff99fb959bdae76dc257f143b4996fc8418778ad63a15839071ed68645225353c767d8f7d7ac2ecd8ae439aafe52f0ce1f5d98a3e89803199aad5b3c69582dda0bef3330f258f25286f30726fca7e3712ddace31228daed18754244817b300b85354dfbb3f7dc016df40c1470ae637afddf01cfa5a443dbbeea537e69c8b5df2a6477e1b1f761b0de88774a3c7797b242c0212351779ee6679407a83750f0cdca059f962fd62a5f3cc6f54a835664c4345df9c775bf3d3f5fd292c7f66335b318aba874c7f037d4213f916ad959ce345d0ad40b65c39e09e0e32779deecfe1760afc5a00994d1aa11dc8c15fd238500d3824e700976863595ee921b460642d33b88428d55bd0aabe9a8d02dd83bcfbb46c109ef5665e91dd74098349dfdfada9db8f4f6b1b2492c86ed302e7a9e4b9b500c2a5216117d3ab1cffe3929ebbd56a57bfcfad556352fe99d521f4f570b40bff03b1ba76f90758a678a08246bfb7a637b27b82114c12aa08ec9123ed0c612d4010f967d81bd63d2b6d84ed887d82308840afd3f7b79080091695e433bd12dc7ca26ef8d9750ee29bc6bd600b39ef81581033095227884132dbb79b610cd4f9196c2cc92a517a77bd2079c8992c3238c2a7a939904a810c2d152a04416f6b3cec44ab145407acdd8410e6507b6a187a2166674acc1ed9e02e5e6c2ccde14882c3feeecbbb319cbab77854e2cda5c74a6aa787203545109557dd7c71bb92cc32d35468b184d46f2ee28479f12e06ef88dd512b12da311d1938e14b1b478a886fb5f1f1150483991b8984ab8953a5d5a2201e1bb1bbacf4f2a5d2ee928630c45d87bd7ff61de92d1d250a6b30bb0ac1936f03ec316839c19f58355aeb1e99f1b166b355bf0fec32ae6ab1ebc02ba692818bd9892af836db76cdfb1d5af4ed82c3408eda2971f98e460032ef53af3a7342832545a8b3f2146a503aade9b0b81a81ad5762246f1c2c6f27c9b5992fe798b74940c2365bf739756ed3261f6029693d7fa2a5435e23860c70945f8f5831b3ee1bd9960ff6e50ba13a7b4a7bc30674fc037c51c8cae6d26b73f901d8b79bc7c89ad3306992f5def8bb0845c65fc00e8513b787cd416bc37a21ec4176c9ef24f37a73105c5e718f99f731780a86cc9cf863da1fcd999f6865c6de69f4045bd6ea43496bdc16f0921136cdaea28b3ced0c095310616ba36443abef84c6ce72fc1f5ac3afdb57197f8f2d55d397e0e044f1bb56bb83b4cc8ba0a6e8af3d2a6bec05e6e5ec3de8d34cb21082069590aa435c86bebc04545a6869807881c0f22633617e81a77c8cbda85bd8e10985b452f5910d7918f2f8f546698a1e65d708ec0be0ff5ab711228968dc5e8c3cea5ebe2fda2c931c89a6c79c94b83c588d4da199573b54cdad6c976d0eb6a883615e216497728fb0e04ea4040ad22b7bc77900970289b035e05f5ee140e8da6b9329eb530d21dd3b1a5dbcd52c81d910b7f75da2da838fe84f08800a79d6d8a412c1d53c431d0e324addd593e73b6c55b56f86fa29f4ebb31d991122debccd6f909c8d68d90d53bb86cb973970f5247355384066750a67712cec33dea2c1befc34c1b614c4ba3c20d2bcfcc8565f18abb261a6a3fca37328cbdd9cb59fdf296369c905cef545e8158aee637915cfa4f8ac197daccc60bbbe5b33bad4c668bb5725ce4b4c9425df31de0a329fae542dc57a6e837fc0719861ab43408ef5da51c2b5bfc25aa237120e146db785a53b501a7986597a1a93e2bc43def6ef4643fef45d20a95fb109df4673ff47bdc603073e8cb1ace615f29d72026df3d37394983a071ee063cce3cd73c1786879d337482fd2ec8b5d17c76b05f819fd674080c1da6cf1bb04151cb28f661969272b2298561642f0f0535679bdee15cbb00a919b23dd4654cab1fd68f5491b5d7ee3a0db38ee63b1be56c13767578c7a115bac51a67cefe3b827df83274c1449d7750040dd1eb6fbf07bccfea0784958f66bb3dead6cc1d6ae0cd84a4b41ecef6921f534a6419d306285c0e0d48d65df2f68e8e9a448f21e83ec8ec69f44538bae18efd9cfeef731304e839e9c211f492840419a9fdc3133075ef769ab44728e412949fc781b4fe2de22af842a1b1aa6e2cdba161c7bebede64e04d324c715c4d08bc9bc41aa8eaa8c7195068cf3f23bafec197247501581865d4d45e3ca89e178584432101985c20c49ff6d7e5baac237398e0e4e0bc91413dd5b4a087ffd23bf8fdf3744c456ba5b1184af64c94fc73469f0f4bda4bb8ed0ded60f6ead3faca3c355f0295672d1b715ad49b3aa613d5ce79512ca35526b727b78d6e14c901c7ba26cedb48cadedf502048d04d0ec35a2f19562ce0b48227e52a6c7933b2bda3c841c83d4afb9671d959e9072ed381ce2806043eca1717e277376b79901efbfd75a1d8cc9f72f9a0f8c2626ef5349cb86c932cb8eaa50b66ec2ee57a44e2a436d3519b2f71eb036e27650deb11e658b7eecafbac01107f10ec2548f7e0f069b1a6105ec3838265c9fd31cf96021b369f4ba23e77d876df150b7d5e0eafabc8f833c8d46a854fa63f95670a9ffde58d53fa6ae2d087dca008d989f3c0a84a9e3adaeef3540b1284dd8827e496b6fc664f5cd38d9e982fc47e86ff641f02422c3135f37c103730f5c75af5a7a060c672dfde6d4a7ecd089cf6f72ad1a09a7e9757c12fc22bed1018104e435850df466dd79785158e2dea011f0fc0e419059ebce4f251fc2c912cab426facd2c9507cc1d996cf293961e0db0a5f581a55a04644032371f65a6d90a8b7f82472abf32570da1fb3cada199a048d0f7b85536ce0ab0f92e46fded9a23b0c1620e192fa42a5b8e60e350ae4999afedf00666bbfe6bd1a845cca268dc1e479985ccc4a67df8de42769977a2975c734609e661de3a098105452b75dfb2300fadc7d97a206c70d7c907010f889b789fdfd2fa7c7ebb13f1017fa3ceae61ffb5ddc8997310edba5797f54f05c61f71617cc123db6f41b55d9bda2eeaf8d36706cbfc0c548bf992ee8d91f8bacec19ff48f10f2fba75205657cc7f5042e3190e147c6f0c40d9373bfb8026015394bef77cb37db584718a4f6ae5fb5eef8dcc5f87c0bbf9729d08d058248fc88a65bbe8cc1b00ed97253d3f5996d193f8caa4a0129a1864a134ccfc89b64ac5d81849df1f3ddbe7671130e21482d5f262950cd4ecbf040f01620def6e3d03e9834ddbcccea47144493922162056636926327c5f5b39935b73f9b9225ce6c760f4af6bc984887d1333213dc6b209611466305bb275ace51b9a43724b3cd786b5722e6ea8ac836c228dba880937313f5203208e4af4bf95f51f54de7c20e2cdb0de2ddca4f16e0d46ed13f71c277fcdfb9fdc442d86fc0420914236734f3b87c59774f8425fdf879c42ba0c7e9f43d744285fc536884bce757a86bdbe8303f848fe0f3942f23f59f0bbcb4ac3cfac3e7d93c484f93090c52b1809030c5e1b08f0b0c89eec5d4f9dd18eb817e8211426fc2044e6b57d57a77956e8ed0e9b05d56acb06c266af4dfbf5d89cc6841ef7d631d1c4f4ab0463c774e9b1b86869fe7743d2c36719460efa6243b940091e1240e96e6f95f6b37dc46594f9c88bc6605d4db0b24e11ec43d10c0cdbcba3f81302857d504a5023b08ec38508b5051a439754fac8dd0585964831fd5a3d2752b3267dd8272e17dd83d51cb3164b78734f5a2d5d50d0166b6ff884ebc8c3c2100672169c7499a20ab180c736223833d072e5744c0c477604d5c5abe8c46ff0f12e8d54a7888eef6d4f6b45f359e1ed093f95ef18a271fb5dc2e0f7b72043ccb381180d1c620eb215b6231e284b062898a5792c0839f3225243559f7fa1fe61826cb25a41927fcfd94b63cda2fa1c547b1e79fed29d730d928b5b9d797c43d60b28822ab6ba526274cdb4c9f97222b1b538771e451b18bec725db30cab16108d2309af1b41266e41cd638f942563ac7932ee4e6e4f1f395820a077727171a8fa6bca47324cb4bb0e70670ae9f87955f09f5e6e015aad15e5fb5d824f932935b9c99feb3e2ac28c23919818376efff9273a54ee40c39e3af45ca90015a72d3908197d4148e46051e15e6dfd2cb075e6455637eb1073068d6d03fb62e6388cce8b7e933066f4c2e3eb864b45b647c2368683a1ac3d9ae0aeff1476106b7cbcf9cfaae98e7b340a9f655162008e031c445858eb38a1701aa922a43da0a8ddf6bf8dd96fc26e6f87e66ca7bb50adb4dced42f880d1c5e75ce0ba0cac9cace9fe8c4f4cfa8b522097089bb8e17924a2f24919999ad7ce576959d4bcc2a34e75b6095743031d6c33e82e814e02ae5e0a18db0ce9af0d6119a1aa0b4bbe61251c7fb4022c92d78f4e1c82797949d3fef1114f733c20b6b4c9eef53895735924d478dad56067dfd2926fd535a722df67ce67df8a20cd737f7366519be84c929b006387a1c2a3ffafdacac1a1551438c8f4342eb982f714e9d1f367358005f4549f8d5de55c597165356de70ad0f40c353c07ac6f1c02440f3c0e839982842e3d8943674f4fea25ff753676df93e8fcc66ab6c3122a51b088265f7dbaacd1daba67c9756570c347bbd51faac41585337c393015cd460a51f05f7d666fc19ce065e98a3f1092999c3b1154015d332a96aaa6e4aebeec14fab57d6f184ff35040781a431b29e94ad18888ca8abdbd9b9c7e36dfd3a000a7801e02379b673895f77231eac02ae7153a586d4916533f3cade28ffce05ebb3891511920ef40948553e3be54f6429a957806e78010b454f15202dd881a0646ac0b8f6eeccc20872adffd60b84739093a04ff466d42550c397bf5d26d9f7374b9339fb0262b0d992fbd39ee101b889a25958fc2064572d1247184aabb8519dfe0a940de6d34c67a9586c2a0f50fe3b1d001133ba7d9ea9626b03f434d0c64a8cfae4a37d22fb9db62e38ef2a07b3c3017ad62ab3925dcf8e4361785516fcdeb25b350011556b69dced0b54dbbf270002c584b6495b7f4531ac035c3dccfb8b138e55ce560675ca73082cd36d856690f667174cf1b097b03b9f990c371ba6eddcb87684f2c2646fc08221e9706679ed9b0427c51105ae2f135c188a6df0b409bdefa2a3457c44f0d7ec0679da432ef1e46d825ba7988eee77f0363fad827060d495c83acde70c7d3ae854a386aa67fe07df65bb42a0128ab68ab6f8f38970daa25f7f12fa007579a47e0b2d23f8ef8f5135cb91c40cf8e2e716a9285e576cba1f316b12b2b7bfcf16ac1ecfe1acb8216bf92bd5ec77c4d05fbf25977e687a394e026e128566c6de144d1b271f5cd90b94798d528032cac4b7f4ddc3e38e900c182a7d4c0dce350adc1f45bd210242643dcf7145f266be9f418cf1ca27bdeda072bd39e36da8ded0ead1bdcf49d3d4fb766c6e0974c86651b3c89218229edcf1c84ce2e0e974c71836505f61534177e54d68f820f25fd136bdf75386f75f34ac7e5be2faf666b19670ed23cd45f49c3859b0f2b52d02fc394184625f63dbb78e478de31d10cd6c9519183ed2a4ac3f7836ce4161c42a180b01b0f9c112c01b2e0327bf5ff0109fd59ce08373331ec64b6514be5d433c64c99e8f94bbc30fd30b9510a36ed56a79add691ef00e3971b55883493cdcf71c84b7981ede3ebfe5c142e954a134bbaae371d04e0aaedff698a13ade5c4eb8fe257abcb4aa2873033ac889312efd2c71e786256561a5af060104febc52fcfe4c4156a3b41f21368f90c1790c99b41841d7a2d3a1e58073af23ee9e9d24b3de3ee65c76339d8fe8d10abfafd64839afb065ae776e8cd648d0ba2de4ab4ea7020140a360ea2744835c4fcc56459139d84e180f51f0e8cd5969a14330a844c9f22de221b0aa18b135d9707eb399e8fb6ae253c84d25a89328118e90b45f1d6856a453ab891af0b1017ed15d338d4f6294f1a0c5fbac0d090e12bdbe0c511bf4a7fe5bc087f9034c49ce2231587c23c71d9b1b3c824d071e83ff2acdfd0b3c8d89021c2db7b7398cbc534bd3aade61f79c68863c1f481a55203430d00f2262ba16a526975d27157ed137d380ae3fb79ee3e4ed6cb1153f9034749c3a21444776fe4bb7e92940ecf5bc587471510b68f471dc0ef5a98e9ab0b6ad32156f585c2769caa545fb431a9e9e82ee415efb8757a3e52659e424247de2b458cbbab269fd33c96109c59c55be449a001eca3bb3e1044a7e86084ae5be025648806f16cb9c98b704bc6bddab80e6d218eee771fc1671c3d28892121ec874e71e8d9ea05fd3810a7b6877d44e04fa53b4119ff9f4c7cd4770ef1c783752deab1f878d0f846e9d0eda08f03f07bff18827e0e7812d3c915348250449c72b950a92399bcab2a73a38ef874d4fb8311f27fd742d7372af89203fd51c7d7d6935f582bf82db1f493f64840cef700fe7629508490ccafcbcb08246075a3b88c404316ad8fa97de106e053d7a0876e22cbba83055cf11b70c81609f1c9ab93d52475969c05fd70f26555d104e074474434a59837bf32cd7b8b50022fda7d97dcae46fc58fe29081e4dc77ec5b18d5e593ade590af514784d8f0d2662511e5189c9ea353f669bd1fe253e763e866d8b06d111ae32d584131d8866a07d162c66336ccb778827c595f91824584d80898019c3bb622a0c7cf6745c62c96938a135c59a5635189ce4a9eb74f18d385ab28f5ff88d52e619936521db6f54583865d9c3734571fdbb03a858dd6cb3b1f4640365e51485f4c398e04b2db6b99651332221f2f1e51607668a32b9d585cf0e0810663502a06aa3ff73a55f644cfa399939d99a5f60f89ab6960ac45ec8151ab6c35fafdea6c89e7d2eea793f2f0618f82ed0d262329a87b6f8993d09beb5debb9e6af410dc462d02572e63bfc92b354526a571735d3038a0bcbd1a657dbe5c803a121b5cc74d5fffb17ae9a33834b0f432d63cabba9651d1fa400101520652f2e09f5f9c48487c9675074b64c667dfe2764bf33a0c51cfa0b839f1f08fcd4407c22e39fb6a3c4ab96611e7eb7d50c3ba09a9c3ce8d743b382c12947f1687f20a39cf8968912141df57ded2001d2014111b0c930d14c8fb57428dd8bb745552f372b7280c2c8ea7f4eac98d0c346d8803d4ed2fd5d192a66befd027081bf66587f8a71405a6f588558bbc3df5451c6e8147af027f2ca3610aee9670892be7c02054d0690eae57334851249bd41767b14d452de092ec394ed98033f3dc691222ccb23311f2706f3ee60e3685eae4729aaa10e83a9da81e85e6cb6c0dd941deff72ad0150c1cbd857d8176f9042e4ff3e6731b04980b84175602e11399a996404a41afcf7aca4f621f59d7162a969dd9603a96cbbd526bae9a8df92f5a941b5d110dca80c9cb6ca27fd095c169e4a57eecd60c64b98ee18ad97e7bc9425615fdd40ea6d6591cf5d2b030a333e91400d0c2d588ad4933ff38490dfdd99c280a5881f7daa25cec67948e3aa492578484dd250576c66a845eb4a0c4ece081fcc093b6bba6135c1c268d4d3460b7705dce06fa62ff82474290cf4a391ba77b332bfab645345e08394045729e511d0dae193ae0079237d0eb10160af79b8bc5ad698b1057f74e6afa3d4704e01f1417fa70464a2cf6ab1c904baeca2b5acde2cc42105122a5e3a74e4ba8b24c2a3de73f88cf10502270c439c7e625646d01f80b26d303c7daf7d8617a29979683d6c2bc7b8b573d3d8b9b5a10b132962364ba4ff8f156859f7b93a750ec5f8278da9b9a5b7eb1fd9fbadf4d0a0c98b69b8b4fa5779b539429e373084ed3717260ad362219604e42ea2cd3aecbf47529ce74e884f15af989a42881848423cb805d38bdf417693f291c23727290db5d6ce1107ff971ebb1911891c6e8ad4204f41305fa499a3e0a455c248e5cd806421b852ad70132d87580741a2e5a6a69fd23beae3f81d5184b650e2c59eca026bb723c2d80303b686f9a5d1574b0126c110dd51dacd34c5b41faa8bdf67a1419618aa8ecd481e779d0b6b4868b66db834728a18e53567f708369a1af1633f22141b20b60024114805e700256bf6f3513cce9edad0f465a5d6bc935e9e5f88607d7e4d0ecca028ff4179040cd19ca4debad7c01627f1cfb12b9c806280366d2a1605f998a0c8e1b601d58b2f6f35abaecba62e7e0fca12192dc64901da157b604a81f8993076b5274bca068acb4cd67c65618dc28e413503f5c0592a24315707eca8a593b36ab479d5de3b5e839d2d2bde8f796f4eab1a16d001ac06d2cf14e7c5c9cb1bd80d251231e9dff00ab98686c7c58e1c928f37e2ee0fd1d686670c3f79b72b163fa46a86b869a620af62f1921d07768933231d3f963f2497865193125572d91a8690319f9115bafdd146f71d634d79e10985e0c4d48475479f0de85e20ac9472a5c3a6c2e9c7e3d36d43649d6eb41ddb3312f99f282ab7a76bb41e2b7344571b9da43b3ed96fd16be593903f5f3713e73b0c9e33d711b8e1baa7737184e785791a998426bbc645ae66a68c1c653f6b195dc0c3d7de6cb5fdf3475f65806e360764a7805b1cab26aacf204737423a39b0c6d8f5c477a79211e90db7b9dfdd56b6d23a261ae16fcc90fd0f5675664cea4cbe6871533e62952fff32cafafd9b25b1d34cfcacfc2a3afee2c62761c6580595d8a56b59369295040d3912903d4d27cc805b212e68273c415dae819b12c9658dafac3e0abcbc65d47f95c8a3466740ac6753f611800d38fb6eabbe6b8f191f9e3ba3c8259559483494c19cd79b4ae355c00aa605ae6bcff072cb319bd27ddc3cb824e64d5e2f1876815efc926aa35add58150597bba038d29dc72a691db6d594184726ef08365b449985c7981aace044d0be052dfc3d5b5e04cddbac22f2748f8733f481f208f4980f39d32199c0765c449c8be77eef2277ba34eaa5751cae59c1c935959da6d212d7078fea4c3f8e0427e40c97398aca7e6ee213733d5ede7acc2c9a8a55d1376d000213af1cfd52c70593dce1d36bab8eb551e8969c2be5bc01ff4e55f642ce83d0012ec71791f8ed6fe7a1f9341d5d726dd231b6aea3db185c744afec3190e1173b5c937fdf3f3236f3c491d29c48124a91afa893c3a2cd3234c471eda3c90944827965caa5e5781ffa74101aebde41fe8b6daacccf50ccd52a037c355f8697b6579cba9a86ef240db2c11a7ccf8b116304e6f217a251b8f927fae4c39368b86568d5228802d02586e1a595d14c6af8b6b49dba9bd0dd9f0b1453ebed6d4b5ab6eb925a5ea609c827147c7f542780f8fdf29a70021ee261c8366068d3c911007ea4d8ad1fcc44dffce386ebc66f78d4687d5904f87f1e19f95071a4e6f914d6e0eafae01b08064aaca1f02b692d6a3667adc76cae82ea8771dd8e61fe7748652f190cba991efaf3de6d0e7c85baf8fae299238cc7308963955a8140a10eb2700342de1cd46bd100df5d7c1d40809a6ab1b6fc7f7285abaa863ab19e4629fad0a2c55ccce4933249825605ee8bf96329962ffea1ca5cd5d1833f977621b61b46551127a93c0bbb995fd8eaf7166c3efa8549e4cd05227aeaf5dab9020ba085c8f132afe4d1bbce4d48cad690058a47ded908b7e2272ee16ddfe1118aeafe56d2e29361c08f4445840a399354dc3287b30ca095a2f97cf1a14e526db5f75f208a5349067c38dc5c16bbbe10bc4c15d497cb4386c98d2f9b5f1db860df1c3d79ff7ca023a0872c17dd6bcec824206e049c7ff55657e2198745656923822289c27ce0d9480af6c38853c5749e1d8a324f18665b0bc382e2498b45146a429179d06ad191bf35093597feead1c46242a9cd2e08d74587b62e2b3360e35fd7176b54ba458571817c0657da60830764a2ee386c00d7568bdc3d18524ed2f5bf2ed73b70b365363b18512b5805211399bc6ea3f12e7da065c66f23999bc2f3132f2f412b111bb86e533a1664020d5d2ec8bbb3991d2f0025b9577411e5a0fb502054bdbbad98162862dc52c8386e06897adb38a1742684b9f10b7e3c1f1e73fbb8a39673afeb3c82f834733ebf2129a67fbdde057ad92e1d31be81fb13006d3fbbb33f0a69b45a44e5831f1365cb5ae305b76acb0515200da71d772886617f29ae3ce59269d403c3c81631fa10e6ecb5bb25dc99438310d82338914d0559e945fee292991fbab04ca9072d8319ebfcbd4f26296902354765c179d8f65470de28886061fd241a74afd546150c26f569cc892fb0efdde24258234797f898dde6da2bfa8cbd8377dd642ee3475b51c4dd835aa9c974f3ec035fb5998b0bc10d2e9da8720b4de0597ececd5bd680315d65d33f6e19f170d149836cbdf8375ff6a3a0be22fc3ff9c690e13bf45f16c331b543c09eefa4ac4b0252c8e02d74921e18cb72d6a545bf50b669a349b7e79d92ce0c5d0d444aebc3d77434b69ec3513c29abda14e73cbeb334b4eb52c8a6921dcb155bbce04f22c92d4aaf87f33a2851d6725c05eb0732642d39db84f2fc2886f7b0d1f0e4c4eba987286ef447915d4859eca6eed69b1e82328ad704a9286973da35baee644be72b4b5264915b7455b262c581567f5777cda7a9a0a53a07c857bf2001ecd4088d8438c1d64cb1b3c5eda70ffc1a3943055b151fb1879f86ad64aa7bdaa40ac8ea66d2efe692ccfd672fc24dbd318845fd1a89a040fe015c984efbef6b3c7c3d7772575df1ff25ae6c6f0a762628d50a738c68d80098a3b13c95b0ca712a0ed80cba4ffa8ea10021c42c6a17808666111efc7955436940be3f93607d3afc66e96af1a5c613652bc2cd38e0d5cbc25aeb6419c2aea0811784aa1d6cb96c7d4461e24a5c4bf18949dfdf5f5e4caccddfe8256a5dee79f6490d810093484f644194201d18dd1ab599a7db7acf149bb8aa6ba0dab34c49a8ad925d36b38eb87a89856816f3a65338ae7a43c96158c0e37879941a9a1423523bafffa39805e5a87400ea0824e6086e7eb821a2a38c3137fe67bf8c64b9468f2b043c9c403fba9756ef9f44832ae03e60e704d9ce8f0aeb9dd60fb500fdcbb0ba4a378b0fab0872be2843e7de42e611b304ba42dc9e94930428a6d288e62635c3ff4f7c39244f2144f821a59e31e7512cca384b48b61c87df0a7d3862ea785f5217a99f34be54e88f5b43292d26ac31b6a38c92b1b2a523a94109a1e42d77c784f090bdc5f9c16d62d4b361cbbf8bb27d00e9578c8a017f1d59c54181b487e5ad94293cf627bf063356ffae57d4d90a1d5dbe79c8dfbd4f1db30d5e49f993735d95a30b078c5e15b0b3bf442911ddc19b9d742a0c3a44868d8262c3ee59c1ee378fb87c8328028086dcbea76a9f631b9349bd7fcf3c485ca622090e8d8eb9cc3d941ff7b1d9d131b98eb07c8b6b13384d9c42aec367a51c7d4f1d1d1f8534b77ae5b6c51881d4800287c7b49bf853cde511b4b1073bf9924b7dbb582896281d399aa955ec7f87875de98eb25e7be6ad78b5c8fcf3005010f5eacaf79dad11f6486b63bd9864045257d38c730e8c9ea265b23e466018aa202e06cbe686854a3587319d257c5fc23de5ad1dbbf065f9428284b2acfd5dd987ba8a6be88cb67e9d30b12d3e536d46b51fccd602e6375c1a77ba2951b3524eae02111654c6c5729430a4144934d11978349e6db8f5f317a0122927a9b782ecc40a305f94dd9c737ecc5237dbe05ee898cbebce7fa80d7dbfd3de23e7affb828e999a80d00ecbd8c09784736c2a40526b92e656c4ed62ba74dcc04155ebd3fbcbe5becb9c9ec9f20dbf1370fc4fc0763ef5c707f84307ecb95ade231c71e571848e5cbf473ed15d2a17c3b6369e038d29f2a30cdc55282b44a207e5f5e48265dc96d0cda1a4fab3e0ef74850d8b6a03390c448ee3e08fee7046ccb9c0c947517075f602f1f41c94563b8db5a8ae0b9b43aacdc1c81deeb6c89637ef8d0c9a582e40668dd2a164c2e12964851e432003d1b6acea9623f14d7e25e8238016b9b079185f3fac40021f28032db1ea20fd82ad1805b998afd4e38b72b5060f6524c676d85c5761cf9e5a2c1ed118be179f3c12edde43221b1cd98d5038d90eb21047469bdaa7e9551216ef01a45848010bb7ba7215f289f5cb2f128c100b9c8b91058f3fa5b48de14aae0d5b7ff2e1787272f9df9dc1545a1dd296a54db83b78c82a8bfe9954f217e9fdbc61b8b5fe51aefb523b7a3a6fab01d446b6f3c984aa16a33f55b3ff6d2213a0bfeb2b27ac71cb538c4280f0bded7385babd98db8aee9fb95feef0b9743d534781da2ccd535ae226b002133aa4f96e93dc30ac3c2227f5c5f4a548989510a96ae3cdda5d173a9f3b59b6f3625d81eb4a72364f22497958ef9743f0e00b1db785eb888b2713f3edc2384ccf5b272ea90560f60dd88745eef982c2eac39e35b0cb33164badc164ad65752f0ca5ba15bd4cf58124adb56e43ed9628da8abcaef5743dbfd84b1d23999f98c2e3d24b4b20a90da9957a6431b59c54829d6776bd5532fdf6ad2c46c45e4a1cbc670237f40b49badb40d0aedb0bff586125a0b1f9eeb69b5d5dbd2f22a29d91af111d7628298fc17691a2d6d295b5287ee79abc8b2d39b3a83811272a357772c42aa83dfd9c4514ddcbe27facc1786b94398520e85648ad343f30833f8377d2e772970501336427ec395e8d1ae179cb14366b832434b332c71365dd4fd20403dbc0c563b8619e1c06fd464503e2c01f6044c5c43262a16f226ec9ffb4f00f29cf7742612edafd2894a21b1d9c4ca7d37ec839d8271e9bbd39bca2b8aad91e225fc6caa98b5c8dae8a43321aa75b0f92b896b333da7c1a51cb20f557e49b3933d4a29bf81d4a6dbe0b0e4bb750c14438c9784a85d1965e1c507b683b532d25b696aafcb7d0188c8a943628ac9a0fd03ca3927010da015cafe28efd42ccc4de313e2185376a823d041631fc7788531c7268008ba7a01dabe0a0b06dbd0873519a9990f099ac3549d22ff1d8e3c0ca0e8f0b081446805923b02414f5d98eedbf11af58b9a1e1042ac5c910f01ddc00bd6dce9e973c1ea1ab2c299315fe256b968d2bd385bc8c50af100ca10f4bc4fc4b700885741de4b746a0801fe4e768033016d0ace1d9dfc1e2a4c7d27caa8bc3299225802bab1d83a118239e99f5fda1e13aae5009936e559f6084988bb99dbfeab84da35ad4e6faafd28127eb93a8cff9c3a67d7c1c1f6d3a9b7bb74943794fddd64c3a6fdcc4df259d1f9a1bc04fb3a42092c2ab078e0c91c2051bcf26fd537f7bff35aad0602c8c8489c0e62fe51c4d27cc42c409d33d8eb864d584fae01e9aeaf608aa7fe64a7accdd8e86af23d943e146d8c03e0dc18d878cf7ae79a571ab8a83a824af0443d904d1242ba9e8641a7a49037384c929eeddfc709eca20b5d0422de045df6655ebf4ff52a33b657bf16b0a900a612c02f9993f81b70ba1a34c7a875860d972458a292ac4d2d5597a3b2baabe2f203c738080e47a09694b16c0bff6f796e273174fc1f9a162d1d7d9fc7746931e4b907765dbb89b1394b97267b2ff73f1109445a8e1c57395edf1950bf71872d3546af0acdb764080b1986d871cbd7986efceb3f88e721ab5965cc106b1c45b561fdca5d093e5c656af8bc1756dfa140541ebe3833054506e32f19d5d19328b6a499721d3517645dced150b41026c9b678273b21b0d4e023ab685d8dc33412dd88364c022e9de7ce955cb3af33300775c7b96d227942ec3c1d288f019498f13b27ae0811085a9e283629938e5d988947ef5df3d8d135681c3220bebe90caf416c4622be823c5f56dcff26a927f92598781303217251bf04f4dc0d12f22826b811954be9138226238759648f992dcc4dd1f8bc38bd41271fc2d2ad386359919bcc3769b2a555eab523945a76f120400c39c2bfe0c58bbad8c1f5428a1a4c4d7011db99959db666ef39c7836562ed923fca4918d7053d4bc7a8b43c67ebe295ea85a482b95aaf418d3934e89e0fcb1dd4523533c1311dbe0c4eadfceb879e5985cdc126bfa2a2099fd80ad425aee1809fb8cf5f851406cdc17bd5c31d7ca6b5bd284df473f8f7e3f692e6a8878cce79271e76f66ee28f33e7d502e5df75173d638efb4ab6bba5b40102b19254e042de9d1d9a4ecd330f7f001aab64173b1a9b3b83aff058e6f858284fe528845190d78ced70d7b5ef80140adbd700a6af38db2bff7a9d61032c8521144cdf586691ebc339074a9aeacc8156bfa6377a3b3f5b3facde84881bc3461a96694d76e3fe303fef8604bcf6b9211ea3d63f81f0e28436d3bd55fa3dc14b7e32cfce9edf4038333fac88e789808e1e3fc1ffc0bebe5a96a41fe2e3a2310f4366a7adbe696b9d4b27295f4e71f54702019f43e0e0859bdbc460d7e1589d7ebf2617a272e4219de10730ca38b9a3c9f1d96e9a9ebea526f4f8927d31db75af80bb320500a8ab1233ff067a22d90d669e2394d595fcbce327eb0e39221f10d5a89e4c2ec1201cfb39afd369cec23d15269e4e712dc3ed7b9d7f1bf23724fd3a303096946c51f70012c7f385783525652db9d99433f71db5a745bcce96fdb5ae85f5a74867591377980ed4a219978bee1cf9757442cf8e922f797ff75a691fdfe409a36af29f493745e86927f1b8272498c65106ea15dacc90a3eb930a1a6b2a03bf569f00517d96efc7da76205ca9968e552b97c296cd773412e727a5fc16b6f6ade326a8dadd87c27b729ad827005822e11fc4dddc0b2380b080958fdf5511fc89861737183f10b87ea750bc2a6d6a95c987883d00f87f8eec263664c8bcf78867c98dfd38da4f1b79e94aa7ddcc1b9ca4404163739f8cc58f3807f8d0492bd46cb71afdd6e6353bf2e5daad6be0d503dd269bf8b4a8173b92c39f416b67ce823a43c2f0856a042917baa8a4271003017a749acb76bddb477cc87d9b0c05592b5ac3b3f639a835fcb442b0dfab63749537f43cb9d4b85fac0b9d3f0024c75a78b285ee504233dfc3f845c5a2081bf54e1ed6c25b9dffd9df087440747c222fc0f3fd40404e8dd5a8a7eef000b251593437fe8726e8ab88aeeacae4faa1fce4c03e1116f457f4c002ae045adc795d133f8c112bd9e8dcc4f1c730484bcdb0fc8dab46856e85a54e2acfe4578a5897bb898e530cb137bab592fef355da6731e080f7244b9ea1645ce8a4758adab993c5c46985c1904ddcfd7cf242ee25fa009b4b2440884d3d1d1bed6e0a46580b5ea6128d006d8d134a66f50fba9b6b55baf58c7d8aaf013708a6bd44c514569d28fe416a8c19f7bf686e254282604f55ebaacfd4a2e314514a38782fa262190dd6d96d27f0477435917f95d2c57c3eed21194da49ec6d8059836b0248c0bcef8e49b59403bed5f9ceefabb1f2e9e19963ae5c66ddf3803370d80f5811845ec2cf431f6abd447844bceb1f4788cee5b0274a721b17cd03cf6a14498b6d4828160ce8c13458d7c565385c8d31f0def6ee0dfad6297d308c46738477c6fc1eca10491889c0fe72b5ee59da427b63f7c7d71a4ee07a30545a5e49e1786daa297bcae41271436521d9981cb1f6f1d5f47d147ce30fa95f44edd225067f420d10d2aec0c902e009711c5f7f57041626d565206268641ab1fcd5f49aae547c0cf35fe3e9370fa0fcee6ccdbccd072a19dcafd17d7848a6aadcdf292528c1dcbc1d58ba380223c15daa419cf847685f2c6520d2375ce3c0c30a2762163269a7f2821b2df5b3511e56ed6c08389e34965145c2b41fe2516fea674b28cb6b19de4b2f41c9f30b6d7d1c65c597bae4efbd1c97a2e214cbb62ed254af4d16541a1ee960b376608c634be196d96692dc7ea901475e7e3ba60f54191f3641254b1a5705a67732b29b1f2ab8c2859848fcccc070cc6fedb5dd5fd0a040592c02803c27187f790b7bd1f34e9f2d0afd39bbca043b57ca43e44b8b92047dfe31c18fe9a24b61bdce54dc216afa40ca566bb40d31db5ce08f9b3530a33a2f3b2517cdac46cd078bbeb6ddfc982480f7548df90cdf62a31936179effdf28ed5725258301ae216d799160aa55fc0ab49748464916af4205e87c0f38ec27c79393ac9f3edc007f2f9f5de2c4a628c9da9671b7d80f5e912b8f57b0e15b497081a015bc76a9aba6ea05201c13e390bc8933575249e02c08ec5a0ce6ff3c026338fbf31a9ec9309ed3ea5b6754dba73611e184ec5e53780138142996c2ef15c8d86812ce5f4ddcb1a69d90c60c3cdbddb225a60cf1e2306b88cc523571d8297a6d58d3bdc5915a87b04a2eee0699f9a50069ce2d5d6dab45972b597b8b8487686a91c2c374c6e89b076f618d50d52c4b004b298e163157fa8b1920616656b3ababe24a1e3b48a2e1b16f2c9c63857b3928fa0bdc00173f80ca8f8774bdd9b8f38c33903af1db64758e924310a173786b3b65bfb290d143be103eafc339aaa0aab209c1d9c5c5b5268090184e98eb527a2e19f4d181a490520f3a7dafafe3d46254d60c88a30ea854bb983c6f3eabbb3afcbd6538c607864a42e6d4e0a981eeb2e89375b077807b70340acc203b58813352ad0d339467f89de54148c5fdbf3812f6e06807b5d530de570ecc7e9a6028dec495a1708aa4b6deff99080f10d5ad26725d29d4dd6816ec9fe03c8838b9ca82a1551a920766510785205ed448085feeb07c567bf07f7c9443e3fd89cb6a9dea4ce3074ad6b74d0de0a3dea88e5545e25889ecc2fad353ffe2e9345b7a330929bac258fa399cde6c4e6a2fa8c4d0b406cec8288d51c18fda94aa1e4ad66d90a5afac0f9ee16e7d43c4c27bdd4a19f3f620ff6c7476a62df6305b940f9f9c314d4dec9bca30c91ee1cf1b4de99a5f43c37428f03bed373ad7e7fa578c503cf5fd69c3e6caf4f753b369201c6601224c96d1d2b362bece8e3dc00652e8ededaf9e95124c8c4f0ecdefa1d6025aa83071888c9973678e2a9b1dd1d7985742543def0bf1aa110f6870a620100ff086cc940bd73f8f4d27154b19cd30bf55bdaa525fc4b2d41d816a26cb571a55fe77a3626bb35eb990113f15e436a6f174c5b6d43c532ba9747925d25e7e59ebf76a0843b691f06a7f4e899f170cf65b91699b3aa31c6721a5de779332f9dc46d1181c2b330f032076f098dd7256eb62096fba3e34eeeee2f6c5829bf0975fa12fb448fc8780e9b574e183095972dd5a53821efce2c52cfafc43d3a506dd9075c4dacdeba535c978c72cc216c21157fc3919449182a4dbd5c700d1bcd16646b7c07b890244c2fb1612adc700606307f43585016558894331ef2678daca7c22b17ae1c6c0243befc592cc546d6acc777e3d6afd981d6d23fb32855e1bb6426b4b711956c54784892a7253decff157ea41bd77f14927807ce3811e09d7bf0fafe81429129d6c356fb45c25e587d6e2aa42302cad65a5e44a6d3354ffd3991b934d654b29396a98cfd13b63f54aa86bbd58eb54c76e9803a27c0f5be47f267366bf6c69921264783b24002b0c281b19ec29cbf7197a5bb2ccfb43563bd5dfffff1ba2556010d106f9a0c4eb89b2736dc4993e0ff91ee81261b2d3d6d3bb9c80d7b2f7fab7267cb890a354618cb54cc694f3c0f4d35caff3ff9a4d3eaaea1387d58ad87d99c974595b67c99cf202c837bd4dbc25610e696782330dfdbaee5b3f86fc9d47b458d3a49e22da8de69fb12d4f10941bd3c290c53dead7a5e60f23ddf58283314c262afed4c122f8ad91f0285d2bbeeed8f7914aececece9768dac19653585f578f52d403eaf0e37af8fe212c02bea44f77857b711e418c506be1fe9dace48b2550455997e8f0ea59531a5c776b4c3762813c2713fefb286811e53210fab7a4c3ec8221263378c799b81e451718aa51b785f730b384d5355460ab7a55d83d1e8de1760cdac50d73d9209a3adf71e19ec15d80e62ac999cf390269114e7f0f3fb4dfdeb673ddad954deda6ed7e651ff96772f4c1b403434421b0123c562ba6a64eb466296feadc12cf59027b8ffc42d2a32094a9dea1b9a5a5edfa5853267400c2211e3e5359940c052bdd2556857393e7d2d57313a04d78dd40c21a54cff6822b18259a2238295d254440da6ed2c4ae007e1bbd46735369ad22ecb67e64390db6148efc8313bc76d489e527980b8e9d96f70f3af15578dc5b45bcdc6643f14da552ba464172a4ae259f0cf8da2ea8a88d4c8f955016d712dd3a7f821db36ec91aec388f0c1ab63104b99de378e2a96c9e68b70a1c5f6da517a4aa668098e69185e9f134410cc22f8e04ed51c01964eae46d343efc48682405fbfa062aed2f99abcd29a516ee70f528c6f8ea282d63aa81e40ed48a2138f0ad8c69ce9b675616473e0ec1ab3b4b43ef3dc28b56c8fa9a5336a99280cc4cbf00bcad5f7d708d22decc24cf337713e011d483730fbd5348f27e957efab6b37e2e4fb8972ed7adc8f1fb19e3eee8ef73e11d218a85f292b8ffc37eb207af3130a5eb68312b837b602e09305d7e251550646c68f41a3a2bd8b14a1e151db92b612b07abd00181bea59842af9befe9f8be6c1983586c790e1368497cfa720f11355e382ed00e2f73b4750b8bfb6b74f3f02fb1e345646ff23e83a23a353770e64af2e353daf20b6aa6cb57bebfd06c91eff179f4484519da37a1eb7f5cfda133bf4ef78fe447831429eab3f2eec76fda145ef1749035639963aa9ddc0936c4d875576f69ad9926c6036ab69dbcbcafdf7307c404eeb35899af0c3c6c13bc9ae935901a601418dfa4f90e860c9ac8eef8fc69928ec1297c0b4ca3eba59e95731428e7e50425b2b29ad930f981888b48a71cdb9f6cd4851b7d3abe7f472b9edcd9a8ba06f48ba2b91269d64480e5d1901b5632248e58a51decca046940fc05e33972f01200d81a44a88db7cdb1296edea0c881dea0ec71007a9f19760f312d4b9f943e83b9ff3dbb02f05557ee56f62bdf232846b417daced3b397498c2cab76f583411562be71ccdb3e3cd9d3003a5cebaa2e50e5d134812191642e777e24b52bc96ed2ce33b0910ddb761f162b5c0b4f16e823f21127f0373854925ae69aacc1f3f4fd8bf842372f702e02513098b2c4db28bc8da615fa5f8c4af33a48deebb345b2016cf226c7b42232bfe5ceb572e70ed8540db820a3fb8019751fdd57033c1bdf63e72c337c6693e04e21be1783ffd85584b5c16210d6fbfc0392385ee0358b57a0b47ed90ab43db0f610a8dae162449b563d83fee925eeb13c5f786489802b4aad286acf3284bf614157ccec0f6833cdb48f89a9b9101d04618716405c65659ff34c118fca2527319df9d82a7a1996eb46f9af87fa8ae011ca2c6a7b55114771b5469f5073dcee42fdcb588bf4f5a745cce9fd85d89863e87519e86e505df5c6b5fa0d058a01174cb1cf8405b92dd9cd954cc5e57b7decb7e9bbe3d14dde8208cf58b281fa19c730ebdabd3596373d961bfe20cdae30afdd95657dce4c4f359f0c43bc2d10f045c9a050d649336d8b2c25eaf831e969848d07d9b1ba6fe258df30a5607e183c031791360ee1f9bb1c332fb9273eb5bfed6ceb29bd1f8291e83339a46e6d3d834832658accf0a266a62939f16378979916bf1d9875e71884df2947a0fe3f69fe78ad5b080b725ce8a2b90acee3551f3b4504ca59a5a7e87a86361fbf87929f5c881b4024657b194b4e3a4b9f0208cfc669604cbcfc5fb447ebb6c58d347c2b3bb56ddaaef8fe1e296617d374ee44f23b1c0be2f5d58b48660ee33b89298989268de6bcbb90851d640d8bc9e994c28abdf06f3abf5ad40ca112f9a192634f125ef8c161de938989e6ec21e901aff71a572359c1816e1e7f76b120461ae5a71161f99d0ea0689f5e838ea412de5e8cf903b6816d5e94ec26a60706282767a2fcbf6d7419ec4ec7b2086400ea6d5c4eb5c3f7af2e1872848b6095e9c9d3afa4c3eec42c818b0a93bbd2157158aabbee7f21a28f4ec192fc5348c1811d22d881f1c5fc07f7bfd3c606ebbb5e14ce8622b49e1a9d4240efb466275e73a42e972eb137c9697bdfe326a430b56a6581a63215486268124208e1740e4f263108872c1bb5ccc8d0f51aeaa1886b07683d3e62f0b26aed42f06f249081e4e3fe3aee0d732169df60a86923b492393138f15d5df799e13d4c652b9a636591dddac8d8da50c6c892e6abf7d1754c429cdd5d7cd2ef5f6f4e41d186109c71f71fedbc7b280fc215a12d189467c54bc3b7d02926dfb1ef8ebf68ac6021ebe77bd0c88f97d4d16e67ffb43b9b0615e74b839351fe9019e78e91cb9650409bba2d7f3523e33c5493b28cea9471a52c715fe1037a1be5a23616ebe4de1e164f6f0767ea07354479b77e85d161d149db54b25f538422268f3441053c66064877a201b91e32bae835ef208df9510f2b95bb93a1cab34e27d5bdb808b3ff3931c6289c5293d67a157f42f0d23de03d5e651e7a41e0cea4b8bd9fa04f08b0aadce41a714d5474ba4575858bdf33ebb3d69b5094d213df3bdcc38bc8e57c480ce6c9ed971b1544af9877c23436a794c8e825383bcc38cf09224bc1a044b7e14ceb1858cbe9ba32f49a0469e6e5df0aa83a3dc5aa5b6c3154b4245f2fa23d10b7d96b67434dcfd56550cbf270b4af3993c272fbcdb7ccc0b0a91b31ba1b0aa6946a32342c05725479f0210e0bfb6a4dacd80a2da28b02643ce6ecfd19744c20a8326251a7a866b0b4ba69dff2f9b1c35782cfe8f5a76f9961eb992350e19b8e3918f38024e319214ecb646646baadaab51a4a8d98891bab0192fdcb357106280f3b285cbf6c7564eae7c0acbfa48c688f620dbb46b8f892110f0ca1e77409fb142009de31336f13ef24d1f87304458b07127c69d7c6184d1923aed6941e9bb2727baf14d5e26dbdbd3c39dd0f9ef7502769da25a1841dd6751bd85842cdd1e3b4320ad0e0261ab1b02277770a12bb17ae1cd5589ae3308e8f15c3b1e87c607607430581cdd0f3991c3f81a630e51d535a3f14ebc6ea2209754ff249c73f195e14b82686570abfd01dda237755842546670185caf47570b1e5606478ad2014ef0d6ebb3a48fbdaa2c5a8327bc21f1698d4239dd83984eb79a3560f5c4c239211a27b2c2c7a0f78c44946ac191a3e9884df859ee9e2d2c01adc982b1fbefe6db72d4524c1274120fae782942c1397d17a61f20e913cd70b45d99bd79b3b8815f611aae0e085e08cca25ba759ebece685180a39eadae56272b8478fb9f93a17057cbec949ff97e954142dfb6a6b4c6aa608a6e70fdbc7f7d519c5e5d89e97de607c8de9788b89ffade918ef75dbba57f0fd7faacc2868c8ab0e1ebb48f15e007719b134f98fb8f70b248b83b80c4066d3fbc80307d1f6c86ccf3e863e71fca0229f9b3723b58f0606a9b6dfd085ce6db97ebe800de6d7d3b31ec5b13a4919ee44d50b22b0b48df1fe7e665230d8e1978d585f328399d39795b12d93408e8a1027ad4ede763823d7437b96c385ca905f5178e87a65343cdc81da74d0d29d3baecf10a4fbbcd0980fd00030b42c4d76844b2ea7be74b137d8a90a3f08a8a40b9f3f4074d734e1eafb057c674dde78f6af83f6da36658eda27053dec43a1a75659220b1aba1913cf77dece831080b6d6096016f8a8bdd92b3fc42d7818658074b900ca8524a60e4238d2c29d0530723419082db34d75e20202c2e71f6891c1f3079c4a42322d8b74d483b3c22569be267b811296fd67f4655439b5aeec96205cc2c919d132c1274cc425ff4b6d64150692eb6b3b5175f9eb675f94aed3475557959cc12ef8d37847bc961e9006b29224c800cb03a79e91706ef1b28d5d6368224f4435fa933e6a8d2da6bb2732e03703de86efea188b4a2d20198f0e1a87cbaffb751e132c8f47ee970619c4ac376d91cfa91c91ac3270ce1eee6af830af045b05b71fa9c8fe1c4a1a56123cd64165adc423eb97e4ec0c79c2b815592c1b3a2d81c962034c661e52f5ae158fdfb40100dabd286e80125c97cd9225ee455c7e81b528708909a2f3fa14c8cf50651a11859bc63a02de99134ff505adcb9988d54428e735d0bc300767d5a39aed88c7e6e648091b107bed43bb16365ea14e732ff392f8ce7eaf574f3b3a0cfb6cf4c8391063f0abad62542aee27990cc8c2be688a6d633005d32fa928aa61ddbd5bf12bb311cccfeacdf6ad71efe8979976b231bfa8a4ff79bdcc983cf886a4b86aee866a4cc880960612ab6bf34866a45c48c3d79aad87c72bf55557fef6c104c4bacd1b327d38107976de216368b4f90ada923b04335cbed95a6a4eb898967a2ea44454db19e2b50b27aa6ad9b13d43fafbade86afbe891aac0e6882eeec481e22cbbb539f95bbc5d9fcc7a3c3d30bb2360f694dac800f4a16e281cc79e41a66f0f2ae7e95e34137d8f59a47f93c312f54e162fdd6873b100ed2cfa9f0e64bdcf7dc9a5e56a920148608e79cd21bda09c57e8448016a8fad9980325573c1917edeaca56a3d5fc5dabc348d2d7a1dd1cf17a3e3e47cbb5cdfca0e4ec5bc317c3ac2d2524969fb232ede47387d72356599e32f3acf7d440ebef0bf696e3852250cafd21ac05123471523912dd452a19261ca09c94f76572d506f1bcd0781c161b71ed8aca970bee4e159f24ac143fda98f880227388b0030cd9aa469d56c847dc9183464dad28a0d3f1ad5c8da8d4bec9a06ef7b5aca5005434e99f2ea0098cc1c7fac3e22216071bb65dffad126a157899c99bcc50a911c6099acd8a53df896565cedc6765792e115525d4c6edccfa0d0ecb4fc20fcc02613cf84e3c5af0ad6e76e61aa6e2a95057bd5dc5fc2b09dfa0225d8b3d38c28f1af2004a97d9731df719c89da070e881d3227fba84b9807d2725710c8b27c0df6def81d5fb03257739f7aaa24c2ace15e4828be8fe01889d36de5c5bb66d0c536c8d69599a8a72d143d4678e1ae8b316d470989f575a91ff4532f84b833d8eeb6b7fa577073aec52804f542bd89112370db9604a549400de009c595455bdca0e162b56282d58ec67997368d842bb4a3ed54ecf16cda80f664de99ae5b8839b4b943f99713b51bc32ae1c364aa4eb0f6c4ee2aa0b0cc53044c629c24cdb438ebc2df4b4f17d46c706750c76804c5e250a34b910787be9ef8574b743b38652aa78fab6d8d153d790422c8bdffecf940ce26742a2cc5dc0f96397ef9fafd1865ad5bb723968b1583d1c7161f5af80fee4d66c6a3bd00080bd82a962d63225df74b60b2693f96b1bf90cb9074ef7e48060618de944d9775d14be3bd954a360cad23474a028396a2ad7b873c43f56afb68074b7d35e812c299ae9618e6820df929522d201be07a139f739a4bd19e7c55f654bde5f36d059aecebea950ca7c688cbad2b9782ccc1f1f05fe8925181ff65e5332427970d1c123ade978e22da43eda92c8eac889a36a82fe54910f98757ef817fc89bce4e9b99cf7541720c5634264c917bc593043fc7d8eca222c91259ebae092c7ed158064f2073014733673e1d083c66d339add97dd7e41a7249c8ac85328386ff6fc193bc6d57a5be25a99a0d19649855f6760c1462c641fe4419ffd04e86b74412dff8a3dd47c1572a7d59ec1de055605286541dc761e37f7be17afe92a4498ab649c08743f42b31c41d9cc7265eedef82a83c2944a36234c89a845dc89d2effce9b368e0f604540a2a4b8b57d494f8cbcbc031ebe002312f69e887ba97a277cb46f0595e0e778311ac0d534144401fda7cfdce65d042b6f377d41e7d77b2f372075d799caca134aea414a751853ef9a7c200eb514b1ee3004bfd281c2075f5fe4a26698172620382a256b66fb6a133bf487fb665a51caa5d8fc7f898b2a0791b2225573798ecdf54ddd3fa2a4e011dfb97616be93d77b146a817f99cc5fbb19136838809fc8b926bb084e8f258403048dc0dd2a8a2e331afea71e4cd9496d57292f3eaec5a703d0d9c52128c93a2e2181e5ffe7655c67a3de08f3292d5d672fcde61f19e7fa4bfbb6a27b766f0705c3df121988cde731e5b371af5404b71d202e4185b5f6e52954c0cc55520e1d314e3eb9cfa9c42d3ce43b9d49c2baf5abd58952fe4e48b2bc751788101eb3dce3590bca4d716e216ad741a43b1e505b5edaac6bec3f7b0ec62c6386a0da56b1a7f9d81afb615bb3a61d19d49c5bfd8f9afb40391b53ab312aeb997d412aec56dcaf6da50f90a56b845c7db6b347c61680431a72b4d996730cac8bfeefc53ff95dcaeaa432409edf00f7c1d90d75ac99c030d5575e3610135cd34036ae79c84f9ad1d4b2f9b997fa34551694a8f7ce492834144522670c850d382daf8f641ac633c7645dce614863491b8a61bce67ea7806bc2e7002c557d423caca7d9b98cfe56467d85ad470f28b6937b17624680a31003ff45324ebe6ccce3f267351abd607d028792377f2085c88db63eef12d215c53948fa8f4cac81b5c76c92347696deff4a356a8310da06b03343a7202ec018ef1efea6bbdedb3fbd80c6baa48580961cdfe3eaf1a84e77fe9335cadc4002d5dc897c4127d919ae484d55197450318f5ff13b89839972d9ae41faca0cdeddddce153d39c5bb08911a86c046f717b660aa7aca7921afe0c5fac2ee1f840518651dfc2b032e957e77c4b0c8bdfd9dc2cf8130d640a818b4044484da9b7117c254cc0fef4b0321b0d7ac5c5cbf33cffe17075c0aea9225bb89d53c5fc9b5d01b46e917feeeca4f77ac0a0fc59b4c9c0aa63b31d109d69ec526d00f04bd345d297f018c4e3e4dc02e96ee4a594235425d6f672e084b12a17d196bb2c67b1be0fc31f0f7e297cd0d95ad7c2f3eae9f8a462d3822c891f70406364df6ea75564cd767733e40002136a7a1ae096aeccbf4897a6955c388d8f959bbb4a05020d4d794100cf8aa0ff63e57b1e1a36fe7662d87ea9f0d09bf3b7037379bd91ef41de30f1ec7a449c17334d1fccb513e4863d773de14ae596c4872df472ac679fc3c061037deb69840ceeb55fbf0f745188ee5215deb0653ed56ce1aef49dafb74b83d3d680c613ae56f5e7e7b11aa7f93fc99c854f9fefb0bd5e207455f08823e12e0426142bb14fca9213732b0edff3c318835e065e3ce2420d7f269ed682fdb5a5e5d5d8c70adc7d686fc77499bbc5478737c1de8ee6cfb77e51ea7f0fd27413ababb3b3136cb22f6a5b1d12292d0bbdcc11aa031ca2747e1ca6b51d7982f59a894203dc06713d662a241791d39bdfa151df140fe2edef41436425869b3e0dfac2ed05f09a76ee3f1cfd674d58f7c6c6a5b171e849b83f567a6bfc32f5eadbb9cb81f9f42eacbcca1c4c0d79e2351fc676297a985be8a409d0c69ad03547643da5193eed1bf6ec7cd95ee51f27ad04abdddc1bbeef8543878d34bc07864cac391b091870691597ddbe62e20d85550c92d7a73333c38454a3e92e8c68388080af1286fb3bcb32fadbdb327dd744429a70b671fbfbbe3f231891859f9f4f214fc00208a89a9b5331cfdfa01977f53de3effc18eb1d6bf83322e42a44321a87a00dcd48f69a4fea0baaf88390e98449ab8566c1c6501b6365b899a6627f2116e7206ad5f74ef2c17a207e227a296e8038b464d0d8aceabb854f125368de92950376ff7c29ff3ba6a018d472aa97a10a91c28204987ef24e29a363e0ff7f37b511b1068a4fce7ad5b91c645f03085a8c2ea97459443f01e4a55fe74122c104e9deee998e4397e50bde82b2c9f8b2302be81b4225d31c2865e6fd0ba369ca1ee3b215d7ab7bc2a7c59bd7869029940aded5f52aac349ca7d4973ecf01e03514528bf263e66888d31b9eef0d4265e6d438bac91127c359601913d28ea5431d0f9b63f9bea38c63cbd472c0bbcc4b7ba1ee701ea21fa9d8e11fea4fe8d704d0ba7fc76f1c6dd4b87a041647898a8208f97df55c9d1fbf9a3f420410e62f69f498e8ff752d473f5d7e55506556735aad9903cd18d99a3510a37cf042d1674ae287c8b745f5c667df1f3c28248bf3b57817f3ab81a7b97473ca6b01418ef0334917591ce16bd6b29c8e0a88ddc90ead0faac44f5fa5c3d78338cff471a46495213a974ce45ad1c093ca4424e0fb79441d1322973156f48dbfee5f36274034ca84b75ea64354c0fd45a4b9267ced7c9b43db91967191ce76ab61b5baa73fdbdb314276a7a5e83ceec5ba1b046de7a1fcdf2b4da9162179a967482b9f97ee6df44c17f56928192d331b2f5fdbc38eff00d789302d436c7efbf990bd4b3c4f654598970f1692f59f265cc25e52b9dc748f0915f7bf532e26a1e5c8e00e9bc973322d22aefc4ff62824b7eeaaec387905e4c6d230044e24b128a2804936e8fe244e6a57d99b050127050bda523a5aa1d354c21ae875f4a6790b93fd6918f91600223ef6105ab8ea62f4d8afb7073a530a0053720347a99ea396e5fe5d9277faf5d81014125c1d6acf8f293d7d974ce84faeb757f255aea3fe8dbffdb92b45e24837e4599a30cecdab3f3f4e07368198c02dee9344c22cfdb9cd6a94cf3342547f1fa59b96752a993ee9cca1803950cd22d796fc122fe481e85d63306735422c38009f6e7cf15f68a1465f4108dbbc85bec81126e72398f4909864af1d76ad068fce4dae28778536c8d21f2caf76fd0627570baa85ec9628c711516952920ca946ce48ed0bf82c11529c020c65a7f7aa7d0b56ecb358ed77ac05248e1b14f1e68808f4acc9a071eb27f34e8dc2be66c4a8e1a733313107e76840f9eb3ab50a6201ec528f2220727bfdb0af6631dcc78488f942b4d807be490edaa54cab0d39daff2ff9a3b0a498c9b3cd07b6849c9be53645563f7b649f91e1096cd6360fa1c41dacc6fd10b5ce5ca9cb7009d999873174c7cd1028fa58672ce65f2b6757456b9330c3122d5ac6e8e8756ab6e17fd11b9e32b66b79790cc84a581a35e90e17bf5e6ca02f4e9bf2bfd8f62e1ca0229bea482ddf25332cf8580ef9139a1b7a85e875505b9c026e1ac8e6d999ec43027862efd351d0ab0efe42e53c5da304071851939d672f8a198f2eb0772cd071577562c6cf1a635a8b374ab4a8cfe9d9a4274ae4a8f77eb862765654879be8ba69cb411a419e4be8e0f3e37f23fceb44295f2df084fb9ad1307b31cc3057deae9a58e8df0a05e8395dc790dde361870dcad90bd0e322fb7fb8f1ee6ce1ec99e1329a328c76add5a163436cd8bfe4a7c69c51db2517287aebad7436c80c20412d43f56acbe2dc7e40d6868cba67cedad614f0d920a38f139b531cedb350f319e0ea9f77743c7ad3d02aa2003a3fff64f3e9b32e197aa5b02a1973f914ea3fbb9c5bf846b3cb9c63561c8f9acdbda7bcc47079b9203541c2928d0bcd5b527b7a1a1317aaf6173d2f9590174f1c2faf14e9854595d6f168558e84f1af92741ad0b2ce50bc20101d069587132a92f4d26b4ccce3f28f5d7dd0934c3edd125d3f3a9268c96c5aac821560a2adb333ab907f1e7641ab14e41903e35ad1571610c2e61dc69b054911422cd29684962c800528f6deb93baeb8f790ab132a8c6447818963348c8ae2f83407da78cd5f7ac984ba8af62ec0988e865feedf76ce10de5c17ac4cfed2672076e8cc95fcb73b0042a0d92d9860fb74db88b163d6d8e4568ce025af40a50de6ecd69c9568e9e7d46c02b0813b6634027619ee7fe23d455e1654c48a121dd4c7808b3a91d73f0778246ad7df45c50af680bd445272da79bf7fd859af14fd209f999a602174324b56cc72211a203fb05b86a247bc37aed763353576bfe79928d50b83c32ebff03d5e151c18525638afc624c2f6fb3b058b5e59b54a296192ac470d0011d95820fa8e610d853e26328d4f93bf8deec209b2eee380c3c681f7da84dd6cc885abbc59e057df9a14643077f57b10cf8cde76b656a3ee437af0dfe334cd3085aaa63712313b5d4c6617480ecc59e8b163ce32e823f970ce065372044c86d4f35feb80db9e790995a00efe1f107d03d36af52d64b2625ce8ae7cdffcae650b40a71a71e1639d10db9daa0b48c48fc675035546096425e8d3d6cfbb98dabdd0293b935645635baef1cb99198d045564d1fa31cc554f9713c12967bad5de1cb107f5ee6dbbbf2f8815c3170b8c179ae7755e060c0edda21ad911fc77e72924b9fddac349cb474859898e0e8bc7e987ca13e1d3cf5edf9d59951473340f810d0e420f00f7949be3a3f95ea625001b3404c29df7dfb248dc0c780d1d49a8ed9381eaed5331e8caa7d014514a9d6838c3186ed7cc32e3e2f9b50f1c70600131c180b5501ac4747410d03d9f9aecc1859c1bda0ae01254d5c41f819f2ffac0a9e0dc8ffd6a0ed46ff0375dcc08705bb416132878f8370210f0843916e625228d49b45e963b92a85db37f8eabcd8ccbcf9557adb52f26923dd3750f723c84a37981a0c9753de7c8fd29766a05aafbde68869ec26eee82db1c50163712add9a019218beadde0098d44d44850aa8ce1f32efc0720c0524298cd2e7583f20435c81906176956498c12ccca69da6d3f72b7a8123a69c326f3de99a8adaa529388bfc7fda41dd7cbfe788bf42f017eeeed3c0b5e37dde84e5f9f2fbc73ca8557c70985204cd4fb7451fb025088de09cc5c277c06dc7edf745d5a349e2a58c7eaf6631e367dbf7697bfc9125c566a9f9c4670c3506639906fcafee7b2305022f075865c62d57f7aaff468064732bfc0466ce56d886b28053a4813fcbe70a5f9bda2979432eec81bda03842cc521f673a91384e29ae1f4994003b861ba3a18e5cf63dfe5be5e1b95e95f53d1930a4f0dbff1984ad7ff3a84d3559be66487e0600c88d52f1a5923a7177a5d249dc6273728e53833d1eab3bdca6737d6f2bae6e5a72cfad102843dd2fccf1eb48f4d778aec24186673933b3fe958f9c0bc7ba5083dac5e63bc095f1c1cd2174b16c6d7f702e2e1d3c103a8e395791125e691cbd49b9b960b970f3687c3fd5128240a59760e42fd7870fad4b845978b534fb0ea1a8c713bf72211a0c36ea69fdd163aa4944b220f152e1ea63d6520e17b89102ef4214353fd86baa65e063ebd96d82de69990c2175747a3752489351da8ebeb737d7331a31213766d41c50185bad730f4ac4f34f655a5fe5b6659d85f41b35f763e08f10f8fbcdc367184ac508afb722cd1d54b83155bd8c9d0495b6d87231f036f784f13d4cc9a7b596448403226c07b278951d1e7b9d71958d072fdd2abafb42416fa2371174795b246431ad151b0aed8826fb273e0885130ccbfe2c8e0666945b63cea2a62b2c7e7fd483af96ed5a141b38c8c286473ca90ef5b3fa49954c54e328a00ef091223a55ba54e068c6442304ec053dc92bc7bd02523717687bb3f245a8a710c954a31905e4639261df0091429bf5aef454154c684b94fc7eba1b46e9450420408b13fe0652a4be2ef54a7ce2568136dde9db1ca09e993bda4f7b7114215edf0fa0f2b9138177ec312efc37a026decfa3e4cf43fc207e144dec49d142ae5df244ce79dc0276476e2c493e25257e7c2ffc460e7d4b976b97144e1d432bb6bdd11bbc1874cc4ece8ff45114935f91c503da68c7642188fe8de5aa94bd459f6a2e0a9f08243fd552f4beb2ff6f8fef78bac46207daa47230cbeff038db0da5f3e572c8044d283791f1c3ad40b00a4a1da520d5413c04afc6d254307b314f08a54f7549c15eac11efcaf1d864be313e5c457faa0d10ed5e64d3a40663b7c8981464ebcab791821beab9edfb78bfa63e4307a53aa7894f2367a9d33a42eb3afdff2a9934b43bddede7d433608f020b4cf768b0662095495e2215a4039551f2725c420d54c7fa5dab13f21d36b08679fe2ef035b5a60e6d9fa13f829a9af3c211ad2fbfb356cb1bed63b7a4206289136aa18dbd3a4555d5ca6fb05abbe580b716c666363dcbaf6f153915691dd8149684298e4cad0832ede9fff697dc22ddb077fe7ff7a04284ff09ba92a9d8109a6ad47a2bcfa41dfaef9b06b6cdb7813e2ee54e562cd9e5800b93a0ab9264566abc32e11f458a4cd85e44d2ae45a7d0386128664624a1247e8f57614537b19580dcc7e3b74f3655eacb2df60399441c255481a4fb5c1ce3494ae9187aca2cee0e16772929396196dde6ec2f939d39a58634d269d2d9c1b6037d6b1aaadbd7aa7975ff274d02307b5238a707b88cdae87c14d24a8b16bee071baffaa5db10c76d86e64657c</script>\n  <div class=\"hbe hbe-content\">\n    <div class=\"hbe hbe-input hbe-input-default\">\n      <input class=\"hbe hbe-input-field hbe-input-field-default\" type=\"password\" id=\"hbePass\">\n      <label class=\"hbe hbe-input-label hbe-input-label-default\" for=\"hbePass\">\n        <span class=\"hbe hbe-input-label-content hbe-input-label-content-default\">你好, 请输入密码。</span>\n      </label>\n    </div>\n  </div>\n</div>\n<script data-pjax src=\"/lib/hbe.js\"></script><link href=\"/css/hbe.style.css\" rel=\"stylesheet\" type=\"text/css\">","content_text":"83e4f756d680019cc75bb3d7e0230dd0b412a416fdea7528d7e9580f6601b2f16c3b74a5d9a5a1da5dd61984e78f0c846a143ecfd5bba379448319807926070c9261aa0fe10bb6f9896ce6f30c9802b7817ce47b5373bb66b6065433067a6176900f891b25ad8f0512f52d29ee75cd3ca8a32a796d253fa17c333d3f711ccbe24f46b73c4094a1d22189cb0a8a140cbd5a088bdb5087c3152c50047f9ab29a03520922ed1473037268b711b17e5d1379d53a4bb76ca4a83340902391de7e7ec1f38c9c8e03327ae25b45f0257dbcf824e46957a2eacb1e308b8fa8472f1b83a8bcc9a8160e981abcb3d1ba30e909ba4fba3980a0c31df7579dc87d797917337ca479a51c09ace72470072c706db76b4621711ab30673bc24149caeac1aa693d644b7692e450c13b7001eac4bd41390809513a1655a130eb440b409ae493deab0672f6807dc5a972d68746e21fe07cad0015a48f47ba88ec7783c353f9d7d333c2dcea3bc8c97a40e5466f0a5aa369c1e3847c1a7a69dda3164b71f49973f30e36e190eb60a806d1c5ea611ddf61e90662860e9f69ad3b89eacb54e7593f925c888789630a77e54c1b76f26163e3e3f286c79d0ca49c845af705deecbed52de6bf77e11dba37461f4adec200886d8ccef97801bc21c2a184a11526e81658baa8482b417f6e2b2a7f1680f18a8b9d54a093e8a2a95523879bef658d040be5ac1b76fb4fab5fdac9bc549ed8d3a97c7514aac148d18eefd093f4c3be32cdde36dba49d50f182a5b9524754252a35b87e69c29f4c208b23d956794403aa7b64cc0294ce7ad147246f8b73ff2dead1a9ffb42fbe28225d4a092417d2f75c5d79b4ba74073d830f27fe86a8af8fc7b103bedc7d2d67c8f230d835305c9e4f385b2324c1b388e6f5f7ebe30ec698ed566bdc70e14d7c15e432cf84a057c5b167716edc065a35e1ba6a88b261d46acbf43aa81fb3c227ce0044c8dc715c806896104f94ae9d7cd42cd3255e2991c71b2cd4bae2591f4f0ed84a8e4750db164e394cc3b7948d8a4c8d5c1482171a5f38e12a56ef416afd326766f9920c368e7c20eea2a32bf02abcd83d9ef84007aa4d1c55a2657162ebb7ccc3509097b914ed6e9ba8fbad114b1834e67e4b4715f3b3e236232e31f145f6e4414913ed297a8a39f9cbcca2f939cf65932b7b3d525cb4677b7d58b608cbb03846ffffec4adb7b2151b88fea005c51e53c05db1b28266b75fe1b55d306638ee6818854adfc4a3f3eab850b5d2d569bcb69a57e2cb29338f7a7d6560cdc9e5cff4422a9f8c1cfc95df0db54304d49d4869e9518a177d495750e7a6424377cbdb9477521c0fec9ffa354e4f9566351fbc722d6249a74c46b541d6f4593cc1e6635bef88ba48de4c2e85a6bf9a8bb0fd9da4857f21e0218c15075c660830c4a044a01a2ad7cf7d2e4a87bc789b2f2454e80e0ed72aef3c3d19070f04218df44f4ca11a083c5e8fd548aaafbaf7ae70fc62e5c618363bb3082e9ac6e760243f257c2f0b0224cf15fe312603c0fa81d9f79e0033e79ea9fad0b9afff0fbee56de193caad1e9077460bcb21198bb326cfa754a4ccfdc138b375e3c70541957e5665d33766672e9cb72a3a8b8b9fe494d87a3cfd26881cd0b17818658e4c423701313db70d8766210287dc8465108f2c9996d1ef6c948ab9890c2bcb7c2d370da76ffbf27d611e2d12119023f14129d5f52e32fe7d7e2fe7a7878b31481093f0d68df50f68473042d5164699288d3a99d9985c5e0fbec11fd12a8e849a4c130779ff1c8667ebbc5a5416a23138ed901c5aef969d2798e80a34be011ea61b6b32e12f555fea75e71d0ec86b1d7d977b91c05faf66f2b9622985b9c7033f056ce6f28efbb275366c907cef920bc76b8adea8d4897d239d1177f2a5777b869048df2bba775fa572876eedf15fb74336d78799cd348540161c1c6b9b51c0886f2f6583ff2201756cfbd31077e0bfdbfa99ef0eb03dcb95f4c74f262a7e7b35779b1dca6f33b226358a5e715b517b9cc38b5d2a36815ee4542721700adde7c8eab9a4d30537af69b546d3c5ce92394399078d427add8bc1e1a1908f8305e39af128d05fcc6ddbd68bdfb892247d5df0a44d4a6108043fc6c681bba47a32e06f83df57c5b819c1ec835c17b0f90d6fb79d8b814c259b04790af6f9977089df3d176d77fc6606645d0e44f548f960ffa525970ef2805c2acf0c8efb399496f5f89fe1a2bdfb662ee3419fa84068d5dbec5a1193a9e8e9d3d8d4ba7665c3022eb51ac47b36caba1d3210cacba2ed2b0945e2816d035059436669f16c2f7cadd506ea0df0cececc9055d0e1f2b8470e34f698b3d2bd4db05ea2917fac43cf17c1f6428e510f05315fc65b597cab7e38bae06e1ba921ef674766ca6f38444fe5fc7103d95a4cf062fe2c3d1dd95aecfc2b7368e7e52b9be97ac904f4d8c0b45232ae0723e025405e2ec097a520fff8ec9b16df1b5417af0c04ad80f94a2251d2a0cd7b967617012a2c7b933326d3da1a412bded92eb4276709bccde039d17b30f30dc8708887ce853317cd94ca8009895aec314d8e1931e12cb7b02c932d340a5a287a937e77cc8a5ba9ec42bcdb4bb06f8b11b1d639316f6633bbb73e33509224cc4cf45d23516c85a596472fd74e6fb5395447de3efdef0fa22f8a03cc98d00c484c38ed4b17e6d5f2e6fe4f5b28b4bd262b32b898142f334067c2c6100efd2a9853ddaeb8da57c3b4082bcdd43980c80dce47dca13a6b95c78a9166f58fdd06b87e32da3a446a82187a1ceb02bd33f301e6e7552d2297538904473ebe83a707ee1286b5ba25b3d9409b7230daa80ce2a6906cc7466da175c9dbce34b8a775ccfe55ced6eba3af158b8b1a7916b984869a575733e5c6ef2b3357bc80f6caf9b41cb8090a2636e7a02c68d83666e661000440cafbdcb97fc4a67f1ddbe90bfd98eeb7e3ebb193b8157a91b956e8689a22180a3563777e129c8f53cf060233587ee8241f3bbafd76bf54a7851cdcb31fef73dc2b1e0995056397d6c29c8ddd72c9644fb5c8bce5a513f70079808ec01bbf02585b8c0f38247d67682038b4f1c869dad326cdbe4b6ee2f9900e345b1d10fc82da3452280c98b0a730dfb1ceed8529b8bcfda4bb93d489252b1db06ff49115dabe6db73a9248fd48cf015d9c0e40e9272a05cc25333c550c14cceb8658b24a6d39adf95f33cd85bcde04e25f91926ec8b06ced533207419e9943f8492191b396b93bdb8bc1002b54c81d63e7652560364e59c942b50d1473aa41e298ac7ac3d0ac887fdabcac36caea8592dee0171636cb8950291208f14abd8191f55117bfcbb517622b63f360f3b8beb4133a04dc207f2bc4ae28c2d897da9a08da15aefe5f1a6f567b4187c307609ef7e6c38e033c64f332191e26fe0cbccd339700b8ada4ce7665d8f002ca013bedcf2bc72a2f288f29a90122bce91bd686b21f8a957e28e96f4a958338400f9d47cd4ebfe37715180e77a6c3df34b8e5703489507d03bd4c102d3a08463ebf97a4d14d56408f4c0c027803ffc0f6afd478d7bf862e51ccef6ccaf6315b5c79f49ad9f60280b043bdcc5449987d5cdf2fe6bec8c1aee4e50f0d9f9ec9c91f9c4e49bce058d2588dabdf37281dd0e9996ae127b4892f0055a710db0523ec09964b69717583607d0231ffde1a917e50495db1fab56b46c57c51e691fc25cccd01bba6eedfd9e998fc3cfa63d23bdadee54b7dc62c3acee57ceb98d7c330685040e68256de3dfef820a0e69af93d0d286b54914d7c3728d7603c12f208163419114d6fc7f35ee30efea56ad3bbd744a6036c6b54f283c4f435e4647ef0d2fcb7df60a4cbab059f31cb64b0fbfe87e9a2495e4ed8ec37f515eee8662b4d0101d5ad8b4523c7c31a485dfe9ad896ad072bd6fe4e0720ae3ffe7f42de0a8c6bf61670eff5bd241e3ecb918094f92df5e791219849f8148b3153fe81224b8a834661653608e3a62896a81bee475a40344518f03d24926d526e06a130341138305bfc4c87ba36c4f814f8f412b64993fa07ce145755e554dfbb096a7b1f5249dae5ba3f19123a1b89a703367faed910b21d91f0ad485ff57f320802f049c65d52aa681a3d2e9f04e99b0e0c2c65c6ef0b5444cbb5f9271a4382a3d046cc5fd4b849d408150b233cd90138306cd314c4a0553dd7fcc82758c271f22e64593e9bd9271355c94e5d1144833bdf73d0daa83b13030799f8727ffe503ef997bca8026083e80b4f322442c6ac17d9b283fc66288fe0e6b6c8dd5bc0278cb60ca3ee35a84cf7e7b7353becb5540e32b7fe6125c6a557dda4ec458c8818b6724538d08669eb2b38cd5160b31f7b91d85f9281ee3cc5d90cdcba8a3441a6f7f66016e680996d026be97770eca9f6b4204b1da4d20bf8e66c91fec9c091a677fca7ae68df44b63ad0631eb080238b27ddd5903ab93f2d6d7785dc4416557868f6ec091694c58e0aaaf1412a0bcaf88ec55f41a6fdf9ff77332e4cefe280453d1b3458d6836cb6c0bb24d9403c10197d9c73180a6cc8201f6f2162c50efbb1c7a00a3938fcc16ec5ae86d0da6941b6b30932f1737567199fe135740d75d79dd06847aa65e6c25443bfaa6ab3045ece4f69a7871e23eea87fbb0d9516772220b8727b3eb1c33c914e76df7658bcc6f9b52ac6ccc2dcd0f32f07a39b5aaca061b56e21e2e9fd5260a08b84d1847054bae3a98a870c9df0c2dc36c1a16645435ed2b290749d36a831e0a0558768b63d513028bb4b35993c6618d525445cd4cd9de25e935ddca4ad8a644cc50d88617e5514fecb31dc443cfc272038e0b7e2f06a94ad762921487aae3590c104a6bb8fe48576e4b30e81424c4741ecaa7dbddea03d80d679b97a86947020905cac63ef156b52775260693ac2511c1b691a996490d78ac2aeb865d0ddd343f24185ffa39cb5e730e5c7e600710297b616c036e163bfbd59ecfc75e3ef8d54e0448850b0095abec1b4b5bb6eb2c41020dd43f776addd783b93b04dba7a7ce5cd3e92a3360c0bbbb4533f891d8a098e9adbd38e0e8fadfbd3f4b90ac54a77b81ca06ae922dc2d15a74748f62e82ec14af79d767cfce92a9c58af17103cc86991fa1a3514a176e072a17776e8b7822083198311266fe5578c6b8b8006199e5b87aea66522e6258d79d5ac2d29b32264e0312f0326ea45e6cd201c53fe0559e00814854461be8645177c728bc609cad8674ffacf3146a97dc9ab4e627b1ca9714744ab0d809d4c678b3d4977690e5b5c88538fe4412431855a633909fa96faac2f8934cf81e372116af5a271840fe1ce38dc05d591e262616de187b378d026f33c67bb543075e703c1dd2a3205beefd57e580f51f5ede218e27ad89ca9ae3dc4035affd9b8e174306b480b2dd323ea0a852eecc8348fa049149db4c0a50248337d2f6e890acc9b41cdf6c12af46cc241365cdf50d29c0f996a0acb311ea042c5716e3661175d6bfded61b16c64052647c24c237b45e0d523665c38986c56ea2c8ac76ee165f82ea3c191f19434742bce404cef2d5c05bd46c64df7996e8f9d130d91bbd2e66089b9670b5e55559317d5588fbe6e61df3afba261285a8e25fd026aca8f06d88d4a3b8f01ec3e464cc7a73a32d7b50784feba1fed04723c47c14cc239c765923b204fef80399431aa727568336253516601353dc8f864f5754b5ba91fcd71c6ca95e65c6b13a6920b79f23c7e74d0cf1e76611b5e78720d5e1beabffd4c53d218b04839c066ee5ffc99c0e8ad95b5bf439f8b1c12080c7dbc08a0f7309754f5ad9e83b7d04b8fca44d84774e6c1abd771059bf9813cd88c2cb7e50ef4eba15212ed21b7f24e768d94526f783c81d4b7d11ef721ce29cbb7222ee76445fe3e5952717b1bf38df4655ba96f04a75eb37d2acdbaa06842deea344082fca771c2b9a906339e1bc9689b79febef103fed77c1d2dee8077df24505d4042d507d09ff8919a7bb534447acb36026db882bbcfed0a582b8e4aef5184a1916a45a7394dca56425687488cd408ed8fae9119ba0b40e0f831215a0115dbf768117845a7353348faa34fe9e577870213fca8360fcecb235ffb35d9774106d4459a7d21e9944d2d4a1aeb69c95d90f403e14f0e9d48d134d398548c374187d024e1f73372a492e54e7971f3b74275402002bf5d7ef6690b122faf05f2fd5c25c7631b3864f3eb63d57b2d266792159237e89cbe2b77701b75497575c7c16abcf7656577330d0f3e26b9793af2189dd1332acb4d06f7f4a7e47c12fd7e2a72c0d1662168b4013398fcb1b5be5990ca5e12ef2a58d63556ca4ac8137745c8ec37e344fd874e278c9aa93fca6217a86901ee78a8d8710763c6b80964fbbc75c399255b22149d4ef42ed6f12db51b2a5cfef4918062c8ce1d94abc04fd526f3ad306376162c4972d0b7c19f79a932b59cbec91d27ceaec647e8d36081c8f68fb9b529a1c74c30e36eb1dd7c4b800efe8fef829f9613ce45efacc0b21b4f57de2aec98442f3e735e908ba408e9672aad7f7627f3466656eaa23da48ceee4a36a5361b062f7105e28f174bff46e88d81b927bd6e175770851efd7e3381a4a182d7604d20e0cdb5ebe0093778f19939b1f3bde080cb302dd5fef9d0c0fac105aca6a35bb08e603f38e1d426262ce85b4dd8b44c032b45faddf3c25a1c70150919c6f14bab78255e782a8d7b7f712e0918f85204aefd4220e647101681b94d84908463b0f7c523e80d8f7569d0f3f961f3d3086a7419667529259a89f802dfcfcb1ed9bddae03b57e411d13eb7cfb0d3d948849e8a919e705f20082d577c7b4bb0d6a6af11241f2ab4f8f4845ccffc7ccf3c9033c320451b1dc29eae59d32151dfef2f19ba2b5dbaa4385d26aebe84e5ed4b06697faabe55bac6c3be8535d3029cf2d04e2ce986c6b7499b2235911684303406d14b32a11667e62183334e257a8b991b5700dc7e3cba64e557ee13e74ba5fd92a45cbc88dc431974dd1cdb31bf8fd016f7a5797a7df1bf882d705b0b96d5ba6f815d848bf80f6658509bec75850616d4518992e6439eda72aea120e1252ef719b920a08d1aa79bde4c8c622a7f9032dc180ecdec18b77150ad1a008f34c07241a2d38af4bfce43256418ca1899130e2646438601ca689f0399a6c77ee612e7042f17f8ed7270669d24d38076a2d5cb52b968c2db158e8b3067a2f6144d0b75a793619db0be8ca9e2458437d9430a778d62c2a9274a261d98491d9e449f559766141fbe4c337b0d602bc364759ac3ec2d895cd29302d47a44871457657f8d12b9ca006e48739f35b130836e0b291222986f163d9612400438f0e33ac5b65ec5e024aee0fb60d885152328559a77c9440e8941503f358eeac99ab50d00f3a938d11b4065300696d4671ffa52d2bf2112fd2bd04ed4b1f39480d2eaf8c829c54ab5651090068ebf59c0efc2f9aef80698374c452c80175cd0c796c64046a860d91b49f01fc67a08af5df3effb19390388e0320a577c8b450a54c292ddb172c5f91b7c7f6eef6f74afda5a520efa39b7bca7237c3479bd694e35995f2c4cb4503ec240375ba0dd04f77eb770ffbffd7fbf636da05224065a3574c0e068535cd741c437b89d8f8769540c0eee8c2c80d32d2de5f486554d0226ea0ded16cb8fb3d85be1d48cd1a86da472f99b1ca6c848901fcbe4708ccad7f9de0eea1dc165dae1e9b12b4c04b15127edc20b0554a9b728e8efb1ee7780b34a97a61c9f50bedf0d8a6598d8f4d7e587dfaff720215c9dcfb5184bd9fad32a9cdfdf01b18c849ca0951ef18d8fbf146d7d0e30c15989e0f1ab9bb5e8b7beb46424e8948582f3c4c488cb22d587082a4a5d3ea1720447ae23649509013c1da44e55f184391c52d762e8bd6ad3303fc91cc0c3cc3270b0dbd482a4033d72b0a382927243db223f4bc8ae4b0d61498b8469da193df0c55ace28f81b5d7d54c7987975f253609616807164888a3221b292b81584089e89ae397eb875d691dbdde28335aec96804106914fa8e2f8d5daf250acfac5b52653ccd160ab4734b41f50b74a1ce8034112a635a6ee2395c3213769f3d528f15001b982c4aad0ac89e0bb66fb53d2604a98d3e81b43631930590a74a8be60feb2deeb6ca64fa9341d23080e20768306849ea69432cb86445af3574ddb9461254b5c570e3664425ecf8d70c47e5c8762bf8aff7f9a83004e7ae3d5b9a69b363588742de1d0ba71fdfb2df1c4ff39c538c6e094aa0018405498119bc909bbe18dd54c7db151ce8ff10f357acfe6f6a8fe5cdf28bd5afdf7744e157834df1aed0af8aa680a5987ee232a3b086ab66b2c26ff91adaa0d2ac96babd7dae860ca419335183ab52d2cc0e94d1597420d711339e58f8078d5688ee51233aca80ca65a0e8ac8525bb8c54d2c2c80bf83bae040d93c51877a675fd73516926e83311be28121b7e935cd7b2f3fdd38f00f91d04ce2e99f8e25c4f3705f0d7420642c9e5f6d4cdabbdbf4be6afe9bb967294c4bf5c23d77ddb5cb8e1c41856101ac0d00b2bc144d4c7ac014c71e82c139c4c856fc91760a4eb984f1d07ff1a7e81fe9ab62fdee61b70fcd4fc2534f9f2d3728b6d685d791e34f2a0528c1ea1f486b3b94be8e2b9ed11bad8b3013a26a347958228031d9b00683194d5d3a2f64734c97e11b25c9cb4aa87743bb5c598c5aef7b05e2e0d1a98e4aa15c3282305bee9244c00128f5794ff2ab656251d2c30d39479744dd8e86f49231dfe838fe20f631e0154bd99972b99230d0d65fb2db2cc09dfd0232dc1f6f99d4d72317d20d0c4ceddf35d927f7ff1acf9ef1ca5fadd2ac1e1b99cff0ec84cbd84fce2a1fcfd77cc00daecea057cb7278b73ce92ac4149dc52580e4f3479ebfdcc2906e08f5e29b87145b4f5f65364a640242c6929d8ef97191d5f3bf020409ad857b411d44bff18697a2e77e1d84dde5c49f304ddf1fd1b9df91737f76da00a9f8f88b8e274b4f932a7d7bc21086740f8defcdc4c80b807dc0309581e3c735e6118006eea9fa228d39b001ccc9d485282c2a23fac2b7fdaf0504dad6c9db94c78b0eaf3a5c99360ad593f395485d9936fc7faa167aeb8e54beb3418ce193318460157bcf99b3f15fbf21b73349c4236429759b14900d53143f76fbdf3c6bf147e45114234e1c26ce5dd0ba7b90dbfd2a8c54815efae7cab2b6887e9aa224a2984b42c1c7244f0f752c6c6ab9b442594e6433cb8a3537b7914eb3481d666570ad0c6dafca2cf58122a71e940280799b7f1d9c544bc4d87cf40cb2fbb762f4b7d1f9c29b839a53ec766ae1ba8106485acecfbf14e4131db4735d74dd622134f48b21d455cc591dbfc67cf93462177abf73830150ce6431c15c5c9d474580be586cd24f4d1340ee4dd4fb197196419f70821064e84549937b99b1bbeb93254b8e0dacd15b7d55743dea61b28716904e7943753962007d0147873ec23893dc3e150887ed8ceaf3e83d2b90797888ea95c35c69f623d71299690e2901c544cfa7c459f0767bbab68afa83ef3716076bc63bcca788883d93958b68524e39c0d1b07bb1abdb2b2893517bc12dfbb96537923ae6064d33f664a5cf6c83e784242c26dc12a82871938ce5accd26f35cff648e0ee3489879f9b129ff3a2468c75a0cb18649ada8fc640a0a40d0176c997d28a040480edb5a7a84860f714872f2362c22e8c2b74f4dfa4f77d82bb9b0b0a1fe5b5f1c313caff857fdfecc6a4eddae24713caaf633b5b4157234fdc13cf071b4a1e20b7594513804de8d5471e0430ae7c6ce474debaa3ed8bae74cef9352b9fc0c3248c22b063b730a7de7eadb3f372646e31ca110549fd57e7b78b24700aebcb84125fbfc2f9951be187e17f0337c190b4a1be1eedff2e677df2282435ca3e42bc20fa1ff59bc56777ccc145a303678b4f12b3c1f178e158f2259705a2345d91c7bd57c86af5efe459e78891f7094496835ecdc8a78b9736ccca7ce45549ce7f23348f2da5fbacebeac6e2e787b35fdbc616de857affc0b7d7d8c2e4f932da807dfb6bc1a9ebfdc1a1328e9e6a210d4a064367c74050c98f066dd691a9b927ef829d99754432024627f078a2fd3066c48145b6ad5d437d1d14ae00035609e23ef741ae974596186edcb518a41a7b6efe50f3569a37ad5718965ade12affe36eeaea65d7c1798082a09c41fd043c8235fdf66bfe90e4cdeae6d996c5fc3922192468183de66cf2beae5690132db0ea6d80fa85c8857458fd472592800f9ba87c47feacebd782c501c11c5d1cb4032f0209675f0c405969c28580d5564fef081446089bac5dac8d7158761420b82b2a4a8f79644d80008025302b2e4c34f1a3747f3f69de72526d0695943e36b72814b19ce7045bcda20b9b874a7bd5d7de9b60037c287aad342d2713682fcc0f1aa5e4a1f01b2d5636266c2b825b2fa755a75b339dfd300e6121a7b8913f8c349cb7ab16c9e4027989edff835f0b3540ace209602aeccde27739100311be21e8aac2eb6160b2e7f3632e8b8eb0e5b5494d9dafe69b09ead8559ce04dda3fe99d942d7720b9118328562848b3c68ca97388fa857c35ba00135322f02f9ab54f6eed6d60ca4d70ce5ec40cd342941ceb2b1923b541bdb2302dea7201f97c0dee2e0aa57143c8cdc48613a9b3c9e7c1276baa8635adcf8e06126f5f3506991b26f0323c26af2958dfc26e23789c5abaeb5f943236e1ca87ec86e6ec8199f590d76b0b2ef4b14ab0e4ccbfee4e1fcb1f66b3f4c398b06c526cef7c9c88340dc41f407329633a4e9250c451b9e0ac0d28d5686ec8b3038ebf2796e3796e5958fdd3415df127ddf6f81d108c1818b443b3fc43c75b52a0a10b6ef10ce06b645566b69383113927e9b9c753445229547be177ea7de522e37973acb70cb0aa6091c2db4322bbd46c544f0f23daedd35baf474ba58169321e147d1cb5b2e97f2783a7835b7b8f389114a82c551befbdebfd0da4b67336afd1017c0f848fc7a1ba41236fbc18c452a56f4a84711190a1e94509f9672b2db194acd767c3ea46071c4a8491d173c4c136856792d2cf5afe2ea790e48e9b1285c80ad75704faac724a40addd76bf357872c7ec233fcc7dc896b4712737cd906e42f6f609c002bdae700e3cfa72abaa4daaf32b51bae4a58dc8ce7331f52786dff41e7584e38e608096bc1f5ad529964d8c5ddd51e2c6d39ba94583377ff831ffc52c7e4fe8f3e35418e547e28321cf4de20770a599ff2af10d90ff898c73415041302948f531975d5c1d1fec27c969d6a42dbc3faa0e9869ac99d3a07dd6bba3a1eaa86543814684c55dc2ae601d45155f1d2df14be1d5b45379a8e3ccb4418dc5a8761475844b53cc1d53d8ad3d23eb10fcfcb56fe0977dcfd5211111515b1d0c0c227bc648e5941adfa885e5ac62cffebb618ea7112b0015e38c0b621bb8a1148f7a465d5f90a4a405b8a10b3f66a000c4039dec96bdfce07d9670ebfa75d728fcd38ca8bd822c95c87e61ec4ea2ff5b8d3a9f9a56487a89e1219afbcfd440c5e9f5f7ddc2c40e73872b97dd61b91dbb9f4d7f97da0de225c7c802c017059f3b5b3b239fd1807da678c341a8cc225bd089a63870a05c4528e28f8e0780834640ba4eca86b3a68c6ff7db0e9b2f2206eb9ee73ba35fdc389d51786ff7912fc7a5ec863c2bbcd8c826811e824f3e62c29db2acc1b7227fe64b906b43db77edb4a1711e4c00e34336ec77e3548db736b2b223908c126eac5f51ff196d824bbebd85303a7a452700368eaf872fa101dede9162dab2e3bae54a172230114d381a120ea4406337bfe28c137bee7e706d33388d1bb1ff55d3c57d7609eded270bca475ba2f9af6754a77d98f836e5bca17029f095c33efe754fe57850cb0740a066720802625eb0cce66e1da1fc6758c6fad550b258be31c734ff490ecb37e399f89b4a61f580505c6782f0fceb08b1af5c920c81914fb194efa091fc866dfe2532ad918f74ace4499f35f482abf9c62e031852f7ef79a6161bd86f0d4fbeb7aee0ad04b2bafe361a144b42dc94a50f30bb020b8f457dd1bf2868fe848c42b927a4e54850cf413d04eb4a6ccff29152877074a747f214ad8098496587475baa275546c7de824593bffe55e17d850046ca34b65ef398dc7ee10173022b452c3c3aba3bf0e00193d3a702d11c6bf66762e736a3fa180e78b7f8da3b7b139eccd88df6359c88cd4299b3e0ca10c57bbe580c0a0adbf8e328237e012c1e495a8098aa96ed9206062f7939618dd29a0a80b42ae59c882fb290242d7bf7d131d8f4fa28f3c7b37ebfeab132681a8a2c88cecdecb27525110a171e32e581bbb95235a3ebc61e76cafb88abf536bfe3c5d35327ac27a37181d8da1f51dbc127e2824b9fb4447d2815c1c414f2de76ad9a199b82b7d5c934872e341d4a2e9f7886a8bc536e9e79c3998b6411a5014ddd7f6992a72ea842eee4f615a985069fd6e472319b0cd3c505af6c210b6fe81b34e85ab0fb0ebb17cd3dd718b88174c93b6c5a9786a271b8924ab95f71a8f35b09799c3498f9c59b1d43726e2e1004564f4ce14d7b36788ccae6e25273cc007e4cb59f8e925c59dd305f37a43be199d7869c3ebfe0f6d913900f81cd271ba62fca8e4dded7df0b4977ad6abdc3711c777461007d0849f39cfbc0e206d2ef235e929eda937d7402de46d7d3a8fcc010635fbdef83a0a6cc1fa6d9e54aa0e5f17a03e4b6d49aa9172c01f7587c14dda63f64bf16c4641ea72104fe4d9f91d7d87a4021f5e0ab634e4327e70dd632acf3e3e4da7193ff20d5a69771ac99a434923c763940f35cac6391ff8f88c741e178884edd02b84e69ec37e6fbf5e7a5a107298a2293f8c81438c553716be35d6c88dfedfce756d4dfdd08e88fdea7ff4fcfc2ab800a12bf8107d4f86c99a91b3ed409d3a7194c9ff22de7e4bf326b974439f4a6fd31ddc4c601d4f48933f3cd2952a79e449dafcbf70553e72f368e21735943c18a2b28ff383884f5b08025c2e9efce38bacab184abdb1d6f7688d1456d40f1eff2b55348f3b2b13546bf6410c9e400c827b0a87ab388167b8bee0d132a7632046cdd55569ad2aa27be1cee8f18e23f413567d59ec9172bbed7511ef32ac36eef51b8a77b24cf71fdac678e05df72ab8c8a4210a43e659ee5f388d3b49fad7b90f2798310a8ed21b3290d17008696a29d65aec7962e71652fc73c7b0fdb642339f894f9269738dc08e9b57106dedbf863154874f6c9ad622a837e06a9ae137e0f6a68e6764df34a77c34cde04095004c0aaf34b362dc52c70683e5b58ddeb5d376ff50caecb5a93b8442e8189e827b0332509305179d8a01049bc1c5b483062b537f9c00b0474d8035b58d881ba7fdb3179363db3d9e858abc1a05458452221c30829ea5daf442bde8f0dffa23385cdc9264bab0dd02763fd2ba50c4085b7c2020079906481414d194945ac5188a54f0e90164ee573f9465670b1da3f3afcfd4a3038c9c311f6a063e50979d4b36e4548d270031e8bd724368311d520145e8c30ee6870359bf637a18ba4889f88ecad4f23e0e87cf365a8bf0fd1462aca4a08ac0fe370068892d44e99b143658285b424be53c957c52e198a2b56559e296631e997ab208c78494a8a61ec9e1f49ae2594251af410ce44293077929f45529c86c418e147954ec3a153a0001202c1c6395f31bf2818ce9040b617085183b9c4233492dcb525cca4ce85d2893c3c02d449bc1d6b557ecb44fe69f9bd96c144c0dbb534cb9d2faba34c2ce559993a05464c3f47337086a35e4445b28d444967116f3a5d240142dcbab1342728114785b1ccdeeb1eac4d8bdf4f5a207c61e0dca255f72da8c06e120de2f0139b30688bd5e34cd69b9889e30b8fee9a2664063db0f15e7d701194a24a38b9c1f7b9d2a267296daab44463b1afa544f083eba4c954cdd55c721c5f409fabba38e89c6de6ea877bf08d0d19e875b05abbcb059995133cc694456673fa80f1cb3816eb0239f3f134069474da3ec63c7440b2b82e87b16425e0b9604555cdb955c09f9a6b554212e4ce16da0b3d207a9c3613c9da6c90fd4cf90cc769c3830bcd0091edeb75c3b445fcb087effaea13ee40b51cbd1b1ba3c902b6a2d9000734aac06ec9836c8b4caccbee1365cbc396af0ca15d733184c2bbd6474f2b3daf507e30b402a8b126b2e91b8ce6b41feea63ee711b7b45b6cee7299d710d6cd20ab988efb3389ccacab521ff33506d6849d8cecfe44b99aa3a17cd067e1fc00728aab47e494838f837dcbcf579686d6af5cad119d7523566a136ff648e045bc2b30bc9342b1d00e1493a2cf8b2332c0934079b7d47001366e6dde90542b11840e20b14fc86ebed6a655e19124a5739ee31823633cc7a122550c79c48ad55da818c8d53c8f1a2e653614f0a4efa4c50f677b6411125d67d0108a24b9f124e321cb175a45f7691a32328c0e4b7eee3994d2b8fafe5f584c261473a093f9d256bb934c513b7813123c9f467979f8082454f199f5d6f139d731d235dafb9c020dd997fe21e908d0f07e7de0e6f717d48cd7f12027be99dd90045d7959feb32fd665e74fa5120ab45f59ba6575f68aeb092925db63eafc8762974d561b760d50d56c5bbeb8d899a0cf1184d2c4b6cd20f2a3f72d36f9a3ed6d44377c9b0b488e9e6fa62501e8621a27799a150782b0d439624e450a7422194541cb0821642727512dbd61b4f7952044e7242e0229be5e44e6832b992d8321a212147c89840df90c58208ec929cccefc21cb324fab41c97c58406a63b9638af124b633791c3ff1fd6e006217f5c8225f67157b68ed093a39fbba55d10bc47073868024f692bde3eee618d6e261816213d2ea5b092492da8c9864f08a6d9f6166bef810298dd7cb849dc2aba15cf06ae83e3fb328ebe16d81b1a056bf7fa2292fc92b0a98de72a1470e1de7c632b2d838abee81e576178a4551e7553bb979b3403d5e9cff6a8360ea4c913cf60b81adced693037ac5879cb910a110c6072a11bf78aabd115c8dc5389895cb69ae09242e66eb4fb60249518c0d18aebd9836c267138810f0d694ae032b5ad6a15e4812e80db88fd20a3c2bba344aa132de1a9878eb449782fe3170e176dd144b0c068fd0d0a6ae93d848340cce16167926e3d82794fced5fea0ebdcdae406fa7df213121fe8f907b32be6d3bce926af5d649da14b0f5667d9a03a44a62717186d82b0a27ddbd283edf9c09b6ab842f35e8989cc73ebe36116c676c75825fb99b00acfa1bf677e7609bce6ac0e6749c4587d360c07dd787b08603a08c0ad695b7b2afa7d6e1f8295dafc508acef07c80421b2cb78037d0be52d29230f9ec8e080dcc295d408a38a0051ad232277fe45b1c7e89a69d19b6e5e03c81884a39c6486155bd0b61ba28c3d08cb9f9b09838fa6aa6aa50e66d550a48bbb90213dc5c68f901a1859a5c5221c753d269a1f451a2480f171ab829644b1642891cc6f9f09fbc972b238bad842c0fb67a7d088ef783df41e7ebe532ec9107c40c2e535b12b6b39950bcf1ee8ebe64ba4284d60efe28ea1ecbb944469c0dfa61cfda2aaff2ee68614d59536387569303b7e0a4429a7a3af78d7c6223e1c9f8c5e24d3ee86d2e90511a9e2cb8f1c43ee035a29ad66b19c24bad987f67e82c1a781dad4636e2309a5c2bee8a65ba188d36859a04af764b2432c1ed44e3ac8c69dbeb36c6aa544ff0c5ada2f29600bc7d946bcc3c0ee140661d5a8a8759a46a405b10dd1cd23d03244b0297f5eff710dc97d6b466fa4c6549e21ac1dc339941785b87b6b8e60ddb63a23ba12b14a9a9b8bc4931a280c124d4c23822127d08977af5dbaf68026915ed1ec026783b6c72c830f4ed2ef13cbb91af57c9dc8cb676db84b42db829398eba3d53fcd69170be073fd0e607353a8368ecc7c7ee10491cdab329ca33457e218095347ef7cb60545f446aadd3a5d1f26e2d8095efd848bfb417b6c4d8e6d1cd0d88e6af2e7a0e1b98bccc3665c81b1a42b2c64910e717f4f6e07714caa067dc669a14759447b1b61707b48ade0c7bc364f08d2efd458933b09ef4b2b14be10f644cf7b0d7c1701ad8f71b72e96db743f761132b3f0357cac9ef7599532791a39a4858de3cd669b028590d8b8c78bc9c64d143143775c3febbd58e75a0f0647a93da42e7b00ff8bdc07ea8d624373bf128d9ea6a0f5f5f971075ebbfba8059fd1f574013674040c1147f2e178fb362b3639facf10691e5364fcc4391dced64dbb09b921ff821c73144513a006ddd401c79f1d608c9606e74efa729fbbec8b9bb3f4bfd4dbd23b9e7e994b48a5f69545bbb8fb6fd5b631a7579404d4fbe07387dc661a1d3c3d30f21c5fcb57900ffa5db5256c42fae4ca7d30f8e1939fcb8231b3738dc06a2e3eddcf545660f974b0159c3aeba022a7658b9c156982969327f817c61f248b271da0e49b1e1d54e115284e121f0639a2054e6a7398ef255dff0c45f4bc2424edc26703d82e5a9db14483b788c070ec83092577ca82ae7b7da375f0e63512f56b399dd8659f28aeb5cc29dda0e5b44b641eebbdb8f3a8098b3ec98fe4a92dffb3eb835aa5d157198af4d9631a585cdef60a89295e1f5c9a21ddb59413a35aafcf734a88b65bf621bf39c81452264196dd93622c1302cdcab1bb76cd66693a536e882edcaaf1929cfbe21be3399798fe6462a5a6a20ea73dfb9f59e838df8a1ba25e144c73fa27de1c2a2b70b36d3f66a51ef8a606677c7463753dd18f25417b70ce024e7c01eae4d40590a309edf250554309ee156dcbbd0e7ba3845fd4c880ff9e01ff6ef9e3d547eb01cb7fec164b525a694b4bac30fcb2f7fdcf1b2466bd56f391b63340d652bcd6b08ccd1f8b75efad3890c6c3ed5b4a9b6358a45fcff93cd3f309b50ee0ab66e3bc01e8e5a8119f0be6409be2c9bf81db20c018cfead696e6fa5f6eb0088cd693a795d97c16f62d2986a285693e28b3f5dff122a366d420f94817b05761e73e4c2f1f70a6054b96680d10670071d32f19e4beebd0d80873a2a9c900caa57d33a6808daee9ce6ac8f27ce9b016fff010b692f2b6421256fcd7872e40de4242fe59683500a955f0d2c67db713cdf79ac36f055b876475cd209b3441639932441955e0c9258a1cee97a8d90a1f2c8a9505f448168199b184d7e0cf29c6fe0dfe70b52fa53715a456494b522a08c969e188dd4e534c4f8eff62686bda23508572e6f3db9e9a045ac1eae506edc1895d9d658c2131ab5b4e7279c6c4e8d5344a742a4fb1f54cf9f9d131b525a591416b4674ba2392b45c17b87a5534d293e211ef8fffdf1a1d9a174d7eabbab580a2563de17ef1902e8573de04e1b3e881c34b92a55ead4c784100829e2b8cd403d8da8d40314d022b977bdf5a35d8f8f14c43fb42e81e2f7b318ec3827a03b1a002b3a166505b21657649879097b9fd4fe1467570b73ae9b0453a786b66ddcda89748225cb8e3c0ffc1a3d0b1ffb4681aa84cc93b6e81ddd46a639cf5eab70a167516cb6e15fb70b3b56e78671e1d430677d2259f640f6e6247d6a80d0e0c56ed34993b9cf5ca0932f33397d353153bdb63c2fe32f1380d0b3f8d3e05589e17a141e37d4e7e856245fb3529a2229e097dad832bca93f427fac6327d85e22898048e0274b6d2dfced9ba7c64ebf9d8c238859e7e2a22c71c0cad17feae733da92cd1d62d379c762628e29781b6db1954b8c8583940b38e12309a1ae107c47914c45d1089defe1bb37ab0fd078748c7d24322cbee4a180eb9a4b0be57f3bbc0df7214ffaa9c0f22e6b6e085291b8087223b77136be7243df991230741918cf42709a09eec1bc293b8483db8efd30aa378767ec0c42ee89465f454df599b4775a6416506b00647a71b8de0691581cc4e2729984d804b3d626dfd8d9a9a50d0c913e0865a6826284b511dc5c923fdf448eb8470a76a7bbd38264aa739a0c99700c9127a35dfc8abd83034bb5dea2fc7e43534253b16e44df601a0858a1bf66c2d0c5a1018f82b5d0cd95fb51305c1c29afc123574d0e685bfeb0d8276edfc973fc4e61957f68da92acc1f45ffb93c4057abc8eb1981a89cf3d8f5bae99b5dc53faa74c2b6c474d31b2abec06babd0057633b07fc7338eb10ad6b4c2d8bc7a23fe6300cbf1ee9ae99e03526f8c2815b0975e973f2ee7e53d29586ef29e470a24af4ae1a61353cd79151a5c858e1218140d29916137993524b5c87fe5f0d309be4837c9e9b46d1010c5e223bc21e34841aa44807134a94cb4450a817c74cf5751971711f2859b86f7149c815813e80d7c81388d3d6d7fc7fd918d85fbf1493a1a252452cd9c489c4514adb7ed7e9424bda2b98611bce7c2ad6eabc438d2fdd1bb58d8d91ea10bcfa57208e7567660af5448ae19a8239643c1d42e6c26fce4d3095192f867415b71fe18a9613bc1188b9d7d271b8398f32b43588239265904dafebc67aef78b52e1e1d00fbe795167d3c66717ecbd3ef716626f2e352660053e39b3c43857c4dbadef1a56b8640d02485d82d1c3fa27d740526bbb8991dd25e5258307a396a2b2ceb0d91e939ce9a1691ab70a82130158e94f209565a2dffb860610f195e8f7f769f930a4db4acaf5d943b7e55d97e140b70ab8248fd065cd12ae927cfd11583f74155ae1f634c02df3b7a4e3ad0210d07c32e2fbfc4eaaa1b8b74c22147191e2d7fe306a5ead2331078e94fa74ab29ca0bed1a3fdb11efef4418eb88e1249787e987b0225aa3ccf5eee43b587e11b1f2ad607d93dd7da21c5bbccd6c5c57dddf3691c4c07823feab54f8f650da1a407b107193b5767fb81e135af97473f27bf5bad5b6e1aae0ababdfa6f2850ab1d5bb79014e5af88f5ae8e480dc1fa7fe83314545b116f70a7d9365678f87ae09a45e7deeb5ca732589485550412f7ae3a2e746ef3bb4c3157b7ff2aaa6bdd8cdf400d8917cf495a2e9ce959ad47fa3ede04ed244c3f0f4ed74a3d0f8c6c27aa2d757d7a5f88a7a1157bf67437d172870ad7171423f42228a56bc9b497e7c5362ee2e956b34bcaa18983417e2ee66aa10461ac01214585bdf88678062a2aead6027af0d49b6eda06d4cba19d7986585e96ae35d9823af4738f277ac540bc288f09c58645e1e059a8112b1845e8bdd37d85345223236099ad5a4017b7dd3df7b28cbf77412cd09d9c01529ed38e1621c6a3234b7a078df9a877b3688135a7976ce330f0d47055039428f904ba4efdcb410df6bdfa0c28ea45dbf942f61fb300b160f4eb2481e932784db2a7550c8eac38ce21c097d9d0fbf88f898433de46c755870523794e8028dff09745b023943c358e73f17cca338e2a19afaa2b015051d2ce83b602c89570f0ab4d295dd6d8dc29b12072eb9365f609d0ea236f076ac82edc23fda3c1349e5a3c06b149dc93dd5e2f09d0097b40437ac014a6d304846bd6515c7f6c5797ddd23e2394c0f7406d07d43dd7d7f49f549beb17408fcb44e18ece0405f2eeb84ab4f99d83f7f1e2fa4a1f0fc70c0187e18caff7782f26bd11b481660f2d447bcfe46f42c145848b84f255e4e27bbc90511283c8524d549a487e2dbe8788a8fa6d6c35692d9a4d158337783ea1f4309d19ef54e812d2c3afab6155e70508cca5f6624dba39a40bb64d5cce88d52a14fc7a836ab5ce9d66f349791283a029606b2c5cf40e635bdb6891e84551b8b726570bb0d283fd427e8d9e7340e10806e58187afa5efaacbfb382435e6b90d809524535104d2f93aac73427352da22c0eba785f936bc434fb8f24f3b8b6b03dad89597b4ac7ba8d154f8d9dbe55b8a021ddf4008aebea026ad905615992367ac66f495a3ebaac3bc9159f4eccd9a45cb88fc18e0e23660ed50ed7d434d07d2414bdca22c67fa5b4cd163e6ab2ea52003abafcd66a18fe78f33ad6567b438b6ce22d793e72473936c6f1320632402d9ec9e037ec2a93e624fa20e93281fbd3c9e174bd50587ec9dd7ad3f589cacc7190e2bcb4f8d077c57d8903aca973bd9f7397382a030628062869c415a5ce4d25f21b6fe646d350f853007e95bfa6f6e7316a5909eff3a8b168bbed89d3221a2890d05f6577443f984c563f70f4142618d9fc4780e1db5efae799ab4720ea1e8fbdf351044d9c27583715a57e6601f702863231f988bb5915c3b3c1abdc6bfe5fb7f2132c230323e35e68adf159a6b3ccd1cbd78f9581952008e1034e09d4c7239b9e9e6c22e43cdfb3d00079a2ad2013b36f977f75a9ac998445f7b80782cbf984c853b1720c50575488399bd765b0b4139fd63294645e49c5fcf146daf4ddb7759b4516404eb51182c8653256e275a92b49373cdd05c0a694d81d113a44323d51e2626ef4f2d3866f672268248c82a47914cf3e806d551cc857ae88c28bfa5d9c83ed08e36e07cd160ca6970ab872a0b794899ddaedc9d69dddbff9dca3a4af60ad04a51d46aed1f09891b5feac67c3f1fbe898a7c5220edb2cdc57bca03f58a8991793a94a546cb70ca7bf963566c962dc29c218057b8af52765f1fc3b7cf10a95e55d59bb357e226836674c4f77100eeb845c8efd196d80f7ebccc42009efa041b7d27d3d0c04d30853b3683bf76d5fac8e9f93a27303c028e35f8270ae72d5c3bf6f37947ed8584b6f222e398dc7acafe5e95165e2b675b5d7fe54fc13c7cc53ca7fefcc9fa0e2ec83e461d98390a27765fea91b4ca165c341ad23d94e2cbace19c3c27a62c8666f2ecbd211aa78ff372e0fabd6fe61085d8bbf0d5175ee74a17803d2195c3c71b05afc6afe9630b43b6c356cd34065729306bd4d80c28fd99989de84de26a3657341e4c895e7e0c4eafc84fee5b819af53dc8a10d037de5331f2d22b11b80e126593efa74e50f156aac0bce066102a3a388586dc5ab084b6bbd21ca7d088f7e54ac49f2792df89ba64d5ddbba125f259de87ea1a5bbacd94a23959f3e673725493afda3e33ccf3a39e5966230d4ac05d474a6d6749297cadb1ca223122c8af837bb7f5b01288aaf0194041a2ae8258315d52a4970074435944f756bdd98078055f2685c6b1130784c596c7c0f9e898eeb2e8f19b3773fe2f18d6d0157b57b5888517294d955ccfe241cf35dec98a39aaf91def454806a7cf8cf1cf440efc1d8abafb2fe57d82967d579807989cc6c67dea990c2e0a9cf941773edef636b635754a62537b3bc6d2b60d4eb89847a04ee2c4d678dcb2a2d45ac935022be7ba20504e34d7eb1acff5371843b8466d3005bdd4b131cdb0911d31e7563b34f142104dab954822c6b02c38426d50cde1ee9a5f76d1540529f068ef6909dc0536bbf3a6ba0ce6ae4353a2211b35ed1be9d4e1fef83ca7ced069623ee40b91c7090c27c9ec5da0fd75814a993e3fde69a07627a04e9c7a8fcc9bad54d2963e1cd467a82a9e1a80736289f4951e8cbcf826936a6b95b10e8fe064194d724d8331e93df3d586d0d937e863abb03d7a0bfb3d01edc0f37ebba4678377862f3967636d92e35f448490e0eb3009f4e52ba5794cc651104aaf9553a50a111d1befcaf4844a75b062eac43aeba179edeb9faa0cbe37a418f3164a73c5bcd3b64e8732b090c511d937dca31284ab6d5a328fda267b883361bcde88336b9a220ccf3c30419f571ff9df026bdd4179f353e70a05f2781e360bd9c4b316671fe7067413c7e790d79990e4f672512a1e5c9e16db07dbd198f5c091683d5744aa8db6c8d771f6ab41793be688ad1d1135a6133feb5d6976af4ad0fdcaec04e9f28581ee90a446ccfbe9639cc014565f546b5d7af09e510ae32cab087ae081435a693b8678dccd3de87cc7a39f7c5a21c55ec7e577b5471b27089271b9d6590f1cbb4813075285d65addaa0edd4aa3fd5f6f1de58417fa4a6de95360dca8dce94916a5aa4df3954cd6d4824b8371a7baa2e36d5abe7cbae5506642836635e35c143de9652aaab9fb4934ce8a883da2f1a54e94bc727d03d65ea20a07b4953d2fccbb38343a3d2e1f5a132477998de77c12170e7ef1eb2e17bfa7d6540c4706cb406ee291d3fecdbcad84e4cb5e115e351e652d312257054eed7de0fd2e57a36b40056fd1f70b3d6c6f6715d4290bc6bcad3eaf0f9ced4f92878954565a5f65c722d0614089e85edf02c2b310a3144ad00c10441a5c8136f2d7d3fe5860f41cd20877f03b072f79a3a4d12efc205a9defd55c5a1ae4bdf6d9583ac6ffc12c89486caebf4403988bc52e59cb62cc413f06a59b82437d6a4cdb877e1812362796486400a74aa08adc091acc6eee6c2dab0c8ae01dfe308251441071fb1a628c9835fc4a1594bb092c4b8a0fc0bb0259841243715aa356ff6c1e9f60e21818d2dff01acd177f63b22edf754a9a08348808eb1abbcf9bac2f67e098d4cd97ff2d9e879e8f50d1f9a3958bbb1dd3c20f101c925718d6ac0ea58c7a9bee821a01676a760a5a40aabe85b3d224e84ea531c1363e50bf0a4fab87d87ea67a0372d90ead53197b28b2629ce5f234c1c9a3aeb8631bcbccf8fc1ca477caf788dfc531cab6d00a8e147ff99fb959bdae76dc257f143b4996fc8418778ad63a15839071ed68645225353c767d8f7d7ac2ecd8ae439aafe52f0ce1f5d98a3e89803199aad5b3c69582dda0bef3330f258f25286f30726fca7e3712ddace31228daed18754244817b300b85354dfbb3f7dc016df40c1470ae637afddf01cfa5a443dbbeea537e69c8b5df2a6477e1b1f761b0de88774a3c7797b242c0212351779ee6679407a83750f0cdca059f962fd62a5f3cc6f54a835664c4345df9c775bf3d3f5fd292c7f66335b318aba874c7f037d4213f916ad959ce345d0ad40b65c39e09e0e32779deecfe1760afc5a00994d1aa11dc8c15fd238500d3824e700976863595ee921b460642d33b88428d55bd0aabe9a8d02dd83bcfbb46c109ef5665e91dd74098349dfdfada9db8f4f6b1b2492c86ed302e7a9e4b9b500c2a5216117d3ab1cffe3929ebbd56a57bfcfad556352fe99d521f4f570b40bff03b1ba76f90758a678a08246bfb7a637b27b82114c12aa08ec9123ed0c612d4010f967d81bd63d2b6d84ed887d82308840afd3f7b79080091695e433bd12dc7ca26ef8d9750ee29bc6bd600b39ef81581033095227884132dbb79b610cd4f9196c2cc92a517a77bd2079c8992c3238c2a7a939904a810c2d152a04416f6b3cec44ab145407acdd8410e6507b6a187a2166674acc1ed9e02e5e6c2ccde14882c3feeecbbb319cbab77854e2cda5c74a6aa787203545109557dd7c71bb92cc32d35468b184d46f2ee28479f12e06ef88dd512b12da311d1938e14b1b478a886fb5f1f1150483991b8984ab8953a5d5a2201e1bb1bbacf4f2a5d2ee928630c45d87bd7ff61de92d1d250a6b30bb0ac1936f03ec316839c19f58355aeb1e99f1b166b355bf0fec32ae6ab1ebc02ba692818bd9892af836db76cdfb1d5af4ed82c3408eda2971f98e460032ef53af3a7342832545a8b3f2146a503aade9b0b81a81ad5762246f1c2c6f27c9b5992fe798b74940c2365bf739756ed3261f6029693d7fa2a5435e23860c70945f8f5831b3ee1bd9960ff6e50ba13a7b4a7bc30674fc037c51c8cae6d26b73f901d8b79bc7c89ad3306992f5def8bb0845c65fc00e8513b787cd416bc37a21ec4176c9ef24f37a73105c5e718f99f731780a86cc9cf863da1fcd999f6865c6de69f4045bd6ea43496bdc16f0921136cdaea28b3ced0c095310616ba36443abef84c6ce72fc1f5ac3afdb57197f8f2d55d397e0e044f1bb56bb83b4cc8ba0a6e8af3d2a6bec05e6e5ec3de8d34cb21082069590aa435c86bebc04545a6869807881c0f22633617e81a77c8cbda85bd8e10985b452f5910d7918f2f8f546698a1e65d708ec0be0ff5ab711228968dc5e8c3cea5ebe2fda2c931c89a6c79c94b83c588d4da199573b54cdad6c976d0eb6a883615e216497728fb0e04ea4040ad22b7bc77900970289b035e05f5ee140e8da6b9329eb530d21dd3b1a5dbcd52c81d910b7f75da2da838fe84f08800a79d6d8a412c1d53c431d0e324addd593e73b6c55b56f86fa29f4ebb31d991122debccd6f909c8d68d90d53bb86cb973970f5247355384066750a67712cec33dea2c1befc34c1b614c4ba3c20d2bcfcc8565f18abb261a6a3fca37328cbdd9cb59fdf296369c905cef545e8158aee637915cfa4f8ac197daccc60bbbe5b33bad4c668bb5725ce4b4c9425df31de0a329fae542dc57a6e837fc0719861ab43408ef5da51c2b5bfc25aa237120e146db785a53b501a7986597a1a93e2bc43def6ef4643fef45d20a95fb109df4673ff47bdc603073e8cb1ace615f29d72026df3d37394983a071ee063cce3cd73c1786879d337482fd2ec8b5d17c76b05f819fd674080c1da6cf1bb04151cb28f661969272b2298561642f0f0535679bdee15cbb00a919b23dd4654cab1fd68f5491b5d7ee3a0db38ee63b1be56c13767578c7a115bac51a67cefe3b827df83274c1449d7750040dd1eb6fbf07bccfea0784958f66bb3dead6cc1d6ae0cd84a4b41ecef6921f534a6419d306285c0e0d48d65df2f68e8e9a448f21e83ec8ec69f44538bae18efd9cfeef731304e839e9c211f492840419a9fdc3133075ef769ab44728e412949fc781b4fe2de22af842a1b1aa6e2cdba161c7bebede64e04d324c715c4d08bc9bc41aa8eaa8c7195068cf3f23bafec197247501581865d4d45e3ca89e178584432101985c20c49ff6d7e5baac237398e0e4e0bc91413dd5b4a087ffd23bf8fdf3744c456ba5b1184af64c94fc73469f0f4bda4bb8ed0ded60f6ead3faca3c355f0295672d1b715ad49b3aa613d5ce79512ca35526b727b78d6e14c901c7ba26cedb48cadedf502048d04d0ec35a2f19562ce0b48227e52a6c7933b2bda3c841c83d4afb9671d959e9072ed381ce2806043eca1717e277376b79901efbfd75a1d8cc9f72f9a0f8c2626ef5349cb86c932cb8eaa50b66ec2ee57a44e2a436d3519b2f71eb036e27650deb11e658b7eecafbac01107f10ec2548f7e0f069b1a6105ec3838265c9fd31cf96021b369f4ba23e77d876df150b7d5e0eafabc8f833c8d46a854fa63f95670a9ffde58d53fa6ae2d087dca008d989f3c0a84a9e3adaeef3540b1284dd8827e496b6fc664f5cd38d9e982fc47e86ff641f02422c3135f37c103730f5c75af5a7a060c672dfde6d4a7ecd089cf6f72ad1a09a7e9757c12fc22bed1018104e435850df466dd79785158e2dea011f0fc0e419059ebce4f251fc2c912cab426facd2c9507cc1d996cf293961e0db0a5f581a55a04644032371f65a6d90a8b7f82472abf32570da1fb3cada199a048d0f7b85536ce0ab0f92e46fded9a23b0c1620e192fa42a5b8e60e350ae4999afedf00666bbfe6bd1a845cca268dc1e479985ccc4a67df8de42769977a2975c734609e661de3a098105452b75dfb2300fadc7d97a206c70d7c907010f889b789fdfd2fa7c7ebb13f1017fa3ceae61ffb5ddc8997310edba5797f54f05c61f71617cc123db6f41b55d9bda2eeaf8d36706cbfc0c548bf992ee8d91f8bacec19ff48f10f2fba75205657cc7f5042e3190e147c6f0c40d9373bfb8026015394bef77cb37db584718a4f6ae5fb5eef8dcc5f87c0bbf9729d08d058248fc88a65bbe8cc1b00ed97253d3f5996d193f8caa4a0129a1864a134ccfc89b64ac5d81849df1f3ddbe7671130e21482d5f262950cd4ecbf040f01620def6e3d03e9834ddbcccea47144493922162056636926327c5f5b39935b73f9b9225ce6c760f4af6bc984887d1333213dc6b209611466305bb275ace51b9a43724b3cd786b5722e6ea8ac836c228dba880937313f5203208e4af4bf95f51f54de7c20e2cdb0de2ddca4f16e0d46ed13f71c277fcdfb9fdc442d86fc0420914236734f3b87c59774f8425fdf879c42ba0c7e9f43d744285fc536884bce757a86bdbe8303f848fe0f3942f23f59f0bbcb4ac3cfac3e7d93c484f93090c52b1809030c5e1b08f0b0c89eec5d4f9dd18eb817e8211426fc2044e6b57d57a77956e8ed0e9b05d56acb06c266af4dfbf5d89cc6841ef7d631d1c4f4ab0463c774e9b1b86869fe7743d2c36719460efa6243b940091e1240e96e6f95f6b37dc46594f9c88bc6605d4db0b24e11ec43d10c0cdbcba3f81302857d504a5023b08ec38508b5051a439754fac8dd0585964831fd5a3d2752b3267dd8272e17dd83d51cb3164b78734f5a2d5d50d0166b6ff884ebc8c3c2100672169c7499a20ab180c736223833d072e5744c0c477604d5c5abe8c46ff0f12e8d54a7888eef6d4f6b45f359e1ed093f95ef18a271fb5dc2e0f7b72043ccb381180d1c620eb215b6231e284b062898a5792c0839f3225243559f7fa1fe61826cb25a41927fcfd94b63cda2fa1c547b1e79fed29d730d928b5b9d797c43d60b28822ab6ba526274cdb4c9f97222b1b538771e451b18bec725db30cab16108d2309af1b41266e41cd638f942563ac7932ee4e6e4f1f395820a077727171a8fa6bca47324cb4bb0e70670ae9f87955f09f5e6e015aad15e5fb5d824f932935b9c99feb3e2ac28c23919818376efff9273a54ee40c39e3af45ca90015a72d3908197d4148e46051e15e6dfd2cb075e6455637eb1073068d6d03fb62e6388cce8b7e933066f4c2e3eb864b45b647c2368683a1ac3d9ae0aeff1476106b7cbcf9cfaae98e7b340a9f655162008e031c445858eb38a1701aa922a43da0a8ddf6bf8dd96fc26e6f87e66ca7bb50adb4dced42f880d1c5e75ce0ba0cac9cace9fe8c4f4cfa8b522097089bb8e17924a2f24919999ad7ce576959d4bcc2a34e75b6095743031d6c33e82e814e02ae5e0a18db0ce9af0d6119a1aa0b4bbe61251c7fb4022c92d78f4e1c82797949d3fef1114f733c20b6b4c9eef53895735924d478dad56067dfd2926fd535a722df67ce67df8a20cd737f7366519be84c929b006387a1c2a3ffafdacac1a1551438c8f4342eb982f714e9d1f367358005f4549f8d5de55c597165356de70ad0f40c353c07ac6f1c02440f3c0e839982842e3d8943674f4fea25ff753676df93e8fcc66ab6c3122a51b088265f7dbaacd1daba67c9756570c347bbd51faac41585337c393015cd460a51f05f7d666fc19ce065e98a3f1092999c3b1154015d332a96aaa6e4aebeec14fab57d6f184ff35040781a431b29e94ad18888ca8abdbd9b9c7e36dfd3a000a7801e02379b673895f77231eac02ae7153a586d4916533f3cade28ffce05ebb3891511920ef40948553e3be54f6429a957806e78010b454f15202dd881a0646ac0b8f6eeccc20872adffd60b84739093a04ff466d42550c397bf5d26d9f7374b9339fb0262b0d992fbd39ee101b889a25958fc2064572d1247184aabb8519dfe0a940de6d34c67a9586c2a0f50fe3b1d001133ba7d9ea9626b03f434d0c64a8cfae4a37d22fb9db62e38ef2a07b3c3017ad62ab3925dcf8e4361785516fcdeb25b350011556b69dced0b54dbbf270002c584b6495b7f4531ac035c3dccfb8b138e55ce560675ca73082cd36d856690f667174cf1b097b03b9f990c371ba6eddcb87684f2c2646fc08221e9706679ed9b0427c51105ae2f135c188a6df0b409bdefa2a3457c44f0d7ec0679da432ef1e46d825ba7988eee77f0363fad827060d495c83acde70c7d3ae854a386aa67fe07df65bb42a0128ab68ab6f8f38970daa25f7f12fa007579a47e0b2d23f8ef8f5135cb91c40cf8e2e716a9285e576cba1f316b12b2b7bfcf16ac1ecfe1acb8216bf92bd5ec77c4d05fbf25977e687a394e026e128566c6de144d1b271f5cd90b94798d528032cac4b7f4ddc3e38e900c182a7d4c0dce350adc1f45bd210242643dcf7145f266be9f418cf1ca27bdeda072bd39e36da8ded0ead1bdcf49d3d4fb766c6e0974c86651b3c89218229edcf1c84ce2e0e974c71836505f61534177e54d68f820f25fd136bdf75386f75f34ac7e5be2faf666b19670ed23cd45f49c3859b0f2b52d02fc394184625f63dbb78e478de31d10cd6c9519183ed2a4ac3f7836ce4161c42a180b01b0f9c112c01b2e0327bf5ff0109fd59ce08373331ec64b6514be5d433c64c99e8f94bbc30fd30b9510a36ed56a79add691ef00e3971b55883493cdcf71c84b7981ede3ebfe5c142e954a134bbaae371d04e0aaedff698a13ade5c4eb8fe257abcb4aa2873033ac889312efd2c71e786256561a5af060104febc52fcfe4c4156a3b41f21368f90c1790c99b41841d7a2d3a1e58073af23ee9e9d24b3de3ee65c76339d8fe8d10abfafd64839afb065ae776e8cd648d0ba2de4ab4ea7020140a360ea2744835c4fcc56459139d84e180f51f0e8cd5969a14330a844c9f22de221b0aa18b135d9707eb399e8fb6ae253c84d25a89328118e90b45f1d6856a453ab891af0b1017ed15d338d4f6294f1a0c5fbac0d090e12bdbe0c511bf4a7fe5bc087f9034c49ce2231587c23c71d9b1b3c824d071e83ff2acdfd0b3c8d89021c2db7b7398cbc534bd3aade61f79c68863c1f481a55203430d00f2262ba16a526975d27157ed137d380ae3fb79ee3e4ed6cb1153f9034749c3a21444776fe4bb7e92940ecf5bc587471510b68f471dc0ef5a98e9ab0b6ad32156f585c2769caa545fb431a9e9e82ee415efb8757a3e52659e424247de2b458cbbab269fd33c96109c59c55be449a001eca3bb3e1044a7e86084ae5be025648806f16cb9c98b704bc6bddab80e6d218eee771fc1671c3d28892121ec874e71e8d9ea05fd3810a7b6877d44e04fa53b4119ff9f4c7cd4770ef1c783752deab1f878d0f846e9d0eda08f03f07bff18827e0e7812d3c915348250449c72b950a92399bcab2a73a38ef874d4fb8311f27fd742d7372af89203fd51c7d7d6935f582bf82db1f493f64840cef700fe7629508490ccafcbcb08246075a3b88c404316ad8fa97de106e053d7a0876e22cbba83055cf11b70c81609f1c9ab93d52475969c05fd70f26555d104e074474434a59837bf32cd7b8b50022fda7d97dcae46fc58fe29081e4dc77ec5b18d5e593ade590af514784d8f0d2662511e5189c9ea353f669bd1fe253e763e866d8b06d111ae32d584131d8866a07d162c66336ccb778827c595f91824584d80898019c3bb622a0c7cf6745c62c96938a135c59a5635189ce4a9eb74f18d385ab28f5ff88d52e619936521db6f54583865d9c3734571fdbb03a858dd6cb3b1f4640365e51485f4c398e04b2db6b99651332221f2f1e51607668a32b9d585cf0e0810663502a06aa3ff73a55f644cfa399939d99a5f60f89ab6960ac45ec8151ab6c35fafdea6c89e7d2eea793f2f0618f82ed0d262329a87b6f8993d09beb5debb9e6af410dc462d02572e63bfc92b354526a571735d3038a0bcbd1a657dbe5c803a121b5cc74d5fffb17ae9a33834b0f432d63cabba9651d1fa400101520652f2e09f5f9c48487c9675074b64c667dfe2764bf33a0c51cfa0b839f1f08fcd4407c22e39fb6a3c4ab96611e7eb7d50c3ba09a9c3ce8d743b382c12947f1687f20a39cf8968912141df57ded2001d2014111b0c930d14c8fb57428dd8bb745552f372b7280c2c8ea7f4eac98d0c346d8803d4ed2fd5d192a66befd027081bf66587f8a71405a6f588558bbc3df5451c6e8147af027f2ca3610aee9670892be7c02054d0690eae57334851249bd41767b14d452de092ec394ed98033f3dc691222ccb23311f2706f3ee60e3685eae4729aaa10e83a9da81e85e6cb6c0dd941deff72ad0150c1cbd857d8176f9042e4ff3e6731b04980b84175602e11399a996404a41afcf7aca4f621f59d7162a969dd9603a96cbbd526bae9a8df92f5a941b5d110dca80c9cb6ca27fd095c169e4a57eecd60c64b98ee18ad97e7bc9425615fdd40ea6d6591cf5d2b030a333e91400d0c2d588ad4933ff38490dfdd99c280a5881f7daa25cec67948e3aa492578484dd250576c66a845eb4a0c4ece081fcc093b6bba6135c1c268d4d3460b7705dce06fa62ff82474290cf4a391ba77b332bfab645345e08394045729e511d0dae193ae0079237d0eb10160af79b8bc5ad698b1057f74e6afa3d4704e01f1417fa70464a2cf6ab1c904baeca2b5acde2cc42105122a5e3a74e4ba8b24c2a3de73f88cf10502270c439c7e625646d01f80b26d303c7daf7d8617a29979683d6c2bc7b8b573d3d8b9b5a10b132962364ba4ff8f156859f7b93a750ec5f8278da9b9a5b7eb1fd9fbadf4d0a0c98b69b8b4fa5779b539429e373084ed3717260ad362219604e42ea2cd3aecbf47529ce74e884f15af989a42881848423cb805d38bdf417693f291c23727290db5d6ce1107ff971ebb1911891c6e8ad4204f41305fa499a3e0a455c248e5cd806421b852ad70132d87580741a2e5a6a69fd23beae3f81d5184b650e2c59eca026bb723c2d80303b686f9a5d1574b0126c110dd51dacd34c5b41faa8bdf67a1419618aa8ecd481e779d0b6b4868b66db834728a18e53567f708369a1af1633f22141b20b60024114805e700256bf6f3513cce9edad0f465a5d6bc935e9e5f88607d7e4d0ecca028ff4179040cd19ca4debad7c01627f1cfb12b9c806280366d2a1605f998a0c8e1b601d58b2f6f35abaecba62e7e0fca12192dc64901da157b604a81f8993076b5274bca068acb4cd67c65618dc28e413503f5c0592a24315707eca8a593b36ab479d5de3b5e839d2d2bde8f796f4eab1a16d001ac06d2cf14e7c5c9cb1bd80d251231e9dff00ab98686c7c58e1c928f37e2ee0fd1d686670c3f79b72b163fa46a86b869a620af62f1921d07768933231d3f963f2497865193125572d91a8690319f9115bafdd146f71d634d79e10985e0c4d48475479f0de85e20ac9472a5c3a6c2e9c7e3d36d43649d6eb41ddb3312f99f282ab7a76bb41e2b7344571b9da43b3ed96fd16be593903f5f3713e73b0c9e33d711b8e1baa7737184e785791a998426bbc645ae66a68c1c653f6b195dc0c3d7de6cb5fdf3475f65806e360764a7805b1cab26aacf204737423a39b0c6d8f5c477a79211e90db7b9dfdd56b6d23a261ae16fcc90fd0f5675664cea4cbe6871533e62952fff32cafafd9b25b1d34cfcacfc2a3afee2c62761c6580595d8a56b59369295040d3912903d4d27cc805b212e68273c415dae819b12c9658dafac3e0abcbc65d47f95c8a3466740ac6753f611800d38fb6eabbe6b8f191f9e3ba3c8259559483494c19cd79b4ae355c00aa605ae6bcff072cb319bd27ddc3cb824e64d5e2f1876815efc926aa35add58150597bba038d29dc72a691db6d594184726ef08365b449985c7981aace044d0be052dfc3d5b5e04cddbac22f2748f8733f481f208f4980f39d32199c0765c449c8be77eef2277ba34eaa5751cae59c1c935959da6d212d7078fea4c3f8e0427e40c97398aca7e6ee213733d5ede7acc2c9a8a55d1376d000213af1cfd52c70593dce1d36bab8eb551e8969c2be5bc01ff4e55f642ce83d0012ec71791f8ed6fe7a1f9341d5d726dd231b6aea3db185c744afec3190e1173b5c937fdf3f3236f3c491d29c48124a91afa893c3a2cd3234c471eda3c90944827965caa5e5781ffa74101aebde41fe8b6daacccf50ccd52a037c355f8697b6579cba9a86ef240db2c11a7ccf8b116304e6f217a251b8f927fae4c39368b86568d5228802d02586e1a595d14c6af8b6b49dba9bd0dd9f0b1453ebed6d4b5ab6eb925a5ea609c827147c7f542780f8fdf29a70021ee261c8366068d3c911007ea4d8ad1fcc44dffce386ebc66f78d4687d5904f87f1e19f95071a4e6f914d6e0eafae01b08064aaca1f02b692d6a3667adc76cae82ea8771dd8e61fe7748652f190cba991efaf3de6d0e7c85baf8fae299238cc7308963955a8140a10eb2700342de1cd46bd100df5d7c1d40809a6ab1b6fc7f7285abaa863ab19e4629fad0a2c55ccce4933249825605ee8bf96329962ffea1ca5cd5d1833f977621b61b46551127a93c0bbb995fd8eaf7166c3efa8549e4cd05227aeaf5dab9020ba085c8f132afe4d1bbce4d48cad690058a47ded908b7e2272ee16ddfe1118aeafe56d2e29361c08f4445840a399354dc3287b30ca095a2f97cf1a14e526db5f75f208a5349067c38dc5c16bbbe10bc4c15d497cb4386c98d2f9b5f1db860df1c3d79ff7ca023a0872c17dd6bcec824206e049c7ff55657e2198745656923822289c27ce0d9480af6c38853c5749e1d8a324f18665b0bc382e2498b45146a429179d06ad191bf35093597feead1c46242a9cd2e08d74587b62e2b3360e35fd7176b54ba458571817c0657da60830764a2ee386c00d7568bdc3d18524ed2f5bf2ed73b70b365363b18512b5805211399bc6ea3f12e7da065c66f23999bc2f3132f2f412b111bb86e533a1664020d5d2ec8bbb3991d2f0025b9577411e5a0fb502054bdbbad98162862dc52c8386e06897adb38a1742684b9f10b7e3c1f1e73fbb8a39673afeb3c82f834733ebf2129a67fbdde057ad92e1d31be81fb13006d3fbbb33f0a69b45a44e5831f1365cb5ae305b76acb0515200da71d772886617f29ae3ce59269d403c3c81631fa10e6ecb5bb25dc99438310d82338914d0559e945fee292991fbab04ca9072d8319ebfcbd4f26296902354765c179d8f65470de28886061fd241a74afd546150c26f569cc892fb0efdde24258234797f898dde6da2bfa8cbd8377dd642ee3475b51c4dd835aa9c974f3ec035fb5998b0bc10d2e9da8720b4de0597ececd5bd680315d65d33f6e19f170d149836cbdf8375ff6a3a0be22fc3ff9c690e13bf45f16c331b543c09eefa4ac4b0252c8e02d74921e18cb72d6a545bf50b669a349b7e79d92ce0c5d0d444aebc3d77434b69ec3513c29abda14e73cbeb334b4eb52c8a6921dcb155bbce04f22c92d4aaf87f33a2851d6725c05eb0732642d39db84f2fc2886f7b0d1f0e4c4eba987286ef447915d4859eca6eed69b1e82328ad704a9286973da35baee644be72b4b5264915b7455b262c581567f5777cda7a9a0a53a07c857bf2001ecd4088d8438c1d64cb1b3c5eda70ffc1a3943055b151fb1879f86ad64aa7bdaa40ac8ea66d2efe692ccfd672fc24dbd318845fd1a89a040fe015c984efbef6b3c7c3d7772575df1ff25ae6c6f0a762628d50a738c68d80098a3b13c95b0ca712a0ed80cba4ffa8ea10021c42c6a17808666111efc7955436940be3f93607d3afc66e96af1a5c613652bc2cd38e0d5cbc25aeb6419c2aea0811784aa1d6cb96c7d4461e24a5c4bf18949dfdf5f5e4caccddfe8256a5dee79f6490d810093484f644194201d18dd1ab599a7db7acf149bb8aa6ba0dab34c49a8ad925d36b38eb87a89856816f3a65338ae7a43c96158c0e37879941a9a1423523bafffa39805e5a87400ea0824e6086e7eb821a2a38c3137fe67bf8c64b9468f2b043c9c403fba9756ef9f44832ae03e60e704d9ce8f0aeb9dd60fb500fdcbb0ba4a378b0fab0872be2843e7de42e611b304ba42dc9e94930428a6d288e62635c3ff4f7c39244f2144f821a59e31e7512cca384b48b61c87df0a7d3862ea785f5217a99f34be54e88f5b43292d26ac31b6a38c92b1b2a523a94109a1e42d77c784f090bdc5f9c16d62d4b361cbbf8bb27d00e9578c8a017f1d59c54181b487e5ad94293cf627bf063356ffae57d4d90a1d5dbe79c8dfbd4f1db30d5e49f993735d95a30b078c5e15b0b3bf442911ddc19b9d742a0c3a44868d8262c3ee59c1ee378fb87c8328028086dcbea76a9f631b9349bd7fcf3c485ca622090e8d8eb9cc3d941ff7b1d9d131b98eb07c8b6b13384d9c42aec367a51c7d4f1d1d1f8534b77ae5b6c51881d4800287c7b49bf853cde511b4b1073bf9924b7dbb582896281d399aa955ec7f87875de98eb25e7be6ad78b5c8fcf3005010f5eacaf79dad11f6486b63bd9864045257d38c730e8c9ea265b23e466018aa202e06cbe686854a3587319d257c5fc23de5ad1dbbf065f9428284b2acfd5dd987ba8a6be88cb67e9d30b12d3e536d46b51fccd602e6375c1a77ba2951b3524eae02111654c6c5729430a4144934d11978349e6db8f5f317a0122927a9b782ecc40a305f94dd9c737ecc5237dbe05ee898cbebce7fa80d7dbfd3de23e7affb828e999a80d00ecbd8c09784736c2a40526b92e656c4ed62ba74dcc04155ebd3fbcbe5becb9c9ec9f20dbf1370fc4fc0763ef5c707f84307ecb95ade231c71e571848e5cbf473ed15d2a17c3b6369e038d29f2a30cdc55282b44a207e5f5e48265dc96d0cda1a4fab3e0ef74850d8b6a03390c448ee3e08fee7046ccb9c0c947517075f602f1f41c94563b8db5a8ae0b9b43aacdc1c81deeb6c89637ef8d0c9a582e40668dd2a164c2e12964851e432003d1b6acea9623f14d7e25e8238016b9b079185f3fac40021f28032db1ea20fd82ad1805b998afd4e38b72b5060f6524c676d85c5761cf9e5a2c1ed118be179f3c12edde43221b1cd98d5038d90eb21047469bdaa7e9551216ef01a45848010bb7ba7215f289f5cb2f128c100b9c8b91058f3fa5b48de14aae0d5b7ff2e1787272f9df9dc1545a1dd296a54db83b78c82a8bfe9954f217e9fdbc61b8b5fe51aefb523b7a3a6fab01d446b6f3c984aa16a33f55b3ff6d2213a0bfeb2b27ac71cb538c4280f0bded7385babd98db8aee9fb95feef0b9743d534781da2ccd535ae226b002133aa4f96e93dc30ac3c2227f5c5f4a548989510a96ae3cdda5d173a9f3b59b6f3625d81eb4a72364f22497958ef9743f0e00b1db785eb888b2713f3edc2384ccf5b272ea90560f60dd88745eef982c2eac39e35b0cb33164badc164ad65752f0ca5ba15bd4cf58124adb56e43ed9628da8abcaef5743dbfd84b1d23999f98c2e3d24b4b20a90da9957a6431b59c54829d6776bd5532fdf6ad2c46c45e4a1cbc670237f40b49badb40d0aedb0bff586125a0b1f9eeb69b5d5dbd2f22a29d91af111d7628298fc17691a2d6d295b5287ee79abc8b2d39b3a83811272a357772c42aa83dfd9c4514ddcbe27facc1786b94398520e85648ad343f30833f8377d2e772970501336427ec395e8d1ae179cb14366b832434b332c71365dd4fd20403dbc0c563b8619e1c06fd464503e2c01f6044c5c43262a16f226ec9ffb4f00f29cf7742612edafd2894a21b1d9c4ca7d37ec839d8271e9bbd39bca2b8aad91e225fc6caa98b5c8dae8a43321aa75b0f92b896b333da7c1a51cb20f557e49b3933d4a29bf81d4a6dbe0b0e4bb750c14438c9784a85d1965e1c507b683b532d25b696aafcb7d0188c8a943628ac9a0fd03ca3927010da015cafe28efd42ccc4de313e2185376a823d041631fc7788531c7268008ba7a01dabe0a0b06dbd0873519a9990f099ac3549d22ff1d8e3c0ca0e8f0b081446805923b02414f5d98eedbf11af58b9a1e1042ac5c910f01ddc00bd6dce9e973c1ea1ab2c299315fe256b968d2bd385bc8c50af100ca10f4bc4fc4b700885741de4b746a0801fe4e768033016d0ace1d9dfc1e2a4c7d27caa8bc3299225802bab1d83a118239e99f5fda1e13aae5009936e559f6084988bb99dbfeab84da35ad4e6faafd28127eb93a8cff9c3a67d7c1c1f6d3a9b7bb74943794fddd64c3a6fdcc4df259d1f9a1bc04fb3a42092c2ab078e0c91c2051bcf26fd537f7bff35aad0602c8c8489c0e62fe51c4d27cc42c409d33d8eb864d584fae01e9aeaf608aa7fe64a7accdd8e86af23d943e146d8c03e0dc18d878cf7ae79a571ab8a83a824af0443d904d1242ba9e8641a7a49037384c929eeddfc709eca20b5d0422de045df6655ebf4ff52a33b657bf16b0a900a612c02f9993f81b70ba1a34c7a875860d972458a292ac4d2d5597a3b2baabe2f203c738080e47a09694b16c0bff6f796e273174fc1f9a162d1d7d9fc7746931e4b907765dbb89b1394b97267b2ff73f1109445a8e1c57395edf1950bf71872d3546af0acdb764080b1986d871cbd7986efceb3f88e721ab5965cc106b1c45b561fdca5d093e5c656af8bc1756dfa140541ebe3833054506e32f19d5d19328b6a499721d3517645dced150b41026c9b678273b21b0d4e023ab685d8dc33412dd88364c022e9de7ce955cb3af33300775c7b96d227942ec3c1d288f019498f13b27ae0811085a9e283629938e5d988947ef5df3d8d135681c3220bebe90caf416c4622be823c5f56dcff26a927f92598781303217251bf04f4dc0d12f22826b811954be9138226238759648f992dcc4dd1f8bc38bd41271fc2d2ad386359919bcc3769b2a555eab523945a76f120400c39c2bfe0c58bbad8c1f5428a1a4c4d7011db99959db666ef39c7836562ed923fca4918d7053d4bc7a8b43c67ebe295ea85a482b95aaf418d3934e89e0fcb1dd4523533c1311dbe0c4eadfceb879e5985cdc126bfa2a2099fd80ad425aee1809fb8cf5f851406cdc17bd5c31d7ca6b5bd284df473f8f7e3f692e6a8878cce79271e76f66ee28f33e7d502e5df75173d638efb4ab6bba5b40102b19254e042de9d1d9a4ecd330f7f001aab64173b1a9b3b83aff058e6f858284fe528845190d78ced70d7b5ef80140adbd700a6af38db2bff7a9d61032c8521144cdf586691ebc339074a9aeacc8156bfa6377a3b3f5b3facde84881bc3461a96694d76e3fe303fef8604bcf6b9211ea3d63f81f0e28436d3bd55fa3dc14b7e32cfce9edf4038333fac88e789808e1e3fc1ffc0bebe5a96a41fe2e3a2310f4366a7adbe696b9d4b27295f4e71f54702019f43e0e0859bdbc460d7e1589d7ebf2617a272e4219de10730ca38b9a3c9f1d96e9a9ebea526f4f8927d31db75af80bb320500a8ab1233ff067a22d90d669e2394d595fcbce327eb0e39221f10d5a89e4c2ec1201cfb39afd369cec23d15269e4e712dc3ed7b9d7f1bf23724fd3a303096946c51f70012c7f385783525652db9d99433f71db5a745bcce96fdb5ae85f5a74867591377980ed4a219978bee1cf9757442cf8e922f797ff75a691fdfe409a36af29f493745e86927f1b8272498c65106ea15dacc90a3eb930a1a6b2a03bf569f00517d96efc7da76205ca9968e552b97c296cd773412e727a5fc16b6f6ade326a8dadd87c27b729ad827005822e11fc4dddc0b2380b080958fdf5511fc89861737183f10b87ea750bc2a6d6a95c987883d00f87f8eec263664c8bcf78867c98dfd38da4f1b79e94aa7ddcc1b9ca4404163739f8cc58f3807f8d0492bd46cb71afdd6e6353bf2e5daad6be0d503dd269bf8b4a8173b92c39f416b67ce823a43c2f0856a042917baa8a4271003017a749acb76bddb477cc87d9b0c05592b5ac3b3f639a835fcb442b0dfab63749537f43cb9d4b85fac0b9d3f0024c75a78b285ee504233dfc3f845c5a2081bf54e1ed6c25b9dffd9df087440747c222fc0f3fd40404e8dd5a8a7eef000b251593437fe8726e8ab88aeeacae4faa1fce4c03e1116f457f4c002ae045adc795d133f8c112bd9e8dcc4f1c730484bcdb0fc8dab46856e85a54e2acfe4578a5897bb898e530cb137bab592fef355da6731e080f7244b9ea1645ce8a4758adab993c5c46985c1904ddcfd7cf242ee25fa009b4b2440884d3d1d1bed6e0a46580b5ea6128d006d8d134a66f50fba9b6b55baf58c7d8aaf013708a6bd44c514569d28fe416a8c19f7bf686e254282604f55ebaacfd4a2e314514a38782fa262190dd6d96d27f0477435917f95d2c57c3eed21194da49ec6d8059836b0248c0bcef8e49b59403bed5f9ceefabb1f2e9e19963ae5c66ddf3803370d80f5811845ec2cf431f6abd447844bceb1f4788cee5b0274a721b17cd03cf6a14498b6d4828160ce8c13458d7c565385c8d31f0def6ee0dfad6297d308c46738477c6fc1eca10491889c0fe72b5ee59da427b63f7c7d71a4ee07a30545a5e49e1786daa297bcae41271436521d9981cb1f6f1d5f47d147ce30fa95f44edd225067f420d10d2aec0c902e009711c5f7f57041626d565206268641ab1fcd5f49aae547c0cf35fe3e9370fa0fcee6ccdbccd072a19dcafd17d7848a6aadcdf292528c1dcbc1d58ba380223c15daa419cf847685f2c6520d2375ce3c0c30a2762163269a7f2821b2df5b3511e56ed6c08389e34965145c2b41fe2516fea674b28cb6b19de4b2f41c9f30b6d7d1c65c597bae4efbd1c97a2e214cbb62ed254af4d16541a1ee960b376608c634be196d96692dc7ea901475e7e3ba60f54191f3641254b1a5705a67732b29b1f2ab8c2859848fcccc070cc6fedb5dd5fd0a040592c02803c27187f790b7bd1f34e9f2d0afd39bbca043b57ca43e44b8b92047dfe31c18fe9a24b61bdce54dc216afa40ca566bb40d31db5ce08f9b3530a33a2f3b2517cdac46cd078bbeb6ddfc982480f7548df90cdf62a31936179effdf28ed5725258301ae216d799160aa55fc0ab49748464916af4205e87c0f38ec27c79393ac9f3edc007f2f9f5de2c4a628c9da9671b7d80f5e912b8f57b0e15b497081a015bc76a9aba6ea05201c13e390bc8933575249e02c08ec5a0ce6ff3c026338fbf31a9ec9309ed3ea5b6754dba73611e184ec5e53780138142996c2ef15c8d86812ce5f4ddcb1a69d90c60c3cdbddb225a60cf1e2306b88cc523571d8297a6d58d3bdc5915a87b04a2eee0699f9a50069ce2d5d6dab45972b597b8b8487686a91c2c374c6e89b076f618d50d52c4b004b298e163157fa8b1920616656b3ababe24a1e3b48a2e1b16f2c9c63857b3928fa0bdc00173f80ca8f8774bdd9b8f38c33903af1db64758e924310a173786b3b65bfb290d143be103eafc339aaa0aab209c1d9c5c5b5268090184e98eb527a2e19f4d181a490520f3a7dafafe3d46254d60c88a30ea854bb983c6f3eabbb3afcbd6538c607864a42e6d4e0a981eeb2e89375b077807b70340acc203b58813352ad0d339467f89de54148c5fdbf3812f6e06807b5d530de570ecc7e9a6028dec495a1708aa4b6deff99080f10d5ad26725d29d4dd6816ec9fe03c8838b9ca82a1551a920766510785205ed448085feeb07c567bf07f7c9443e3fd89cb6a9dea4ce3074ad6b74d0de0a3dea88e5545e25889ecc2fad353ffe2e9345b7a330929bac258fa399cde6c4e6a2fa8c4d0b406cec8288d51c18fda94aa1e4ad66d90a5afac0f9ee16e7d43c4c27bdd4a19f3f620ff6c7476a62df6305b940f9f9c314d4dec9bca30c91ee1cf1b4de99a5f43c37428f03bed373ad7e7fa578c503cf5fd69c3e6caf4f753b369201c6601224c96d1d2b362bece8e3dc00652e8ededaf9e95124c8c4f0ecdefa1d6025aa83071888c9973678e2a9b1dd1d7985742543def0bf1aa110f6870a620100ff086cc940bd73f8f4d27154b19cd30bf55bdaa525fc4b2d41d816a26cb571a55fe77a3626bb35eb990113f15e436a6f174c5b6d43c532ba9747925d25e7e59ebf76a0843b691f06a7f4e899f170cf65b91699b3aa31c6721a5de779332f9dc46d1181c2b330f032076f098dd7256eb62096fba3e34eeeee2f6c5829bf0975fa12fb448fc8780e9b574e183095972dd5a53821efce2c52cfafc43d3a506dd9075c4dacdeba535c978c72cc216c21157fc3919449182a4dbd5c700d1bcd16646b7c07b890244c2fb1612adc700606307f43585016558894331ef2678daca7c22b17ae1c6c0243befc592cc546d6acc777e3d6afd981d6d23fb32855e1bb6426b4b711956c54784892a7253decff157ea41bd77f14927807ce3811e09d7bf0fafe81429129d6c356fb45c25e587d6e2aa42302cad65a5e44a6d3354ffd3991b934d654b29396a98cfd13b63f54aa86bbd58eb54c76e9803a27c0f5be47f267366bf6c69921264783b24002b0c281b19ec29cbf7197a5bb2ccfb43563bd5dfffff1ba2556010d106f9a0c4eb89b2736dc4993e0ff91ee81261b2d3d6d3bb9c80d7b2f7fab7267cb890a354618cb54cc694f3c0f4d35caff3ff9a4d3eaaea1387d58ad87d99c974595b67c99cf202c837bd4dbc25610e696782330dfdbaee5b3f86fc9d47b458d3a49e22da8de69fb12d4f10941bd3c290c53dead7a5e60f23ddf58283314c262afed4c122f8ad91f0285d2bbeeed8f7914aececece9768dac19653585f578f52d403eaf0e37af8fe212c02bea44f77857b711e418c506be1fe9dace48b2550455997e8f0ea59531a5c776b4c3762813c2713fefb286811e53210fab7a4c3ec8221263378c799b81e451718aa51b785f730b384d5355460ab7a55d83d1e8de1760cdac50d73d9209a3adf71e19ec15d80e62ac999cf390269114e7f0f3fb4dfdeb673ddad954deda6ed7e651ff96772f4c1b403434421b0123c562ba6a64eb466296feadc12cf59027b8ffc42d2a32094a9dea1b9a5a5edfa5853267400c2211e3e5359940c052bdd2556857393e7d2d57313a04d78dd40c21a54cff6822b18259a2238295d254440da6ed2c4ae007e1bbd46735369ad22ecb67e64390db6148efc8313bc76d489e527980b8e9d96f70f3af15578dc5b45bcdc6643f14da552ba464172a4ae259f0cf8da2ea8a88d4c8f955016d712dd3a7f821db36ec91aec388f0c1ab63104b99de378e2a96c9e68b70a1c5f6da517a4aa668098e69185e9f134410cc22f8e04ed51c01964eae46d343efc48682405fbfa062aed2f99abcd29a516ee70f528c6f8ea282d63aa81e40ed48a2138f0ad8c69ce9b675616473e0ec1ab3b4b43ef3dc28b56c8fa9a5336a99280cc4cbf00bcad5f7d708d22decc24cf337713e011d483730fbd5348f27e957efab6b37e2e4fb8972ed7adc8f1fb19e3eee8ef73e11d218a85f292b8ffc37eb207af3130a5eb68312b837b602e09305d7e251550646c68f41a3a2bd8b14a1e151db92b612b07abd00181bea59842af9befe9f8be6c1983586c790e1368497cfa720f11355e382ed00e2f73b4750b8bfb6b74f3f02fb1e345646ff23e83a23a353770e64af2e353daf20b6aa6cb57bebfd06c91eff179f4484519da37a1eb7f5cfda133bf4ef78fe447831429eab3f2eec76fda145ef1749035639963aa9ddc0936c4d875576f69ad9926c6036ab69dbcbcafdf7307c404eeb35899af0c3c6c13bc9ae935901a601418dfa4f90e860c9ac8eef8fc69928ec1297c0b4ca3eba59e95731428e7e50425b2b29ad930f981888b48a71cdb9f6cd4851b7d3abe7f472b9edcd9a8ba06f48ba2b91269d64480e5d1901b5632248e58a51decca046940fc05e33972f01200d81a44a88db7cdb1296edea0c881dea0ec71007a9f19760f312d4b9f943e83b9ff3dbb02f05557ee56f62bdf232846b417daced3b397498c2cab76f583411562be71ccdb3e3cd9d3003a5cebaa2e50e5d134812191642e777e24b52bc96ed2ce33b0910ddb761f162b5c0b4f16e823f21127f0373854925ae69aacc1f3f4fd8bf842372f702e02513098b2c4db28bc8da615fa5f8c4af33a48deebb345b2016cf226c7b42232bfe5ceb572e70ed8540db820a3fb8019751fdd57033c1bdf63e72c337c6693e04e21be1783ffd85584b5c16210d6fbfc0392385ee0358b57a0b47ed90ab43db0f610a8dae162449b563d83fee925eeb13c5f786489802b4aad286acf3284bf614157ccec0f6833cdb48f89a9b9101d04618716405c65659ff34c118fca2527319df9d82a7a1996eb46f9af87fa8ae011ca2c6a7b55114771b5469f5073dcee42fdcb588bf4f5a745cce9fd85d89863e87519e86e505df5c6b5fa0d058a01174cb1cf8405b92dd9cd954cc5e57b7decb7e9bbe3d14dde8208cf58b281fa19c730ebdabd3596373d961bfe20cdae30afdd95657dce4c4f359f0c43bc2d10f045c9a050d649336d8b2c25eaf831e969848d07d9b1ba6fe258df30a5607e183c031791360ee1f9bb1c332fb9273eb5bfed6ceb29bd1f8291e83339a46e6d3d834832658accf0a266a62939f16378979916bf1d9875e71884df2947a0fe3f69fe78ad5b080b725ce8a2b90acee3551f3b4504ca59a5a7e87a86361fbf87929f5c881b4024657b194b4e3a4b9f0208cfc669604cbcfc5fb447ebb6c58d347c2b3bb56ddaaef8fe1e296617d374ee44f23b1c0be2f5d58b48660ee33b89298989268de6bcbb90851d640d8bc9e994c28abdf06f3abf5ad40ca112f9a192634f125ef8c161de938989e6ec21e901aff71a572359c1816e1e7f76b120461ae5a71161f99d0ea0689f5e838ea412de5e8cf903b6816d5e94ec26a60706282767a2fcbf6d7419ec4ec7b2086400ea6d5c4eb5c3f7af2e1872848b6095e9c9d3afa4c3eec42c818b0a93bbd2157158aabbee7f21a28f4ec192fc5348c1811d22d881f1c5fc07f7bfd3c606ebbb5e14ce8622b49e1a9d4240efb466275e73a42e972eb137c9697bdfe326a430b56a6581a63215486268124208e1740e4f263108872c1bb5ccc8d0f51aeaa1886b07683d3e62f0b26aed42f06f249081e4e3fe3aee0d732169df60a86923b492393138f15d5df799e13d4c652b9a636591dddac8d8da50c6c892e6abf7d1754c429cdd5d7cd2ef5f6f4e41d186109c71f71fedbc7b280fc215a12d189467c54bc3b7d02926dfb1ef8ebf68ac6021ebe77bd0c88f97d4d16e67ffb43b9b0615e74b839351fe9019e78e91cb9650409bba2d7f3523e33c5493b28cea9471a52c715fe1037a1be5a23616ebe4de1e164f6f0767ea07354479b77e85d161d149db54b25f538422268f3441053c66064877a201b91e32bae835ef208df9510f2b95bb93a1cab34e27d5bdb808b3ff3931c6289c5293d67a157f42f0d23de03d5e651e7a41e0cea4b8bd9fa04f08b0aadce41a714d5474ba4575858bdf33ebb3d69b5094d213df3bdcc38bc8e57c480ce6c9ed971b1544af9877c23436a794c8e825383bcc38cf09224bc1a044b7e14ceb1858cbe9ba32f49a0469e6e5df0aa83a3dc5aa5b6c3154b4245f2fa23d10b7d96b67434dcfd56550cbf270b4af3993c272fbcdb7ccc0b0a91b31ba1b0aa6946a32342c05725479f0210e0bfb6a4dacd80a2da28b02643ce6ecfd19744c20a8326251a7a866b0b4ba69dff2f9b1c35782cfe8f5a76f9961eb992350e19b8e3918f38024e319214ecb646646baadaab51a4a8d98891bab0192fdcb357106280f3b285cbf6c7564eae7c0acbfa48c688f620dbb46b8f892110f0ca1e77409fb142009de31336f13ef24d1f87304458b07127c69d7c6184d1923aed6941e9bb2727baf14d5e26dbdbd3c39dd0f9ef7502769da25a1841dd6751bd85842cdd1e3b4320ad0e0261ab1b02277770a12bb17ae1cd5589ae3308e8f15c3b1e87c607607430581cdd0f3991c3f81a630e51d535a3f14ebc6ea2209754ff249c73f195e14b82686570abfd01dda237755842546670185caf47570b1e5606478ad2014ef0d6ebb3a48fbdaa2c5a8327bc21f1698d4239dd83984eb79a3560f5c4c239211a27b2c2c7a0f78c44946ac191a3e9884df859ee9e2d2c01adc982b1fbefe6db72d4524c1274120fae782942c1397d17a61f20e913cd70b45d99bd79b3b8815f611aae0e085e08cca25ba759ebece685180a39eadae56272b8478fb9f93a17057cbec949ff97e954142dfb6a6b4c6aa608a6e70fdbc7f7d519c5e5d89e97de607c8de9788b89ffade918ef75dbba57f0fd7faacc2868c8ab0e1ebb48f15e007719b134f98fb8f70b248b83b80c4066d3fbc80307d1f6c86ccf3e863e71fca0229f9b3723b58f0606a9b6dfd085ce6db97ebe800de6d7d3b31ec5b13a4919ee44d50b22b0b48df1fe7e665230d8e1978d585f328399d39795b12d93408e8a1027ad4ede763823d7437b96c385ca905f5178e87a65343cdc81da74d0d29d3baecf10a4fbbcd0980fd00030b42c4d76844b2ea7be74b137d8a90a3f08a8a40b9f3f4074d734e1eafb057c674dde78f6af83f6da36658eda27053dec43a1a75659220b1aba1913cf77dece831080b6d6096016f8a8bdd92b3fc42d7818658074b900ca8524a60e4238d2c29d0530723419082db34d75e20202c2e71f6891c1f3079c4a42322d8b74d483b3c22569be267b811296fd67f4655439b5aeec96205cc2c919d132c1274cc425ff4b6d64150692eb6b3b5175f9eb675f94aed3475557959cc12ef8d37847bc961e9006b29224c800cb03a79e91706ef1b28d5d6368224f4435fa933e6a8d2da6bb2732e03703de86efea188b4a2d20198f0e1a87cbaffb751e132c8f47ee970619c4ac376d91cfa91c91ac3270ce1eee6af830af045b05b71fa9c8fe1c4a1a56123cd64165adc423eb97e4ec0c79c2b815592c1b3a2d81c962034c661e52f5ae158fdfb40100dabd286e80125c97cd9225ee455c7e81b528708909a2f3fa14c8cf50651a11859bc63a02de99134ff505adcb9988d54428e735d0bc300767d5a39aed88c7e6e648091b107bed43bb16365ea14e732ff392f8ce7eaf574f3b3a0cfb6cf4c8391063f0abad62542aee27990cc8c2be688a6d633005d32fa928aa61ddbd5bf12bb311cccfeacdf6ad71efe8979976b231bfa8a4ff79bdcc983cf886a4b86aee866a4cc880960612ab6bf34866a45c48c3d79aad87c72bf55557fef6c104c4bacd1b327d38107976de216368b4f90ada923b04335cbed95a6a4eb898967a2ea44454db19e2b50b27aa6ad9b13d43fafbade86afbe891aac0e6882eeec481e22cbbb539f95bbc5d9fcc7a3c3d30bb2360f694dac800f4a16e281cc79e41a66f0f2ae7e95e34137d8f59a47f93c312f54e162fdd6873b100ed2cfa9f0e64bdcf7dc9a5e56a920148608e79cd21bda09c57e8448016a8fad9980325573c1917edeaca56a3d5fc5dabc348d2d7a1dd1cf17a3e3e47cbb5cdfca0e4ec5bc317c3ac2d2524969fb232ede47387d72356599e32f3acf7d440ebef0bf696e3852250cafd21ac05123471523912dd452a19261ca09c94f76572d506f1bcd0781c161b71ed8aca970bee4e159f24ac143fda98f880227388b0030cd9aa469d56c847dc9183464dad28a0d3f1ad5c8da8d4bec9a06ef7b5aca5005434e99f2ea0098cc1c7fac3e22216071bb65dffad126a157899c99bcc50a911c6099acd8a53df896565cedc6765792e115525d4c6edccfa0d0ecb4fc20fcc02613cf84e3c5af0ad6e76e61aa6e2a95057bd5dc5fc2b09dfa0225d8b3d38c28f1af2004a97d9731df719c89da070e881d3227fba84b9807d2725710c8b27c0df6def81d5fb03257739f7aaa24c2ace15e4828be8fe01889d36de5c5bb66d0c536c8d69599a8a72d143d4678e1ae8b316d470989f575a91ff4532f84b833d8eeb6b7fa577073aec52804f542bd89112370db9604a549400de009c595455bdca0e162b56282d58ec67997368d842bb4a3ed54ecf16cda80f664de99ae5b8839b4b943f99713b51bc32ae1c364aa4eb0f6c4ee2aa0b0cc53044c629c24cdb438ebc2df4b4f17d46c706750c76804c5e250a34b910787be9ef8574b743b38652aa78fab6d8d153d790422c8bdffecf940ce26742a2cc5dc0f96397ef9fafd1865ad5bb723968b1583d1c7161f5af80fee4d66c6a3bd00080bd82a962d63225df74b60b2693f96b1bf90cb9074ef7e48060618de944d9775d14be3bd954a360cad23474a028396a2ad7b873c43f56afb68074b7d35e812c299ae9618e6820df929522d201be07a139f739a4bd19e7c55f654bde5f36d059aecebea950ca7c688cbad2b9782ccc1f1f05fe8925181ff65e5332427970d1c123ade978e22da43eda92c8eac889a36a82fe54910f98757ef817fc89bce4e9b99cf7541720c5634264c917bc593043fc7d8eca222c91259ebae092c7ed158064f2073014733673e1d083c66d339add97dd7e41a7249c8ac85328386ff6fc193bc6d57a5be25a99a0d19649855f6760c1462c641fe4419ffd04e86b74412dff8a3dd47c1572a7d59ec1de055605286541dc761e37f7be17afe92a4498ab649c08743f42b31c41d9cc7265eedef82a83c2944a36234c89a845dc89d2effce9b368e0f604540a2a4b8b57d494f8cbcbc031ebe002312f69e887ba97a277cb46f0595e0e778311ac0d534144401fda7cfdce65d042b6f377d41e7d77b2f372075d799caca134aea414a751853ef9a7c200eb514b1ee3004bfd281c2075f5fe4a26698172620382a256b66fb6a133bf487fb665a51caa5d8fc7f898b2a0791b2225573798ecdf54ddd3fa2a4e011dfb97616be93d77b146a817f99cc5fbb19136838809fc8b926bb084e8f258403048dc0dd2a8a2e331afea71e4cd9496d57292f3eaec5a703d0d9c52128c93a2e2181e5ffe7655c67a3de08f3292d5d672fcde61f19e7fa4bfbb6a27b766f0705c3df121988cde731e5b371af5404b71d202e4185b5f6e52954c0cc55520e1d314e3eb9cfa9c42d3ce43b9d49c2baf5abd58952fe4e48b2bc751788101eb3dce3590bca4d716e216ad741a43b1e505b5edaac6bec3f7b0ec62c6386a0da56b1a7f9d81afb615bb3a61d19d49c5bfd8f9afb40391b53ab312aeb997d412aec56dcaf6da50f90a56b845c7db6b347c61680431a72b4d996730cac8bfeefc53ff95dcaeaa432409edf00f7c1d90d75ac99c030d5575e3610135cd34036ae79c84f9ad1d4b2f9b997fa34551694a8f7ce492834144522670c850d382daf8f641ac633c7645dce614863491b8a61bce67ea7806bc2e7002c557d423caca7d9b98cfe56467d85ad470f28b6937b17624680a31003ff45324ebe6ccce3f267351abd607d028792377f2085c88db63eef12d215c53948fa8f4cac81b5c76c92347696deff4a356a8310da06b03343a7202ec018ef1efea6bbdedb3fbd80c6baa48580961cdfe3eaf1a84e77fe9335cadc4002d5dc897c4127d919ae484d55197450318f5ff13b89839972d9ae41faca0cdeddddce153d39c5bb08911a86c046f717b660aa7aca7921afe0c5fac2ee1f840518651dfc2b032e957e77c4b0c8bdfd9dc2cf8130d640a818b4044484da9b7117c254cc0fef4b0321b0d7ac5c5cbf33cffe17075c0aea9225bb89d53c5fc9b5d01b46e917feeeca4f77ac0a0fc59b4c9c0aa63b31d109d69ec526d00f04bd345d297f018c4e3e4dc02e96ee4a594235425d6f672e084b12a17d196bb2c67b1be0fc31f0f7e297cd0d95ad7c2f3eae9f8a462d3822c891f70406364df6ea75564cd767733e40002136a7a1ae096aeccbf4897a6955c388d8f959bbb4a05020d4d794100cf8aa0ff63e57b1e1a36fe7662d87ea9f0d09bf3b7037379bd91ef41de30f1ec7a449c17334d1fccb513e4863d773de14ae596c4872df472ac679fc3c061037deb69840ceeb55fbf0f745188ee5215deb0653ed56ce1aef49dafb74b83d3d680c613ae56f5e7e7b11aa7f93fc99c854f9fefb0bd5e207455f08823e12e0426142bb14fca9213732b0edff3c318835e065e3ce2420d7f269ed682fdb5a5e5d5d8c70adc7d686fc77499bbc5478737c1de8ee6cfb77e51ea7f0fd27413ababb3b3136cb22f6a5b1d12292d0bbdcc11aa031ca2747e1ca6b51d7982f59a894203dc06713d662a241791d39bdfa151df140fe2edef41436425869b3e0dfac2ed05f09a76ee3f1cfd674d58f7c6c6a5b171e849b83f567a6bfc32f5eadbb9cb81f9f42eacbcca1c4c0d79e2351fc676297a985be8a409d0c69ad03547643da5193eed1bf6ec7cd95ee51f27ad04abdddc1bbeef8543878d34bc07864cac391b091870691597ddbe62e20d85550c92d7a73333c38454a3e92e8c68388080af1286fb3bcb32fadbdb327dd744429a70b671fbfbbe3f231891859f9f4f214fc00208a89a9b5331cfdfa01977f53de3effc18eb1d6bf83322e42a44321a87a00dcd48f69a4fea0baaf88390e98449ab8566c1c6501b6365b899a6627f2116e7206ad5f74ef2c17a207e227a296e8038b464d0d8aceabb854f125368de92950376ff7c29ff3ba6a018d472aa97a10a91c28204987ef24e29a363e0ff7f37b511b1068a4fce7ad5b91c645f03085a8c2ea97459443f01e4a55fe74122c104e9deee998e4397e50bde82b2c9f8b2302be81b4225d31c2865e6fd0ba369ca1ee3b215d7ab7bc2a7c59bd7869029940aded5f52aac349ca7d4973ecf01e03514528bf263e66888d31b9eef0d4265e6d438bac91127c359601913d28ea5431d0f9b63f9bea38c63cbd472c0bbcc4b7ba1ee701ea21fa9d8e11fea4fe8d704d0ba7fc76f1c6dd4b87a041647898a8208f97df55c9d1fbf9a3f420410e62f69f498e8ff752d473f5d7e55506556735aad9903cd18d99a3510a37cf042d1674ae287c8b745f5c667df1f3c28248bf3b57817f3ab81a7b97473ca6b01418ef0334917591ce16bd6b29c8e0a88ddc90ead0faac44f5fa5c3d78338cff471a46495213a974ce45ad1c093ca4424e0fb79441d1322973156f48dbfee5f36274034ca84b75ea64354c0fd45a4b9267ced7c9b43db91967191ce76ab61b5baa73fdbdb314276a7a5e83ceec5ba1b046de7a1fcdf2b4da9162179a967482b9f97ee6df44c17f56928192d331b2f5fdbc38eff00d789302d436c7efbf990bd4b3c4f654598970f1692f59f265cc25e52b9dc748f0915f7bf532e26a1e5c8e00e9bc973322d22aefc4ff62824b7eeaaec387905e4c6d230044e24b128a2804936e8fe244e6a57d99b050127050bda523a5aa1d354c21ae875f4a6790b93fd6918f91600223ef6105ab8ea62f4d8afb7073a530a0053720347a99ea396e5fe5d9277faf5d81014125c1d6acf8f293d7d974ce84faeb757f255aea3fe8dbffdb92b45e24837e4599a30cecdab3f3f4e07368198c02dee9344c22cfdb9cd6a94cf3342547f1fa59b96752a993ee9cca1803950cd22d796fc122fe481e85d63306735422c38009f6e7cf15f68a1465f4108dbbc85bec81126e72398f4909864af1d76ad068fce4dae28778536c8d21f2caf76fd0627570baa85ec9628c711516952920ca946ce48ed0bf82c11529c020c65a7f7aa7d0b56ecb358ed77ac05248e1b14f1e68808f4acc9a071eb27f34e8dc2be66c4a8e1a733313107e76840f9eb3ab50a6201ec528f2220727bfdb0af6631dcc78488f942b4d807be490edaa54cab0d39daff2ff9a3b0a498c9b3cd07b6849c9be53645563f7b649f91e1096cd6360fa1c41dacc6fd10b5ce5ca9cb7009d999873174c7cd1028fa58672ce65f2b6757456b9330c3122d5ac6e8e8756ab6e17fd11b9e32b66b79790cc84a581a35e90e17bf5e6ca02f4e9bf2bfd8f62e1ca0229bea482ddf25332cf8580ef9139a1b7a85e875505b9c026e1ac8e6d999ec43027862efd351d0ab0efe42e53c5da304071851939d672f8a198f2eb0772cd071577562c6cf1a635a8b374ab4a8cfe9d9a4274ae4a8f77eb862765654879be8ba69cb411a419e4be8e0f3e37f23fceb44295f2df084fb9ad1307b31cc3057deae9a58e8df0a05e8395dc790dde361870dcad90bd0e322fb7fb8f1ee6ce1ec99e1329a328c76add5a163436cd8bfe4a7c69c51db2517287aebad7436c80c20412d43f56acbe2dc7e40d6868cba67cedad614f0d920a38f139b531cedb350f319e0ea9f77743c7ad3d02aa2003a3fff64f3e9b32e197aa5b02a1973f914ea3fbb9c5bf846b3cb9c63561c8f9acdbda7bcc47079b9203541c2928d0bcd5b527b7a1a1317aaf6173d2f9590174f1c2faf14e9854595d6f168558e84f1af92741ad0b2ce50bc20101d069587132a92f4d26b4ccce3f28f5d7dd0934c3edd125d3f3a9268c96c5aac821560a2adb333ab907f1e7641ab14e41903e35ad1571610c2e61dc69b054911422cd29684962c800528f6deb93baeb8f790ab132a8c6447818963348c8ae2f83407da78cd5f7ac984ba8af62ec0988e865feedf76ce10de5c17ac4cfed2672076e8cc95fcb73b0042a0d92d9860fb74db88b163d6d8e4568ce025af40a50de6ecd69c9568e9e7d46c02b0813b6634027619ee7fe23d455e1654c48a121dd4c7808b3a91d73f0778246ad7df45c50af680bd445272da79bf7fd859af14fd209f999a602174324b56cc72211a203fb05b86a247bc37aed763353576bfe79928d50b83c32ebff03d5e151c18525638afc624c2f6fb3b058b5e59b54a296192ac470d0011d95820fa8e610d853e26328d4f93bf8deec209b2eee380c3c681f7da84dd6cc885abbc59e057df9a14643077f57b10cf8cde76b656a3ee437af0dfe334cd3085aaa63712313b5d4c6617480ecc59e8b163ce32e823f970ce065372044c86d4f35feb80db9e790995a00efe1f107d03d36af52d64b2625ce8ae7cdffcae650b40a71a71e1639d10db9daa0b48c48fc675035546096425e8d3d6cfbb98dabdd0293b935645635baef1cb99198d045564d1fa31cc554f9713c12967bad5de1cb107f5ee6dbbbf2f8815c3170b8c179ae7755e060c0edda21ad911fc77e72924b9fddac349cb474859898e0e8bc7e987ca13e1d3cf5edf9d59951473340f810d0e420f00f7949be3a3f95ea625001b3404c29df7dfb248dc0c780d1d49a8ed9381eaed5331e8caa7d014514a9d6838c3186ed7cc32e3e2f9b50f1c70600131c180b5501ac4747410d03d9f9aecc1859c1bda0ae01254d5c41f819f2ffac0a9e0dc8ffd6a0ed46ff0375dcc08705bb416132878f8370210f0843916e625228d49b45e963b92a85db37f8eabcd8ccbcf9557adb52f26923dd3750f723c84a37981a0c9753de7c8fd29766a05aafbde68869ec26eee82db1c50163712add9a019218beadde0098d44d44850aa8ce1f32efc0720c0524298cd2e7583f20435c81906176956498c12ccca69da6d3f72b7a8123a69c326f3de99a8adaa529388bfc7fda41dd7cbfe788bf42f017eeeed3c0b5e37dde84e5f9f2fbc73ca8557c70985204cd4fb7451fb025088de09cc5c277c06dc7edf745d5a349e2a58c7eaf6631e367dbf7697bfc9125c566a9f9c4670c3506639906fcafee7b2305022f075865c62d57f7aaff468064732bfc0466ce56d886b28053a4813fcbe70a5f9bda2979432eec81bda03842cc521f673a91384e29ae1f4994003b861ba3a18e5cf63dfe5be5e1b95e95f53d1930a4f0dbff1984ad7ff3a84d3559be66487e0600c88d52f1a5923a7177a5d249dc6273728e53833d1eab3bdca6737d6f2bae6e5a72cfad102843dd2fccf1eb48f4d778aec24186673933b3fe958f9c0bc7ba5083dac5e63bc095f1c1cd2174b16c6d7f702e2e1d3c103a8e395791125e691cbd49b9b960b970f3687c3fd5128240a59760e42fd7870fad4b845978b534fb0ea1a8c713bf72211a0c36ea69fdd163aa4944b220f152e1ea63d6520e17b89102ef4214353fd86baa65e063ebd96d82de69990c2175747a3752489351da8ebeb737d7331a31213766d41c50185bad730f4ac4f34f655a5fe5b6659d85f41b35f763e08f10f8fbcdc367184ac508afb722cd1d54b83155bd8c9d0495b6d87231f036f784f13d4cc9a7b596448403226c07b278951d1e7b9d71958d072fdd2abafb42416fa2371174795b246431ad151b0aed8826fb273e0885130ccbfe2c8e0666945b63cea2a62b2c7e7fd483af96ed5a141b38c8c286473ca90ef5b3fa49954c54e328a00ef091223a55ba54e068c6442304ec053dc92bc7bd02523717687bb3f245a8a710c954a31905e4639261df0091429bf5aef454154c684b94fc7eba1b46e9450420408b13fe0652a4be2ef54a7ce2568136dde9db1ca09e993bda4f7b7114215edf0fa0f2b9138177ec312efc37a026decfa3e4cf43fc207e144dec49d142ae5df244ce79dc0276476e2c493e25257e7c2ffc460e7d4b976b97144e1d432bb6bdd11bbc1874cc4ece8ff45114935f91c503da68c7642188fe8de5aa94bd459f6a2e0a9f08243fd552f4beb2ff6f8fef78bac46207daa47230cbeff038db0da5f3e572c8044d283791f1c3ad40b00a4a1da520d5413c04afc6d254307b314f08a54f7549c15eac11efcaf1d864be313e5c457faa0d10ed5e64d3a40663b7c8981464ebcab791821beab9edfb78bfa63e4307a53aa7894f2367a9d33a42eb3afdff2a9934b43bddede7d433608f020b4cf768b0662095495e2215a4039551f2725c420d54c7fa5dab13f21d36b08679fe2ef035b5a60e6d9fa13f829a9af3c211ad2fbfb356cb1bed63b7a4206289136aa18dbd3a4555d5ca6fb05abbe580b716c666363dcbaf6f153915691dd8149684298e4cad0832ede9fff697dc22ddb077fe7ff7a04284ff09ba92a9d8109a6ad47a2bcfa41dfaef9b06b6cdb7813e2ee54e562cd9e5800b93a0ab9264566abc32e11f458a4cd85e44d2ae45a7d0386128664624a1247e8f57614537b19580dcc7e3b74f3655eacb2df60399441c255481a4fb5c1ce3494ae9187aca2cee0e16772929396196dde6ec2f939d39a58634d269d2d9c1b6037d6b1aaadbd7aa7975ff274d02307b5238a707b88cdae87c14d24a8b16bee071baffaa5db10c76d86e64657c 你好, 请输入密码。","summary":"本文介绍并发容器BlockingQueue相关技术","date_published":"2023-05-25T14:34:05.000Z","tags":["技术","java","java多线程","java"]},{"id":"https://blog.hanqunfeng.com/2023/05/24/java-concurrency09-container/","url":"https://blog.hanqunfeng.com/2023/05/24/java-concurrency09-container/","title":"Java并发编程--JUC并发容器","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度 ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍并发容器相关技术</p>\n</li>\n<li class=\"lvl-2\">\n<p>本文基于<code>jdk1.8</code></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"并发容器\">并发容器</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Java的集合容器框架中，主要有四大类别：<code>List</code>、<code>Set</code>、<code>Queue</code>、<code>Map</code>，大家熟知的这些集合类<code>ArrayList</code>、<code>LinkedList</code>、<code>HashMap</code>等这些容器都是非线程安全的。</p>\n</li>\n<li class=\"lvl-2\">\n<p>为了保证线程安全，所以java提供了<code>同步容器</code>，可以简单地理解为通过<code>synchronized</code>来实现同步的容器，比如<code>Vector</code>、<code>Hashtable</code>以及<code>SynchronizedList</code>等容器，这样做的代价是削弱了并发性，当多个线程共同竞争容器级的锁时，吞吐量就会降低。</p>\n</li>\n<li class=\"lvl-2\">\n<p>因此为了解决同步容器的性能问题，所以才有了<code>并发容器</code>，<code>java.util.concurrent</code>包中提供了多种并发类容器：<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/Y7os2P.jpg\" alt=\"\" width=\"600\" height=\"600\"></p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>并发容器</th>\n<th>对应的非并发容器</th>\n<th>代替的同步容器</th>\n<th>实现原理</th>\n<th>应用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CopyOnWriteArrayList</td>\n<td>ArrayList</td>\n<td>Vector、synchronizedList</td>\n<td>CopyOnWriteArrayList 内部使用了一种称为“写时复制”的机制。当需要进行写操作时，它会创建一个新的数组，并将原始数组的内容复制到新数组中，然后进行写操作。一旦修改完成，新的副本会替代原始数组，成为新的数据源。<br>因此，读操作不会被写操作阻塞，读操作返回的结果可能不是最新的，但是对于许多应用场景来说，这是可以接受的。此外，由于读操作不需要加锁，因此它可以支持更高的并发度。<br><span style=\"color:red;\">需要注意的是，虽然副本会替代原始数组，但是这个替代并不是立即发生的。在修改操作期间，读操作仍然可能会访问原始数组。只有当修改完成后，才会将新的副本设置为源数组。</span></td>\n<td>1. 读多写少的场景由于 CopyOnWriteArrayList 的读操作不需要加锁，因此它非常适合在读多写少的场景中使用。例如，一个读取频率比写入频率高得多的缓存，使用 CopyOnWriteArrayList 可以提高读取性能，并减少锁竞争的开销。<br>2. 不需要实时更新的数据由于 CopyOnWriteArrayList 读取的数据可能不是最新的，因此它适合于不需要实时更新的数据。例如，在日志应用中，为了保证应用的性能，日志记录的操作可能被缓冲，并不是实时写入文件系统，而是在某个时刻批量写入。这种情况下，使用 CopyOnWriteArrayList 可以避免多个线程之间的竞争，提高应用的性能。<br><span style=\"color:red;\">注意：由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致 young gc 或者full gc，谨慎使用</span></td>\n</tr>\n<tr>\n<td>CopyOnWriteArraySet</td>\n<td>HashSet</td>\n<td>synchronizedSet</td>\n<td>基于CopyOnWriteArrayList实现，其唯一的不同是在add时调用的是CopyOnWriteArrayList的addIfAbsent方法，其遍历当前Object数组，如Object数组中已有了当前元素，则直接返回，如果没有则放入Object数组的尾部，并返回。</td>\n<td>同CopyOnWriteArrayList</td>\n</tr>\n<tr>\n<td>ConcurrentHashMap</td>\n<td>HashMap</td>\n<td>Hashtable、synchronizedMap</td>\n<td>在JDK1.8之前，ConcurrentHashMap使用分段锁以在保证线程安全的同时获得更大的效率。<br>JDK1.8开始舍弃了分段锁，使用自旋+CAS+synchronized关键字来实现同步。<br>这样做的好处：<br>1.节省内存空间 ，分段锁需要更多的内存空间，而大多数情况下，并发粒度达不到设置的粒度，竞争概率较小，反而导致更新的长时间等待（因为锁定一段后整个段就无法更新了）<br>2.提高GC效率。</td>\n<td>1.共享数据的线程安全：在多线程编程中，如果需要进行共享数据的读写，可以使用 ConcurrentHashMap 保证线程安全。<br>2. 缓存：ConcurrentHashMap 的高并发性能和线程安全能力，使其成为一种很好的缓存实现方案。在多线程环境下，使用 ConcurrentHashMap 作为缓存的数据结构，能够提高程序的并发性能，同时保证数据的一致性。</td>\n</tr>\n<tr>\n<td>ConcurrentSkipListMap</td>\n<td>TreeMap</td>\n<td>synchronizedSortedMap(TreeMap)</td>\n<td>基于Skip list（跳表）实现的有序映射（Map）数据结构，是一种可以代替平衡树的数据结构，默认是按照Key值升序的。</td>\n<td>ConcurrentSkipListMap适用于需要高并发性能、支持有序性和区间查询的场景，能够有效地提高系统的性能和可扩展性。</td>\n</tr>\n<tr>\n<td>ConcurrentLinkedQueue</td>\n<td>LinkedList</td>\n<td>LinkedBlockingQueue</td>\n<td>ConcurrentLinkedQueue 基于无锁算法和乐观并发策略，旨在提供高效的并发操作。它使用一个单向链表数据结构来存储元素，并且保持了先进先出（FIFO）的顺序。<br>ConcurrentLinkedQueue 是一个无界队列，它没有固定的容量限制。可以根据需要动态地增长或缩小链表的长度。<br><span style=\"color:red;\">需要注意的是，ConcurrentLinkedQueue 并不适合在迭代过程中进行修改操作，因为它的结构在并发情况下可能会发生变化。</span></td>\n<td>1.高并发环境：ConcurrentLinkedQueue 适用于需要高并发性能和线程安全的场景。由于它采用无锁算法和乐观并发策略，可以在高并发环境下提供较高的吞吐量。<br>2.生产者-消费者模式：ConcurrentLinkedQueue 在实现生产者-消费者模式时非常有用。生产者线程可以将元素添加到队列的尾部，而消费者线程可以从队列的头部获取元素，实现了解耦和并发处理。<br>3.任务调度：ConcurrentLinkedQueue 可以作为任务调度的数据结构，用于存储待执行的任务。多个线程可以从队列中获取任务并执行，从而实现任务的并发处理。</td>\n</tr>\n<tr>\n<td>ConcurrentLinkedDeque</td>\n<td>LinkedList</td>\n<td>无</td>\n<td>与ConcurrentLinkedQueue 相比 ConcurrentLinkedDeque 是基于双向链表实现的并发双端队列。它支持在队头和队尾进行插入和移除操作，保持了元素的先进先出顺序。</td>\n<td>ConcurrentLinkedDeque 适用于需要双端操作的并发场景，例如生产者-消费者模式中的多线程同时插入和移除元素的场景。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"CopyOnWriteArrayList\">CopyOnWriteArrayList</h2>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>int size()</code></td>\n<td>返回列表中的元素数量。</td>\n</tr>\n<tr>\n<td><code>boolean isEmpty()</code></td>\n<td>检查列表是否为空。</td>\n</tr>\n<tr>\n<td><code>boolean contains(Object o)</code></td>\n<td>检查列表是否包含指定元素。</td>\n</tr>\n<tr>\n<td><code>Iterator&lt;E&gt; iterator()</code></td>\n<td>返回一个迭代器，用于遍历列表中的元素。</td>\n</tr>\n<tr>\n<td><code>boolean add(E e)</code></td>\n<td>将元素添加到列表末尾。</td>\n</tr>\n<tr>\n<td><code>boolean remove(Object o)</code></td>\n<td>从列表中移除指定元素的第一个匹配项。</td>\n</tr>\n<tr>\n<td><code>boolean containsAll(Collection&lt;?&gt; c)</code></td>\n<td>检查列表是否包含指定集合中的所有元素。</td>\n</tr>\n<tr>\n<td><code>boolean addAll(Collection&lt;? extends E&gt; c)</code></td>\n<td>将指定集合中的所有元素添加到列表末尾。</td>\n</tr>\n<tr>\n<td><code>boolean addAll(int index, Collection&lt;? extends E&gt; c)</code></td>\n<td>将指定集合中的所有元素插入到列表的指定位置。</td>\n</tr>\n<tr>\n<td><code>boolean removeAll(Collection&lt;?&gt; c)</code></td>\n<td>移除列表中与指定集合中的元素相匹配的所有元素。</td>\n</tr>\n<tr>\n<td><code>boolean retainAll(Collection&lt;?&gt; c)</code></td>\n<td>仅保留列表中与指定集合中的元素相匹配的元素，移除其他元素。</td>\n</tr>\n<tr>\n<td><code>void clear()</code></td>\n<td>清空列表中的所有元素。</td>\n</tr>\n<tr>\n<td><code>E get(int index)</code></td>\n<td>返回列表中指定位置的元素。</td>\n</tr>\n<tr>\n<td><code>E set(int index, E element)</code></td>\n<td>用指定元素替换列表中指定位置的元素，并返回原来的元素。</td>\n</tr>\n<tr>\n<td><code>void add(int index, E element)</code></td>\n<td>在列表的指定位置插入指定元素。</td>\n</tr>\n<tr>\n<td><code>E remove(int index)</code></td>\n<td>移除列表中指定位置的元素，并返回被移除的元素。</td>\n</tr>\n<tr>\n<td><code>int indexOf(Object o)</code></td>\n<td>返回指定元素在列表中首次出现的位置索引，如果不存在，则返回 -1。</td>\n</tr>\n<tr>\n<td><code>int lastIndexOf(Object o)</code></td>\n<td>返回指定元素在列表中最后一次出现的位置索引，如果不存在，则返回 -1。</td>\n</tr>\n</tbody>\n</table>\n<div class=\"tips\">\n<p><em><strong>小贴士</strong></em></p>\n<h2 id=\"迭代器的-fail-fast-与-fail-safe-机制\">迭代器的 fail-fast 与 fail-safe 机制</h2>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">在 Java 中，迭代器（Iterator）在迭代的过程中，如果底层的集合被修改（添加或删除元素），不同的迭代器对此的表现行为是不一样的，可分为两类：Fail-Fast（快速失败）和 Fail-Safe（安全失败）。</li>\n</ul>\n<h3 id=\"fail-fast-机制\">fail-fast 机制</h3>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">fail-fast 机制是java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生 fail-fast 事件。例如：当某一个线程A通过 iterator 去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生 fail-fast 事件。</li>\n<li class=\"lvl-2\">在 java.util 包中的集合，如 ArrayList、HashMap 等，它们的迭代器默认都是采用 Fail-Fast 机制。</li>\n<li class=\"lvl-2\">fail-fast解决方案\n<ul class=\"lvl-3\">\n<li class=\"lvl-6\">方案一：在遍历过程中所有涉及到改变modCount 值的地方全部加上synchronized 或者直接使用Collection#synchronizedList，这样就可以解决问题，但是不推荐，因为增删造成的同步锁可能会阻塞遍历操作。</li>\n<li class=\"lvl-6\">方案二：使用CopyOnWriteArrayList 替换 ArrayList，推荐使用该方案（即fail-safe）。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"fail-safe机制\">fail-safe机制</h3>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">任何对集合结构的修改都会在一个复制的集合上进行，因此不会抛出ConcurrentModificationException。在 java.util.concurrent 包中的集合，如CopyOnWriteArrayList、ConcurrentHashMap 等，它们的迭代器一般都是采用 Fail-Safe 机制。</li>\n<li class=\"lvl-2\">缺点：\n<ul class=\"lvl-3\">\n<li class=\"lvl-6\">采用 Fail-Safe 机制的集合类都是线程安全的，但是它们无法保证数据的实时一致性，它们只能保证数据的最终一致性。在迭代过程中，如果集合被修改了，可能读取到的仍然是旧的数据。</li>\n<li class=\"lvl-6\">Fail-Safe 机制还存在另外一个问题，就是内存占用。由于这类集合一般都是通过复制来实现读写分离的，因此它们会创建出更多的对象，导致占用更多的内存，甚至可能引起频繁的垃圾回收，严重影响性能</li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id=\"CopyOnWriteArraySet\">CopyOnWriteArraySet</h2>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>int size()</code></td>\n<td>返回集合中的元素数量。</td>\n</tr>\n<tr>\n<td><code>boolean isEmpty()</code></td>\n<td>检查集合是否为空。</td>\n</tr>\n<tr>\n<td><code>boolean contains(Object o)</code></td>\n<td>检查集合是否包含指定的元素。</td>\n</tr>\n<tr>\n<td><code>boolean add(E e)</code></td>\n<td>将指定元素添加到集合中。</td>\n</tr>\n<tr>\n<td><code>boolean remove(Object o)</code></td>\n<td>从集合中移除指定元素。</td>\n</tr>\n<tr>\n<td><code>void clear()</code></td>\n<td>清空集合中的所有元素。</td>\n</tr>\n<tr>\n<td><code>Iterator&lt;E&gt; iterator()</code></td>\n<td>返回在集合上进行迭代的迭代器。</td>\n</tr>\n<tr>\n<td><code>boolean containsAll(Collection&lt;?&gt; c)</code></td>\n<td>检查集合是否包含指定集合中的所有元素。</td>\n</tr>\n<tr>\n<td><code>boolean addAll(Collection&lt;? extends E&gt; c)</code></td>\n<td>将指定集合中的所有元素添加到集合中。</td>\n</tr>\n<tr>\n<td><code>boolean removeAll(Collection&lt;?&gt; c)</code></td>\n<td>从集合中移除指定集合中包含的所有元素。</td>\n</tr>\n<tr>\n<td><code>boolean retainAll(Collection&lt;?&gt; c)</code></td>\n<td>仅保留集合中包含在指定集合中的元素，移除其他元素。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"CopyOnWriteArraySet与CopyOnWriteArrayList的区别\">CopyOnWriteArraySet与CopyOnWriteArrayList的区别</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>数据结构类型：CopyOnWriteArraySet 是一个基于数组的集合，而 CopyOnWriteArrayList 是一个基于数组的列表。</p>\n</li>\n<li class=\"lvl-2\">\n<p>元素的唯一性：CopyOnWriteArraySet 保证集合中的元素是唯一的，不允许重复元素的存在。而 CopyOnWriteArrayList 允许列表中存在重复元素。</p>\n</li>\n<li class=\"lvl-2\">\n<p>集合与列表的特性：CopyOnWriteArraySet 实现了 Set 接口，它是一个无序的集合，不保留插入顺序。CopyOnWriteArrayList 实现了 List 接口，它是一个有序的列表，保留插入顺序。</p>\n</li>\n</ul>\n<h3 id=\"代码示例\">代码示例</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建 CopyOnWriteArraySet 实例</span></span><br><span class=\"line\">CopyOnWriteArraySet&lt;String&gt; set = <span class=\"keyword\">new</span> <span class=\"title class_\">CopyOnWriteArraySet</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 添加元素</span></span><br><span class=\"line\">set.add(<span class=\"string\">&quot;Apple&quot;</span>);</span><br><span class=\"line\">set.add(<span class=\"string\">&quot;Banana&quot;</span>);</span><br><span class=\"line\">set.add(<span class=\"string\">&quot;Orange&quot;</span>);</span><br><span class=\"line\">set.add(<span class=\"string\">&quot;Grapes&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 打印集合元素，可能得到的输出：[Apple, Banana, Grapes, Orange]</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;集合元素: &quot;</span> + set);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建 CopyOnWriteArrayList 实例</span></span><br><span class=\"line\">CopyOnWriteArrayList&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 添加元素</span></span><br><span class=\"line\">list.add(<span class=\"string\">&quot;Apple&quot;</span>);</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;Banana&quot;</span>);</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;Orange&quot;</span>);</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;Grapes&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 打印列表元素，得到的输出：[Apple, Banana, Orange, Grapes]</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;列表元素: &quot;</span> + list);</span><br></pre></td></tr></table></figure>\n<h2 id=\"ConcurrentHashMap\">ConcurrentHashMap</h2>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>int size()</code></td>\n<td>返回映射中的键值对数量。</td>\n</tr>\n<tr>\n<td><code>boolean isEmpty()</code></td>\n<td>检查映射是否为空。</td>\n</tr>\n<tr>\n<td><code>boolean containsKey(Object key)</code></td>\n<td>检查映射是否包含指定的键。</td>\n</tr>\n<tr>\n<td><code>boolean containsValue(Object value)</code></td>\n<td>检查映射是否包含指定的值。</td>\n</tr>\n<tr>\n<td><code>V get(Object key)</code></td>\n<td>获取与指定键关联的值。</td>\n</tr>\n<tr>\n<td><code>V put(K key, V value)</code></td>\n<td>将指定的键值对添加到映射中。</td>\n</tr>\n<tr>\n<td><code>V remove(Object key)</code></td>\n<td>从映射中移除指定键的映射关系，并返回对应的值。</td>\n</tr>\n<tr>\n<td><code>void clear()</code></td>\n<td>清空映射中的所有键值对。</td>\n</tr>\n<tr>\n<td><code>Set&lt;K&gt; keySet()</code></td>\n<td>返回映射中所有键的集合。</td>\n</tr>\n<tr>\n<td><code>Collection&lt;V&gt; values()</code></td>\n<td>返回映射中所有值的集合。</td>\n</tr>\n<tr>\n<td><code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</code></td>\n<td>返回映射中所有键值对的集合。</td>\n</tr>\n<tr>\n<td><code>V putIfAbsent(K key, V value)</code></td>\n<td>当指定的键尚未映射到值时，将指定的键值对添加到映射中。</td>\n</tr>\n<tr>\n<td><code>boolean remove(Object key, Object value)</code></td>\n<td>从映射中移除指定键值对。</td>\n</tr>\n<tr>\n<td><code>boolean replace(K key, V oldValue, V newValue)</code></td>\n<td>用新的值替换指定键的旧值，仅当当前值与指定的旧值相等时才替换。</td>\n</tr>\n<tr>\n<td><code>V replace(K key, V value)</code></td>\n<td>用指定值替换指定键的值。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"JDK1-7-中的ConcurrentHashMap\">JDK1.7 中的ConcurrentHashMap</h3>\n<p>在jdk1.7及其以下的版本中，结构是用Segments数组 + HashEntry数组 + 链表实现的</p>\n<h3 id=\"JDK1-8中的ConcurrentHashMap\">JDK1.8中的ConcurrentHashMap</h3>\n<p>jdk1.8抛弃了Segments分段锁的方案，而是改用了和HashMap一样的结构操作，也就是数组 + 链表+ 红黑树结构，比jdk1.7中的ConcurrentHashMap提高了效率，在并发方面，使用了<code>cas +synchronized</code>的方式保证数据的一致性</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>链表转化为红黑树需要满足2个条件:</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">1.链表的节点数量大于等于树化阈值8</li>\n<li class=\"lvl-6\">2.Node数组的长度大于等于最小树化容量值64</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"代码示例-2\">代码示例</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConcurrentHashMapExample</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建 ConcurrentHashMap 实例</span></span><br><span class=\"line\">        ConcurrentHashMap&lt;String, Integer&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 添加键值对</span></span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;Apple&quot;</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;Banana&quot;</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;Orange&quot;</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;Grapes&quot;</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 打印映射内容，映射内容: &#123;Banana=1, Grapes=4, Orange=2, Apple=3&#125;</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;映射内容: &quot;</span> + map);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取键值对数量</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;键值对数量: &quot;</span> + map.size());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 检查是否包含指定键</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;是否包含键 &#x27;Orange&#x27;: &quot;</span> + map.containsKey(<span class=\"string\">&quot;Orange&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取指定键对应的值</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;键 &#x27;Apple&#x27; 对应的值: &quot;</span> + map.get(<span class=\"string\">&quot;Apple&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 移除指定键的映射关系</span></span><br><span class=\"line\">        map.remove(<span class=\"string\">&quot;Banana&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 打印映射内容</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;移除键 &#x27;Banana&#x27; 后的映射内容: &quot;</span> + map);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ConcurrentSkipListMap\">ConcurrentSkipListMap</h2>\n<h3 id=\"ConcurrentSkipListMap-和-ConcurrentHashMap-是-Java-中用于并发访问的映射数据结构，它们之间有一些区别\">ConcurrentSkipListMap 和 ConcurrentHashMap 是 Java 中用于并发访问的映射数据结构，它们之间有一些区别</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>数据结构：ConcurrentSkipListMap 是基于跳表（Skip List）的数据结构实现，而 ConcurrentHashMap 是基于<code>数组 + 链表+ 红黑树</code>的数据结构实现。</p>\n</li>\n<li class=\"lvl-2\">\n<p>排序性：ConcurrentSkipListMap 是有序映射，按照键的自然顺序或自定义的比较器对键进行排序。而 ConcurrentHashMap 是无序映射，不保证键值对的顺序。</p>\n</li>\n<li class=\"lvl-2\">\n<p>并发访问性能：在高度并发的情况下，ConcurrentSkipListMap 在读取方面的性能较好，因为它支持并发读取操作，并且有序结构使得读取更高效。而 ConcurrentHashMap 在写入方面的性能较好，因为它使用<code>cas +synchronized</code>来支持并发写入操作。</p>\n</li>\n<li class=\"lvl-2\">\n<p>内存占用：通常情况下，ConcurrentSkipListMap 的内存占用比 ConcurrentHashMap 更高，因为它需要额外的存储空间来维护跳表结构。</p>\n</li>\n<li class=\"lvl-2\">\n<p>功能特性：由于有序性的特点，ConcurrentSkipListMap 提供了一些与顺序相关的方法，如 <code>firstKey()</code>、<code>lastKey()</code>、<code>subMap()</code> 等。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>K firstKey()</code></td>\n<td>返回映射中的第一个键。</td>\n</tr>\n<tr>\n<td><code>K lastKey()</code></td>\n<td>返回映射中的最后一个键。</td>\n</tr>\n<tr>\n<td><code>ConcurrentNavigableMap&lt;K, V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)</code></td>\n<td>返回一个视图，该视图包含映射中键的子范围。</td>\n</tr>\n<tr>\n<td><code>ConcurrentNavigableMap&lt;K, V&gt; headMap(K toKey, boolean inclusive)</code></td>\n<td>返回一个视图，该视图包含映射中小于（或小于等于）给定键的部分。</td>\n</tr>\n<tr>\n<td><code>ConcurrentNavigableMap&lt;K, V&gt; tailMap(K fromKey, boolean inclusive)</code></td>\n<td>返回一个视图，该视图包含映射中大于（或大于等于）给定键的部分。</td>\n</tr>\n<tr>\n<td><code>ConcurrentNavigableMap&lt;K, V&gt; descendingMap()</code></td>\n<td>返回与此映射相反的顺序的视图。</td>\n</tr>\n<tr>\n<td><code>ConcurrentNavigableSet&lt;K&gt; navigableKeySet()</code></td>\n<td>返回包含映射中所有键的并发可导航集合。</td>\n</tr>\n<tr>\n<td><code>ConcurrentNavigableSet&lt;K&gt; descendingKeySet()</code></td>\n<td>返回与此映射中的键相反顺序对应的并发可导航集合。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"代码示例-3\">代码示例</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ConcurrentSkipListMap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConcurrentSkipListMapExample</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建 ConcurrentSkipListMap 实例</span></span><br><span class=\"line\">        ConcurrentSkipListMap&lt;Integer, String&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentSkipListMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 添加键值对</span></span><br><span class=\"line\">        map.put(<span class=\"number\">3</span>, <span class=\"string\">&quot;Apple&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"number\">1</span>, <span class=\"string\">&quot;Banana&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"number\">2</span>, <span class=\"string\">&quot;Orange&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"number\">4</span>, <span class=\"string\">&quot;Grapes&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 打印映射内容，映射内容: &#123;1=Banana, 2=Orange, 3=Apple, 4=Grapes&#125;</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;映射内容: &quot;</span> + map);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取键值对数量</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;键值对数量: &quot;</span> + map.size());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 检查是否包含指定键</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;是否包含键 2: &quot;</span> + map.containsKey(<span class=\"number\">2</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取指定键对应的值</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;键 3 对应的值: &quot;</span> + map.get(<span class=\"number\">3</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 移除指定键的映射关系</span></span><br><span class=\"line\">        map.remove(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 打印映射内容</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;移除键 1 后的映射内容: &quot;</span> + map);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取最小的键</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;最小的键: &quot;</span> + map.firstKey());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取最大的键</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;最大的键: &quot;</span> + map.lastKey());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取键小于等于 3 的子映射</span></span><br><span class=\"line\">        ConcurrentSkipListMap&lt;Integer, String&gt; subMap = map.headMap(<span class=\"number\">3</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;键小于等于 3 的子映射: &quot;</span> + subMap);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>小贴士</strong></em></p>\n<h2 id=\"跳表\">跳表</h2>\n<p>跳表（Skip List）是一种用于实现有序集合的数据结构，它的设计灵感来自于平衡树。跳表通过使用多层链表结构，每一层链表按照升序排列，并且每一层链表都是前一层链表的子集。这样的结构允许在搜索、插入和删除元素时具有较高的效率。</p>\n<p>跳表的核心思想是通过建立索引层来加快搜索的速度。最底层是原始链表，每个节点都包含一个元素。而上层的链表是通过原始链表中的一部分节点创建的。在每一层中，节点以一定的概率被提升到更高层，从而形成了跨越多个层级的链接。</p>\n<p>跳表的主要优点是在具有合理的设计和维护下，可以在平均情况下以 O(log n) 的时间复杂度执行搜索、插入和删除操作。这是因为每一层的节点数量是下一层的节点数量的一半，从而形成了一种对数级别的分布。</p>\n<p>以下是跳表的主要操作：</p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">\n<p>搜索：从顶层开始，沿着每一层的链表进行比较，如果目标元素大于当前节点的值，则在当前层继续向右移动；如果目标元素小于当前节点的值，则退回到下一层继续比较。直到找到目标元素或者无法再继续向右或下移动。</p>\n</li>\n<li class=\"lvl-2\">\n<p>插入：通过搜索找到插入位置后，在每一层链表中插入新节点，并更新相应的索引层。</p>\n</li>\n<li class=\"lvl-2\">\n<p>删除：通过搜索找到要删除的节点位置后，在每一层链表中删除节点，并更新相应的索引层。</p>\n</li>\n</ul>\n<p>跳表的实现相对简单，它提供了在有序集合中进行快速搜索和更新的高效方式。然而，它的空间复杂度相对于平衡树较高，因为需要维护额外的索引层。跳表在并发环境下也需要考虑同步的问题，以确保数据的一致性和线程安全性。</p>\n<p>总结而言，跳表通过建立多层索引结构，在有序集合中实现了较快的搜索、插入和删除操作。它是一种简单而高效的数据结构，在一些场景中可以作为替代平衡树的选择。<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/Mffk0p.png\" alt=\"\" width=\"600\" height=\"400\"></p>\n</div>\n<h2 id=\"ConcurrentLinkedQueue\">ConcurrentLinkedQueue</h2>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>boolean add(E e)</code></td>\n<td>将指定元素添加到队列的尾部。</td>\n</tr>\n<tr>\n<td><code>boolean offer(E e)</code></td>\n<td>将指定元素添加到队列的尾部。</td>\n</tr>\n<tr>\n<td><code>E poll()</code></td>\n<td>获取并移除队列的头部元素。</td>\n</tr>\n<tr>\n<td><code>E peek()</code></td>\n<td>获取队列的头部元素，但不移除。</td>\n</tr>\n<tr>\n<td><code>int size()</code></td>\n<td>返回队列中的元素数量。</td>\n</tr>\n<tr>\n<td><code>boolean isEmpty()</code></td>\n<td>检查队列是否为空。</td>\n</tr>\n<tr>\n<td><code>boolean contains(Object o)</code></td>\n<td>检查队列是否包含指定元素。</td>\n</tr>\n<tr>\n<td><code>boolean remove(Object o)</code></td>\n<td>从队列中移除指定元素的第一个匹配项。</td>\n</tr>\n<tr>\n<td><code>void clear()</code></td>\n<td>移除队列中的所有元素。</td>\n</tr>\n<tr>\n<td><code>boolean containsAll(Collection&lt;?&gt; c)</code></td>\n<td>检查队列是否包含指定集合中的所有元素。</td>\n</tr>\n<tr>\n<td><code>boolean addAll(Collection&lt;? extends E&gt; c)</code></td>\n<td>将指定集合中的所有元素添加到队列的尾部。</td>\n</tr>\n<tr>\n<td><code>boolean removeAll(Collection&lt;?&gt; c)</code></td>\n<td>从队列中移除包含在指定集合中的所有元素。</td>\n</tr>\n<tr>\n<td><code>boolean retainAll(Collection&lt;?&gt; c)</code></td>\n<td>仅保留队列中包含在指定集合中的元素，移除其他元素。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"代码示例-4\">代码示例</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConcurrentLinkedQueueExample</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建 ConcurrentLinkedQueue 实例</span></span><br><span class=\"line\">        ConcurrentLinkedQueue&lt;String&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentLinkedQueue</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 添加元素到队列</span></span><br><span class=\"line\">        queue.add(<span class=\"string\">&quot;Apple&quot;</span>);</span><br><span class=\"line\">        queue.add(<span class=\"string\">&quot;Banana&quot;</span>);</span><br><span class=\"line\">        queue.add(<span class=\"string\">&quot;Orange&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取队列元素数量</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;队列元素数量: &quot;</span> + queue.size());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 检查队列是否为空</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;队列是否为空: &quot;</span> + queue.isEmpty());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取并移除队列头部元素</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">head</span> <span class=\"operator\">=</span> queue.poll();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;移除的队列头部元素: &quot;</span> + head);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取队列头部元素</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">newHead</span> <span class=\"operator\">=</span> queue.peek();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;新的队列头部元素: &quot;</span> + newHead);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 打印队列元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;队列元素: &quot;</span> + queue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ConcurrentLinkedDeque\">ConcurrentLinkedDeque</h2>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>void addFirst(E e)</code></td>\n<td>将指定元素插入到双端队列的开头。</td>\n</tr>\n<tr>\n<td><code>void addLast(E e)</code></td>\n<td>将指定元素插入到双端队列的末尾。</td>\n</tr>\n<tr>\n<td><code>boolean offerFirst(E e)</code></td>\n<td>将指定元素插入到双端队列的开头。如果成功则返回 <code>true</code>，否则返回 <code>false</code>。</td>\n</tr>\n<tr>\n<td><code>boolean offerLast(E e)</code></td>\n<td>将指定元素插入到双端队列的末尾。如果成功则返回 <code>true</code>，否则返回 <code>false</code>。</td>\n</tr>\n<tr>\n<td><code>E pollFirst()</code></td>\n<td>获取并移除双端队列的开头元素。</td>\n</tr>\n<tr>\n<td><code>E pollLast()</code></td>\n<td>获取并移除双端队列的末尾元素。</td>\n</tr>\n<tr>\n<td><code>E peekFirst()</code></td>\n<td>获取双端队列的开头元素，但不移除。</td>\n</tr>\n<tr>\n<td><code>E peekLast()</code></td>\n<td>获取双端队列的末尾元素，但不移除。</td>\n</tr>\n<tr>\n<td><code>boolean removeFirstOccurrence(Object o)</code></td>\n<td>从双端队列中移除首次出现的指定元素。</td>\n</tr>\n<tr>\n<td><code>boolean removeLastOccurrence(Object o)</code></td>\n<td>从双端队列中移除最后一次出现的指定元素。</td>\n</tr>\n<tr>\n<td><code>void push(E e)</code></td>\n<td>将元素推入双端队列的开头。</td>\n</tr>\n<tr>\n<td><code>E pop()</code></td>\n<td>从双端队列的开头弹出一个元素。</td>\n</tr>\n<tr>\n<td><code>boolean remove(Object o)</code></td>\n<td>从双端队列中移除指定元素的第一个匹配项。</td>\n</tr>\n<tr>\n<td><code>boolean contains(Object o)</code></td>\n<td>检查双端队列是否包含指定元素。</td>\n</tr>\n<tr>\n<td><code>int size()</code></td>\n<td>返回双端队列中的元素数量。</td>\n</tr>\n<tr>\n<td><code>boolean isEmpty()</code></td>\n<td>检查双端队列是否为空。</td>\n</tr>\n<tr>\n<td><code>void clear()</code></td>\n<td>移除双端队列中的所有元素。</td>\n</tr>\n<tr>\n<td><code>boolean containsAll(Collection&lt;?&gt; c)</code></td>\n<td>检查双端队列是否包含指定集合中的所有元素。</td>\n</tr>\n<tr>\n<td><code>boolean addAll(Collection&lt;? extends E&gt; c)</code></td>\n<td>将指定集合中的所有元素添加到双端队列的末尾。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"代码示例-5\">代码示例</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ConcurrentLinkedDeque;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConcurrentLinkedDequeExample</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建 ConcurrentLinkedDeque 实例</span></span><br><span class=\"line\">        ConcurrentLinkedDeque&lt;String&gt; deque = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentLinkedDeque</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 添加元素到双端队列</span></span><br><span class=\"line\">        deque.addFirst(<span class=\"string\">&quot;Apple&quot;</span>);</span><br><span class=\"line\">        deque.addLast(<span class=\"string\">&quot;Banana&quot;</span>);</span><br><span class=\"line\">        deque.addLast(<span class=\"string\">&quot;Orange&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取双端队列元素数量</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;双端队列元素数量: &quot;</span> + deque.size());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 检查双端队列是否为空</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;双端队列是否为空: &quot;</span> + deque.isEmpty());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取并移除双端队列头部元素</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">head</span> <span class=\"operator\">=</span> deque.pollFirst();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;移除的双端队列头部元素: &quot;</span> + head);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取双端队列头部元素</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">newHead</span> <span class=\"operator\">=</span> deque.peekFirst();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;新的双端队列头部元素: &quot;</span> + newHead);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取双端队列尾部元素</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">tail</span> <span class=\"operator\">=</span> deque.peekLast();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;双端队列尾部元素: &quot;</span> + tail);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 打印双端队列元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;双端队列元素: &quot;</span> + deque);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","content_text":"摘要 本文介绍并发容器相关技术 本文基于jdk1.8 并发容器 Java的集合容器框架中，主要有四大类别：List、Set、Queue、Map，大家熟知的这些集合类ArrayList、LinkedList、HashMap等这些容器都是非线程安全的。 为了保证线程安全，所以java提供了同步容器，可以简单地理解为通过synchronized来实现同步的容器，比如Vector、Hashtable以及SynchronizedList等容器，这样做的代价是削弱了并发性，当多个线程共同竞争容器级的锁时，吞吐量就会降低。 因此为了解决同步容器的性能问题，所以才有了并发容器，java.util.concurrent包中提供了多种并发类容器： 并发容器 对应的非并发容器 代替的同步容器 实现原理 应用场景 CopyOnWriteArrayList ArrayList Vector、synchronizedList CopyOnWriteArrayList 内部使用了一种称为“写时复制”的机制。当需要进行写操作时，它会创建一个新的数组，并将原始数组的内容复制到新数组中，然后进行写操作。一旦修改完成，新的副本会替代原始数组，成为新的数据源。因此，读操作不会被写操作阻塞，读操作返回的结果可能不是最新的，但是对于许多应用场景来说，这是可以接受的。此外，由于读操作不需要加锁，因此它可以支持更高的并发度。需要注意的是，虽然副本会替代原始数组，但是这个替代并不是立即发生的。在修改操作期间，读操作仍然可能会访问原始数组。只有当修改完成后，才会将新的副本设置为源数组。 1. 读多写少的场景由于 CopyOnWriteArrayList 的读操作不需要加锁，因此它非常适合在读多写少的场景中使用。例如，一个读取频率比写入频率高得多的缓存，使用 CopyOnWriteArrayList 可以提高读取性能，并减少锁竞争的开销。2. 不需要实时更新的数据由于 CopyOnWriteArrayList 读取的数据可能不是最新的，因此它适合于不需要实时更新的数据。例如，在日志应用中，为了保证应用的性能，日志记录的操作可能被缓冲，并不是实时写入文件系统，而是在某个时刻批量写入。这种情况下，使用 CopyOnWriteArrayList 可以避免多个线程之间的竞争，提高应用的性能。注意：由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致 young gc 或者full gc，谨慎使用 CopyOnWriteArraySet HashSet synchronizedSet 基于CopyOnWriteArrayList实现，其唯一的不同是在add时调用的是CopyOnWriteArrayList的addIfAbsent方法，其遍历当前Object数组，如Object数组中已有了当前元素，则直接返回，如果没有则放入Object数组的尾部，并返回。 同CopyOnWriteArrayList ConcurrentHashMap HashMap Hashtable、synchronizedMap 在JDK1.8之前，ConcurrentHashMap使用分段锁以在保证线程安全的同时获得更大的效率。JDK1.8开始舍弃了分段锁，使用自旋+CAS+synchronized关键字来实现同步。这样做的好处：1.节省内存空间 ，分段锁需要更多的内存空间，而大多数情况下，并发粒度达不到设置的粒度，竞争概率较小，反而导致更新的长时间等待（因为锁定一段后整个段就无法更新了）2.提高GC效率。 1.共享数据的线程安全：在多线程编程中，如果需要进行共享数据的读写，可以使用 ConcurrentHashMap 保证线程安全。2. 缓存：ConcurrentHashMap 的高并发性能和线程安全能力，使其成为一种很好的缓存实现方案。在多线程环境下，使用 ConcurrentHashMap 作为缓存的数据结构，能够提高程序的并发性能，同时保证数据的一致性。 ConcurrentSkipListMap TreeMap synchronizedSortedMap(TreeMap) 基于Skip list（跳表）实现的有序映射（Map）数据结构，是一种可以代替平衡树的数据结构，默认是按照Key值升序的。 ConcurrentSkipListMap适用于需要高并发性能、支持有序性和区间查询的场景，能够有效地提高系统的性能和可扩展性。 ConcurrentLinkedQueue LinkedList LinkedBlockingQueue ConcurrentLinkedQueue 基于无锁算法和乐观并发策略，旨在提供高效的并发操作。它使用一个单向链表数据结构来存储元素，并且保持了先进先出（FIFO）的顺序。ConcurrentLinkedQueue 是一个无界队列，它没有固定的容量限制。可以根据需要动态地增长或缩小链表的长度。需要注意的是，ConcurrentLinkedQueue 并不适合在迭代过程中进行修改操作，因为它的结构在并发情况下可能会发生变化。 1.高并发环境：ConcurrentLinkedQueue 适用于需要高并发性能和线程安全的场景。由于它采用无锁算法和乐观并发策略，可以在高并发环境下提供较高的吞吐量。2.生产者-消费者模式：ConcurrentLinkedQueue 在实现生产者-消费者模式时非常有用。生产者线程可以将元素添加到队列的尾部，而消费者线程可以从队列的头部获取元素，实现了解耦和并发处理。3.任务调度：ConcurrentLinkedQueue 可以作为任务调度的数据结构，用于存储待执行的任务。多个线程可以从队列中获取任务并执行，从而实现任务的并发处理。 ConcurrentLinkedDeque LinkedList 无 与ConcurrentLinkedQueue 相比 ConcurrentLinkedDeque 是基于双向链表实现的并发双端队列。它支持在队头和队尾进行插入和移除操作，保持了元素的先进先出顺序。 ConcurrentLinkedDeque 适用于需要双端操作的并发场景，例如生产者-消费者模式中的多线程同时插入和移除元素的场景。 CopyOnWriteArrayList 方法 描述 int size() 返回列表中的元素数量。 boolean isEmpty() 检查列表是否为空。 boolean contains(Object o) 检查列表是否包含指定元素。 Iterator&lt;E&gt; iterator() 返回一个迭代器，用于遍历列表中的元素。 boolean add(E e) 将元素添加到列表末尾。 boolean remove(Object o) 从列表中移除指定元素的第一个匹配项。 boolean containsAll(Collection&lt;?&gt; c) 检查列表是否包含指定集合中的所有元素。 boolean addAll(Collection&lt;? extends E&gt; c) 将指定集合中的所有元素添加到列表末尾。 boolean addAll(int index, Collection&lt;? extends E&gt; c) 将指定集合中的所有元素插入到列表的指定位置。 boolean removeAll(Collection&lt;?&gt; c) 移除列表中与指定集合中的元素相匹配的所有元素。 boolean retainAll(Collection&lt;?&gt; c) 仅保留列表中与指定集合中的元素相匹配的元素，移除其他元素。 void clear() 清空列表中的所有元素。 E get(int index) 返回列表中指定位置的元素。 E set(int index, E element) 用指定元素替换列表中指定位置的元素，并返回原来的元素。 void add(int index, E element) 在列表的指定位置插入指定元素。 E remove(int index) 移除列表中指定位置的元素，并返回被移除的元素。 int indexOf(Object o) 返回指定元素在列表中首次出现的位置索引，如果不存在，则返回 -1。 int lastIndexOf(Object o) 返回指定元素在列表中最后一次出现的位置索引，如果不存在，则返回 -1。 小贴士 迭代器的 fail-fast 与 fail-safe 机制 在 Java 中，迭代器（Iterator）在迭代的过程中，如果底层的集合被修改（添加或删除元素），不同的迭代器对此的表现行为是不一样的，可分为两类：Fail-Fast（快速失败）和 Fail-Safe（安全失败）。 fail-fast 机制 fail-fast 机制是java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生 fail-fast 事件。例如：当某一个线程A通过 iterator 去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生 fail-fast 事件。 在 java.util 包中的集合，如 ArrayList、HashMap 等，它们的迭代器默认都是采用 Fail-Fast 机制。 fail-fast解决方案 方案一：在遍历过程中所有涉及到改变modCount 值的地方全部加上synchronized 或者直接使用Collection#synchronizedList，这样就可以解决问题，但是不推荐，因为增删造成的同步锁可能会阻塞遍历操作。 方案二：使用CopyOnWriteArrayList 替换 ArrayList，推荐使用该方案（即fail-safe）。 fail-safe机制 任何对集合结构的修改都会在一个复制的集合上进行，因此不会抛出ConcurrentModificationException。在 java.util.concurrent 包中的集合，如CopyOnWriteArrayList、ConcurrentHashMap 等，它们的迭代器一般都是采用 Fail-Safe 机制。 缺点： 采用 Fail-Safe 机制的集合类都是线程安全的，但是它们无法保证数据的实时一致性，它们只能保证数据的最终一致性。在迭代过程中，如果集合被修改了，可能读取到的仍然是旧的数据。 Fail-Safe 机制还存在另外一个问题，就是内存占用。由于这类集合一般都是通过复制来实现读写分离的，因此它们会创建出更多的对象，导致占用更多的内存，甚至可能引起频繁的垃圾回收，严重影响性能 CopyOnWriteArraySet 方法 描述 int size() 返回集合中的元素数量。 boolean isEmpty() 检查集合是否为空。 boolean contains(Object o) 检查集合是否包含指定的元素。 boolean add(E e) 将指定元素添加到集合中。 boolean remove(Object o) 从集合中移除指定元素。 void clear() 清空集合中的所有元素。 Iterator&lt;E&gt; iterator() 返回在集合上进行迭代的迭代器。 boolean containsAll(Collection&lt;?&gt; c) 检查集合是否包含指定集合中的所有元素。 boolean addAll(Collection&lt;? extends E&gt; c) 将指定集合中的所有元素添加到集合中。 boolean removeAll(Collection&lt;?&gt; c) 从集合中移除指定集合中包含的所有元素。 boolean retainAll(Collection&lt;?&gt; c) 仅保留集合中包含在指定集合中的元素，移除其他元素。 CopyOnWriteArraySet与CopyOnWriteArrayList的区别 数据结构类型：CopyOnWriteArraySet 是一个基于数组的集合，而 CopyOnWriteArrayList 是一个基于数组的列表。 元素的唯一性：CopyOnWriteArraySet 保证集合中的元素是唯一的，不允许重复元素的存在。而 CopyOnWriteArrayList 允许列表中存在重复元素。 集合与列表的特性：CopyOnWriteArraySet 实现了 Set 接口，它是一个无序的集合，不保留插入顺序。CopyOnWriteArrayList 实现了 List 接口，它是一个有序的列表，保留插入顺序。 代码示例 1234567891011121314151617181920212223// 创建 CopyOnWriteArraySet 实例CopyOnWriteArraySet&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;();// 添加元素set.add(&quot;Apple&quot;);set.add(&quot;Banana&quot;);set.add(&quot;Orange&quot;);set.add(&quot;Grapes&quot;);// 打印集合元素，可能得到的输出：[Apple, Banana, Grapes, Orange]System.out.println(&quot;集合元素: &quot; + set);// 创建 CopyOnWriteArrayList 实例CopyOnWriteArrayList&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();// 添加元素list.add(&quot;Apple&quot;);list.add(&quot;Banana&quot;);list.add(&quot;Orange&quot;);list.add(&quot;Grapes&quot;);// 打印列表元素，得到的输出：[Apple, Banana, Orange, Grapes]System.out.println(&quot;列表元素: &quot; + list); ConcurrentHashMap 方法 描述 int size() 返回映射中的键值对数量。 boolean isEmpty() 检查映射是否为空。 boolean containsKey(Object key) 检查映射是否包含指定的键。 boolean containsValue(Object value) 检查映射是否包含指定的值。 V get(Object key) 获取与指定键关联的值。 V put(K key, V value) 将指定的键值对添加到映射中。 V remove(Object key) 从映射中移除指定键的映射关系，并返回对应的值。 void clear() 清空映射中的所有键值对。 Set&lt;K&gt; keySet() 返回映射中所有键的集合。 Collection&lt;V&gt; values() 返回映射中所有值的集合。 Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet() 返回映射中所有键值对的集合。 V putIfAbsent(K key, V value) 当指定的键尚未映射到值时，将指定的键值对添加到映射中。 boolean remove(Object key, Object value) 从映射中移除指定键值对。 boolean replace(K key, V oldValue, V newValue) 用新的值替换指定键的旧值，仅当当前值与指定的旧值相等时才替换。 V replace(K key, V value) 用指定值替换指定键的值。 JDK1.7 中的ConcurrentHashMap 在jdk1.7及其以下的版本中，结构是用Segments数组 + HashEntry数组 + 链表实现的 JDK1.8中的ConcurrentHashMap jdk1.8抛弃了Segments分段锁的方案，而是改用了和HashMap一样的结构操作，也就是数组 + 链表+ 红黑树结构，比jdk1.7中的ConcurrentHashMap提高了效率，在并发方面，使用了cas +synchronized的方式保证数据的一致性 链表转化为红黑树需要满足2个条件: 1.链表的节点数量大于等于树化阈值8 2.Node数组的长度大于等于最小树化容量值64 代码示例 1234567891011121314151617181920212223242526272829303132import java.util.concurrent.ConcurrentHashMap;public class ConcurrentHashMapExample &#123; public static void main(String[] args) &#123; // 创建 ConcurrentHashMap 实例 ConcurrentHashMap&lt;String, Integer&gt; map = new ConcurrentHashMap&lt;&gt;(); // 添加键值对 map.put(&quot;Apple&quot;, 3); map.put(&quot;Banana&quot;, 1); map.put(&quot;Orange&quot;, 2); map.put(&quot;Grapes&quot;, 4); // 打印映射内容，映射内容: &#123;Banana=1, Grapes=4, Orange=2, Apple=3&#125; System.out.println(&quot;映射内容: &quot; + map); // 获取键值对数量 System.out.println(&quot;键值对数量: &quot; + map.size()); // 检查是否包含指定键 System.out.println(&quot;是否包含键 &#x27;Orange&#x27;: &quot; + map.containsKey(&quot;Orange&quot;)); // 获取指定键对应的值 System.out.println(&quot;键 &#x27;Apple&#x27; 对应的值: &quot; + map.get(&quot;Apple&quot;)); // 移除指定键的映射关系 map.remove(&quot;Banana&quot;); // 打印映射内容 System.out.println(&quot;移除键 &#x27;Banana&#x27; 后的映射内容: &quot; + map); &#125;&#125; ConcurrentSkipListMap ConcurrentSkipListMap 和 ConcurrentHashMap 是 Java 中用于并发访问的映射数据结构，它们之间有一些区别 数据结构：ConcurrentSkipListMap 是基于跳表（Skip List）的数据结构实现，而 ConcurrentHashMap 是基于数组 + 链表+ 红黑树的数据结构实现。 排序性：ConcurrentSkipListMap 是有序映射，按照键的自然顺序或自定义的比较器对键进行排序。而 ConcurrentHashMap 是无序映射，不保证键值对的顺序。 并发访问性能：在高度并发的情况下，ConcurrentSkipListMap 在读取方面的性能较好，因为它支持并发读取操作，并且有序结构使得读取更高效。而 ConcurrentHashMap 在写入方面的性能较好，因为它使用cas +synchronized来支持并发写入操作。 内存占用：通常情况下，ConcurrentSkipListMap 的内存占用比 ConcurrentHashMap 更高，因为它需要额外的存储空间来维护跳表结构。 功能特性：由于有序性的特点，ConcurrentSkipListMap 提供了一些与顺序相关的方法，如 firstKey()、lastKey()、subMap() 等。 方法 描述 K firstKey() 返回映射中的第一个键。 K lastKey() 返回映射中的最后一个键。 ConcurrentNavigableMap&lt;K, V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) 返回一个视图，该视图包含映射中键的子范围。 ConcurrentNavigableMap&lt;K, V&gt; headMap(K toKey, boolean inclusive) 返回一个视图，该视图包含映射中小于（或小于等于）给定键的部分。 ConcurrentNavigableMap&lt;K, V&gt; tailMap(K fromKey, boolean inclusive) 返回一个视图，该视图包含映射中大于（或大于等于）给定键的部分。 ConcurrentNavigableMap&lt;K, V&gt; descendingMap() 返回与此映射相反的顺序的视图。 ConcurrentNavigableSet&lt;K&gt; navigableKeySet() 返回包含映射中所有键的并发可导航集合。 ConcurrentNavigableSet&lt;K&gt; descendingKeySet() 返回与此映射中的键相反顺序对应的并发可导航集合。 代码示例 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.concurrent.ConcurrentSkipListMap;public class ConcurrentSkipListMapExample &#123; public static void main(String[] args) &#123; // 创建 ConcurrentSkipListMap 实例 ConcurrentSkipListMap&lt;Integer, String&gt; map = new ConcurrentSkipListMap&lt;&gt;(); // 添加键值对 map.put(3, &quot;Apple&quot;); map.put(1, &quot;Banana&quot;); map.put(2, &quot;Orange&quot;); map.put(4, &quot;Grapes&quot;); // 打印映射内容，映射内容: &#123;1=Banana, 2=Orange, 3=Apple, 4=Grapes&#125; System.out.println(&quot;映射内容: &quot; + map); // 获取键值对数量 System.out.println(&quot;键值对数量: &quot; + map.size()); // 检查是否包含指定键 System.out.println(&quot;是否包含键 2: &quot; + map.containsKey(2)); // 获取指定键对应的值 System.out.println(&quot;键 3 对应的值: &quot; + map.get(3)); // 移除指定键的映射关系 map.remove(1); // 打印映射内容 System.out.println(&quot;移除键 1 后的映射内容: &quot; + map); // 获取最小的键 System.out.println(&quot;最小的键: &quot; + map.firstKey()); // 获取最大的键 System.out.println(&quot;最大的键: &quot; + map.lastKey()); // 获取键小于等于 3 的子映射 ConcurrentSkipListMap&lt;Integer, String&gt; subMap = map.headMap(3, true); System.out.println(&quot;键小于等于 3 的子映射: &quot; + subMap); &#125;&#125; 小贴士 跳表 跳表（Skip List）是一种用于实现有序集合的数据结构，它的设计灵感来自于平衡树。跳表通过使用多层链表结构，每一层链表按照升序排列，并且每一层链表都是前一层链表的子集。这样的结构允许在搜索、插入和删除元素时具有较高的效率。 跳表的核心思想是通过建立索引层来加快搜索的速度。最底层是原始链表，每个节点都包含一个元素。而上层的链表是通过原始链表中的一部分节点创建的。在每一层中，节点以一定的概率被提升到更高层，从而形成了跨越多个层级的链接。 跳表的主要优点是在具有合理的设计和维护下，可以在平均情况下以 O(log n) 的时间复杂度执行搜索、插入和删除操作。这是因为每一层的节点数量是下一层的节点数量的一半，从而形成了一种对数级别的分布。 以下是跳表的主要操作： 搜索：从顶层开始，沿着每一层的链表进行比较，如果目标元素大于当前节点的值，则在当前层继续向右移动；如果目标元素小于当前节点的值，则退回到下一层继续比较。直到找到目标元素或者无法再继续向右或下移动。 插入：通过搜索找到插入位置后，在每一层链表中插入新节点，并更新相应的索引层。 删除：通过搜索找到要删除的节点位置后，在每一层链表中删除节点，并更新相应的索引层。 跳表的实现相对简单，它提供了在有序集合中进行快速搜索和更新的高效方式。然而，它的空间复杂度相对于平衡树较高，因为需要维护额外的索引层。跳表在并发环境下也需要考虑同步的问题，以确保数据的一致性和线程安全性。 总结而言，跳表通过建立多层索引结构，在有序集合中实现了较快的搜索、插入和删除操作。它是一种简单而高效的数据结构，在一些场景中可以作为替代平衡树的选择。 ConcurrentLinkedQueue 方法 描述 boolean add(E e) 将指定元素添加到队列的尾部。 boolean offer(E e) 将指定元素添加到队列的尾部。 E poll() 获取并移除队列的头部元素。 E peek() 获取队列的头部元素，但不移除。 int size() 返回队列中的元素数量。 boolean isEmpty() 检查队列是否为空。 boolean contains(Object o) 检查队列是否包含指定元素。 boolean remove(Object o) 从队列中移除指定元素的第一个匹配项。 void clear() 移除队列中的所有元素。 boolean containsAll(Collection&lt;?&gt; c) 检查队列是否包含指定集合中的所有元素。 boolean addAll(Collection&lt;? extends E&gt; c) 将指定集合中的所有元素添加到队列的尾部。 boolean removeAll(Collection&lt;?&gt; c) 从队列中移除包含在指定集合中的所有元素。 boolean retainAll(Collection&lt;?&gt; c) 仅保留队列中包含在指定集合中的元素，移除其他元素。 代码示例 123456789101112131415161718192021222324252627282930import java.util.concurrent.ConcurrentLinkedQueue;public class ConcurrentLinkedQueueExample &#123; public static void main(String[] args) &#123; // 创建 ConcurrentLinkedQueue 实例 ConcurrentLinkedQueue&lt;String&gt; queue = new ConcurrentLinkedQueue&lt;&gt;(); // 添加元素到队列 queue.add(&quot;Apple&quot;); queue.add(&quot;Banana&quot;); queue.add(&quot;Orange&quot;); // 获取队列元素数量 System.out.println(&quot;队列元素数量: &quot; + queue.size()); // 检查队列是否为空 System.out.println(&quot;队列是否为空: &quot; + queue.isEmpty()); // 获取并移除队列头部元素 String head = queue.poll(); System.out.println(&quot;移除的队列头部元素: &quot; + head); // 获取队列头部元素 String newHead = queue.peek(); System.out.println(&quot;新的队列头部元素: &quot; + newHead); // 打印队列元素 System.out.println(&quot;队列元素: &quot; + queue); &#125;&#125; ConcurrentLinkedDeque 方法 描述 void addFirst(E e) 将指定元素插入到双端队列的开头。 void addLast(E e) 将指定元素插入到双端队列的末尾。 boolean offerFirst(E e) 将指定元素插入到双端队列的开头。如果成功则返回 true，否则返回 false。 boolean offerLast(E e) 将指定元素插入到双端队列的末尾。如果成功则返回 true，否则返回 false。 E pollFirst() 获取并移除双端队列的开头元素。 E pollLast() 获取并移除双端队列的末尾元素。 E peekFirst() 获取双端队列的开头元素，但不移除。 E peekLast() 获取双端队列的末尾元素，但不移除。 boolean removeFirstOccurrence(Object o) 从双端队列中移除首次出现的指定元素。 boolean removeLastOccurrence(Object o) 从双端队列中移除最后一次出现的指定元素。 void push(E e) 将元素推入双端队列的开头。 E pop() 从双端队列的开头弹出一个元素。 boolean remove(Object o) 从双端队列中移除指定元素的第一个匹配项。 boolean contains(Object o) 检查双端队列是否包含指定元素。 int size() 返回双端队列中的元素数量。 boolean isEmpty() 检查双端队列是否为空。 void clear() 移除双端队列中的所有元素。 boolean containsAll(Collection&lt;?&gt; c) 检查双端队列是否包含指定集合中的所有元素。 boolean addAll(Collection&lt;? extends E&gt; c) 将指定集合中的所有元素添加到双端队列的末尾。 代码示例 12345678910111213141516171819202122232425262728293031323334import java.util.concurrent.ConcurrentLinkedDeque;public class ConcurrentLinkedDequeExample &#123; public static void main(String[] args) &#123; // 创建 ConcurrentLinkedDeque 实例 ConcurrentLinkedDeque&lt;String&gt; deque = new ConcurrentLinkedDeque&lt;&gt;(); // 添加元素到双端队列 deque.addFirst(&quot;Apple&quot;); deque.addLast(&quot;Banana&quot;); deque.addLast(&quot;Orange&quot;); // 获取双端队列元素数量 System.out.println(&quot;双端队列元素数量: &quot; + deque.size()); // 检查双端队列是否为空 System.out.println(&quot;双端队列是否为空: &quot; + deque.isEmpty()); // 获取并移除双端队列头部元素 String head = deque.pollFirst(); System.out.println(&quot;移除的双端队列头部元素: &quot; + head); // 获取双端队列头部元素 String newHead = deque.peekFirst(); System.out.println(&quot;新的双端队列头部元素: &quot; + newHead); // 获取双端队列尾部元素 String tail = deque.peekLast(); System.out.println(&quot;双端队列尾部元素: &quot; + tail); // 打印双端队列元素 System.out.println(&quot;双端队列元素: &quot; + deque); &#125;&#125;","summary":"摘要 本文介绍并发容器相关技术 本文基于jdk1.8","date_published":"2023-05-24T14:34:05.000Z","tags":["技术","java","java多线程","java"]},{"id":"https://blog.hanqunfeng.com/2023/05/23/java-concurrency08-LockSupport/","url":"https://blog.hanqunfeng.com/2023/05/23/java-concurrency08-LockSupport/","title":"Java并发编程--JUC并发工具类之LockSupport","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度 ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍LockSupport相关技术</p>\n</li>\n<li class=\"lvl-2\">\n<p>本文基于<code>jdk1.8</code></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"LockSupport介绍\">LockSupport介绍</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>LockSupport</code>是Java并发工具类中的一个重要成员。它提供了一种基于线程的阻塞和唤醒机制，使得线程可以在特定条件下暂停和继续执行。</p>\n</li>\n<li class=\"lvl-2\">\n<p>与传统的<code>wait()</code>和<code>notify()</code>方法相比，<code>LockSupport</code>具有以下优势：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">精准的线程阻塞和唤醒：<br>\n<code>LockSupport</code>提供了精确控制线程阻塞和唤醒的能力。通过调用<code>LockSupport</code>类的<code>park()</code>方法，线程可以主动进入阻塞状态，直到其他线程调用了相应线程的<code>unpark()</code>方法才能被唤醒。相比之下，<code>wait()</code>和<code>notify()</code>方法的使用需要依赖于对象的监视器（monitor），并且无法指定特定的线程进行唤醒。</li>\n<li class=\"lvl-6\">不依赖于对象的监视器：<br>\n传统的<code>wait()</code>和<code>notify()</code>方法需要依赖于对象的监视器（monitor），即在synchronized块中调用。这种依赖关系可能导致代码结构上的限制，而<code>LockSupport</code>则不依赖于特定的对象，可以在任何位置进行线程的阻塞和唤醒操作。</li>\n<li class=\"lvl-6\">避免死锁问题：<br>\n在使用<code>wait()</code>和<code>notify()</code>方法时，由于需要依赖于对象的监视器，可能会出现死锁问题，例如线程A等待线程B的通知，而线程B也在等待线程A的通知，导致双方无法继续执行。<code>LockSupport</code>通过给每个线程关联一个许可（<code>permit</code>）来避免死锁问题，即使在<code>park()</code>和<code>unpark()</code>方法的调用顺序上没有特定的要求。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>总体而言，<code>LockSupport</code>是一种强大而灵活的线程阻塞和唤醒机制，能够满足并发编程中的各种需求。它的设计理念与传统的<code>wait()</code>和<code>notify()</code>方法有所不同，提供了更加直观和可控的线程调度方式。然而，在使用<code>LockSupport</code>时，仍需谨慎处理线程的阻塞和唤醒逻辑，以避免潜在的并发问题。</p>\n</li>\n</ul>\n<h2 id=\"LockSupport-API说明\">LockSupport API说明</h2>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>void park()</code></td>\n<td>阻塞当前线程，直到被唤醒</td>\n</tr>\n<tr>\n<td><code>void park(Object blocker)</code></td>\n<td>阻塞当前线程，并关联一个阻塞对象</td>\n</tr>\n<tr>\n<td><code>void parkNanos(long nanos)</code></td>\n<td>阻塞当前线程，最多等待指定纳秒时间</td>\n</tr>\n<tr>\n<td><code>void parkNanos(Object blocker, long nanos)</code></td>\n<td>阻塞当前线程，并关联一个阻塞对象，最多等待指定纳秒时间</td>\n</tr>\n<tr>\n<td><code>void parkUntil(long deadline)</code></td>\n<td>阻塞当前线程，直到指定的绝对时间点</td>\n</tr>\n<tr>\n<td><code>void parkUntil(Object blocker, long deadline)</code></td>\n<td>阻塞当前线程，并关联一个阻塞对象，直到指定的绝对时间点</td>\n</tr>\n<tr>\n<td><code>void unpark(Thread thread)</code></td>\n<td>唤醒指定的线程</td>\n</tr>\n<tr>\n<td><code>Object getBlocker(Thread thread)</code></td>\n<td>获取指定线程关联的阻塞对象</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>其中，<code>park()</code>和<code>unpark()</code>是最常用的方法，用于线程的阻塞和唤醒操作。</p>\n</li>\n<li class=\"lvl-2\">\n<p>其他方法提供了更多灵活的线程阻塞和唤醒方式，如指定阻塞对象、等待一定时间等。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>getBlocker()</code>方法可以获取指定线程关联的阻塞对象，以便进行进一步的操作或分析。</p>\n</li>\n</ul>\n<h2 id=\"代码示例\">代码示例</h2>\n<h3 id=\"示例1–park-和unpark\">示例1–<code>park()</code>和<code>unpark()</code></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LockSupportExample</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">thread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">WorkerThread</span>());</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 主线程暂停一段时间</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 唤醒WorkerThread线程</span></span><br><span class=\"line\">        LockSupport.unpark(thread);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WorkerThread</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;WorkerThread started&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 线程阻塞</span></span><br><span class=\"line\">            LockSupport.park();</span><br><span class=\"line\"></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;WorkerThread resumed&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在这个示例中，我们创建了一个<code>WorkerThread</code>线程，并在主线程中启动它。主线程在启动<code>WorkerThread</code>后暂停了<code>2</code>秒钟，然后通过调用<code>LockSupport.unpark()</code>方法唤醒了<code>WorkerThread</code>线程。<code>WorkerThread</code>线程在<code>run()</code>方法中调用<code>LockSupport.park()</code>进入阻塞状态，直到被唤醒才会继续执行。执行结果会打印出&quot;WorkerThread started&quot;和&quot;WorkerThread resumed&quot;。</p>\n</li>\n</ul>\n<h3 id=\"示例2–park-Object-blocker-和getBlocker-Thread-thread\">示例2–<code>park(Object blocker)</code>和<code>getBlocker(Thread thread)</code></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ParkBlockerExample</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">blocker</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>(); <span class=\"comment\">// 创建一个阻塞对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">thread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Thread is parking...&quot;</span>);</span><br><span class=\"line\">            LockSupport.park(blocker); <span class=\"comment\">// 阻塞当前线程，并关联阻塞对象</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Thread is unparked&quot;</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取并输出关联的阻塞对象</span></span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">associatedBlocker</span> <span class=\"operator\">=</span> LockSupport.getBlocker(thread);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Associated blocker: &quot;</span> + associatedBlocker);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 唤醒线程</span></span><br><span class=\"line\">        LockSupport.unpark(thread);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在上述示例中，我们创建了一个阻塞对象<code>blocker</code>。在thread线程中，我们调用<code>LockSupport.park(blocker)</code>方法阻塞当前线程，并将阻塞对象与线程关联。</p>\n</li>\n<li class=\"lvl-2\">\n<p>在主线程中，我们使用<code>LockSupport.getBlocker(thread)</code>方法获取与线程关联的阻塞对象，并输出它。</p>\n</li>\n</ul>\n<h3 id=\"park方法中阻塞对象的作用\">park方法中阻塞对象的作用</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当调用<code>LockSupport的park()</code>方法时，线程将被阻塞，等待被唤醒。<code>park(Object blocker)</code>方法是<code>park()</code>方法的一个重载形式，它允许您将一个阻塞对象与当前线程相关联。绑定阻塞对象的作用在于更好地识别和监控线程的阻塞原因。</p>\n</li>\n<li class=\"lvl-2\">\n<p>当线程被阻塞时，可以通过调用<code>getBlocker(Thread thread)</code>方法来获取与该线程相关联的阻塞对象。这样，您可以在代码中根据阻塞对象进行更精确的条件判断、监控或其他操作。</p>\n</li>\n<li class=\"lvl-2\">\n<p>以下是一些使用场景的例子，说明绑定阻塞对象的作用：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">调试和诊断：当多个线程被阻塞时，可以使用阻塞对象来确定具体是哪个线程被阻塞，以及被阻塞的原因。通过获取阻塞对象，您可以在调试过程中定位问题，并根据阻塞对象的不同采取相应的调试措施。</li>\n<li class=\"lvl-6\">更精确的控制和唤醒：通过关联特定的阻塞对象，您可以在需要唤醒线程时，只选择唤醒与该阻塞对象相关联的线程。这种精确的唤醒机制可以避免不必要的线程唤醒，提高系统的性能和效率。</li>\n<li class=\"lvl-6\">条件等待：在某些情况下，您可能希望线程在特定条件下被阻塞，直到满足某个条件后才被唤醒。通过绑定阻塞对象，您可以根据不同的条件选择不同的阻塞对象，从而实现对不同条件的精确等待和唤醒。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>绑定阻塞对象的作用是提供更多的上下文信息，帮助您更好地理解和控制线程的阻塞状态。它可以作为一种辅助手段，用于更精确地调试、监控和控制线程的行为。</p>\n</li>\n</ul>\n<h2 id=\"ReentrantLock的阻塞唤醒机制是基于LockSupport实现的\">ReentrantLock的阻塞唤醒机制是基于LockSupport实现的</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>ReentrantLock</code>是Java中提供的可重入锁的实现，它使用了内部类<code>Sync</code>来管理锁的状态和线程的阻塞与唤醒。<code>Sync</code>类内部使用了<code>LockSupport</code>工具类来实现线程的阻塞和唤醒操作。</p>\n</li>\n<li class=\"lvl-2\">\n<p>当一个线程无法获取到<code>ReentrantLock</code>的锁时，它会被阻塞，并且进入等待状态，在这种情况下，<code>ReentrantLock</code>内部会调用<code>LockSupport.park()</code>方法阻塞当前线程。</p>\n</li>\n<li class=\"lvl-2\">\n<p>当其他线程释放了锁或者调用了<code>ReentrantLock</code>的<code>unlock()</code>方法时，被阻塞的线程将会被唤醒，此时<code>ReentrantLock</code>会通过调用<code>LockSupport.unpark()</code>方法来唤醒被阻塞的线程。</p>\n</li>\n</ul>\n","content_text":"摘要 本文介绍LockSupport相关技术 本文基于jdk1.8 LockSupport介绍 LockSupport是Java并发工具类中的一个重要成员。它提供了一种基于线程的阻塞和唤醒机制，使得线程可以在特定条件下暂停和继续执行。 与传统的wait()和notify()方法相比，LockSupport具有以下优势： 精准的线程阻塞和唤醒： LockSupport提供了精确控制线程阻塞和唤醒的能力。通过调用LockSupport类的park()方法，线程可以主动进入阻塞状态，直到其他线程调用了相应线程的unpark()方法才能被唤醒。相比之下，wait()和notify()方法的使用需要依赖于对象的监视器（monitor），并且无法指定特定的线程进行唤醒。 不依赖于对象的监视器： 传统的wait()和notify()方法需要依赖于对象的监视器（monitor），即在synchronized块中调用。这种依赖关系可能导致代码结构上的限制，而LockSupport则不依赖于特定的对象，可以在任何位置进行线程的阻塞和唤醒操作。 避免死锁问题： 在使用wait()和notify()方法时，由于需要依赖于对象的监视器，可能会出现死锁问题，例如线程A等待线程B的通知，而线程B也在等待线程A的通知，导致双方无法继续执行。LockSupport通过给每个线程关联一个许可（permit）来避免死锁问题，即使在park()和unpark()方法的调用顺序上没有特定的要求。 总体而言，LockSupport是一种强大而灵活的线程阻塞和唤醒机制，能够满足并发编程中的各种需求。它的设计理念与传统的wait()和notify()方法有所不同，提供了更加直观和可控的线程调度方式。然而，在使用LockSupport时，仍需谨慎处理线程的阻塞和唤醒逻辑，以避免潜在的并发问题。 LockSupport API说明 方法 描述 void park() 阻塞当前线程，直到被唤醒 void park(Object blocker) 阻塞当前线程，并关联一个阻塞对象 void parkNanos(long nanos) 阻塞当前线程，最多等待指定纳秒时间 void parkNanos(Object blocker, long nanos) 阻塞当前线程，并关联一个阻塞对象，最多等待指定纳秒时间 void parkUntil(long deadline) 阻塞当前线程，直到指定的绝对时间点 void parkUntil(Object blocker, long deadline) 阻塞当前线程，并关联一个阻塞对象，直到指定的绝对时间点 void unpark(Thread thread) 唤醒指定的线程 Object getBlocker(Thread thread) 获取指定线程关联的阻塞对象 其中，park()和unpark()是最常用的方法，用于线程的阻塞和唤醒操作。 其他方法提供了更多灵活的线程阻塞和唤醒方式，如指定阻塞对象、等待一定时间等。 getBlocker()方法可以获取指定线程关联的阻塞对象，以便进行进一步的操作或分析。 代码示例 示例1–park()和unpark() 123456789101112131415161718192021222324252627282930import java.util.concurrent.locks.LockSupport;public class LockSupportExample &#123; public static void main(String[] args) &#123; Thread thread = new Thread(new WorkerThread()); thread.start(); // 主线程暂停一段时间 try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 唤醒WorkerThread线程 LockSupport.unpark(thread); &#125; static class WorkerThread implements Runnable &#123; @Override public void run() &#123; System.out.println(&quot;WorkerThread started&quot;); // 线程阻塞 LockSupport.park(); System.out.println(&quot;WorkerThread resumed&quot;); &#125; &#125;&#125; 在这个示例中，我们创建了一个WorkerThread线程，并在主线程中启动它。主线程在启动WorkerThread后暂停了2秒钟，然后通过调用LockSupport.unpark()方法唤醒了WorkerThread线程。WorkerThread线程在run()方法中调用LockSupport.park()进入阻塞状态，直到被唤醒才会继续执行。执行结果会打印出&quot;WorkerThread started&quot;和&quot;WorkerThread resumed&quot;。 示例2–park(Object blocker)和getBlocker(Thread thread) 123456789101112131415161718192021222324import java.util.concurrent.locks.LockSupport;public class ParkBlockerExample &#123; public static void main(String[] args) throws InterruptedException &#123; Object blocker = new Object(); // 创建一个阻塞对象 Thread thread = new Thread(() -&gt; &#123; System.out.println(&quot;Thread is parking...&quot;); LockSupport.park(blocker); // 阻塞当前线程，并关联阻塞对象 System.out.println(&quot;Thread is unparked&quot;); &#125;); thread.start(); Thread.sleep(2000); // 获取并输出关联的阻塞对象 Object associatedBlocker = LockSupport.getBlocker(thread); System.out.println(&quot;Associated blocker: &quot; + associatedBlocker); // 唤醒线程 LockSupport.unpark(thread); &#125;&#125; 在上述示例中，我们创建了一个阻塞对象blocker。在thread线程中，我们调用LockSupport.park(blocker)方法阻塞当前线程，并将阻塞对象与线程关联。 在主线程中，我们使用LockSupport.getBlocker(thread)方法获取与线程关联的阻塞对象，并输出它。 park方法中阻塞对象的作用 当调用LockSupport的park()方法时，线程将被阻塞，等待被唤醒。park(Object blocker)方法是park()方法的一个重载形式，它允许您将一个阻塞对象与当前线程相关联。绑定阻塞对象的作用在于更好地识别和监控线程的阻塞原因。 当线程被阻塞时，可以通过调用getBlocker(Thread thread)方法来获取与该线程相关联的阻塞对象。这样，您可以在代码中根据阻塞对象进行更精确的条件判断、监控或其他操作。 以下是一些使用场景的例子，说明绑定阻塞对象的作用： 调试和诊断：当多个线程被阻塞时，可以使用阻塞对象来确定具体是哪个线程被阻塞，以及被阻塞的原因。通过获取阻塞对象，您可以在调试过程中定位问题，并根据阻塞对象的不同采取相应的调试措施。 更精确的控制和唤醒：通过关联特定的阻塞对象，您可以在需要唤醒线程时，只选择唤醒与该阻塞对象相关联的线程。这种精确的唤醒机制可以避免不必要的线程唤醒，提高系统的性能和效率。 条件等待：在某些情况下，您可能希望线程在特定条件下被阻塞，直到满足某个条件后才被唤醒。通过绑定阻塞对象，您可以根据不同的条件选择不同的阻塞对象，从而实现对不同条件的精确等待和唤醒。 绑定阻塞对象的作用是提供更多的上下文信息，帮助您更好地理解和控制线程的阻塞状态。它可以作为一种辅助手段，用于更精确地调试、监控和控制线程的行为。 ReentrantLock的阻塞唤醒机制是基于LockSupport实现的 ReentrantLock是Java中提供的可重入锁的实现，它使用了内部类Sync来管理锁的状态和线程的阻塞与唤醒。Sync类内部使用了LockSupport工具类来实现线程的阻塞和唤醒操作。 当一个线程无法获取到ReentrantLock的锁时，它会被阻塞，并且进入等待状态，在这种情况下，ReentrantLock内部会调用LockSupport.park()方法阻塞当前线程。 当其他线程释放了锁或者调用了ReentrantLock的unlock()方法时，被阻塞的线程将会被唤醒，此时ReentrantLock会通过调用LockSupport.unpark()方法来唤醒被阻塞的线程。","summary":"摘要 本文介绍LockSupport相关技术 本文基于jdk1.8","date_published":"2023-05-23T14:34:05.000Z","tags":["技术","java","java多线程","java"]},{"id":"https://blog.hanqunfeng.com/2023/05/22/java-concurrency07-CyclicBarrier/","url":"https://blog.hanqunfeng.com/2023/05/22/java-concurrency07-CyclicBarrier/","title":"Java并发编程--JUC并发工具类之CyclicBarrier","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度 ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍CyclicBarrier相关技术</p>\n</li>\n<li class=\"lvl-2\">\n<p>本文基于<code>jdk1.8</code></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"CyclicBarrier介绍\">CyclicBarrier介绍</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>CyclicBarrier（回环栅栏或循环屏障），是 Java 并发库中的一个同步工具，通过它可以实现让一组线程等待至某个状态（屏障点）之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。</p>\n</li>\n<li class=\"lvl-2\">\n<p>CyclicBarrier内部维护了一个计数器，当线程到达临界点时，会调用await()方法进行等待。当计数器达到指定的数量时，所有等待的线程都会被释放，并继续执行后续操作。<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/mWTzBf.jpg\" alt=\"\" width=\"900\" height=\"600\"></p>\n</li>\n</ul>\n<h2 id=\"CyclicBarrier的常用方法\">CyclicBarrier的常用方法</h2>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CyclicBarrier(int parties)</td>\n<td>构造函数， parties表示屏障拦截的线程数量，每个线程调用 await 方法告诉 CyclicBarrier 我已经到达了屏</td>\n</tr>\n<tr>\n<td>障，然后当前线程被阻塞。</td>\n<td></td>\n</tr>\n<tr>\n<td>CyclicBarrier(int parties, Runnable barrierAction)</td>\n<td>构造函数，用于在线程到达屏障时，优先执行 barrierAction，方便处理更复杂的业务场景(该线程的执行时机是</td>\n</tr>\n<tr>\n<td>在到达屏障之后再执行)</td>\n<td></td>\n</tr>\n<tr>\n<td>await()方法</td>\n<td>线程通过调用await()方法进入等待状态，直到所有线程到达临界点。计数器将重置，并且所有等待的线程会被释放继续执行。</td>\n</tr>\n<tr>\n<td>await(long timeout, TimeUnit unit)方法</td>\n<td>超时等待</td>\n</tr>\n<tr>\n<td>getParties()方法</td>\n<td>获取参与线程的数量。</td>\n</tr>\n<tr>\n<td>reset()方法</td>\n<td>重置计数器，可以复用CyclicBarrier对象。</td>\n</tr>\n<tr>\n<td>isBroken()方法</td>\n<td>判断等待的线程是否被中断。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"代码示例\">代码示例</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CyclicBarrierExample</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">THREAD_COUNT</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">CyclicBarrier</span> <span class=\"variable\">barrier</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CyclicBarrier</span>(THREAD_COUNT, <span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;All threads have reached the barrier. Let&#x27;s continue!&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建并启动三个线程</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= THREAD_COUNT; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">thread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Worker</span>(barrier, <span class=\"string\">&quot;Thread &quot;</span> + i));</span><br><span class=\"line\">            thread.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Worker</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CyclicBarrier barrier;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"title function_\">Worker</span><span class=\"params\">(CyclicBarrier barrier, String name)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.barrier = barrier;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            System.out.println(name + <span class=\"string\">&quot; has started its task.&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 模拟工作</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            System.out.println(name + <span class=\"string\">&quot; has reached the barrier.&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                barrier.await(); <span class=\"comment\">// 等待其他线程到达栅栏</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            System.out.println(name + <span class=\"string\">&quot; has continued its task.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在上述示例中，我们创建了一个<code>CyclicBarrier</code>对象，并指定参与线程的数量为<code>3</code>。</p>\n</li>\n<li class=\"lvl-2\">\n<p>每个线程在执行任务前会先打印一条信息，然后模拟工作<code>2</code>秒钟。</p>\n</li>\n<li class=\"lvl-2\">\n<p>接着，线程会调用<code>barrier.await()</code>方法等待其他线程到达栅栏。</p>\n</li>\n<li class=\"lvl-2\">\n<p>当所有线程都到达栅栏后，其中一个线程会执行栅栏构造函数中传入的<code>Runnable</code>对象，并打印一条提示信息。</p>\n</li>\n<li class=\"lvl-2\">\n<p>之后，所有线程会继续执行各自的任务。</p>\n</li>\n</ul>\n<h2 id=\"CyclicBarrier的应用场景\">CyclicBarrier的应用场景</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>多线程任务：<code>CyclicBarrier</code> 可以用于将复杂的任务分配给多个线程执行，并在所有线程完成工作后触发后续操作。</p>\n</li>\n<li class=\"lvl-2\">\n<p>数据处理：<code>CyclicBarrier</code> 可以用于协调多个线程间的数据处理，在所有线程处理完数据后触发后续操作。</p>\n</li>\n</ul>\n<h2 id=\"CyclicBarrier-与-CountDownLatch-区别\">CyclicBarrier 与 CountDownLatch 区别</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>CountDownLatch</code> 是一次性的，<code>CyclicBarrier</code> 是可循环利用的</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>CountDownLatch</code> 参与的线程的职责是不一样的，有的在倒计时，有的在等待倒计时结束。<code>CyclicBarrier</code> 参与的线程职责是一样的。</p>\n</li>\n</ul>\n","content_text":"摘要 本文介绍CyclicBarrier相关技术 本文基于jdk1.8 CyclicBarrier介绍 CyclicBarrier（回环栅栏或循环屏障），是 Java 并发库中的一个同步工具，通过它可以实现让一组线程等待至某个状态（屏障点）之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。 CyclicBarrier内部维护了一个计数器，当线程到达临界点时，会调用await()方法进行等待。当计数器达到指定的数量时，所有等待的线程都会被释放，并继续执行后续操作。 CyclicBarrier的常用方法 方法 描述 CyclicBarrier(int parties) 构造函数， parties表示屏障拦截的线程数量，每个线程调用 await 方法告诉 CyclicBarrier 我已经到达了屏 障，然后当前线程被阻塞。 CyclicBarrier(int parties, Runnable barrierAction) 构造函数，用于在线程到达屏障时，优先执行 barrierAction，方便处理更复杂的业务场景(该线程的执行时机是 在到达屏障之后再执行) await()方法 线程通过调用await()方法进入等待状态，直到所有线程到达临界点。计数器将重置，并且所有等待的线程会被释放继续执行。 await(long timeout, TimeUnit unit)方法 超时等待 getParties()方法 获取参与线程的数量。 reset()方法 重置计数器，可以复用CyclicBarrier对象。 isBroken()方法 判断等待的线程是否被中断。 代码示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;public class CyclicBarrierExample &#123; public static void main(String[] args) &#123; final int THREAD_COUNT = 3; final CyclicBarrier barrier = new CyclicBarrier(THREAD_COUNT, new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;All threads have reached the barrier. Let&#x27;s continue!&quot;); &#125; &#125;); // 创建并启动三个线程 for (int i = 1; i &lt;= THREAD_COUNT; i++) &#123; Thread thread = new Thread(new Worker(barrier, &quot;Thread &quot; + i)); thread.start(); &#125; &#125; static class Worker implements Runnable &#123; private final CyclicBarrier barrier; private final String name; public Worker(CyclicBarrier barrier, String name) &#123; this.barrier = barrier; this.name = name; &#125; @Override public void run() &#123; System.out.println(name + &quot; has started its task.&quot;); // 模拟工作 try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(name + &quot; has reached the barrier.&quot;); try &#123; barrier.await(); // 等待其他线程到达栅栏 &#125; catch (InterruptedException | BrokenBarrierException e) &#123; e.printStackTrace(); &#125; System.out.println(name + &quot; has continued its task.&quot;); &#125; &#125;&#125; 在上述示例中，我们创建了一个CyclicBarrier对象，并指定参与线程的数量为3。 每个线程在执行任务前会先打印一条信息，然后模拟工作2秒钟。 接着，线程会调用barrier.await()方法等待其他线程到达栅栏。 当所有线程都到达栅栏后，其中一个线程会执行栅栏构造函数中传入的Runnable对象，并打印一条提示信息。 之后，所有线程会继续执行各自的任务。 CyclicBarrier的应用场景 多线程任务：CyclicBarrier 可以用于将复杂的任务分配给多个线程执行，并在所有线程完成工作后触发后续操作。 数据处理：CyclicBarrier 可以用于协调多个线程间的数据处理，在所有线程处理完数据后触发后续操作。 CyclicBarrier 与 CountDownLatch 区别 CountDownLatch 是一次性的，CyclicBarrier 是可循环利用的 CountDownLatch 参与的线程的职责是不一样的，有的在倒计时，有的在等待倒计时结束。CyclicBarrier 参与的线程职责是一样的。","summary":"摘要 本文介绍CyclicBarrier相关技术 本文基于jdk1.8","date_published":"2023-05-22T14:34:05.000Z","tags":["技术","java","java多线程","java"]},{"id":"https://blog.hanqunfeng.com/2023/05/22/java-concurrency06-CountDownLatch/","url":"https://blog.hanqunfeng.com/2023/05/22/java-concurrency06-CountDownLatch/","title":"Java并发编程--JUC并发工具类之CountDownLatch","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度 ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍CountDownLatch相关技术</p>\n</li>\n<li class=\"lvl-2\">\n<p>本文基于<code>jdk1.8</code></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"CountDownLatch介绍\">CountDownLatch介绍</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>CountDownLatch</code>提供了一种同步机制，用于在多个线程之间进行等待和协调。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>CountDownLatch</code>是一种计数器，它允许一个或多个线程等待其他线程完成操作后再继续执行。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>CountDownLatch</code>的工作原理很简单，它通过一个初始计数器来初始化，该计数器表示需要等待的线程数。当一个线程完成了它的操作时，计数器会减少。当计数器达到零时，所有等待的线程都会被释放，可以继续执行。</p>\n</li>\n</ul>\n<h2 id=\"CountDownLatch的常用方法\">CountDownLatch的常用方法</h2>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>CountDownLatch(int count)</code></td>\n<td>构造函数，创建一个CountDownLatch对象，指定初始计数器的值为count</td>\n</tr>\n<tr>\n<td><code>void await()</code></td>\n<td>阻塞调用此方法的线程，直到计数器达到零。如果计数器的值不为零，则调用线程将被阻塞</td>\n</tr>\n<tr>\n<td>boolean await(long timeout, TimeUnit unit)</td>\n<td>阻塞调用此方法的线程，直到计数器达到零或超过指定的等待时间。如果计数器的值不为零，则调用线程将被阻塞</td>\n</tr>\n<tr>\n<td><code>void countDown()</code></td>\n<td>计数器减少一个单位。当一个线程完成了它的操作时，应该调用此方法来减少计数器的值</td>\n</tr>\n<tr>\n<td><code>long getCount()</code></td>\n<td>获取当前计数器的值</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"代码示例\">代码示例</h2>\n<h3 id=\"示例1–多任务完成后合并汇总\">示例1–多任务完成后合并汇总</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.CountDownLatch;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CountDownLatchExample</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">THREAD_COUNT</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">CountDownLatch</span> <span class=\"variable\">latch</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CountDownLatch</span>(THREAD_COUNT);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建并启动三个线程</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= THREAD_COUNT; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">thread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Worker</span>(latch, <span class=\"string\">&quot;Thread &quot;</span> + i)); <span class=\"comment\">// 创建Worker对象并传递CountDownLatch和线程名称</span></span><br><span class=\"line\">            thread.start(); <span class=\"comment\">// 启动线程</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            latch.await(); <span class=\"comment\">// 主线程等待所有线程完成任务</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;All threads have completed their tasks.&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Worker</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CountDownLatch latch;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Worker</span><span class=\"params\">(CountDownLatch latch, String name)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.latch = latch; <span class=\"comment\">// 初始化CountDownLatch</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name; <span class=\"comment\">// 初始化线程名称</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(name + <span class=\"string\">&quot; has started its task.&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 模拟工作</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">2000</span>); <span class=\"comment\">// 线程休眠2秒，模拟执行任务的耗时操作</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(name + <span class=\"string\">&quot; has completed its task.&quot;</span>);</span><br><span class=\"line\">        latch.countDown(); <span class=\"comment\">// 任务完成后计数器减少</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在上述示例中，主线程创建了一个<code>CountDownLatch</code>对象，并指定初始计数器的值为<code>3</code>。然后，主线程启动了三个工作线程，并将<code>CountDownLatch</code>对象传递给它们。</p>\n</li>\n<li class=\"lvl-2\">\n<p>每个工作线程在执行任务前会输出开始信息，然后模拟执行任务的耗时操作（这里用<code>Thread.sleep(2000)</code>模拟），最后输出任务完成信息。在任务完成后，每个工作线程都会调用<code>latch.countDown()</code>来减少计数器的值。</p>\n</li>\n<li class=\"lvl-2\">\n<p>主线程通过调用<code>latch.await()</code>方法阻塞自己，等待所有工作线程完成任务。当计数器的值为零时，主线程被唤醒，继续执行，输出&quot;All threads have completed their tasks.&quot;的信息。</p>\n</li>\n</ul>\n<h3 id=\"示例2–模拟实现百米赛跑\">示例2–模拟实现百米赛跑</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CountDownLatchDemo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">CountDownLatch</span> <span class=\"variable\">begin</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CountDownLatch</span>(<span class=\"number\">1</span>); <span class=\"comment\">// begin 代表裁判 初始为 1</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">CountDownLatch</span> <span class=\"variable\">end</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CountDownLatch</span>(<span class=\"number\">8</span>); <span class=\"comment\">// end 代表玩家 初始为 8</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= <span class=\"number\">8</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@SneakyThrows</span></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 预备状态</span></span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;参赛者&quot;</span> + Thread.currentThread().getName() + <span class=\"string\">&quot;已经准备好了&quot;</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 等待裁判吹哨，这里就类似于多个子线程等待某个共享资源的初始化完成后再开始执行。</span></span><br><span class=\"line\">                    begin.await();</span><br><span class=\"line\">                    <span class=\"comment\">// 开始跑步</span></span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;参赛者&quot;</span> + Thread.currentThread().getName() + <span class=\"string\">&quot;开始跑步&quot;</span>);</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 跑步结束, 跑完了</span></span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;参赛者&quot;</span> + Thread.currentThread().getName() + <span class=\"string\">&quot;到达终点&quot;</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 跑到终点, 计数器就减一</span></span><br><span class=\"line\">                    end.countDown();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 等待 5s 就开始吹哨</span></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;开始比赛&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 裁判吹哨, 计数器减一</span></span><br><span class=\"line\">        begin.countDown();</span><br><span class=\"line\">        <span class=\"comment\">// 等待所有玩家到达终点，即主线程等待多个子线程完成任务后再继续执行。</span></span><br><span class=\"line\">        end.await();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;比赛结束&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>上述代码展示了使用<code>CountDownLatch</code>进行比赛场景的模拟。裁判（<code>begin</code>）初始计数为<code>1</code>，代表裁判等待的条件为所有参赛者准备就绪。玩家（<code>end</code>）初始计数为<code>8</code>，代表参赛者的数量。</p>\n</li>\n<li class=\"lvl-2\">\n<p>每个参赛者都会在准备好后等待裁判的指令，然后开始跑步，跑到终点后计数器减一。裁判会在等待<code>5</code>秒后吹哨，开始比赛。当所有玩家到达终点后，比赛结束。</p>\n</li>\n</ul>\n<h2 id=\"CountDownLatch通常用于以下场景\">CountDownLatch通常用于以下场景</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>主线程等待多个子线程完成任务后再继续执行。</p>\n</li>\n<li class=\"lvl-2\">\n<p>多个子线程等待某个共享资源的初始化完成后再开始执行。</p>\n</li>\n<li class=\"lvl-2\">\n<p>协调多个线程执行的时间点。</p>\n</li>\n</ul>\n<h2 id=\"使用CountDownLatch的注意事项\">使用CountDownLatch的注意事项</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>初始化计数器的值：在创建<code>CountDownLatch</code>对象时，需要确定初始计数器的值。该值应该与等待的线程数量一致，以确保所有线程完成任务后计数器的值为0。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>await()</code>方法的阻塞：调用<code>await()</code>方法会使当前线程阻塞，直到计数器的值变为<code>0</code>。需要确保在调用<code>await()</code>方法之前，计数器的值能够达到<code>0</code>。否则，调用线程将一直被阻塞，无法继续执行。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>countDown()</code>方法的调用：在每个线程完成任务后，都需要调用<code>countDown()</code>方法来减少计数器的值。确保在适当的位置调用<code>countDown()</code>，否则计数器的值无法正确减少，导致主线程一直被阻塞。</p>\n</li>\n<li class=\"lvl-2\">\n<p>异常处理：在使用<code>CountDownLatch</code>时，需要注意处理可能抛出的<code>InterruptedException</code>异常。例如，在调用<code>await()</code>方法时需要捕获<code>InterruptedException</code>，并进行适当的处理。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>CountDownLatch</code>的复用：<code>CountDownLatch</code>对象在计数器值减少到<code>0</code>后，可以重用。可以通过重新设置计数器的值来复用<code>CountDownLatch</code>对象，以便在新的场景中再次使用。</p>\n</li>\n<li class=\"lvl-2\">\n<p>计数器值的访问：可以使用<code>getCount()</code>方法获取当前计数器的值，以便在需要时查看计数器的状态。</p>\n</li>\n</ul>\n","content_text":"摘要 本文介绍CountDownLatch相关技术 本文基于jdk1.8 CountDownLatch介绍 CountDownLatch提供了一种同步机制，用于在多个线程之间进行等待和协调。 CountDownLatch是一种计数器，它允许一个或多个线程等待其他线程完成操作后再继续执行。 CountDownLatch的工作原理很简单，它通过一个初始计数器来初始化，该计数器表示需要等待的线程数。当一个线程完成了它的操作时，计数器会减少。当计数器达到零时，所有等待的线程都会被释放，可以继续执行。 CountDownLatch的常用方法 方法 描述 CountDownLatch(int count) 构造函数，创建一个CountDownLatch对象，指定初始计数器的值为count void await() 阻塞调用此方法的线程，直到计数器达到零。如果计数器的值不为零，则调用线程将被阻塞 boolean await(long timeout, TimeUnit unit) 阻塞调用此方法的线程，直到计数器达到零或超过指定的等待时间。如果计数器的值不为零，则调用线程将被阻塞 void countDown() 计数器减少一个单位。当一个线程完成了它的操作时，应该调用此方法来减少计数器的值 long getCount() 获取当前计数器的值 代码示例 示例1–多任务完成后合并汇总 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.concurrent.CountDownLatch;public class CountDownLatchExample &#123; public static void main(String[] args) &#123; final int THREAD_COUNT = 3; final CountDownLatch latch = new CountDownLatch(THREAD_COUNT); // 创建并启动三个线程 for (int i = 1; i &lt;= THREAD_COUNT; i++) &#123; Thread thread = new Thread(new Worker(latch, &quot;Thread &quot; + i)); // 创建Worker对象并传递CountDownLatch和线程名称 thread.start(); // 启动线程 &#125; try &#123; latch.await(); // 主线程等待所有线程完成任务 System.out.println(&quot;All threads have completed their tasks.&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class Worker implements Runnable &#123; private final CountDownLatch latch; private final String name; public Worker(CountDownLatch latch, String name) &#123; this.latch = latch; // 初始化CountDownLatch this.name = name; // 初始化线程名称 &#125; @Override public void run() &#123; System.out.println(name + &quot; has started its task.&quot;); // 模拟工作 try &#123; Thread.sleep(2000); // 线程休眠2秒，模拟执行任务的耗时操作 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(name + &quot; has completed its task.&quot;); latch.countDown(); // 任务完成后计数器减少 &#125;&#125; 在上述示例中，主线程创建了一个CountDownLatch对象，并指定初始计数器的值为3。然后，主线程启动了三个工作线程，并将CountDownLatch对象传递给它们。 每个工作线程在执行任务前会输出开始信息，然后模拟执行任务的耗时操作（这里用Thread.sleep(2000)模拟），最后输出任务完成信息。在任务完成后，每个工作线程都会调用latch.countDown()来减少计数器的值。 主线程通过调用latch.await()方法阻塞自己，等待所有工作线程完成任务。当计数器的值为零时，主线程被唤醒，继续执行，输出&quot;All threads have completed their tasks.&quot;的信息。 示例2–模拟实现百米赛跑 12345678910111213141516171819202122232425262728293031323334public class CountDownLatchDemo &#123; private static CountDownLatch begin = new CountDownLatch(1); // begin 代表裁判 初始为 1 private static CountDownLatch end = new CountDownLatch(8); // end 代表玩家 初始为 8 public static void main(String[] args) throws InterruptedException &#123; for (int i = 1; i &lt;= 8; i++) &#123; new Thread(new Runnable() &#123; @SneakyThrows @Override public void run() &#123; // 预备状态 System.out.println(&quot;参赛者&quot; + Thread.currentThread().getName() + &quot;已经准备好了&quot;); // 等待裁判吹哨，这里就类似于多个子线程等待某个共享资源的初始化完成后再开始执行。 begin.await(); // 开始跑步 System.out.println(&quot;参赛者&quot; + Thread.currentThread().getName() + &quot;开始跑步&quot;); Thread.sleep(1000); // 跑步结束, 跑完了 System.out.println(&quot;参赛者&quot; + Thread.currentThread().getName() + &quot;到达终点&quot;); // 跑到终点, 计数器就减一 end.countDown(); &#125; &#125;).start(); &#125; // 等待 5s 就开始吹哨 Thread.sleep(5000); System.out.println(&quot;开始比赛&quot;); // 裁判吹哨, 计数器减一 begin.countDown(); // 等待所有玩家到达终点，即主线程等待多个子线程完成任务后再继续执行。 end.await(); System.out.println(&quot;比赛结束&quot;); &#125;&#125; 上述代码展示了使用CountDownLatch进行比赛场景的模拟。裁判（begin）初始计数为1，代表裁判等待的条件为所有参赛者准备就绪。玩家（end）初始计数为8，代表参赛者的数量。 每个参赛者都会在准备好后等待裁判的指令，然后开始跑步，跑到终点后计数器减一。裁判会在等待5秒后吹哨，开始比赛。当所有玩家到达终点后，比赛结束。 CountDownLatch通常用于以下场景 主线程等待多个子线程完成任务后再继续执行。 多个子线程等待某个共享资源的初始化完成后再开始执行。 协调多个线程执行的时间点。 使用CountDownLatch的注意事项 初始化计数器的值：在创建CountDownLatch对象时，需要确定初始计数器的值。该值应该与等待的线程数量一致，以确保所有线程完成任务后计数器的值为0。 await()方法的阻塞：调用await()方法会使当前线程阻塞，直到计数器的值变为0。需要确保在调用await()方法之前，计数器的值能够达到0。否则，调用线程将一直被阻塞，无法继续执行。 countDown()方法的调用：在每个线程完成任务后，都需要调用countDown()方法来减少计数器的值。确保在适当的位置调用countDown()，否则计数器的值无法正确减少，导致主线程一直被阻塞。 异常处理：在使用CountDownLatch时，需要注意处理可能抛出的InterruptedException异常。例如，在调用await()方法时需要捕获InterruptedException，并进行适当的处理。 CountDownLatch的复用：CountDownLatch对象在计数器值减少到0后，可以重用。可以通过重新设置计数器的值来复用CountDownLatch对象，以便在新的场景中再次使用。 计数器值的访问：可以使用getCount()方法获取当前计数器的值，以便在需要时查看计数器的状态。","summary":"摘要 本文介绍CountDownLatch相关技术 本文基于jdk1.8","date_published":"2023-05-22T14:33:05.000Z","tags":["技术","java","java多线程","java"]},{"id":"https://blog.hanqunfeng.com/2023/05/22/java-concurrency05-Semaphore/","url":"https://blog.hanqunfeng.com/2023/05/22/java-concurrency05-Semaphore/","title":"Java并发编程--JUC并发工具类之Semaphore","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度 ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍Semaphore相关技术</p>\n</li>\n<li class=\"lvl-2\">\n<p>本文基于<code>jdk1.8</code></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Semaphore介绍\">Semaphore介绍</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>Semaphore</code>（信号量）是一种用于多线程编程的同步工具，用于控制同时访问某个资源的线程数量。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>Semaphore</code>维护了一个计数器，线程可以通过调用<code>acquire()</code>方法来获取<code>Semaphore</code>中的许可证，当计数器为<code>0</code>时，调用<code>acquire()</code>的线程将被阻塞，直到有其他线程释放许可证；</p>\n</li>\n<li class=\"lvl-2\">\n<p>线程可以通过调用<code>release()</code>方法来释放<code>Semaphore</code>中的许可证，这会使<code>Semaphore</code>中的计数器增加，从而允许更多的线程访问共享资源。<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/kcdir2.jpg\" alt=\"\"></p>\n</li>\n</ul>\n<h2 id=\"Semaphore常用方法\">Semaphore常用方法</h2>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>Semaphore(int permits)</code></td>\n<td>构造函数，创建具有给定许可数的Semaphore对象</td>\n</tr>\n<tr>\n<td><code>Semaphore(int permits,boolean fair)</code></td>\n<td>构造函数，创建具有给定许可数的Semaphore对象，fair 表示公平性，如果这个设为 true 的话，下次执行的线程会是等待最久的线程</td>\n</tr>\n<tr>\n<td><code>int availablePermits()</code></td>\n<td>返回当前可用的许可数</td>\n</tr>\n<tr>\n<td><code>void acquire()</code></td>\n<td>获取一个许可，如果没有可用的许可，则阻塞直到有可用的许可</td>\n</tr>\n<tr>\n<td><code>void release()</code></td>\n<td>释放一个许可</td>\n</tr>\n<tr>\n<td><code>boolean tryAcquire()</code></td>\n<td>尝试获取一个许可，如果有可用的许可，则获取成功，返回true；否则返回false</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Semaphore代码示例\">Semaphore代码示例</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在这个示例中，Semaphore的初始许可数为2，意味着最多允许两个线程同时访问共享资源。</p>\n</li>\n<li class=\"lvl-2\">\n<p>每个工作线程在执行工作前都会请求一个许可，如果许可可用，它将获得许可并执行工作，然后释放许可供其他线程使用。</p>\n</li>\n<li class=\"lvl-2\">\n<p>如果没有可用的许可，线程将被阻塞直到有可用的许可为止。通过Semaphore的控制，最多允许两个线程并发执行，而第三个线程需要等待前面的线程释放许可后才能执行。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Semaphore;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SemaphoreConcurrencyExample</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Semaphore</span> <span class=\"variable\">semaphore</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Semaphore</span>(<span class=\"number\">2</span>); <span class=\"comment\">// 创建Semaphore对象，限制并发数为2</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建并启动三个线程</span></span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">thread1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Worker</span>(semaphore, <span class=\"string\">&quot;Thread 1&quot;</span>));</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">thread2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Worker</span>(semaphore, <span class=\"string\">&quot;Thread 2&quot;</span>));</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">thread3</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Worker</span>(semaphore, <span class=\"string\">&quot;Thread 3&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        thread1.start();</span><br><span class=\"line\">        thread2.start();</span><br><span class=\"line\">        thread3.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Worker</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Semaphore semaphore;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Worker</span><span class=\"params\">(Semaphore semaphore, String name)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.semaphore = semaphore;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            System.out.println(name + <span class=\"string\">&quot; is waiting for a permit.&quot;</span>);</span><br><span class=\"line\">            semaphore.acquire(); <span class=\"comment\">// 获取许可</span></span><br><span class=\"line\"></span><br><span class=\"line\">            System.out.println(name + <span class=\"string\">&quot; has acquired a permit.&quot;</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 模拟工作</span></span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            System.out.println(name + <span class=\"string\">&quot; is releasing the permit.&quot;</span>);</span><br><span class=\"line\">            semaphore.release(); <span class=\"comment\">// 释放许可</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Semaphore应用场景\">Semaphore应用场景</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>限流：<code>Semaphore</code>可以用于限制对共享资源的并发访问数量，以控制系统的流量。</p>\n</li>\n<li class=\"lvl-2\">\n<p>资源池：<code>Semaphore</code>可以用于实现资源池，以维护一组有限的共享资源</p>\n</li>\n</ul>\n","content_text":"摘要 本文介绍Semaphore相关技术 本文基于jdk1.8 Semaphore介绍 Semaphore（信号量）是一种用于多线程编程的同步工具，用于控制同时访问某个资源的线程数量。 Semaphore维护了一个计数器，线程可以通过调用acquire()方法来获取Semaphore中的许可证，当计数器为0时，调用acquire()的线程将被阻塞，直到有其他线程释放许可证； 线程可以通过调用release()方法来释放Semaphore中的许可证，这会使Semaphore中的计数器增加，从而允许更多的线程访问共享资源。 Semaphore常用方法 方法 描述 Semaphore(int permits) 构造函数，创建具有给定许可数的Semaphore对象 Semaphore(int permits,boolean fair) 构造函数，创建具有给定许可数的Semaphore对象，fair 表示公平性，如果这个设为 true 的话，下次执行的线程会是等待最久的线程 int availablePermits() 返回当前可用的许可数 void acquire() 获取一个许可，如果没有可用的许可，则阻塞直到有可用的许可 void release() 释放一个许可 boolean tryAcquire() 尝试获取一个许可，如果有可用的许可，则获取成功，返回true；否则返回false Semaphore代码示例 在这个示例中，Semaphore的初始许可数为2，意味着最多允许两个线程同时访问共享资源。 每个工作线程在执行工作前都会请求一个许可，如果许可可用，它将获得许可并执行工作，然后释放许可供其他线程使用。 如果没有可用的许可，线程将被阻塞直到有可用的许可为止。通过Semaphore的控制，最多允许两个线程并发执行，而第三个线程需要等待前面的线程释放许可后才能执行。 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.concurrent.Semaphore;public class SemaphoreConcurrencyExample &#123; public static void main(String[] args) &#123; Semaphore semaphore = new Semaphore(2); // 创建Semaphore对象，限制并发数为2 // 创建并启动三个线程 Thread thread1 = new Thread(new Worker(semaphore, &quot;Thread 1&quot;)); Thread thread2 = new Thread(new Worker(semaphore, &quot;Thread 2&quot;)); Thread thread3 = new Thread(new Worker(semaphore, &quot;Thread 3&quot;)); thread1.start(); thread2.start(); thread3.start(); &#125;&#125;class Worker implements Runnable &#123; private final Semaphore semaphore; private final String name; public Worker(Semaphore semaphore, String name) &#123; this.semaphore = semaphore; this.name = name; &#125; @Override public void run() &#123; try &#123; System.out.println(name + &quot; is waiting for a permit.&quot;); semaphore.acquire(); // 获取许可 System.out.println(name + &quot; has acquired a permit.&quot;); // 模拟工作 Thread.sleep(2000); System.out.println(name + &quot; is releasing the permit.&quot;); semaphore.release(); // 释放许可 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Semaphore应用场景 限流：Semaphore可以用于限制对共享资源的并发访问数量，以控制系统的流量。 资源池：Semaphore可以用于实现资源池，以维护一组有限的共享资源","summary":"摘要 本文介绍Semaphore相关技术 本文基于jdk1.8","date_published":"2023-05-22T14:32:05.000Z","tags":["技术","java","java多线程","java"]},{"id":"https://blog.hanqunfeng.com/2023/05/22/java-concurrency04-StampedLock/","url":"https://blog.hanqunfeng.com/2023/05/22/java-concurrency04-StampedLock/","title":"Java并发编程--JUC并发工具类之StampedLock","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度 ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍StampedLock相关技术</p>\n</li>\n<li class=\"lvl-2\">\n<p>本文基于<code>jdk1.8</code></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"StampedLock介绍\">StampedLock介绍</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果我们深入分析<code>ReentrantReadWriteLock</code>，会发现它有个潜在的问题：如果有线程正在读，写线程需要等待读线程释放锁后才能获取写锁，即读的过程中不允许写，这是一种悲观的读锁。</p>\n</li>\n<li class=\"lvl-2\">\n<p>为了进一步提升并发执行效率，Java 8引入了新的读写锁：StampedLock。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>StampedLock</code>和<code>ReentrantReadWriteLock</code>相比，改进之处在于：读的过程中也允许获取写锁后写入！在原先读写锁的基础上新增了一种叫乐观读（<code>Optimistic Reading</code>）的模式。该模式并不会加锁，所以不会阻塞线程，会有更高的吞吐量和更高的性能。</p>\n</li>\n<li class=\"lvl-2\">\n<p>它的设计初衷是作为一个内部工具类，用于开发其他线程安全的组件，提升系统性能，并且编程模型也比<code>ReentrantReadWriteLock</code> 复杂，所以用不好就很容易出现死锁或者线程安全等莫名其妙的问题。</p>\n</li>\n<li class=\"lvl-2\">\n<p>注意：<code>StampedLock</code>是Java 8引入的类，需要使用支持Java 8及更高版本的编译器和运行时环境。</p>\n</li>\n</ul>\n<h2 id=\"StampLock三种访问模式\">StampLock三种访问模式</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>Writing</code>（独占写锁）：<code>writeLock</code> 方法会使线程阻塞等待独占访问，可类比<code>ReentrantReadWriteLock</code> 的写锁模式，同一时刻有且只有一个写线程获取锁资源；</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>Reading</code>（悲观读锁）：<code>readLock</code>方法，允许多个线程同时获取悲观读锁，悲观读锁与独占写锁互斥，与乐观读共享。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>Optimistic Reading</code>（乐观读）：这里需要注意了，乐观读并没有加锁，也就是不会有 <code>CAS</code> 机制并且没有阻塞线程。仅当当前未处于 <code>Writing</code> 模式 <code>tryOptimisticRead</code> 才会返回非 <code>0</code> 的邮戳（<code>Stamp</code>），如果在获取乐观读之后没有出现写模式线程获取锁，则在方法<code>validate</code>返回 <code>true</code> ，允许多个线程获取乐观读以及读锁，同时允许一个写线程获取写锁。</p>\n</li>\n</ul>\n<h2 id=\"乐观读编程模型的模板\">乐观读编程模型的模板</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">optimisticRead</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 非阻塞乐观读模式获取版本信息</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">stamp</span> <span class=\"operator\">=</span> lock.tryOptimisticRead();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2. 拷贝共享数据到线程本地栈中，即将共享变量赋值给方法内变量</span></span><br><span class=\"line\">    copyVaraibale2ThreadMemory();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 3. 校验乐观读模式读取的数据是否被修改过</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!lock.validate(stamp)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 3.1 校验未通过，上读锁</span></span><br><span class=\"line\">        stamp = lock.readLock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 3.2 拷贝共享变量数据到局部变量</span></span><br><span class=\"line\">            copyVaraibale2ThreadMemory();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 释放读锁</span></span><br><span class=\"line\">            lock.unlockRead(stamp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 3.3 校验通过，使用线程本地栈的数据进行逻辑操作</span></span><br><span class=\"line\">    useThreadMemoryVarables();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"StampedLock的代码示例\">StampedLock的代码示例</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.StampedLock;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">StampedLockExample</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">double</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">double</span> y;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">StampedLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StampedLock</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 移动坐标点</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> deltaX X轴增量</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> deltaY Y轴增量</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">move</span><span class=\"params\">(<span class=\"type\">double</span> deltaX, <span class=\"type\">double</span> deltaY)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">stamp</span> <span class=\"operator\">=</span> lock.writeLock(); <span class=\"comment\">// 获取写锁</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            x += deltaX;</span><br><span class=\"line\">            y += deltaY;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlockWrite(stamp); <span class=\"comment\">// 释放写锁</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 计算当前坐标点与原点的距离</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 原点的距离</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">double</span> <span class=\"title function_\">distanceFromOrigin</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">stamp</span> <span class=\"operator\">=</span> lock.tryOptimisticRead(); <span class=\"comment\">// 尝试获取乐观读锁</span></span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">currentX</span> <span class=\"operator\">=</span> x;</span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">currentY</span> <span class=\"operator\">=</span> y;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!lock.validate(stamp)) &#123; <span class=\"comment\">// 校验乐观读锁是否有效</span></span><br><span class=\"line\">            stamp = lock.readLock(); <span class=\"comment\">// 乐观读锁无效则获取悲观读锁</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                currentX = x;</span><br><span class=\"line\">                currentY = y;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                lock.unlockRead(stamp); <span class=\"comment\">// 释放悲观读锁</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 如果当前坐标在原点，则移动坐标</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> newX 新的X坐标</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> newY 新的Y坐标</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">moveIfAtOrigin</span><span class=\"params\">(<span class=\"type\">double</span> newX, <span class=\"type\">double</span> newY)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">stamp</span> <span class=\"operator\">=</span> lock.readLock(); <span class=\"comment\">// 获取悲观读锁</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (x == <span class=\"number\">0.0</span> &amp;&amp; y == <span class=\"number\">0.0</span>) &#123;</span><br><span class=\"line\">                <span class=\"type\">long</span> <span class=\"variable\">writeStamp</span> <span class=\"operator\">=</span> lock.tryConvertToWriteLock(stamp); <span class=\"comment\">// 尝试将悲观读锁升级为写锁</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (writeStamp != <span class=\"number\">0L</span>) &#123; <span class=\"comment\">// 升级成功</span></span><br><span class=\"line\">                    x = newX;</span><br><span class=\"line\">                    y = newY;</span><br><span class=\"line\">                    stamp = writeStamp;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    lock.unlockRead(stamp); <span class=\"comment\">// 释放悲观读锁</span></span><br><span class=\"line\">                    stamp = lock.writeLock(); <span class=\"comment\">// 获取写锁</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock(stamp); <span class=\"comment\">// 释放锁（读锁或写锁）</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在上述示例中，<code>StampedLockExample</code>类使用了<code>StampedLock</code>来管理对x和y坐标的访问。</p>\n</li>\n<li class=\"lvl-2\">\n<p>其中<code>move</code>方法使用写锁来更新x和y坐标的值。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>distanceFromOrigin</code>方法使用乐观读锁尝试读取<code>x</code>和<code>y</code>坐标的值，如果乐观读锁无效，则获取悲观读锁来读取。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>moveIfAtOrigin</code>方法首先获取悲观读锁，然后检查当前坐标是否在原点。如果在原点，则尝试将悲观读锁升级为写锁，以便进行坐标更新。如果升级失败，则释放悲观读锁并获取写锁。</p>\n</li>\n</ul>\n<h2 id=\"StampedLock使用场景\">StampedLock使用场景</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>适用于读多写少的高并发场景</p>\n</li>\n</ul>\n<h2 id=\"使用StampedLock的注意事项\">使用StampedLock的注意事项</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>StampedLock</code> 写锁是不可重入的，如果当前线程已经获取了写锁，再次重复获取的话就会死锁，使用过程中一定要注意；</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>StampedLock</code>的悲观读、写锁都不支持条件变量 <code>Conditon</code> ，当需要这个特性的时候需要注意；</p>\n</li>\n<li class=\"lvl-2\">\n<p>如果线程阻塞在 <code>StampedLock</code> 的 <code>readLock()</code> 或者 <code>writeLock()</code> 上时，此时调用该阻塞线程的 <code>interrupt()</code> 方法，会导致 CPU 飙升。所以，使用 <code>StampedLock</code> 一定不要调用中断操作，如果需要支持中断功能，一定使用可中断的悲观读锁 <code>readLockInterruptibly()</code> 和写锁 <code>writeLockInterruptibly()</code>。</p>\n</li>\n</ul>\n<h2 id=\"ReentrantLock-、-ReentrantReadWriteLock-和-StampedLock-的比较\">ReentrantLock 、 ReentrantReadWriteLock 和 StampedLock 的比较</h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>ReentrantLock</th>\n<th>ReentrantReadWriteLock</th>\n<th>StampedLock</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>锁类型</td>\n<td>独占锁（Exclusive Lock）</td>\n<td>读写锁（Read-Write Lock）</td>\n<td>乐观读锁和悲观读锁（Optimistic and Pessimistic Read Locks）</td>\n</tr>\n<tr>\n<td>读-读并发性</td>\n<td>不支持</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>读-写并发性</td>\n<td>不支持</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>写-写并发性</td>\n<td>不支持</td>\n<td>不支持</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>锁的公平性</td>\n<td>支持设置为公平或非公平锁</td>\n<td>支持设置为公平或非公平锁</td>\n<td>不支持设置公平性(非公平锁)</td>\n</tr>\n<tr>\n<td>性能</td>\n<td>适用于读操作少、写操作多的场景</td>\n<td>适用于读操作频繁、写操作较少的场景</td>\n<td>适用于乐观读多于写的场景</td>\n</tr>\n<tr>\n<td>锁降级</td>\n<td>不支持</td>\n<td>支持</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>可重入性</td>\n<td>支持</td>\n<td>支持</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>API</td>\n<td>提供基本锁操作方法（lock、unlock、tryLock等）</td>\n<td>提供与ReentrantLock类似的锁操作方法，以及读锁和写锁的获取方法</td>\n<td>提供乐观读锁和悲观读锁的获取方法，以及锁的转换操作</td>\n</tr>\n<tr>\n<td>适用场景</td>\n<td>读操作较少、写操作较多的场景，互斥访问共享资源</td>\n<td>读操作频繁、写操作较少的场景，读多写少的并发访问</td>\n<td>读操作多于写操作的场景，乐观读锁性能好</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍StampedLock相关技术 本文基于jdk1.8 StampedLock介绍 如果我们深入分析ReentrantReadWriteLock，会发现它有个潜在的问题：如果有线程正在读，写线程需要等待读线程释放锁后才能获取写锁，即读的过程中不允许写，这是一种悲观的读锁。 为了进一步提升并发执行效率，Java 8引入了新的读写锁：StampedLock。 StampedLock和ReentrantReadWriteLock相比，改进之处在于：读的过程中也允许获取写锁后写入！在原先读写锁的基础上新增了一种叫乐观读（Optimistic Reading）的模式。该模式并不会加锁，所以不会阻塞线程，会有更高的吞吐量和更高的性能。 它的设计初衷是作为一个内部工具类，用于开发其他线程安全的组件，提升系统性能，并且编程模型也比ReentrantReadWriteLock 复杂，所以用不好就很容易出现死锁或者线程安全等莫名其妙的问题。 注意：StampedLock是Java 8引入的类，需要使用支持Java 8及更高版本的编译器和运行时环境。 StampLock三种访问模式 Writing（独占写锁）：writeLock 方法会使线程阻塞等待独占访问，可类比ReentrantReadWriteLock 的写锁模式，同一时刻有且只有一个写线程获取锁资源； Reading（悲观读锁）：readLock方法，允许多个线程同时获取悲观读锁，悲观读锁与独占写锁互斥，与乐观读共享。 Optimistic Reading（乐观读）：这里需要注意了，乐观读并没有加锁，也就是不会有 CAS 机制并且没有阻塞线程。仅当当前未处于 Writing 模式 tryOptimisticRead 才会返回非 0 的邮戳（Stamp），如果在获取乐观读之后没有出现写模式线程获取锁，则在方法validate返回 true ，允许多个线程获取乐观读以及读锁，同时允许一个写线程获取写锁。 乐观读编程模型的模板 1234567891011121314151617181920212223public void optimisticRead() &#123; // 1. 非阻塞乐观读模式获取版本信息 long stamp = lock.tryOptimisticRead(); // 2. 拷贝共享数据到线程本地栈中，即将共享变量赋值给方法内变量 copyVaraibale2ThreadMemory(); // 3. 校验乐观读模式读取的数据是否被修改过 if (!lock.validate(stamp)) &#123; // 3.1 校验未通过，上读锁 stamp = lock.readLock(); try &#123; // 3.2 拷贝共享变量数据到局部变量 copyVaraibale2ThreadMemory(); &#125; finally &#123; // 释放读锁 lock.unlockRead(stamp); &#125; &#125; // 3.3 校验通过，使用线程本地栈的数据进行逻辑操作 useThreadMemoryVarables();&#125; StampedLock的代码示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import java.util.concurrent.locks.StampedLock;public class StampedLockExample &#123; private double x; private double y; private final StampedLock lock = new StampedLock(); /** * 移动坐标点 * * @param deltaX X轴增量 * @param deltaY Y轴增量 */ public void move(double deltaX, double deltaY) &#123; long stamp = lock.writeLock(); // 获取写锁 try &#123; x += deltaX; y += deltaY; &#125; finally &#123; lock.unlockWrite(stamp); // 释放写锁 &#125; &#125; /** * 计算当前坐标点与原点的距离 * * @return 原点的距离 */ public double distanceFromOrigin() &#123; long stamp = lock.tryOptimisticRead(); // 尝试获取乐观读锁 double currentX = x; double currentY = y; if (!lock.validate(stamp)) &#123; // 校验乐观读锁是否有效 stamp = lock.readLock(); // 乐观读锁无效则获取悲观读锁 try &#123; currentX = x; currentY = y; &#125; finally &#123; lock.unlockRead(stamp); // 释放悲观读锁 &#125; &#125; return Math.sqrt(currentX * currentX + currentY * currentY); &#125; /** * 如果当前坐标在原点，则移动坐标 * * @param newX 新的X坐标 * @param newY 新的Y坐标 */ public void moveIfAtOrigin(double newX, double newY) &#123; long stamp = lock.readLock(); // 获取悲观读锁 try &#123; while (x == 0.0 &amp;&amp; y == 0.0) &#123; long writeStamp = lock.tryConvertToWriteLock(stamp); // 尝试将悲观读锁升级为写锁 if (writeStamp != 0L) &#123; // 升级成功 x = newX; y = newY; stamp = writeStamp; break; &#125; else &#123; lock.unlockRead(stamp); // 释放悲观读锁 stamp = lock.writeLock(); // 获取写锁 &#125; &#125; &#125; finally &#123; lock.unlock(stamp); // 释放锁（读锁或写锁） &#125; &#125;&#125; 在上述示例中，StampedLockExample类使用了StampedLock来管理对x和y坐标的访问。 其中move方法使用写锁来更新x和y坐标的值。 distanceFromOrigin方法使用乐观读锁尝试读取x和y坐标的值，如果乐观读锁无效，则获取悲观读锁来读取。 moveIfAtOrigin方法首先获取悲观读锁，然后检查当前坐标是否在原点。如果在原点，则尝试将悲观读锁升级为写锁，以便进行坐标更新。如果升级失败，则释放悲观读锁并获取写锁。 StampedLock使用场景 适用于读多写少的高并发场景 使用StampedLock的注意事项 StampedLock 写锁是不可重入的，如果当前线程已经获取了写锁，再次重复获取的话就会死锁，使用过程中一定要注意； StampedLock的悲观读、写锁都不支持条件变量 Conditon ，当需要这个特性的时候需要注意； 如果线程阻塞在 StampedLock 的 readLock() 或者 writeLock() 上时，此时调用该阻塞线程的 interrupt() 方法，会导致 CPU 飙升。所以，使用 StampedLock 一定不要调用中断操作，如果需要支持中断功能，一定使用可中断的悲观读锁 readLockInterruptibly() 和写锁 writeLockInterruptibly()。 ReentrantLock 、 ReentrantReadWriteLock 和 StampedLock 的比较 特性 ReentrantLock ReentrantReadWriteLock StampedLock 锁类型 独占锁（Exclusive Lock） 读写锁（Read-Write Lock） 乐观读锁和悲观读锁（Optimistic and Pessimistic Read Locks） 读-读并发性 不支持 支持 支持 读-写并发性 不支持 支持 支持 写-写并发性 不支持 不支持 不支持 锁的公平性 支持设置为公平或非公平锁 支持设置为公平或非公平锁 不支持设置公平性(非公平锁) 性能 适用于读操作少、写操作多的场景 适用于读操作频繁、写操作较少的场景 适用于乐观读多于写的场景 锁降级 不支持 支持 不支持 可重入性 支持 支持 不支持 API 提供基本锁操作方法（lock、unlock、tryLock等） 提供与ReentrantLock类似的锁操作方法，以及读锁和写锁的获取方法 提供乐观读锁和悲观读锁的获取方法，以及锁的转换操作 适用场景 读操作较少、写操作较多的场景，互斥访问共享资源 读操作频繁、写操作较少的场景，读多写少的并发访问 读操作多于写操作的场景，乐观读锁性能好","summary":"摘要 本文介绍StampedLock相关技术 本文基于jdk1.8","date_published":"2023-05-22T14:31:05.000Z","tags":["技术","java","java多线程","java"]},{"id":"https://blog.hanqunfeng.com/2023/05/22/java-concurrency03-ReentrantReadWriteLock/","url":"https://blog.hanqunfeng.com/2023/05/22/java-concurrency03-ReentrantReadWriteLock/","title":"Java并发编程--JUC并发工具类之ReentrantReadWriteLock","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度 ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍ReentrantReadWriteLock相关技术</p>\n</li>\n<li class=\"lvl-2\">\n<p>本文基于<code>jdk1.8</code></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"读写锁\">读写锁</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>读写锁<code>ReadWriteLock</code>，顾名思义一把锁分为读与写两部分，读锁允许多个线程同时获得，因为读操作本身是线程安全的。而写锁是互斥锁，不允许多个线程同时获得写锁。并且读与写操作也是互斥的。读写锁适合多读少写的业务场景。</p>\n</li>\n<li class=\"lvl-2\">\n<p>线程进入读锁的前提条件：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">没有其他线程的写锁（读写互斥，但是读读不互斥）</li>\n<li class=\"lvl-6\">没有写请求，或者有写请求但调用线程和持有锁的线程是同一个。(写时可以读，但读时不可以写)</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>线程进入写锁的前提条件：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">没有其他线程的读锁（读写互斥）</li>\n<li class=\"lvl-6\">没有其他线程的写锁（写写互斥）</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>而读写锁有以下三个重要的特性：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">公平选择性：支持非公平（默认）和公平的锁获取方式，吞吐量还是非公平优于公平。</li>\n<li class=\"lvl-6\">可重入：读锁和写锁都支持线程重入。以读写线程为例：读线程获取读锁后，能够再次获取读锁。写线程在获取写锁之后能够再次获取写锁，同时也可以获取读锁。</li>\n<li class=\"lvl-6\">锁降级：遵循获取写锁、再获取读锁最后释放写锁的次序，写锁能够降级成为读锁。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"ReentrantReadWriteLock\">ReentrantReadWriteLock</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>ReentrantReadWriteLock</code> 是可重入的读写锁实现类。在它内部，维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。</p>\n</li>\n<li class=\"lvl-2\">\n<p>只要没有 <code>Writer</code> 线程，读锁可以由多个 <code>Reader</code> 线程同时持有。也就是说，写锁是独占的，读锁是共享的。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>RentrantReadWriteLock</code>支持<code>锁降级</code>，但不支持<code>锁升级</code>，目的也是保证数据可见性。</p>\n</li>\n</ul>\n<h3 id=\"基本语法\">基本语法</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">ReadWriteLock</span> <span class=\"variable\">readWriteLock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantReadWriteLock</span>();</span><br><span class=\"line\"><span class=\"comment\">// 创建读锁</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">Lock</span> <span class=\"variable\">readLock</span> <span class=\"operator\">=</span> readWriteLock.readLock();</span><br><span class=\"line\"><span class=\"comment\">// 创建写锁</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">Lock</span> <span class=\"variable\">writeLock</span> <span class=\"operator\">=</span> readWriteLock.writeLock();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读操作上读锁</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Data <span class=\"title function_\">get</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">    readLock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO 业务逻辑</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        readLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写操作上写锁</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Data <span class=\"title function_\">put</span><span class=\"params\">(String key, Data value)</span> &#123;</span><br><span class=\"line\">    writeLock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO 业务逻辑</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        writeLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>小贴士</strong></em></p>\n<h2 id=\"锁降级\">锁降级</h2>\n<p>锁降级指的是写锁降级成为读锁。<br>\n如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。<br>\n锁降级是指在持有写锁的情况下获取读锁，然后释放写锁。<br>\n锁降级可以帮助我们拿到当前线程修改后的结果而不被其他线程所破坏，防止更新丢失。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">ReadWriteLock</span> <span class=\"variable\">readWriteLock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantReadWriteLock</span>();</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">Lock</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> readWriteLock.readLock();</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">Lock</span> <span class=\"variable\">w</span> <span class=\"operator\">=</span> readWriteLock.writeLock();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">performWriteOperation</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    w.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行写操作，例如修改共享数据</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 锁降级：获取读锁，并释放写锁</span></span><br><span class=\"line\">        r.lock();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        w.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行读操作，例如读取共享数据</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        r.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><em><strong>锁降级中读锁的获取是否必要呢？答案是必要的。</strong></em><br>\n主要是为了保证数据的可见性，如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程（记作线程T）获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新。<br>\n如果当前线程获取读锁，即遵循锁降级的步骤，则线程T将会被阻塞，直到当前线程使用数据并释放读锁之后，线程T才能获取写锁进行数据更新。</p>\n<h2 id=\"锁升级\">锁升级</h2>\n<p>锁降级指的是读锁升级成为写锁。<br>\nRentrantReadWriteLock不支持锁升级（把持读锁、获取写锁，最后释放读锁的过程）。<br>\n目的也是保证数据可见性，如果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新了数据，则其更新对其他获取到读锁的线程是不可见的。</p>\n</div>\n<h2 id=\"ReentrantReadWriteLock应用场景\">ReentrantReadWriteLock应用场景</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>读多写少：<code>ReentrantReadWriteLock</code>适用于读操作比写操作频繁的场景，因为它允许多个读线程同时访问共享数据，而写操作是独占的。</p>\n</li>\n<li class=\"lvl-2\">\n<p>缓存：<code>ReentrantReadWriteLock</code>可以用于实现缓存，因为它可以有效地处理大量的读操作，同时保护缓存数据的一致性。</p>\n</li>\n</ul>\n<h2 id=\"ReentrantLock-和-ReentrantReadWriteLock-比较\">ReentrantLock 和 ReentrantReadWriteLock 比较</h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>ReentrantLock</th>\n<th>ReentrantReadWriteLock</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>锁类型</td>\n<td>独占锁（Exclusive Lock）</td>\n<td>读写锁（Read-Write Lock）</td>\n</tr>\n<tr>\n<td>读-读并发性</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>读-写并发性</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>写-写并发性</td>\n<td>不支持</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>锁的公平性</td>\n<td>支持设置为公平或非公平锁</td>\n<td>支持设置为公平或非公平锁</td>\n</tr>\n<tr>\n<td>性能</td>\n<td>适用于读操作少、写操作多的场景</td>\n<td>适用于读操作频繁、写操作较少的场景</td>\n</tr>\n<tr>\n<td>锁降级</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>可重入性</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>API</td>\n<td>提供基本锁操作方法（lock、unlock、tryLock等）</td>\n<td>提供与ReentrantLock类似的锁操作方法，以及读锁和写锁的获取方法</td>\n</tr>\n<tr>\n<td>适用场景</td>\n<td>读操作较少、写操作较多的场景，互斥访问共享资源</td>\n<td>读操作频繁、写操作较少的场景，读多写少的并发访问</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"ReentrantReadWriteLock-的问题\">ReentrantReadWriteLock 的问题</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果有线程正在读，写线程需要等待读线程释放锁后才能获取写锁，即读的过程中不允许写，这是一种悲观的读锁。</p>\n</li>\n</ul>\n<h2 id=\"悲观锁与乐观锁\">悲观锁与乐观锁</h2>\n<table>\n<thead>\n<tr>\n<th>锁策略</th>\n<th>悲观锁（Pessimistic Locking）</th>\n<th>乐观锁（Optimistic Locking）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>预期</td>\n<td>悲观锁认为并发访问中会发生冲突，因此默认情况下假设其他线程会干扰当前线程的操作。</td>\n<td>乐观锁认为并发冲突的概率较低，因此默认情况下假设其他线程不会干扰当前线程的操作。</td>\n</tr>\n<tr>\n<td>实现方式</td>\n<td>悲观锁通常使用互斥锁（如ReentrantLock）或数据库的行级锁来实现。</td>\n<td>乐观锁通常使用版本号（Versioning）或比较并交换（Compare and Swap）等机制来实现。</td>\n</tr>\n<tr>\n<td>加锁时机</td>\n<td>悲观锁在访问共享资源之前获取锁，以确保其他线程无法同时访问资源。</td>\n<td>乐观锁在更新数据时不进行加锁，而是在更新时检查是否有其他线程修改了数据。如果未发生变化，则进行更新，否则进行冲突处理。</td>\n</tr>\n<tr>\n<td>数据一致性</td>\n<td>悲观锁保证了数据的完整性和一致性，因为始终保持对共享资源的独占访问。</td>\n<td>乐观锁无法保证数据的一致性，因为在更新时可能会发生冲突，需要进行相应的冲突处理，可能导致部分更新被丢弃或需要重试。</td>\n</tr>\n<tr>\n<td>竞争与性能</td>\n<td>悲观锁在并发访问高的情况下可能导致线程竞争和性能下降，因为每个线程都需要等待获取锁。</td>\n<td>乐观锁避免了大部分加锁和解锁开销，适用于并发冲突概率较低的场景，可以提高并发性能。但如果冲突频率较高，乐观锁可能需要进行多次重试或回滚操作。</td>\n</tr>\n<tr>\n<td>适用场景</td>\n<td>悲观锁适用于并发冲突概率较高的场景，需要保证数据的一致性和完整性，适用于互斥访问共享资源的场景。</td>\n<td>乐观锁适用于并发冲突概率较低的场景，适用于读多写少的并发访问，可以提高并发性能，但需要处理可能的冲突和数据一致性</td>\n</tr>\n</tbody>\n</table>\n","content_text":"摘要 本文介绍ReentrantReadWriteLock相关技术 本文基于jdk1.8 读写锁 读写锁ReadWriteLock，顾名思义一把锁分为读与写两部分，读锁允许多个线程同时获得，因为读操作本身是线程安全的。而写锁是互斥锁，不允许多个线程同时获得写锁。并且读与写操作也是互斥的。读写锁适合多读少写的业务场景。 线程进入读锁的前提条件： 没有其他线程的写锁（读写互斥，但是读读不互斥） 没有写请求，或者有写请求但调用线程和持有锁的线程是同一个。(写时可以读，但读时不可以写) 线程进入写锁的前提条件： 没有其他线程的读锁（读写互斥） 没有其他线程的写锁（写写互斥） 而读写锁有以下三个重要的特性： 公平选择性：支持非公平（默认）和公平的锁获取方式，吞吐量还是非公平优于公平。 可重入：读锁和写锁都支持线程重入。以读写线程为例：读线程获取读锁后，能够再次获取读锁。写线程在获取写锁之后能够再次获取写锁，同时也可以获取读锁。 锁降级：遵循获取写锁、再获取读锁最后释放写锁的次序，写锁能够降级成为读锁。 ReentrantReadWriteLock ReentrantReadWriteLock 是可重入的读写锁实现类。在它内部，维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。 只要没有 Writer 线程，读锁可以由多个 Reader 线程同时持有。也就是说，写锁是独占的，读锁是共享的。 RentrantReadWriteLock支持锁降级，但不支持锁升级，目的也是保证数据可见性。 基本语法 12345678910111213141516171819202122232425private ReadWriteLock readWriteLock = new ReentrantReadWriteLock();// 创建读锁private Lock readLock = readWriteLock.readLock();// 创建写锁private Lock writeLock = readWriteLock.writeLock();// 读操作上读锁public Data get(String key) &#123; readLock.lock(); try &#123; // TODO 业务逻辑 &#125; finally &#123; readLock.unlock(); &#125;&#125;// 写操作上写锁public Data put(String key, Data value) &#123; writeLock.lock(); try &#123; // TODO 业务逻辑 &#125; finally &#123; writeLock.unlock(); &#125;&#125; 小贴士 锁降级 锁降级指的是写锁降级成为读锁。 如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。 锁降级是指在持有写锁的情况下获取读锁，然后释放写锁。 锁降级可以帮助我们拿到当前线程修改后的结果而不被其他线程所破坏，防止更新丢失。 123456789101112131415161718192021private ReadWriteLock readWriteLock = new ReentrantReadWriteLock();private Lock r = readWriteLock.readLock();private Lock w = readWriteLock.writeLock();public void performWriteOperation() &#123; w.lock(); try &#123; // 执行写操作，例如修改共享数据 // 锁降级：获取读锁，并释放写锁 r.lock(); &#125; finally &#123; w.unlock(); &#125; try &#123; // 执行读操作，例如读取共享数据 &#125; finally &#123; r.unlock(); &#125;&#125; 锁降级中读锁的获取是否必要呢？答案是必要的。 主要是为了保证数据的可见性，如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程（记作线程T）获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新。 如果当前线程获取读锁，即遵循锁降级的步骤，则线程T将会被阻塞，直到当前线程使用数据并释放读锁之后，线程T才能获取写锁进行数据更新。 锁升级 锁降级指的是读锁升级成为写锁。 RentrantReadWriteLock不支持锁升级（把持读锁、获取写锁，最后释放读锁的过程）。 目的也是保证数据可见性，如果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新了数据，则其更新对其他获取到读锁的线程是不可见的。 ReentrantReadWriteLock应用场景 读多写少：ReentrantReadWriteLock适用于读操作比写操作频繁的场景，因为它允许多个读线程同时访问共享数据，而写操作是独占的。 缓存：ReentrantReadWriteLock可以用于实现缓存，因为它可以有效地处理大量的读操作，同时保护缓存数据的一致性。 ReentrantLock 和 ReentrantReadWriteLock 比较 特性 ReentrantLock ReentrantReadWriteLock 锁类型 独占锁（Exclusive Lock） 读写锁（Read-Write Lock） 读-读并发性 不支持 支持 读-写并发性 不支持 支持 写-写并发性 不支持 不支持 锁的公平性 支持设置为公平或非公平锁 支持设置为公平或非公平锁 性能 适用于读操作少、写操作多的场景 适用于读操作频繁、写操作较少的场景 锁降级 不支持 支持 可重入性 支持 支持 API 提供基本锁操作方法（lock、unlock、tryLock等） 提供与ReentrantLock类似的锁操作方法，以及读锁和写锁的获取方法 适用场景 读操作较少、写操作较多的场景，互斥访问共享资源 读操作频繁、写操作较少的场景，读多写少的并发访问 ReentrantReadWriteLock 的问题 如果有线程正在读，写线程需要等待读线程释放锁后才能获取写锁，即读的过程中不允许写，这是一种悲观的读锁。 悲观锁与乐观锁 锁策略 悲观锁（Pessimistic Locking） 乐观锁（Optimistic Locking） 预期 悲观锁认为并发访问中会发生冲突，因此默认情况下假设其他线程会干扰当前线程的操作。 乐观锁认为并发冲突的概率较低，因此默认情况下假设其他线程不会干扰当前线程的操作。 实现方式 悲观锁通常使用互斥锁（如ReentrantLock）或数据库的行级锁来实现。 乐观锁通常使用版本号（Versioning）或比较并交换（Compare and Swap）等机制来实现。 加锁时机 悲观锁在访问共享资源之前获取锁，以确保其他线程无法同时访问资源。 乐观锁在更新数据时不进行加锁，而是在更新时检查是否有其他线程修改了数据。如果未发生变化，则进行更新，否则进行冲突处理。 数据一致性 悲观锁保证了数据的完整性和一致性，因为始终保持对共享资源的独占访问。 乐观锁无法保证数据的一致性，因为在更新时可能会发生冲突，需要进行相应的冲突处理，可能导致部分更新被丢弃或需要重试。 竞争与性能 悲观锁在并发访问高的情况下可能导致线程竞争和性能下降，因为每个线程都需要等待获取锁。 乐观锁避免了大部分加锁和解锁开销，适用于并发冲突概率较低的场景，可以提高并发性能。但如果冲突频率较高，乐观锁可能需要进行多次重试或回滚操作。 适用场景 悲观锁适用于并发冲突概率较高的场景，需要保证数据的一致性和完整性，适用于互斥访问共享资源的场景。 乐观锁适用于并发冲突概率较低的场景，适用于读多写少的并发访问，可以提高并发性能，但需要处理可能的冲突和数据一致性","summary":"摘要 本文介绍ReentrantReadWriteLock相关技术 本文基于jdk1.8","date_published":"2023-05-22T14:30:05.000Z","tags":["技术","java","java多线程","java"]},{"id":"https://blog.hanqunfeng.com/2023/05/19/java-concurrency02-ReentrantLock/","url":"https://blog.hanqunfeng.com/2023/05/19/java-concurrency02-ReentrantLock/","title":"Java并发编程--JUC并发工具类之ReentrantLock","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度 ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍ReentrantLock相关技术</p>\n</li>\n<li class=\"lvl-2\">\n<p>本文基于<code>jdk1.8</code></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"ReentrantLock\">ReentrantLock</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ReentrantLock 是一种可重入的独占锁，它允许同一个线程多次获取同一个锁而不会被阻塞。</p>\n</li>\n<li class=\"lvl-2\">\n<p>它的功能类似于 synchronized，是一种互斥锁，可以保证线程安全。</p>\n</li>\n<li class=\"lvl-2\">\n<p>相对于 synchronized，ReentrantLock 具备如下特点：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">可中断</li>\n<li class=\"lvl-6\">可以设置超时时间</li>\n<li class=\"lvl-6\">可以设置为公平锁</li>\n<li class=\"lvl-6\">支持多个条件变量</li>\n<li class=\"lvl-6\">与 synchronized 一样，都支持可重入</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>它的主要应用场景是在多线程环境下对共享资源进行独占式访问，以保证数据的一致性和安全性。</p>\n</li>\n</ul>\n<h3 id=\"常用API\">常用API</h3>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>void lock()</td>\n<td>获取锁，调用该方法当前线程会获取锁，当锁获得后，该方法返回</td>\n</tr>\n<tr>\n<td>void lockInterruptibly() throws InterruptedException</td>\n<td>可中断的获取锁，和<code>lock()</code>方法不同之处在于该方法会响应中断，即在锁的获取中可以中断当前线程</td>\n</tr>\n<tr>\n<td>boolean tryLock()</td>\n<td>尝试非阻塞的获取锁，调用该方法后立即返回。如果能够获取到返回<code>true</code>，否则返回<code>false</code></td>\n</tr>\n<tr>\n<td>boolean tryLock(long time, TimeUnit unit) throws InterruptedException</td>\n<td>超时获取锁，当前线程在以下三种情况下会被返回:<br>1. 当前线程在超时时间内获取了锁<br>2. 当前线程在超时时间内被中断<br>3. 超时时间结束，返回<code>false</code></td>\n</tr>\n<tr>\n<td>void unlock()</td>\n<td>释放锁</td>\n</tr>\n<tr>\n<td>Condition newCondition()</td>\n<td>获取等待通知组件，该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的<code>await()</code>方法，而调用后，当前线程将释放锁</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"基本语法\">基本语法</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ReentrantLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();<span class=\"comment\">//默认非公平锁</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">ReentrantLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>(<span class=\"literal\">true</span>);<span class=\"comment\">//公平锁</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 加锁 阻塞</span></span><br><span class=\"line\">lock.lock();</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 解锁</span></span><br><span class=\"line\">    lock.unlock();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 尝试加锁 非阻塞</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (lock.tryLock(<span class=\"number\">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在使用时要注意 4 个问题：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">\n<ol>\n<li class=\"lvl-9\">默认情况下 ReentrantLock 为非公平锁而非公平锁;</li>\n</ol>\n</li>\n<li class=\"lvl-6\">\n<ol start=\"2\">\n<li class=\"lvl-9\">加锁次数和释放锁次数一定要保持一致，否则会导致线程阻塞或程序异常;</li>\n</ol>\n</li>\n<li class=\"lvl-6\">\n<ol start=\"3\">\n<li class=\"lvl-9\">加锁操作一定要放在 try 代码之前，这样可以避免未加锁成功又释放锁的异常;</li>\n</ol>\n</li>\n<li class=\"lvl-6\">\n<ol start=\"4\">\n<li class=\"lvl-9\">释放锁一定要放在 finally 中，否则会导致线程阻塞。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<div class=\"tips\">\n<p><em><strong>小贴士</strong></em></p>\n<h2 id=\"公平锁和非公平锁\">公平锁和非公平锁</h2>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">公平锁：线程在获取锁时，按照等待的先后顺序获取锁。</li>\n<li class=\"lvl-2\">非公平锁：线程在获取锁时，不按照等待的先后顺序获取锁，而是随机获取锁。</li>\n</ul>\n<h2 id=\"可重入锁\">可重入锁</h2>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">\n<p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象），不会因为之前已经获取过还没释放而阻塞。</p>\n</li>\n<li class=\"lvl-2\">\n<p>Java中<code>ReentrantLock</code>和<code>synchronized</code>都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。</p>\n</li>\n<li class=\"lvl-2\">\n<p>在实际开发中，可重入锁常常应用于递归操作、调用同一个类中的其他方法、锁嵌套等场景中。</p>\n</li>\n</ul>\n</div>\n<h2 id=\"ReentrantLock的等待通知机制\">ReentrantLock的等待通知机制</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>java.util.concurrent</code>类库中提供<code>Condition</code>类来实现线程之间的协调。</p>\n</li>\n<li class=\"lvl-2\">\n<p>调用<code>Condition.await()</code> 方法使线程等待，同时释放锁</p>\n</li>\n<li class=\"lvl-2\">\n<p>其他线程调用<code>Condition.signal()</code> 或 <code>Condition.signalAll()</code> 方法唤醒等待的线程。</p>\n</li>\n<li class=\"lvl-2\">\n<p>注意：调用<code>Condition</code>的<code>await()</code>和<code>signal()</code>方法，都必须在lock保护之内。</p>\n</li>\n<li class=\"lvl-2\">\n<p>下面是一个使用ReentrantLock的生产者–消费者模型的示例代码，在这个示例程序中，我们使用了一个ReentrantLock和两个Condition（notFull和notEmpty）来实现等待通知机制。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.LinkedList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Queue;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.Condition;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ProducerConsumerExample</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CAPACITY</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>; <span class=\"comment\">// 队列容量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Queue&lt;Integer&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;(); <span class=\"comment\">// 共享队列</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">ReentrantLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>(); <span class=\"comment\">// 可重入锁</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Condition</span> <span class=\"variable\">notFull</span> <span class=\"operator\">=</span> lock.newCondition(); <span class=\"comment\">// 非满条件</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Condition</span> <span class=\"variable\">notEmpty</span> <span class=\"operator\">=</span> lock.newCondition(); <span class=\"comment\">// 非空条件</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">producerThread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()); <span class=\"comment\">// 创建生产者线程</span></span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">consumerThread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()); <span class=\"comment\">// 创建消费者线程</span></span><br><span class=\"line\">        producerThread.start(); <span class=\"comment\">// 启动生产者线程</span></span><br><span class=\"line\">        consumerThread.start(); <span class=\"comment\">// 启动消费者线程</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++) &#123;</span><br><span class=\"line\">                lock.lock(); <span class=\"comment\">// 获取锁</span></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (queue.size() == CAPACITY) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 队列已满，等待非满条件</span></span><br><span class=\"line\">                        notFull.await();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    queue.offer(i); <span class=\"comment\">// 将项目放入队列</span></span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;生产者生产: &quot;</span> + i);</span><br><span class=\"line\">                    <span class=\"comment\">// 通知消费者队列非空</span></span><br><span class=\"line\">                    notEmpty.signal();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    Thread.currentThread().interrupt();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    lock.unlock(); <span class=\"comment\">// 释放锁</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++) &#123;</span><br><span class=\"line\">                lock.lock(); <span class=\"comment\">// 获取锁</span></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (queue.isEmpty()) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 队列为空，等待非空条件</span></span><br><span class=\"line\">                        notEmpty.await();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"type\">int</span> <span class=\"variable\">item</span> <span class=\"operator\">=</span> queue.poll(); <span class=\"comment\">// 从队列中取出项目</span></span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;消费者消费: &quot;</span> + item);</span><br><span class=\"line\">                    <span class=\"comment\">// 通知生产者队列非满</span></span><br><span class=\"line\">                    notFull.signal();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    Thread.currentThread().interrupt();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    lock.unlock(); <span class=\"comment\">// 释放锁</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>对于<code>Condition</code>的<code>await()</code>和<code>signal()</code>方法，它们的行为与使用<code>wait()</code>和<code>notify()</code>方法时的情况类似。具体而言：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\"><code>Condition</code>的<code>await()</code>方法会释放当前线程持有的锁，并使线程进入等待状态，直到接收到<code>signal()</code>方法的通知后才会重新竞争锁并继续执行。</li>\n<li class=\"lvl-6\"><code>Condition</code>的<code>signal()</code>方法会发送一个通知给等待在该条件上的一个线程，使其从等待状态被唤醒。注意，<code>signal()</code>方法执行后，并不会立即释放锁，它会等待当前线程执行完临界区代码后才会释放锁，然后等待被唤醒的线程重新竞争锁。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"ReentrantLock具体应用场景\">ReentrantLock具体应用场景</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1.解决多线程竞争资源的问题，例如多个线程同时对同一个数据库进行写操作，可以使用ReentrantLock保证每次只有一个线程能够写入。</p>\n</li>\n<li class=\"lvl-2\">\n<p>2.实现多线程任务的顺序执行，例如在一个线程执行完某个任务后，再让另一个线程执行任务。</p>\n</li>\n<li class=\"lvl-2\">\n<p>3.实现多线程等待/通知机制，例如在某个线程执行完某个任务后，通知其他线程继续执行任务。</p>\n</li>\n</ul>\n<h2 id=\"ReentrantLock的问题\">ReentrantLock的问题</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ReentrantLock 是一个互斥锁，同一时间只允许一个线程持有锁，其他线程必须等待释放锁后才能获取锁，适用于那些读操作少、写操作多的场景，因为读操作时其他线程无法读取，导致并发性能较低。</p>\n</li>\n<li class=\"lvl-2\">\n<p>ReentrantLock 可以是公平锁（fairness=true）或非公平锁（fairness=false）。在公平锁模式下，锁将按照线程请求的顺序分配，但会导致性能下降。在非公平锁模式下，线程有机会插队获取锁，可能导致某些线程长时间等待。</p>\n</li>\n</ul>\n","content_text":"摘要 本文介绍ReentrantLock相关技术 本文基于jdk1.8 ReentrantLock ReentrantLock 是一种可重入的独占锁，它允许同一个线程多次获取同一个锁而不会被阻塞。 它的功能类似于 synchronized，是一种互斥锁，可以保证线程安全。 相对于 synchronized，ReentrantLock 具备如下特点： 可中断 可以设置超时时间 可以设置为公平锁 支持多个条件变量 与 synchronized 一样，都支持可重入 它的主要应用场景是在多线程环境下对共享资源进行独占式访问，以保证数据的一致性和安全性。 常用API 方法 描述 void lock() 获取锁，调用该方法当前线程会获取锁，当锁获得后，该方法返回 void lockInterruptibly() throws InterruptedException 可中断的获取锁，和lock()方法不同之处在于该方法会响应中断，即在锁的获取中可以中断当前线程 boolean tryLock() 尝试非阻塞的获取锁，调用该方法后立即返回。如果能够获取到返回true，否则返回false boolean tryLock(long time, TimeUnit unit) throws InterruptedException 超时获取锁，当前线程在以下三种情况下会被返回:1. 当前线程在超时时间内获取了锁2. 当前线程在超时时间内被中断3. 超时时间结束，返回false void unlock() 释放锁 Condition newCondition() 获取等待通知组件，该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的await()方法，而调用后，当前线程将释放锁 基本语法 123456789101112131415161718192021ReentrantLock lock = new ReentrantLock();//默认非公平锁ReentrantLock lock = new ReentrantLock(true);//公平锁// 加锁 阻塞lock.lock();try &#123; // ...&#125; finally &#123; // 解锁 lock.unlock();&#125;// 尝试加锁 非阻塞if (lock.tryLock(1, TimeUnit.SECONDS)) &#123; try &#123; // ... &#125; finally &#123; lock.unlock(); &#125;&#125; 在使用时要注意 4 个问题： 默认情况下 ReentrantLock 为非公平锁而非公平锁; 加锁次数和释放锁次数一定要保持一致，否则会导致线程阻塞或程序异常; 加锁操作一定要放在 try 代码之前，这样可以避免未加锁成功又释放锁的异常; 释放锁一定要放在 finally 中，否则会导致线程阻塞。 小贴士 公平锁和非公平锁 公平锁：线程在获取锁时，按照等待的先后顺序获取锁。 非公平锁：线程在获取锁时，不按照等待的先后顺序获取锁，而是随机获取锁。 可重入锁 可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象），不会因为之前已经获取过还没释放而阻塞。 Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。 在实际开发中，可重入锁常常应用于递归操作、调用同一个类中的其他方法、锁嵌套等场景中。 ReentrantLock的等待通知机制 java.util.concurrent类库中提供Condition类来实现线程之间的协调。 调用Condition.await() 方法使线程等待，同时释放锁 其他线程调用Condition.signal() 或 Condition.signalAll() 方法唤醒等待的线程。 注意：调用Condition的await()和signal()方法，都必须在lock保护之内。 下面是一个使用ReentrantLock的生产者–消费者模型的示例代码，在这个示例程序中，我们使用了一个ReentrantLock和两个Condition（notFull和notEmpty）来实现等待通知机制。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.util.LinkedList;import java.util.Queue;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;public class ProducerConsumerExample &#123; private static final int CAPACITY = 10; // 队列容量 private static Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); // 共享队列 private static ReentrantLock lock = new ReentrantLock(); // 可重入锁 private static Condition notFull = lock.newCondition(); // 非满条件 private static Condition notEmpty = lock.newCondition(); // 非空条件 public static void main(String[] args) &#123; Thread producerThread = new Thread(new Producer()); // 创建生产者线程 Thread consumerThread = new Thread(new Consumer()); // 创建消费者线程 producerThread.start(); // 启动生产者线程 consumerThread.start(); // 启动消费者线程 &#125; static class Producer implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; lock.lock(); // 获取锁 try &#123; while (queue.size() == CAPACITY) &#123; // 队列已满，等待非满条件 notFull.await(); &#125; queue.offer(i); // 将项目放入队列 System.out.println(&quot;生产者生产: &quot; + i); // 通知消费者队列非空 notEmpty.signal(); &#125; catch (InterruptedException e) &#123; Thread.currentThread().interrupt(); &#125; finally &#123; lock.unlock(); // 释放锁 &#125; &#125; &#125; &#125; static class Consumer implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; lock.lock(); // 获取锁 try &#123; while (queue.isEmpty()) &#123; // 队列为空，等待非空条件 notEmpty.await(); &#125; int item = queue.poll(); // 从队列中取出项目 System.out.println(&quot;消费者消费: &quot; + item); // 通知生产者队列非满 notFull.signal(); &#125; catch (InterruptedException e) &#123; Thread.currentThread().interrupt(); &#125; finally &#123; lock.unlock(); // 释放锁 &#125; &#125; &#125; &#125;&#125; 对于Condition的await()和signal()方法，它们的行为与使用wait()和notify()方法时的情况类似。具体而言： Condition的await()方法会释放当前线程持有的锁，并使线程进入等待状态，直到接收到signal()方法的通知后才会重新竞争锁并继续执行。 Condition的signal()方法会发送一个通知给等待在该条件上的一个线程，使其从等待状态被唤醒。注意，signal()方法执行后，并不会立即释放锁，它会等待当前线程执行完临界区代码后才会释放锁，然后等待被唤醒的线程重新竞争锁。 ReentrantLock具体应用场景 1.解决多线程竞争资源的问题，例如多个线程同时对同一个数据库进行写操作，可以使用ReentrantLock保证每次只有一个线程能够写入。 2.实现多线程任务的顺序执行，例如在一个线程执行完某个任务后，再让另一个线程执行任务。 3.实现多线程等待/通知机制，例如在某个线程执行完某个任务后，通知其他线程继续执行任务。 ReentrantLock的问题 ReentrantLock 是一个互斥锁，同一时间只允许一个线程持有锁，其他线程必须等待释放锁后才能获取锁，适用于那些读操作少、写操作多的场景，因为读操作时其他线程无法读取，导致并发性能较低。 ReentrantLock 可以是公平锁（fairness=true）或非公平锁（fairness=false）。在公平锁模式下，锁将按照线程请求的顺序分配，但会导致性能下降。在非公平锁模式下，线程有机会插队获取锁，可能导致某些线程长时间等待。","summary":"摘要 本文介绍ReentrantLock相关技术 本文基于jdk1.8","date_published":"2023-05-19T14:30:05.000Z","tags":["技术","java","java多线程","java"]},{"id":"https://blog.hanqunfeng.com/2023/05/18/java-concurrency01-base/","url":"https://blog.hanqunfeng.com/2023/05/18/java-concurrency01-base/","title":"Java并发编程--基本概念","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度 ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍java并发编程相关技术</p>\n</li>\n<li class=\"lvl-2\">\n<p>本文基于<code>jdk1.8</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>并发编程是为了解决什么问题的？<br>\n<em><strong>性能+线程安全</strong></em></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Java并发编程\">Java并发编程</h2>\n<h3 id=\"并发与并行\">并发与并行</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>并发 <code>Concurrent</code>：指应用能够交替执行不同的任务，比如单 CPU 核心下执行多线程并非是同时执行多个任务,如果你开两个线程执行,就是在你几乎不可能察觉到的速度不断去切换这两个任务,已达到&quot;同时执行效果&quot;,其实并不是的,只是计算机的速度太快,我们无法察觉到而已。</p>\n</li>\n<li class=\"lvl-2\">\n<p>并行 <code>Parallel</code>：指应用能够同时在多个CPU核心下执行不同的任务，例:吃饭的时候可以边吃饭边打电话,这两件事情可以同时执行</p>\n</li>\n<li class=\"lvl-2\">\n<p>两者区别：一个是单核交替执行,一个是多核同时执行。</p>\n</li>\n</ul>\n<h3 id=\"线程的状态-生命周期\">线程的状态/生命周期</h3>\n<p>Java 中线程的状态分为 6 种：</p>\n<ol>\n<li class=\"lvl-3\">\n<p>初始(<code>NEW</code>)：新创建了一个线程对象，但还没有调用 start()方法。</p>\n</li>\n<li class=\"lvl-3\">\n<p>运行(<code>RUNNABLE</code>)：Java 线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。线程对象创建后，其他线程(比如 main 线程）调用了该对象的 start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取 CPU 的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得 CPU 时间片后变为运行中状态（running）。</p>\n</li>\n<li class=\"lvl-3\">\n<p>阻塞(<code>BLOCKED</code>)：表示线程阻塞于锁。</p>\n</li>\n<li class=\"lvl-3\">\n<p>等待(<code>WAITING</code>)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</p>\n</li>\n<li class=\"lvl-3\">\n<p>超时等待(<code>TIMED_WAITING</code>)：该状态不同于 WAITING，它可以在指定的时间后自行返回。</p>\n</li>\n<li class=\"lvl-3\">\n<p>终止(<code>TERMINATED</code>)：表示该线程已经执行完毕。<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/3bVMls.png\" alt=\"\" width=\"900\" height=\"600\"></p>\n</li>\n</ol>\n<h3 id=\"Thread与Runnable\">Thread与Runnable</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Thread 才是 Java 里对线程的唯一抽象，Runnable 只是对任务（业务逻辑）的抽象。Thread 可以接受任意一个 Runnable 的实例并执行。</p>\n</li>\n<li class=\"lvl-2\">\n<p>官方说法是在 Java 中有两种方式创建一个线程用以执行，一种是派生自Thread 类，另一种是实现 Runnable 接口。当然本质上 Java 中实现线程只有一种方式，都是通过 new Thread()创建线程对象，调用 Thread#start 启动线程。至于基于 callable 接口的方式，因为最终是要把实现了 callable 接口的对象通过 FutureTask 包装成 Runnable，再交给 Thread 去执行，所以这个其实可以和实现 Runnable 接口看成同一类。</p>\n</li>\n<li class=\"lvl-2\">\n<p>java的多线程最终是交由操作系统来维护和调度的。只有调用Thread对象的start方法才能启动一个线程，start方法不能多次调用，重复调用会抛出异常。Thread 的 start 方法中调用了 start0()方法，而start0()是个 native 方法，这就说明Thread#start 一定和操作系统是密切相关的。</p>\n</li>\n<li class=\"lvl-2\">\n<p>创建并启动线程</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">扩展自Thread类</li>\n</ul>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">UseThread</span> <span class=\"variable\">useThread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UseThread</span>();</span><br><span class=\"line\">useThread.start();</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">实现Runnable接口</li>\n</ul>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">UseRunnable</span> <span class=\"variable\">useRunnable</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UseRunnable</span>();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(useRunnable).start();</span><br></pre></td></tr></table></figure>\n</li>\n<li class=\"lvl-2\">\n<p>static方法</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\"><code>Thread.currentThread()</code>：获取当前线程对象</li>\n<li class=\"lvl-6\"><code>Thread.sleep(10)</code> ：休眠10毫秒</li>\n<li class=\"lvl-6\"><code>Thread.activeCount()</code> ：获取当前活动线程的数量，活动线程是指尚未终止的线程，包括正在运行、等待或阻塞的线程。包括守护线程和非守护线程</li>\n<li class=\"lvl-6\"><code>Thread.yield()</code> : 暂停当前线程，给其他线程执行的机会\n<blockquote>\n<p>1.具体作用如下：提示调度器当前线程愿意放弃当前的 CPU 执行时间片，给其他具有相同优先级的线程执行的机会。不保证一定能让其他线程执行，只是给其他线程执行的机会更大。通常情况下，操作系统的线程调度器会按照一定的算法分配 CPU 时间给各个线程，而 yield() 方法可以用于向调度器发出提示，表明当前线程愿意让出 CPU 时间，让其他线程有更多的机会执行。<br>\n2.当一个线程调用 yield() 方法后，它会进入就绪状态，让出当前的 CPU 时间片，并允许其他线程有更大的机会获得 CPU 时间。然后，调度器会在众多就绪状态的线程中选择一个线程来运行，但选择哪个线程运行是由调度器决定的，可能会选择当前线程继续执行，也可能选择其他线程执行。所以，调用 yield() 方法后，当前线程可能会被立即重新调度并继续执行，也可能在稍后的时间被调度器重新选中并继续执行，也可能在一段时间内都没有被重新调度。</p>\n</blockquote>\n</li>\n<li class=\"lvl-6\"><code>Thread.interrupted()</code> : 用于检查当前线程是否被中断，并返回一个布尔值。调用<code>interrupted()</code>方法会清除当前线程的中断状态。线程是中断状态时，则只有第一次调用<code>interrupted()</code>方法会返回 true。而Thread对象的<code>isInterrupted()</code>方法不会清除中断状态。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>守护线程：主线程结束，则守护线程立即停止</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建并启动线程：</span></span><br><span class=\"line\"><span class=\"type\">UseThread</span> <span class=\"variable\">useThread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UseThread</span>();</span><br><span class=\"line\">useThread.setDaemon(<span class=\"literal\">true</span>); <span class=\"comment\">//设置线程为守护线程，主线程结束，则守护线程立即停止</span></span><br><span class=\"line\">useThread.start();</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>join()</code>: 将指定线程运行完成后再运行后面的代码</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建并启动线程：</span></span><br><span class=\"line\"><span class=\"type\">ThreadA</span> <span class=\"variable\">threadA</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadA</span>();</span><br><span class=\"line\">threadA.start();</span><br><span class=\"line\"><span class=\"comment\">//threadA要运行完成后再运行后面的代码：</span></span><br><span class=\"line\">threadA.join();</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>setPriority()</code>：设置线程优先级</p>\n<blockquote>\n<p>1.优先级的范围从 1~10，其中1表示最低优先级，10表示最高优先级。默认优先级是 5，优先级高的线程分配时间片的数量要多于优先级低的线程。设置线程优先级时，针对频繁阻塞（休眠或者 I/O 操作）的线程需要设置较高优先级，而偏重计算（需要较多 CPU 时间或者偏运算）的线程则设置较低的优先级，确保处理器不会被独占。需要注意的是，线程优先级只是给操作系统提供一个建议，操作系统不保证严格按照优先级来调度线程。在不同的 JVM 以及操作系统上，线程规划会存在差异，有些操作系统甚至会忽略对线程优先级的设定。慎重使用。<br>\n2.Java 线程调度是抢占式调度的，而且 Java 中的线程优先级是通过映射到操作系统的原生线程上实现的，所以线程的调度最终取决于操作系统，操作系统中线程的优先级有时并不能和 Java 中的一一对应，所以Java 优先级并不是特别靠谱。</p>\n</blockquote>\n</li>\n<li class=\"lvl-2\">\n<p>中断线程：</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建并启动线程：</span></span><br><span class=\"line\"><span class=\"type\">ThreadA</span> <span class=\"variable\">threadA</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadA</span>();</span><br><span class=\"line\">threadA.start();</span><br><span class=\"line\"><span class=\"comment\">//中断线程：</span></span><br><span class=\"line\">threadA.interrupt();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//线程方法中判断是否被中断：</span></span><br><span class=\"line\">Thread.currentThread().isInterrupted(); <span class=\"comment\">//中断返回true</span></span><br><span class=\"line\"><span class=\"comment\">//注意：处于死锁状态的线程无法被中断</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"死锁（Deadlock）\">死锁（Deadlock）</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>死锁（Deadlock）是指两个或多个线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，彼此互相等待对方释放资源，导致程序无法继续执行的状态。</p>\n</li>\n<li class=\"lvl-2\">\n<p>死锁通常发生在多个线程同时持有多个共享资源，并试图获取对方持有的资源时。</p>\n</li>\n<li class=\"lvl-2\">\n<p>死锁的发生必须具备以下四个必要条件:</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">1）互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</li>\n<li class=\"lvl-6\">2）请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li>\n<li class=\"lvl-6\">3）不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li>\n<li class=\"lvl-6\">4）环路等待条件：指在发生死锁时，必然存在一个进程–资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的 P0 正在等待一个 P1 占用的资源；P1正在等待 P2 占用的资源，……，Pn 正在等待已被 P0 占用的资源。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>只要打破四个必要条件之一就能有效预防死锁的发生</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。</li>\n<li class=\"lvl-6\">打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。</li>\n<li class=\"lvl-6\">打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。</li>\n<li class=\"lvl-6\">打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>死锁的危害</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">1、线程不工作了，但是整个程序还是活着的</li>\n<li class=\"lvl-6\">2、没有任何的异常信息可以供我们检查。</li>\n<li class=\"lvl-6\">3、一旦程序发生了发生了死锁，是没有任何的办法恢复的，只能重启程序，对生产平台的程序来说，这是个很严重的问题。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>如何查看运行的程序是否有死锁线程</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">通过 jps 查询应用的 id，再通过 jstack id 查看应用的锁的持有情况，进程状态为 BLOCKED 表示死锁</li>\n<li class=\"lvl-6\">jdk1.8以后，jstack 专门给出了死锁的检查，一般在显示信息的最下方展示是否发现死锁信息</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>如何避免死锁</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">1、内部通过顺序比较，确定拿锁的顺序；</li>\n<li class=\"lvl-6\">2、采用尝试拿锁的机制。\n<blockquote>\n<p>尝试拿锁会存在<code>活锁</code>的问题，即多个线程在尝试拿锁的机制中，发生多个线程之间互相谦让，不断发生同一个线程总是拿到同一把锁，在尝试拿另一把锁时因为拿不到，而将本来已经持有的锁释放的过程。<br>\n解决办法：每个线程休眠随机数，错开拿锁的时间。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"synchronized：可以作用在方法或代码块上\"><code>synchronized</code>：可以作用在方法或代码块上</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>方法: 当前对象锁，等价于 <code>synchronized (this)</code></p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">incCountMethod</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    count++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>方法: 当前类锁，等价于 <code>synchronized (Object.class)</code></p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">incCountMethod</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    count++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>代码块：</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//任意对象锁</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">incCountObj</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (obj)&#123;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//当前对象锁</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">incCountBlock</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"built_in\">this</span>)&#123;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//类锁</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">incCountBlock</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (Object.class)&#123;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"wait与notify-notifyAll：等待唤醒机制\"><code>wait</code>与<code>notify</code>/<code>notifyAll</code>：等待唤醒机制</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>一个线程：<code>synchronized (pool)；</code> <code>while(某种条件)</code> 线程等待：<code>pool.wait();</code> 另一个线程：<code>synchronized (pool);</code>  通知其他等待的线程：<code>pool.notifyAll();</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>synchronized</code>作用在方法上时，就是当前对象，直接在方法内使用<code>wait();</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>wait()</code> 和 <code>wait(long timeout)</code> 都是用于线程间进行协作和同步的方法，用于在对象上进行等待。<code>wait()</code> 方法是没有超时参数的形式，它使当前线程进入等待状态，直到其他线程调用相同对象上的 <code>notify()</code> 或 <code>notifyAll()</code> 方法来唤醒等待的线程，或者当前线程被中断（<code>InterruptedException</code>）。<code>wait(long timeout)</code> 方法是带有超时参数的形式，它使当前线程进入等待状态，但最多等待指定的时间（以毫秒为单位）。如果超过指定时间还未被唤醒，线程将自动唤醒并继续执行。这个方法可以防止线程永久地等待下去，即使没有其他线程调用相同对象上的 <code>notify()</code> 或 <code>notifyAll()</code> 方法。因此，<code>wait()</code> 方法是一直等待直到被唤醒或中断，而 <code>wait(long timeout)</code> 方法是等待一段时间后自动唤醒，或者在被唤醒之前超过了指定的等待时间。需要注意的是，这两个方法必须在同步代码块（<code>synchronized</code>）内部调用，并且在调用这些方法前，线程必须拥有对象的监视器（即获取了对象的锁）。否则，将会抛出 <code>IllegalMonitorStateException</code> 异常。</p>\n</li>\n<li class=\"lvl-2\">\n<p>尽可能用 <code>notifyall()</code>，谨慎使用 <code>notify()</code>，因为 <code>notify()</code>只会唤醒一个线程，我们无法确保被唤醒的这个线程一定就是我们需要唤醒的线程</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>yield()</code> 、<code>sleep()</code>被调用后，都不会释放当前线程所持有的锁。调用 <code>wait()</code>方法后，会释放当前线程持有的锁，而且当前被唤醒后，会重新去竞争锁，锁竞争到后才会执行 <code>wait()</code> 方法后面的代码。调用 <code>notify()</code>系列方法后，对锁无影响，线程只有在 <code>synchronized</code> 同步代码执行完后才会自然而然的释放锁，所以 <code>notify()</code>系列方法一般都是 <code>synchronized</code> 同步代码的最后一行。</p>\n</li>\n<li class=\"lvl-2\">\n<p>为什么你应该在循环中检查等待条件?</p>\n<blockquote>\n<p>处于等待状态的线程可能会收到错误警报和伪唤醒(被唤醒时不一定满足等待条件)，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在 <code>notify()</code>方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用 <code>wait()</code>方法效果更好的原因。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"Callable-T-、Future-T-与FutureTask-T\"><code>Callable&lt;T&gt;</code>、<code>Future&lt;T&gt;</code>与<code>FutureTask&lt;T&gt;</code>:</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>Callable</code> 位于 <code>java.util.concurrent</code> 包下，它也是一个接口，在它里面也只声明了一个方法，只不过这个方法叫做 <code>call()</code>，这是一个泛型接口，<code>call()</code>函数返回的类型就是传递进来的 <code>T</code> 类型。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>FutureTask</code> 类实现了 <code>RunnableFuture</code> 接口，<code>RunnableFuture</code> 继承了 <code>Runnable</code>接口和 <code>Future</code> 接口，而 <code>FutureTask</code> 实现了 <code>RunnableFuture</code> 接口。所以它既可以作为 <code>Runnable</code> 被线程执行，又可以作为 <code>Future</code> 得到 <code>Callable</code> 的返回值。</p>\n</li>\n<li class=\"lvl-2\">\n<p>自定义<code>Callable&lt;T&gt;</code>的实现类，其有返回值，比如：<code>public class UseCallable implements Callable&lt;Integer&gt;</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>创建<code>FutureTask</code>：<code>FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(new UseCallable());</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>启动线程：<code>new Thread(futureTask).start();</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>获取返回值：<code>futureTask.get();</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>中断线程：<code>futureTask.cancel(true);</code></p>\n</li>\n</ul>\n<h3 id=\"CompletableFuture-T-：返回值的子线程，这里只罗列一些常用的方法\"><code>CompletableFuture&lt;T&gt;</code>：返回值的子线程，这里只罗列一些常用的方法</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建：</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">//子线程代码逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;str&quot;</span>; <span class=\"comment\">//返回值</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>工厂方法：</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">supplyAsync</span><span class=\"params\">(Supplier&lt;U&gt; supplier)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class=\"title function_\">supplyAsync</span><span class=\"params\">(Supplier&lt;U&gt; supplier,Executor executor)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">runAsync</span><span class=\"params\">(Runnable runnable)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> CompletableFuture&lt;Void&gt; <span class=\"title function_\">runAsync</span><span class=\"params\">(Runnable runnable,Executor executor)</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Asynsc 表示异步,而 supplyAsync 与 runAsync 不同在于，supplyAsync 异步返回一个结果,runAsync 是 void。第二个函数第二个参数表示是用我们自己创建的线程池,否则采用默认的ForkJoinPool.commonPool()作为它的线程池</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>获取返回值: <code>get</code>与<code>join</code>的区别</p>\n<blockquote>\n<p>future.get(); 需要处理异常：InterruptedException，ExecutionException<br>\nfuture.join();  不需要处理异常</p>\n</blockquote>\n</li>\n<li class=\"lvl-2\">\n<p><code>allOf</code>、<code>anyOf</code></p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.allOf(future1,future2,future3).thenRun(()-&gt;&#123;</span><br><span class=\"line\">    <span class=\"comment\">//所有线程全部返回</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;All done!&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//接收返回最快的那个值</span></span><br><span class=\"line\">CompletableFuture&lt;Object&gt; f = CompletableFuture.anyOf(future1,future2,future3);</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>处理返回结果：</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//thenAccept :消费，没有返回值</span></span><br><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; <span class=\"string\">&quot;hello&quot;</span>).thenAccept(s -&gt; System.out.println(s+<span class=\"string\">&quot; world&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//thenApply ：变更返回结果(值或类型)</span></span><br><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; <span class=\"string\">&quot;hello&quot;</span>).thenApply(s -&gt; s + <span class=\"string\">&quot; world&quot;</span>).join();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//exceptionally ：捕获异常并返回结果</span></span><br><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; <span class=\"string\">&quot;hello&quot;</span>).exceptionally(e -&gt; &#123;</span><br><span class=\"line\">    System.out.println(e.getMessage());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello world&quot;</span>;</span><br><span class=\"line\">&#125;).join();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//thenCompose ：第一个future的结果作为第二个future的参数</span></span><br><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; <span class=\"number\">10</span>).thenCompose(i -&gt; CompletableFuture.supplyAsync(() -&gt; i+<span class=\"number\">1</span>)).join();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//whenComplete：不修改返回值</span></span><br><span class=\"line\"><span class=\"comment\">//whenComplete()方法接收一个BiConsumer参数，当异步任务完成时，无论是否发生异常，都会执行该BiConsumer。如果任务发生异常，异常信息会被传递给BiConsumer，但whenComplete()方法无法修改异常或处理异常。</span></span><br><span class=\"line\">    CompletableFuture.supplyAsync(() -&gt; <span class=\"string\">&quot;hello&quot;</span>).whenComplete((s, t) -&gt; &#123;</span><br><span class=\"line\">        System.out.println(s); <span class=\"comment\">//s是返回值</span></span><br><span class=\"line\">        System.out.println(t.getMessage()); <span class=\"comment\">//t是异常对象</span></span><br><span class=\"line\">    &#125;).join();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//handle ：会修改返回值</span></span><br><span class=\"line\"><span class=\"comment\">//handle()方法接收一个BiFunction参数，当异步任务完成时，可以对任务的结果进行处理。如果任务发生异常，异常信息会被传递给BiFunction，并允许你根据异常进行处理并返回一个结果。如果没有异常发生，BiFunction将使用任务的结果进行处理。</span></span><br><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; <span class=\"string\">&quot;hello&quot;</span>).handle((s, t) -&gt; &#123;</span><br><span class=\"line\">    System.out.println(s); <span class=\"comment\">//s是返回值</span></span><br><span class=\"line\">    System.out.println(t.getMessage()); <span class=\"comment\">//t是异常对象return s;</span></span><br><span class=\"line\">&#125;).join();</span><br></pre></td></tr></table></figure>\n<h3 id=\"volatile：最轻量的通信-同步机制，保证变量在多个线程间的可见性，即值被一个线程修改，其它线程立刻可见\">volatile：最轻量的通信/同步机制，保证变量在多个线程间的可见性，即值被一个线程修改，其它线程立刻可见</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> <span class=\"type\">boolean</span> ready;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>volatile</code> 不能保证数据在多个线程下同时写时的线程安全</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>volatile</code> 最适用的场景：一个线程写，多个线程读。</p>\n</li>\n</ul>\n<h3 id=\"ThreadLocal-T-：保证线程变量独享\">ThreadLocal<T> ：保证线程变量独享</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadLocal&lt;String&gt; threadLocal = <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadLocal</span>&lt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">//设置当前线程的线程局部变量的值。</span></span><br><span class=\"line\">threadLocal.set(<span class=\"string\">&quot;线程变量&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//返回当前线程所对应的线程局部变量。</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> threadLocal.get();</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>初始化方法</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//方式1</span></span><br><span class=\"line\">ThreadLocal&lt;Integer&gt; threadLocal1 = <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadLocal</span>&lt;Integer&gt;()&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> Integer <span class=\"title function_\">initialValue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//方式2，Java 8及更高版本</span></span><br><span class=\"line\">ThreadLocal&lt;Integer&gt; threadLocal2 = ThreadLocal.withInitial(() -&gt; <span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>为了避免内存泄露，ThreadLocal变量用完后要进行销毁：<code>threadLocal.remove();</code></p>\n</li>\n</ul>\n<h3 id=\"CAS\">CAS</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>CAS 是 <code>Compare and Swap</code>（比较并交换）的缩写，是一种常见的并发编程技术，也是原子类实现线程安全的基础操作。CAS 操作包括三个参数：一个内存位置（通常是一个变量的内存地址）、期望的值和新值。CAS 操作会先比较内存位置的当前值与期望的值是否相等，如果相等，则将内存位置的值替换为新值，否则不进行任何操作。ßCAS 操作是原子的，即在进行比较和交换的过程中不会被其他线程干扰。</p>\n</li>\n<li class=\"lvl-2\">\n<p>CAS 实现原子操作的三大问题</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">ABA 问题\n<blockquote>\n<p>下文有对ABA问题的介绍</p>\n</blockquote>\n</li>\n<li class=\"lvl-6\">循环时间长开销大\n<blockquote>\n<p>自旋 CAS 如果长时间不成功，会给 CPU 带来非常大的执行开销。</p>\n</blockquote>\n</li>\n<li class=\"lvl-6\">只能保证一个共享变量的原子操作\n<blockquote>\n<p>当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁。<br>\n从 Java 1.5开始，JDK 提供了 <code>AtomicReference</code> 类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行 CAS 操作。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"原子操作类\">原子操作类:</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Integer：AtomicInteger，AtomicIntegerArray</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">AtomicInteger</span> <span class=\"variable\">ai</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">ai.get(); <span class=\"comment\">//获取当前值</span></span><br><span class=\"line\">ai.set(<span class=\"number\">10</span>); <span class=\"comment\">//设置新值</span></span><br><span class=\"line\">ai.getAndIncrement();  <span class=\"comment\">//获取原值并自增，getAndDecrement()自减</span></span><br><span class=\"line\">ai.incrementAndGet(); <span class=\"comment\">//获取自增后的值，decrementAndGet()自减</span></span><br><span class=\"line\">ai.compareAndSet(原值,新值); <span class=\"comment\">//比较并设置新值，成功返回true</span></span><br><span class=\"line\">ai.getAndAdd(<span class=\"number\">24</span>); <span class=\"comment\">//增加指定的值后返回原值</span></span><br><span class=\"line\">ai.addAndGet(<span class=\"number\">24</span>); <span class=\"comment\">//增加指定的值后返回新值</span></span><br><span class=\"line\"><span class=\"comment\">//基于数组初始化</span></span><br><span class=\"line\"><span class=\"type\">AtomicIntegerArray</span> <span class=\"variable\">ai</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicIntegerArray</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[] &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span> &#125;);</span><br><span class=\"line\"><span class=\"comment\">//基于数组长度初始化</span></span><br><span class=\"line\"><span class=\"type\">AtomicIntegerArray</span> <span class=\"variable\">ai</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicIntegerArray</span>(<span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Long：<code>AtomicLong</code>，<code>AtomicLongArray</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>Long：<code>LongAdder</code>，加、减、求和等操作性能高于<code>AtomicLong</code></p>\n</li>\n</ul>\n<div class=\"tips\">\n<p><em><strong>小贴士</strong></em><br>\nAtomicLong 是利用了底层的 CAS 操作来提供并发性的，调用了 Unsafe 类的getAndAddLong 方法，该方法是个 native 方法，它的逻辑是采用自旋的方式不断更新目标值，直到更新成功。<br>\n在并发量较低的环境下，线程冲突的概率比较小，自旋的次数不会很多。但是，高并发环境下，N 个线程同时进行自旋操作，会出现大量失败并不断自旋的情况，此时 AtomicLong 的自旋会成为瓶颈。<br>\n这就是 LongAdder 引入的初衷——解决高并发环境下 AtomicLong 的自旋瓶颈问题。</p>\n<p>AtomicLong 中有个内部变量 value 保存着实际的 long 值，所有的操作都是针对该变量进行。也就是说，高并发环境下，value 变量其实是一个热点，也就是 N 个线程竞争一个热点。<br>\nLongAdder 的基本思路就是分散热点，将 value 值分散到一个数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行 CAS 操作，这样热点就被分散了，冲突的概率就小很多。<br>\n如果要获取真正的 long 值，只要将各个槽中的变量值累加返回。</p>\n<p>这种做法和 ConcurrentHashMap 中的“分段锁”其实就是类似的思路。<br>\nLongAdder 提供的 API 和 AtomicLong 比较接近，两者都能以原子的方式对long 型变量进行增减。</p>\n<p>但是 AtomicLong 提供的功能其实更丰富，尤其是 addAndGet、decrementAndGet、compareAndSet 这些方法。<br>\naddAndGet、decrementAndGet 除了单纯的做自增自减外，还可以立即获取增减后的值，而 LongAdder 则需要做同步控制才能精确获取增减后的值。如果业务需求需要精确的控制计数，做计数比较，AtomicLong 也更合适。</p>\n<p>另外，从空间方面考虑，LongAdder 其实是一种“空间换时间”的思想，从这一点来讲 AtomicLong 更适合。<br>\n总之，低并发、一般的业务场景下 AtomicLong 是足够了。如果并发量很多，存在大量写多读少的情况，那 LongAdder 可能更合适。</p>\n</div>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Double：<code>DoubleAdder</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>对象：<code>AtomicReference</code>，<code>AtomicReferenceArray</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>对象：<code>AtomicStampedReference</code>：引入版本号，用于解决ABA问题</p>\n</li>\n</ul>\n<div class=\"tips\">\n<p><em><strong>小贴士</strong></em><br>\n如果你想比较AtomicReference中存储的User对象，你需要确保User类正确实现了适当的equals()和hashCode()方法。<br>\n在Java中，对象的比较通常是通过equals()方法来实现的。equals()方法用于判断两个对象是否相等。当你使用AtomicReference进行比较时，它将使用equals()方法来比较存储在AtomicReference中的对象。<br>\n默认情况下，Object类的equals()方法比较的是对象的引用，而不是内容。因此，如果你想在AtomicReference中比较User对象的内容而不是引用，你需要在User类中重写equals()方法来进行内容比较。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 省略构造函数和其他方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">equals</span><span class=\"params\">(Object o)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span> == o) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"literal\">null</span> || getClass() != o.getClass()) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> (User) o;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (age != user.age) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name != <span class=\"literal\">null</span> ? name.equals(user.name) : user.name == <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">hashCode</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> name != <span class=\"literal\">null</span> ? name.hashCode() : <span class=\"number\">0</span>;</span><br><span class=\"line\">        result = <span class=\"number\">31</span> * result + age;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上述示例中，我们重写了equals()方法以比较User对象的name和age属性。我们使用了自动生成的hashCode()方法来生成哈希码，以保证在使用哈希表等数据结构时的正确性。<br>\n重写了equals()和hashCode()方法后，你可以使用AtomicReference<User>来比较User对象。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AtomicReference&lt;User&gt; atomicReference = <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicReference</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">User</span>(<span class=\"string\">&quot;Alice&quot;</span>, <span class=\"number\">25</span>));</span><br><span class=\"line\"><span class=\"type\">User</span> <span class=\"variable\">expectedUser</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>(<span class=\"string\">&quot;Alice&quot;</span>, <span class=\"number\">25</span>);</span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"variable\">updated</span> <span class=\"operator\">=</span> atomicReference.compareAndSet(expectedUser, <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>(<span class=\"string\">&quot;Bob&quot;</span>, <span class=\"number\">30</span>));</span><br></pre></td></tr></table></figure>\n<p>而AtomicStampedReference是为了解决ABA问题而设计的，并提供了对对象引用的比较以及对标记（stamp）的比较。<br>\nAtomicStampedReference通过引入一个标记（stamp）来解决ABA问题。它不仅比较对象引用，还比较对象的标记值。当对象和标记值都相等时，才认为对象相等。</p>\n</div>\n<h3 id=\"ABA\">ABA</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ABA 问题指的是在并发环境下，某个线程对一个值进行比较并操作时，可能出现以下情况：</p>\n</li>\n</ul>\n<ol>\n<li class=\"lvl-3\">\n<p>初始状态下，值为 A。</p>\n</li>\n<li class=\"lvl-3\">\n<p>线程 1 将值从 A 修改为 B。</p>\n</li>\n<li class=\"lvl-3\">\n<p>线程 1 又将值从 B 修改回 A。</p>\n</li>\n<li class=\"lvl-3\">\n<p>线程 2 检查值，发现值仍然是 A，于是做出操作。<br>\n从线程 2 的角度来看，值似乎没有被修改过，但实际上经历了从 A 到 B 再到 A 的变化。这种情况可能会导致意外的结果或错误的判断。<br>\nABA 问题的发生是因为 CAS 操作只关注当前值和期望值是否相等，而不考虑期间发生的其他变化。<br>\n在上述示例中，CAS 操作在进行比较时，发现当前值仍然是 A，与期望值相等，因此会执行操作，但它无法感知到值的中间变化。<br>\nABA 问题可能会对某些并发算法和数据结构产生影响，例如自旋锁、无锁算法等。<br>\n为了解决 ABA 问题，可以使用一种称为 “版本号” 的技术，每次修改值时都会增加一个版本号，这样在进行 CAS 操作时除了比较值本身，还会比较版本号，从而避免了 ABA 问题的发生。<br>\n在Java中，<code>AtomicStampedReference</code>就是通过引入版本号（标记）来解决ABA问题的一种原子类。</p>\n</li>\n</ol>\n<h3 id=\"重排序\">重排序</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在Java中，重排序是指编译器和处理器为了提高程序性能而对指令执行顺序进行重新排序的优化技术。重排序可以改变程序中指令的执行顺序，但不会改变程序的最终结果（即保持串行语义），因为这些重排序是在保持依赖关系的前提下进行的。</p>\n</li>\n<li class=\"lvl-2\">\n<p>然而，重排序可能会导致并发安全问题。并发安全问题主要涉及到多线程的执行顺序和对共享数据的访问。</p>\n</li>\n<li class=\"lvl-2\">\n<p>考虑以下示例代码：</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>上述代码是一个经典的基于双重检查锁定的懒汉式单例模式。在单线程环境下，这段代码是没有问题的。但是在多线程环境下，由于重排序的存在会导致线程安全问题，为什么呢？</p>\n</li>\n<li class=\"lvl-2\">\n<p>这是因为<code>instance = new Singleton();</code>虽然只有一行代码，但是其实在具体执行的时候有好几步操作：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">1、JVM 为 <code>Singleton</code> 的对象实例在内存中分配空间</li>\n<li class=\"lvl-6\">2、进行对象初始化，完成 <code>new</code> 操作</li>\n<li class=\"lvl-6\">3、JVM 把这个空间的地址赋给我们的引用 <code>instance</code></li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>因为 JVM 内部的实现原理会导致重排序，就会产生一种情况，第 3 步会在第 2 步之前执行。</p>\n</li>\n<li class=\"lvl-2\">\n<p>于是在多线程下就会产生问题：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">A 线程正在 syn 同步块中执行 <code>instance = new Singleton();</code>，</li>\n<li class=\"lvl-6\">此时 B 线程也来执行 <code>getInstance()</code>，进行了 <code>instance == null</code> 的检查，</li>\n<li class=\"lvl-6\">因为第 3 步会在第 2 步之前执行，B 线程检查发现 <code>instance</code> 不为 <code>null</code>，会直接拿着 <code>instance</code> 实例使用，</li>\n<li class=\"lvl-6\">但是这时 A 线程还在执行对象初始化，这就导致 B 线程拿到的 <code>instance</code> 实例可能只初始化了一半，B 线程访问 <code>instance</code> 实例中的对象域就很有可能出错。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>这些问题是由于编译器和处理器进行的重排序导致的，并发安全问题不会在单线程环境下出现，只有在多线程环境下才会显现。</p>\n</li>\n<li class=\"lvl-2\">\n<p>另外，即使在同步块内部没有发生重排序，当一个线程在初始化实例时，由于处理器和内存之间的交互延迟，也可能存在可见性问题。</p>\n</li>\n<li class=\"lvl-2\">\n<p>为了解决这些问题，可以使用<code>volatile</code>关键字来修饰<code>instance</code>，<code>volatile</code>会禁止编译器和处理器进行重排序，同时使用<code>volatile</code>修饰的变量时，会先清除当前线程的本地缓存再从主内存中重新加载数据，以确保可见性：</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton instance;</span><br></pre></td></tr></table></figure>\n<h3 id=\"管程与MESA模型\">管程与MESA模型</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>管程(Monitor): 是一种并发编程的概念模型，旨在解决多线程程序中的互斥访问和同步问题。它提供了一种结构化的方式来管理共享资源，并确保线程在访问共享资源时的安全性。</p>\n</li>\n<li class=\"lvl-2\">\n<p>MESA(Meta-Environment for Scheduling Agents)模型: 是现在正在广泛使用的管程模型。<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/2aB7dM.jpg\" alt=\"\"></p>\n</li>\n</ul>\n<h3 id=\"AQS\">AQS</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>java.util.concurrent</code>包中的大多数同步器实现都是围绕着共同的基础行为，比如等待队列、条件队列、独占获取、共享获取等，而这些行为的抽象就是基于<code>AbstractQueuedSynchronizer</code>（简称<code>AQS</code>）实现的，<code>AQS</code>是一个抽象同步框架，可以用来实现一个依赖状态的同步器。</p>\n</li>\n<li class=\"lvl-2\">\n<p>JDK中提供的大多数的同步器如<code>Lock</code>, <code>Latch</code>, <code>Barrier</code>等，都是基于AQS框架来实现的。<br>\n<img src=\"https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/vz5BJt.png\" alt=\"\"></p>\n</li>\n<li class=\"lvl-2\">\n<p>基于AQS构建的<code>ReentrantLock</code>和<code>CountDownLatch</code>等同步类就是借鉴了MESA模型中的概念和技术，如互斥锁、条件变量等，以提供线程间的同步和互斥功能。</p>\n</li>\n</ul>\n","content_text":"摘要 本文介绍java并发编程相关技术 本文基于jdk1.8 并发编程是为了解决什么问题的？ 性能+线程安全 Java并发编程 并发与并行 并发 Concurrent：指应用能够交替执行不同的任务，比如单 CPU 核心下执行多线程并非是同时执行多个任务,如果你开两个线程执行,就是在你几乎不可能察觉到的速度不断去切换这两个任务,已达到&quot;同时执行效果&quot;,其实并不是的,只是计算机的速度太快,我们无法察觉到而已。 并行 Parallel：指应用能够同时在多个CPU核心下执行不同的任务，例:吃饭的时候可以边吃饭边打电话,这两件事情可以同时执行 两者区别：一个是单核交替执行,一个是多核同时执行。 线程的状态/生命周期 Java 中线程的状态分为 6 种： 初始(NEW)：新创建了一个线程对象，但还没有调用 start()方法。 运行(RUNNABLE)：Java 线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。线程对象创建后，其他线程(比如 main 线程）调用了该对象的 start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取 CPU 的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得 CPU 时间片后变为运行中状态（running）。 阻塞(BLOCKED)：表示线程阻塞于锁。 等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。 超时等待(TIMED_WAITING)：该状态不同于 WAITING，它可以在指定的时间后自行返回。 终止(TERMINATED)：表示该线程已经执行完毕。 Thread与Runnable Thread 才是 Java 里对线程的唯一抽象，Runnable 只是对任务（业务逻辑）的抽象。Thread 可以接受任意一个 Runnable 的实例并执行。 官方说法是在 Java 中有两种方式创建一个线程用以执行，一种是派生自Thread 类，另一种是实现 Runnable 接口。当然本质上 Java 中实现线程只有一种方式，都是通过 new Thread()创建线程对象，调用 Thread#start 启动线程。至于基于 callable 接口的方式，因为最终是要把实现了 callable 接口的对象通过 FutureTask 包装成 Runnable，再交给 Thread 去执行，所以这个其实可以和实现 Runnable 接口看成同一类。 java的多线程最终是交由操作系统来维护和调度的。只有调用Thread对象的start方法才能启动一个线程，start方法不能多次调用，重复调用会抛出异常。Thread 的 start 方法中调用了 start0()方法，而start0()是个 native 方法，这就说明Thread#start 一定和操作系统是密切相关的。 创建并启动线程 扩展自Thread类 12UseThread useThread = new UseThread();useThread.start(); 实现Runnable接口 12UseRunnable useRunnable = new UseRunnable();new Thread(useRunnable).start(); static方法 Thread.currentThread()：获取当前线程对象 Thread.sleep(10) ：休眠10毫秒 Thread.activeCount() ：获取当前活动线程的数量，活动线程是指尚未终止的线程，包括正在运行、等待或阻塞的线程。包括守护线程和非守护线程 Thread.yield() : 暂停当前线程，给其他线程执行的机会 1.具体作用如下：提示调度器当前线程愿意放弃当前的 CPU 执行时间片，给其他具有相同优先级的线程执行的机会。不保证一定能让其他线程执行，只是给其他线程执行的机会更大。通常情况下，操作系统的线程调度器会按照一定的算法分配 CPU 时间给各个线程，而 yield() 方法可以用于向调度器发出提示，表明当前线程愿意让出 CPU 时间，让其他线程有更多的机会执行。 2.当一个线程调用 yield() 方法后，它会进入就绪状态，让出当前的 CPU 时间片，并允许其他线程有更大的机会获得 CPU 时间。然后，调度器会在众多就绪状态的线程中选择一个线程来运行，但选择哪个线程运行是由调度器决定的，可能会选择当前线程继续执行，也可能选择其他线程执行。所以，调用 yield() 方法后，当前线程可能会被立即重新调度并继续执行，也可能在稍后的时间被调度器重新选中并继续执行，也可能在一段时间内都没有被重新调度。 Thread.interrupted() : 用于检查当前线程是否被中断，并返回一个布尔值。调用interrupted()方法会清除当前线程的中断状态。线程是中断状态时，则只有第一次调用interrupted()方法会返回 true。而Thread对象的isInterrupted()方法不会清除中断状态。 守护线程：主线程结束，则守护线程立即停止 1234// 创建并启动线程：UseThread useThread = new UseThread();useThread.setDaemon(true); //设置线程为守护线程，主线程结束，则守护线程立即停止useThread.start(); join(): 将指定线程运行完成后再运行后面的代码 12345//创建并启动线程：ThreadA threadA = new ThreadA();threadA.start();//threadA要运行完成后再运行后面的代码：threadA.join(); setPriority()：设置线程优先级 1.优先级的范围从 1~10，其中1表示最低优先级，10表示最高优先级。默认优先级是 5，优先级高的线程分配时间片的数量要多于优先级低的线程。设置线程优先级时，针对频繁阻塞（休眠或者 I/O 操作）的线程需要设置较高优先级，而偏重计算（需要较多 CPU 时间或者偏运算）的线程则设置较低的优先级，确保处理器不会被独占。需要注意的是，线程优先级只是给操作系统提供一个建议，操作系统不保证严格按照优先级来调度线程。在不同的 JVM 以及操作系统上，线程规划会存在差异，有些操作系统甚至会忽略对线程优先级的设定。慎重使用。 2.Java 线程调度是抢占式调度的，而且 Java 中的线程优先级是通过映射到操作系统的原生线程上实现的，所以线程的调度最终取决于操作系统，操作系统中线程的优先级有时并不能和 Java 中的一一对应，所以Java 优先级并不是特别靠谱。 中断线程： 123456789//创建并启动线程：ThreadA threadA = new ThreadA();threadA.start();//中断线程：threadA.interrupt();//线程方法中判断是否被中断：Thread.currentThread().isInterrupted(); //中断返回true//注意：处于死锁状态的线程无法被中断 死锁（Deadlock） 死锁（Deadlock）是指两个或多个线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，彼此互相等待对方释放资源，导致程序无法继续执行的状态。 死锁通常发生在多个线程同时持有多个共享资源，并试图获取对方持有的资源时。 死锁的发生必须具备以下四个必要条件: 1）互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。 2）请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。 3）不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。 4）环路等待条件：指在发生死锁时，必然存在一个进程–资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的 P0 正在等待一个 P1 占用的资源；P1正在等待 P2 占用的资源，……，Pn 正在等待已被 P0 占用的资源。 只要打破四个必要条件之一就能有效预防死锁的发生 打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。 打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。 打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。 打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。 死锁的危害 1、线程不工作了，但是整个程序还是活着的 2、没有任何的异常信息可以供我们检查。 3、一旦程序发生了发生了死锁，是没有任何的办法恢复的，只能重启程序，对生产平台的程序来说，这是个很严重的问题。 如何查看运行的程序是否有死锁线程 通过 jps 查询应用的 id，再通过 jstack id 查看应用的锁的持有情况，进程状态为 BLOCKED 表示死锁 jdk1.8以后，jstack 专门给出了死锁的检查，一般在显示信息的最下方展示是否发现死锁信息 如何避免死锁 1、内部通过顺序比较，确定拿锁的顺序； 2、采用尝试拿锁的机制。 尝试拿锁会存在活锁的问题，即多个线程在尝试拿锁的机制中，发生多个线程之间互相谦让，不断发生同一个线程总是拿到同一把锁，在尝试拿另一把锁时因为拿不到，而将本来已经持有的锁释放的过程。 解决办法：每个线程休眠随机数，错开拿锁的时间。 synchronized：可以作用在方法或代码块上 方法: 当前对象锁，等价于 synchronized (this) 123public synchronized void incCountMethod()&#123; count++;&#125; 方法: 当前类锁，等价于 synchronized (Object.class) 123public static synchronized void incCountMethod()&#123; count++;&#125; 代码块： 123456789101112131415161718//任意对象锁public void incCountObj()&#123; synchronized (obj)&#123; count++; &#125;&#125;//当前对象锁public void incCountBlock()&#123; synchronized (this)&#123; count++; &#125;&#125;//类锁public void incCountBlock()&#123; synchronized (Object.class)&#123; count++; &#125;&#125; wait与notify/notifyAll：等待唤醒机制 一个线程：synchronized (pool)； while(某种条件) 线程等待：pool.wait(); 另一个线程：synchronized (pool); 通知其他等待的线程：pool.notifyAll(); synchronized作用在方法上时，就是当前对象，直接在方法内使用wait(); wait() 和 wait(long timeout) 都是用于线程间进行协作和同步的方法，用于在对象上进行等待。wait() 方法是没有超时参数的形式，它使当前线程进入等待状态，直到其他线程调用相同对象上的 notify() 或 notifyAll() 方法来唤醒等待的线程，或者当前线程被中断（InterruptedException）。wait(long timeout) 方法是带有超时参数的形式，它使当前线程进入等待状态，但最多等待指定的时间（以毫秒为单位）。如果超过指定时间还未被唤醒，线程将自动唤醒并继续执行。这个方法可以防止线程永久地等待下去，即使没有其他线程调用相同对象上的 notify() 或 notifyAll() 方法。因此，wait() 方法是一直等待直到被唤醒或中断，而 wait(long timeout) 方法是等待一段时间后自动唤醒，或者在被唤醒之前超过了指定的等待时间。需要注意的是，这两个方法必须在同步代码块（synchronized）内部调用，并且在调用这些方法前，线程必须拥有对象的监视器（即获取了对象的锁）。否则，将会抛出 IllegalMonitorStateException 异常。 尽可能用 notifyall()，谨慎使用 notify()，因为 notify()只会唤醒一个线程，我们无法确保被唤醒的这个线程一定就是我们需要唤醒的线程 yield() 、sleep()被调用后，都不会释放当前线程所持有的锁。调用 wait()方法后，会释放当前线程持有的锁，而且当前被唤醒后，会重新去竞争锁，锁竞争到后才会执行 wait() 方法后面的代码。调用 notify()系列方法后，对锁无影响，线程只有在 synchronized 同步代码执行完后才会自然而然的释放锁，所以 notify()系列方法一般都是 synchronized 同步代码的最后一行。 为什么你应该在循环中检查等待条件? 处于等待状态的线程可能会收到错误警报和伪唤醒(被唤醒时不一定满足等待条件)，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在 notify()方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用 wait()方法效果更好的原因。 Callable&lt;T&gt;、Future&lt;T&gt;与FutureTask&lt;T&gt;: Callable 位于 java.util.concurrent 包下，它也是一个接口，在它里面也只声明了一个方法，只不过这个方法叫做 call()，这是一个泛型接口，call()函数返回的类型就是传递进来的 T 类型。 FutureTask 类实现了 RunnableFuture 接口，RunnableFuture 继承了 Runnable接口和 Future 接口，而 FutureTask 实现了 RunnableFuture 接口。所以它既可以作为 Runnable 被线程执行，又可以作为 Future 得到 Callable 的返回值。 自定义Callable&lt;T&gt;的实现类，其有返回值，比如：public class UseCallable implements Callable&lt;Integer&gt; 创建FutureTask：FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(new UseCallable()); 启动线程：new Thread(futureTask).start(); 获取返回值：futureTask.get(); 中断线程：futureTask.cancel(true); CompletableFuture&lt;T&gt;：返回值的子线程，这里只罗列一些常用的方法 创建： 1234CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123; //子线程代码逻辑 return &quot;str&quot;; //返回值&#125;); 工厂方法： 1234public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier)public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier,Executor executor)public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable)public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable,Executor executor) Asynsc 表示异步,而 supplyAsync 与 runAsync 不同在于，supplyAsync 异步返回一个结果,runAsync 是 void。第二个函数第二个参数表示是用我们自己创建的线程池,否则采用默认的ForkJoinPool.commonPool()作为它的线程池 获取返回值: get与join的区别 future.get(); 需要处理异常：InterruptedException，ExecutionException future.join(); 不需要处理异常 allOf、anyOf 1234567CompletableFuture.allOf(future1,future2,future3).thenRun(()-&gt;&#123; //所有线程全部返回 System.out.println(&quot;All done!&quot;);&#125;);//接收返回最快的那个值CompletableFuture&lt;Object&gt; f = CompletableFuture.anyOf(future1,future2,future3); 处理返回结果： 12345678910111213141516171819202122232425262728//thenAccept :消费，没有返回值CompletableFuture.supplyAsync(() -&gt; &quot;hello&quot;).thenAccept(s -&gt; System.out.println(s+&quot; world&quot;));//thenApply ：变更返回结果(值或类型)CompletableFuture.supplyAsync(() -&gt; &quot;hello&quot;).thenApply(s -&gt; s + &quot; world&quot;).join();//exceptionally ：捕获异常并返回结果CompletableFuture.supplyAsync(() -&gt; &quot;hello&quot;).exceptionally(e -&gt; &#123; System.out.println(e.getMessage()); return &quot;hello world&quot;;&#125;).join();//thenCompose ：第一个future的结果作为第二个future的参数CompletableFuture.supplyAsync(() -&gt; 10).thenCompose(i -&gt; CompletableFuture.supplyAsync(() -&gt; i+1)).join();//whenComplete：不修改返回值//whenComplete()方法接收一个BiConsumer参数，当异步任务完成时，无论是否发生异常，都会执行该BiConsumer。如果任务发生异常，异常信息会被传递给BiConsumer，但whenComplete()方法无法修改异常或处理异常。 CompletableFuture.supplyAsync(() -&gt; &quot;hello&quot;).whenComplete((s, t) -&gt; &#123; System.out.println(s); //s是返回值 System.out.println(t.getMessage()); //t是异常对象 &#125;).join();//handle ：会修改返回值//handle()方法接收一个BiFunction参数，当异步任务完成时，可以对任务的结果进行处理。如果任务发生异常，异常信息会被传递给BiFunction，并允许你根据异常进行处理并返回一个结果。如果没有异常发生，BiFunction将使用任务的结果进行处理。CompletableFuture.supplyAsync(() -&gt; &quot;hello&quot;).handle((s, t) -&gt; &#123; System.out.println(s); //s是返回值 System.out.println(t.getMessage()); //t是异常对象return s;&#125;).join(); volatile：最轻量的通信/同步机制，保证变量在多个线程间的可见性，即值被一个线程修改，其它线程立刻可见 1private static volatile boolean ready; volatile 不能保证数据在多个线程下同时写时的线程安全 volatile 最适用的场景：一个线程写，多个线程读。 ThreadLocal ：保证线程变量独享 12345ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;();//设置当前线程的线程局部变量的值。threadLocal.set(&quot;线程变量&quot;);//返回当前线程所对应的线程局部变量。String str = threadLocal.get(); 初始化方法 12345678910//方式1ThreadLocal&lt;Integer&gt; threadLocal1 = new ThreadLocal&lt;Integer&gt;()&#123; @Override protected Integer initialValue() &#123; return 10; &#125; &#125;;//方式2，Java 8及更高版本ThreadLocal&lt;Integer&gt; threadLocal2 = ThreadLocal.withInitial(() -&gt; 10); 为了避免内存泄露，ThreadLocal变量用完后要进行销毁：threadLocal.remove(); CAS CAS 是 Compare and Swap（比较并交换）的缩写，是一种常见的并发编程技术，也是原子类实现线程安全的基础操作。CAS 操作包括三个参数：一个内存位置（通常是一个变量的内存地址）、期望的值和新值。CAS 操作会先比较内存位置的当前值与期望的值是否相等，如果相等，则将内存位置的值替换为新值，否则不进行任何操作。ßCAS 操作是原子的，即在进行比较和交换的过程中不会被其他线程干扰。 CAS 实现原子操作的三大问题 ABA 问题 下文有对ABA问题的介绍 循环时间长开销大 自旋 CAS 如果长时间不成功，会给 CPU 带来非常大的执行开销。 只能保证一个共享变量的原子操作 当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁。 从 Java 1.5开始，JDK 提供了 AtomicReference 类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行 CAS 操作。 原子操作类: Integer：AtomicInteger，AtomicIntegerArray 123456789101112AtomicInteger ai = new AtomicInteger(10);ai.get(); //获取当前值ai.set(10); //设置新值ai.getAndIncrement(); //获取原值并自增，getAndDecrement()自减ai.incrementAndGet(); //获取自增后的值，decrementAndGet()自减ai.compareAndSet(原值,新值); //比较并设置新值，成功返回trueai.getAndAdd(24); //增加指定的值后返回原值ai.addAndGet(24); //增加指定的值后返回新值//基于数组初始化AtomicIntegerArray ai = new AtomicIntegerArray(new int[] &#123; 1, 2 &#125;);//基于数组长度初始化AtomicIntegerArray ai = new AtomicIntegerArray(10); Long：AtomicLong，AtomicLongArray Long：LongAdder，加、减、求和等操作性能高于AtomicLong 小贴士 AtomicLong 是利用了底层的 CAS 操作来提供并发性的，调用了 Unsafe 类的getAndAddLong 方法，该方法是个 native 方法，它的逻辑是采用自旋的方式不断更新目标值，直到更新成功。 在并发量较低的环境下，线程冲突的概率比较小，自旋的次数不会很多。但是，高并发环境下，N 个线程同时进行自旋操作，会出现大量失败并不断自旋的情况，此时 AtomicLong 的自旋会成为瓶颈。 这就是 LongAdder 引入的初衷——解决高并发环境下 AtomicLong 的自旋瓶颈问题。 AtomicLong 中有个内部变量 value 保存着实际的 long 值，所有的操作都是针对该变量进行。也就是说，高并发环境下，value 变量其实是一个热点，也就是 N 个线程竞争一个热点。 LongAdder 的基本思路就是分散热点，将 value 值分散到一个数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行 CAS 操作，这样热点就被分散了，冲突的概率就小很多。 如果要获取真正的 long 值，只要将各个槽中的变量值累加返回。 这种做法和 ConcurrentHashMap 中的“分段锁”其实就是类似的思路。 LongAdder 提供的 API 和 AtomicLong 比较接近，两者都能以原子的方式对long 型变量进行增减。 但是 AtomicLong 提供的功能其实更丰富，尤其是 addAndGet、decrementAndGet、compareAndSet 这些方法。 addAndGet、decrementAndGet 除了单纯的做自增自减外，还可以立即获取增减后的值，而 LongAdder 则需要做同步控制才能精确获取增减后的值。如果业务需求需要精确的控制计数，做计数比较，AtomicLong 也更合适。 另外，从空间方面考虑，LongAdder 其实是一种“空间换时间”的思想，从这一点来讲 AtomicLong 更适合。 总之，低并发、一般的业务场景下 AtomicLong 是足够了。如果并发量很多，存在大量写多读少的情况，那 LongAdder 可能更合适。 Double：DoubleAdder 对象：AtomicReference，AtomicReferenceArray 对象：AtomicStampedReference：引入版本号，用于解决ABA问题 小贴士 如果你想比较AtomicReference中存储的User对象，你需要确保User类正确实现了适当的equals()和hashCode()方法。 在Java中，对象的比较通常是通过equals()方法来实现的。equals()方法用于判断两个对象是否相等。当你使用AtomicReference进行比较时，它将使用equals()方法来比较存储在AtomicReference中的对象。 默认情况下，Object类的equals()方法比较的是对象的引用，而不是内容。因此，如果你想在AtomicReference中比较User对象的内容而不是引用，你需要在User类中重写equals()方法来进行内容比较。 123456789101112131415161718192021222324public class User &#123; private String name; private int age; // 省略构造函数和其他方法 @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; User user = (User) o; if (age != user.age) return false; return name != null ? name.equals(user.name) : user.name == null; &#125; @Override public int hashCode() &#123; int result = name != null ? name.hashCode() : 0; result = 31 * result + age; return result; &#125;&#125; 在上述示例中，我们重写了equals()方法以比较User对象的name和age属性。我们使用了自动生成的hashCode()方法来生成哈希码，以保证在使用哈希表等数据结构时的正确性。 重写了equals()和hashCode()方法后，你可以使用AtomicReference来比较User对象。例如： 123AtomicReference&lt;User&gt; atomicReference = new AtomicReference&lt;&gt;(new User(&quot;Alice&quot;, 25));User expectedUser = new User(&quot;Alice&quot;, 25);boolean updated = atomicReference.compareAndSet(expectedUser, new User(&quot;Bob&quot;, 30)); 而AtomicStampedReference是为了解决ABA问题而设计的，并提供了对对象引用的比较以及对标记（stamp）的比较。 AtomicStampedReference通过引入一个标记（stamp）来解决ABA问题。它不仅比较对象引用，还比较对象的标记值。当对象和标记值都相等时，才认为对象相等。 ABA ABA 问题指的是在并发环境下，某个线程对一个值进行比较并操作时，可能出现以下情况： 初始状态下，值为 A。 线程 1 将值从 A 修改为 B。 线程 1 又将值从 B 修改回 A。 线程 2 检查值，发现值仍然是 A，于是做出操作。 从线程 2 的角度来看，值似乎没有被修改过，但实际上经历了从 A 到 B 再到 A 的变化。这种情况可能会导致意外的结果或错误的判断。 ABA 问题的发生是因为 CAS 操作只关注当前值和期望值是否相等，而不考虑期间发生的其他变化。 在上述示例中，CAS 操作在进行比较时，发现当前值仍然是 A，与期望值相等，因此会执行操作，但它无法感知到值的中间变化。 ABA 问题可能会对某些并发算法和数据结构产生影响，例如自旋锁、无锁算法等。 为了解决 ABA 问题，可以使用一种称为 “版本号” 的技术，每次修改值时都会增加一个版本号，这样在进行 CAS 操作时除了比较值本身，还会比较版本号，从而避免了 ABA 问题的发生。 在Java中，AtomicStampedReference就是通过引入版本号（标记）来解决ABA问题的一种原子类。 重排序 在Java中，重排序是指编译器和处理器为了提高程序性能而对指令执行顺序进行重新排序的优化技术。重排序可以改变程序中指令的执行顺序，但不会改变程序的最终结果（即保持串行语义），因为这些重排序是在保持依赖关系的前提下进行的。 然而，重排序可能会导致并发安全问题。并发安全问题主要涉及到多线程的执行顺序和对共享数据的访问。 考虑以下示例代码： 12345678910111213141516class Singleton &#123; private static Singleton instance; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 上述代码是一个经典的基于双重检查锁定的懒汉式单例模式。在单线程环境下，这段代码是没有问题的。但是在多线程环境下，由于重排序的存在会导致线程安全问题，为什么呢？ 这是因为instance = new Singleton();虽然只有一行代码，但是其实在具体执行的时候有好几步操作： 1、JVM 为 Singleton 的对象实例在内存中分配空间 2、进行对象初始化，完成 new 操作 3、JVM 把这个空间的地址赋给我们的引用 instance 因为 JVM 内部的实现原理会导致重排序，就会产生一种情况，第 3 步会在第 2 步之前执行。 于是在多线程下就会产生问题： A 线程正在 syn 同步块中执行 instance = new Singleton();， 此时 B 线程也来执行 getInstance()，进行了 instance == null 的检查， 因为第 3 步会在第 2 步之前执行，B 线程检查发现 instance 不为 null，会直接拿着 instance 实例使用， 但是这时 A 线程还在执行对象初始化，这就导致 B 线程拿到的 instance 实例可能只初始化了一半，B 线程访问 instance 实例中的对象域就很有可能出错。 这些问题是由于编译器和处理器进行的重排序导致的，并发安全问题不会在单线程环境下出现，只有在多线程环境下才会显现。 另外，即使在同步块内部没有发生重排序，当一个线程在初始化实例时，由于处理器和内存之间的交互延迟，也可能存在可见性问题。 为了解决这些问题，可以使用volatile关键字来修饰instance，volatile会禁止编译器和处理器进行重排序，同时使用volatile修饰的变量时，会先清除当前线程的本地缓存再从主内存中重新加载数据，以确保可见性： 1private volatile static Singleton instance; 管程与MESA模型 管程(Monitor): 是一种并发编程的概念模型，旨在解决多线程程序中的互斥访问和同步问题。它提供了一种结构化的方式来管理共享资源，并确保线程在访问共享资源时的安全性。 MESA(Meta-Environment for Scheduling Agents)模型: 是现在正在广泛使用的管程模型。 AQS java.util.concurrent包中的大多数同步器实现都是围绕着共同的基础行为，比如等待队列、条件队列、独占获取、共享获取等，而这些行为的抽象就是基于AbstractQueuedSynchronizer（简称AQS）实现的，AQS是一个抽象同步框架，可以用来实现一个依赖状态的同步器。 JDK中提供的大多数的同步器如Lock, Latch, Barrier等，都是基于AQS框架来实现的。 基于AQS构建的ReentrantLock和CountDownLatch等同步类就是借鉴了MESA模型中的概念和技术，如互斥锁、条件变量等，以提供线程间的同步和互斥功能。","summary":"摘要 本文介绍java并发编程相关技术 本文基于jdk1.8 并发编程是为了解决什么问题的？ 性能+线程安全","date_published":"2023-05-18T14:30:05.000Z","tags":["技术","java","java多线程","java"]},{"id":"https://blog.hanqunfeng.com/2023/04/20/linux-command11-user/","url":"https://blog.hanqunfeng.com/2023/04/20/linux-command11-user/","title":"Linux常用命令--用户管理","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度 ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>文本介绍linux中用户的维护及其相关命令</p>\n</li>\n<li class=\"lvl-2\">\n<p>本文基于<code>CentOS8(x86_64)</code></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"一-配置文件说明\">一.配置文件说明</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1./etc/passwd :用户信息文件<br>\n<code>vipw</code> :编辑/etc/passwd文件<br>\n<code>pwck</code> :检查/etc/passwd内容是否有效，比如宿主目录是否存在等等</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root:x:0:0:root:/root:/bin/bash</span><br><span class=\"line\">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class=\"line\"></span><br><span class=\"line\">格式：用户名:密码位:UID:GID:注释:宿主目录:shell</span><br><span class=\"line\"></span><br><span class=\"line\">UID说明:</span><br><span class=\"line\">root: UID=0</span><br><span class=\"line\">伪用户: UID 1-499，比如ftp,sshd,mail,shutdown等等</span><br><span class=\"line\">普通用户: UID 500-60000,新增用户</span><br><span class=\"line\"></span><br><span class=\"line\">shell说明:</span><br><span class=\"line\">/bin/bash :登录后默认的shell</span><br><span class=\"line\">/sbin/nologin :该用户禁止登录</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2./etc/shadow :密码文件</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root:!!:18755:0:99999:7:::</span><br><span class=\"line\">bin:*:18394:0:99999:7:::</span><br><span class=\"line\">nginx:$6$VJ6lIEAtIoLpbMmA<span class=\"variable\">$GSIZfx5Ous2ih</span>/KHjZTuTT7hSk6PBd/3c/nanwtXh5BKFOtEQdRvp6hS2usZ.rle.InjoKW0tp6UNQrhRscUG/:19468:0:99999:7:::</span><br><span class=\"line\"></span><br><span class=\"line\">格式：用户名:密码:最后一次修改密码的天数:两次修改密码的最小天数间隔:密码保持有效的最多天数:密码失效前提前警告的天数:账号闲置时间:密码已经失效的天数:标志（一般不用）</span><br><span class=\"line\"></span><br><span class=\"line\">密码说明：</span><br><span class=\"line\">!! :该用户不能通过密码登录</span><br><span class=\"line\">* :禁止登录</span><br><span class=\"line\">*，! 和 !! 的全部都是无效的哈希，均表示不可以通过密码登录</span><br><span class=\"line\">上面nginx的密码就是一个有效的哈希值，如果对nginx用户设置了禁用，</span><br><span class=\"line\">比如: `usermod -L nginx`</span><br><span class=\"line\">此时就会在密码前面增加一个 `!`，使其变为无效的哈希值，这样就不能通过密码登录了</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>3./etc/group  :用户组文件<br>\n<code>vigr</code> :编辑/etc/group文件<br>\n<code>grpck</code> :检查/etc/group内容是否有效</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root:x:0:</span><br><span class=\"line\">bin:x:1:</span><br><span class=\"line\"></span><br><span class=\"line\">格式：组名:组密码位:GID:组内用户列表(逗号分隔)</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>4./etc/gshadow :组密码文件</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root:::</span><br><span class=\"line\">bin:::</span><br><span class=\"line\">nginx:$6<span class=\"variable\">$G0GIKwWPuT</span>/RMftY<span class=\"variable\">$JYqudvqgbUw5jJFqqaNBggs1lHpu</span>.BXfqaHRCy2fNklc5zYG0yjh4HZ5t2r4mkeLGU9McigZa4FsBBDV9IcCR1::</span><br><span class=\"line\">redis:!:redis:redis,centos</span><br><span class=\"line\"></span><br><span class=\"line\">格式：组名:组密码:组管理员:组内用户列表(逗号分隔)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 说明：</span></span><br><span class=\"line\">1.一般情况下没必要设置组密码</span><br><span class=\"line\">2.组管理员可以将用户添加到组或从组里删除用户</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>5./etc/skel/* :新用户环境变量文件</p>\n</li>\n<li class=\"lvl-2\">\n<p>6./etc/login.defs :使用useradd默认创建用户时的缺省配置，比如UID范围，GID范围，密码有效期，密码长度限制，是否自动创建Home目录，密码加密方式等等</p>\n</li>\n<li class=\"lvl-2\">\n<p>7./etc/default/useradd :使用useradd默认创建用户时的缺省配置，比如Home目录位置，默认shell，默认使用的新用户环境变量文件位置（/etc/skel），等等</p>\n</li>\n</ul>\n<h2 id=\"二-添加、删除用户\">二.添加、删除用户</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1.通过<code>useradd</code>命令创建用户,并使用<code>passwd</code>设置用户密码</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># root创建用户</span></span><br><span class=\"line\">useradd 用户名</span><br><span class=\"line\">    -u:指定UID</span><br><span class=\"line\">    -g:指定所属用户初始组GID或组名称，用户创建文件时的默认组，可以通过 `newgrp 组名` 切换初始组</span><br><span class=\"line\">    -G:指定所属多个附加组名称，逗号分隔，用户同时拥有这些组的权限</span><br><span class=\"line\">    -d:宿主目录，会自动创建，如果目录已经存在，则不会将环境变量文件拷贝到该目录，需要手工拷贝</span><br><span class=\"line\">    -s:命令解释器shell</span><br><span class=\"line\">    -c:描述信息</span><br><span class=\"line\">    -e:指定失效时间</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 例子：</span></span><br><span class=\"line\">useradd utest -u 600 -g 0 -G sys,adm -d /home/utest -s /bin/bash -c <span class=\"string\">&quot;this is a testuser&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 注意：</span></span><br><span class=\"line\">useradd &lt;==&gt; adduser</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># root为用户设置密码</span></span><br><span class=\"line\">passwd 用户名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 非root用户修改自己的密码</span></span><br><span class=\"line\">passwd</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2.通过编辑配置文件创建</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">1）分别在/etc/passwd、/etc/group和/etc/shadow中增加一行记录<br>\n密码设置：<code>echo 123456 | sha512sum</code></li>\n<li class=\"lvl-6\">2）创建宿主目录</li>\n<li class=\"lvl-6\">3）拷贝默认的配置文件到宿主目录: <code>cp -rf /etc/skel/* dir</code></li>\n<li class=\"lvl-6\">4）设置用户初始密码</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>3.删除用户</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">userdel -r 用户名</span><br><span class=\"line\">    -r:删除用户宿主目录</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>4.修改用户</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将用户添加到附加组中</span></span><br><span class=\"line\">usermod -G 组名称 用户名</span><br><span class=\"line\"><span class=\"comment\"># 将用户的名改为新用户名，并且指定初始组，同时修改宿主目录</span></span><br><span class=\"line\">usermod -l 新用户名 -d <span class=\"built_in\">dir</span> -g 组名称 用户名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 说明，usermod仅root用户可以使用</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"三-添加、删除组\">三.添加、删除组</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>1.创建组</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">groupadd 组名</span><br><span class=\"line\">    -g:指定GID</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2.删除组</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">groupdel 组名</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>3.修改组名称</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">groupmod -n newname oldname</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>4.设置组密码</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">设置密码：gpasswd 组名</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>5.其它组命令</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将用户加入组</span></span><br><span class=\"line\">gpasswd -a 用户名 组名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从组中删除用户</span></span><br><span class=\"line\">gpasswd -d 用户名 组名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除组密码</span></span><br><span class=\"line\">gpasswd -r 组名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 让群组的密码失效</span></span><br><span class=\"line\">gpasswd -R 组名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置组管理员</span></span><br><span class=\"line\">gpasswd -A 用户名 组名</span><br></pre></td></tr></table></figure>\n<h2 id=\"四-用户管理命令\">四.用户管理命令</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">whoami</span> :显示当前用户名称</span><br><span class=\"line\"><span class=\"built_in\">id</span> :查看当前用的UID，GID和组信息</span><br><span class=\"line\"><span class=\"built_in\">who</span> :显示用户登录时间和来源IP</span><br><span class=\"line\">last :显示所有用户的登录时间和来源IP历史记录</span><br><span class=\"line\">su - 用户名 :切换用户，带环境变量，<span class=\"built_in\">exit</span>退出</span><br><span class=\"line\"></span><br><span class=\"line\">passwd -S 用户名 :查看用户密码状态</span><br><span class=\"line\">chage -l 用户名：查看用户密码配置信息</span><br><span class=\"line\">vipw :编辑/etc/passwd文件</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">groups</span> 用户名 :查看用户隶属于哪些组</span><br><span class=\"line\"><span class=\"built_in\">chgrp</span> 组名 file/dir :修改文件所属组 目录加 -R</span><br><span class=\"line\"><span class=\"built_in\">chown</span> 用户名 file/dir :修改文件所属用户 目录加 -R</span><br><span class=\"line\">    <span class=\"built_in\">chown</span> -R 用户名.组名 file/dir</span><br><span class=\"line\">vigr :编辑/etc/group文件</span><br><span class=\"line\">newgrp 组名 :临时切换当前用户的初始组。newgrp 命令每一次切换用户的初始组，该用户都会以另外一个 shell（新进程，也可以说是子进程）登陆，只不过在新 shell 上登陆的该用户，其初始组改变了而已。<span class=\"built_in\">exit</span>退出。</span><br><span class=\"line\"></span><br><span class=\"line\">pwck :检查/etc/passwd内容是否有效，比如宿主目录是否存在等等</span><br><span class=\"line\">grpck :检查/etc/group内容是否有效</span><br></pre></td></tr></table></figure>\n<h2 id=\"五-用户禁用与恢复\">五.用户禁用与恢复</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>禁用：锁定用户，不能登录</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">usermod -L 用户名  :/etc/shadow中对应的密码前面增加一个`!`</span><br><span class=\"line\"><span class=\"comment\"># 或者</span></span><br><span class=\"line\">passwd -l 用户名  :/etc/shadow中对应的密码前面增加两个`!`</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 锁定的原理就是使密码变为无效的哈希值</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>恢复：解锁</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">usermod -U 用户名</span><br><span class=\"line\">passwd -u 用户名</span><br></pre></td></tr></table></figure>\n<h2 id=\"六-sudo\">六.sudo</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>配置文件/etc/sudoers</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">格式： A B = (C) D E</span><br><span class=\"line\">且C与D是可以省略的</span><br><span class=\"line\">A代表授权使用sudo的用户或者组</span><br><span class=\"line\">B代表允许授权用户在哪些主机上使用这些权利，ALL表示任意主机</span><br><span class=\"line\">C代表允许被授权用户提权到什么用户什么组级别的权限，ALL代表允许提权到任意用户级别，如果省略就表示提权到root级别</span><br><span class=\"line\">D代表当被授权用户是否需要输入自身密码来使用特权，若省略则代表需要输入自身的密码，如果为NOPASSWD:则表示不需要</span><br><span class=\"line\">E代表允许执行的命令，如果是ALL就代表允许执行所有命令，多个命令之间逗号分隔，必须为绝对路径</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 例子：</span></span><br><span class=\"line\"><span class=\"comment\"># A B = (C)  E</span></span><br><span class=\"line\">root    ALL=(ALL)       ALL</span><br><span class=\"line\"><span class=\"comment\"># NOPASSWD: ALL 可以免密码以root身份执行所有命令</span></span><br><span class=\"line\"><span class=\"comment\"># A B = (C) D E</span></span><br><span class=\"line\">centos  ALL=(ALL)       NOPASSWD: ALL</span><br><span class=\"line\"><span class=\"comment\"># A B = E</span></span><br><span class=\"line\">wap     ALL=/bin/chown,/usr/sbin/useradd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># %wheel 表示 wheel 这个组下的所有用户</span></span><br><span class=\"line\">%wheel  ALL=(ALL)       ALL</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>visudo</code> :编辑/etc/sudoers</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>sudo command</code> :执行命令，需要输入当前用户密码</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>sudo -l</code> :查看当前用户可以使用sudo执行哪些命令</p>\n</li>\n</ul>\n<h2 id=\"七-批量添加用户，适用于少量添加，大量可以编写个脚步\">七.批量添加用户，适用于少量添加，大量可以编写个脚步</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.编辑一个用户信息文件，比如user.info,格式与/etc/passwd相同</span><br><span class=\"line\">2.newusers &lt; user.info :写入/etc/passwd，会自动创建宿主目录</span><br><span class=\"line\">3.pwunconv :关闭shadow passwd功能</span><br><span class=\"line\">4.创建一个密码文件，比如passwd.info,格式与/etc/shadow相同,但密码是明文</span><br><span class=\"line\">5.chpasswd &lt; passwd.info :写入/etc/shadow</span><br><span class=\"line\">6.pwconv :开启shadow passwd功能，写入password密文</span><br></pre></td></tr></table></figure>\n","content_text":"摘要 文本介绍linux中用户的维护及其相关命令 本文基于CentOS8(x86_64) 一.配置文件说明 1./etc/passwd :用户信息文件 vipw :编辑/etc/passwd文件 pwck :检查/etc/passwd内容是否有效，比如宿主目录是否存在等等 12345678910111213root:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologin格式：用户名:密码位:UID:GID:注释:宿主目录:shellUID说明:root: UID=0伪用户: UID 1-499，比如ftp,sshd,mail,shutdown等等普通用户: UID 500-60000,新增用户shell说明:/bin/bash :登录后默认的shell/sbin/nologin :该用户禁止登录 2./etc/shadow :密码文件 12345678910111213root:!!:18755:0:99999:7:::bin:*:18394:0:99999:7:::nginx:$6$VJ6lIEAtIoLpbMmA$GSIZfx5Ous2ih/KHjZTuTT7hSk6PBd/3c/nanwtXh5BKFOtEQdRvp6hS2usZ.rle.InjoKW0tp6UNQrhRscUG/:19468:0:99999:7:::格式：用户名:密码:最后一次修改密码的天数:两次修改密码的最小天数间隔:密码保持有效的最多天数:密码失效前提前警告的天数:账号闲置时间:密码已经失效的天数:标志（一般不用）密码说明：!! :该用户不能通过密码登录* :禁止登录*，! 和 !! 的全部都是无效的哈希，均表示不可以通过密码登录上面nginx的密码就是一个有效的哈希值，如果对nginx用户设置了禁用，比如: `usermod -L nginx`此时就会在密码前面增加一个 `!`，使其变为无效的哈希值，这样就不能通过密码登录了 3./etc/group :用户组文件 vigr :编辑/etc/group文件 grpck :检查/etc/group内容是否有效 1234root:x:0:bin:x:1:格式：组名:组密码位:GID:组内用户列表(逗号分隔) 4./etc/gshadow :组密码文件 12345678910root:::bin:::nginx:$6$G0GIKwWPuT/RMftY$JYqudvqgbUw5jJFqqaNBggs1lHpu.BXfqaHRCy2fNklc5zYG0yjh4HZ5t2r4mkeLGU9McigZa4FsBBDV9IcCR1::redis:!:redis:redis,centos格式：组名:组密码:组管理员:组内用户列表(逗号分隔)# 说明：1.一般情况下没必要设置组密码2.组管理员可以将用户添加到组或从组里删除用户 5./etc/skel/* :新用户环境变量文件 6./etc/login.defs :使用useradd默认创建用户时的缺省配置，比如UID范围，GID范围，密码有效期，密码长度限制，是否自动创建Home目录，密码加密方式等等 7./etc/default/useradd :使用useradd默认创建用户时的缺省配置，比如Home目录位置，默认shell，默认使用的新用户环境变量文件位置（/etc/skel），等等 二.添加、删除用户 1.通过useradd命令创建用户,并使用passwd设置用户密码 123456789101112131415161718192021# root创建用户useradd 用户名 -u:指定UID -g:指定所属用户初始组GID或组名称，用户创建文件时的默认组，可以通过 `newgrp 组名` 切换初始组 -G:指定所属多个附加组名称，逗号分隔，用户同时拥有这些组的权限 -d:宿主目录，会自动创建，如果目录已经存在，则不会将环境变量文件拷贝到该目录，需要手工拷贝 -s:命令解释器shell -c:描述信息 -e:指定失效时间# 例子：useradd utest -u 600 -g 0 -G sys,adm -d /home/utest -s /bin/bash -c &quot;this is a testuser&quot;# 注意：useradd &lt;==&gt; adduser# root为用户设置密码passwd 用户名# 非root用户修改自己的密码passwd 2.通过编辑配置文件创建 1）分别在/etc/passwd、/etc/group和/etc/shadow中增加一行记录 密码设置：echo 123456 | sha512sum 2）创建宿主目录 3）拷贝默认的配置文件到宿主目录: cp -rf /etc/skel/* dir 4）设置用户初始密码 3.删除用户 12userdel -r 用户名 -r:删除用户宿主目录 4.修改用户 123456# 将用户添加到附加组中usermod -G 组名称 用户名# 将用户的名改为新用户名，并且指定初始组，同时修改宿主目录usermod -l 新用户名 -d dir -g 组名称 用户名# 说明，usermod仅root用户可以使用 三.添加、删除组 1.创建组 12groupadd 组名 -g:指定GID 2.删除组 1groupdel 组名 3.修改组名称 1groupmod -n newname oldname 4.设置组密码 1设置密码：gpasswd 组名 5.其它组命令 1234567891011121314# 将用户加入组gpasswd -a 用户名 组名# 从组中删除用户gpasswd -d 用户名 组名# 删除组密码gpasswd -r 组名# 让群组的密码失效gpasswd -R 组名# 设置组管理员gpasswd -A 用户名 组名 四.用户管理命令 12345678910111213141516171819whoami :显示当前用户名称id :查看当前用的UID，GID和组信息who :显示用户登录时间和来源IPlast :显示所有用户的登录时间和来源IP历史记录su - 用户名 :切换用户，带环境变量，exit退出passwd -S 用户名 :查看用户密码状态chage -l 用户名：查看用户密码配置信息vipw :编辑/etc/passwd文件groups 用户名 :查看用户隶属于哪些组chgrp 组名 file/dir :修改文件所属组 目录加 -Rchown 用户名 file/dir :修改文件所属用户 目录加 -R chown -R 用户名.组名 file/dirvigr :编辑/etc/group文件newgrp 组名 :临时切换当前用户的初始组。newgrp 命令每一次切换用户的初始组，该用户都会以另外一个 shell（新进程，也可以说是子进程）登陆，只不过在新 shell 上登陆的该用户，其初始组改变了而已。exit退出。pwck :检查/etc/passwd内容是否有效，比如宿主目录是否存在等等grpck :检查/etc/group内容是否有效 五.用户禁用与恢复 禁用：锁定用户，不能登录 12345usermod -L 用户名 :/etc/shadow中对应的密码前面增加一个`!`# 或者passwd -l 用户名 :/etc/shadow中对应的密码前面增加两个`!`# 锁定的原理就是使密码变为无效的哈希值 恢复：解锁 12usermod -U 用户名passwd -u 用户名 六.sudo 配置文件/etc/sudoers 12345678910111213141516171819格式： A B = (C) D E且C与D是可以省略的A代表授权使用sudo的用户或者组B代表允许授权用户在哪些主机上使用这些权利，ALL表示任意主机C代表允许被授权用户提权到什么用户什么组级别的权限，ALL代表允许提权到任意用户级别，如果省略就表示提权到root级别D代表当被授权用户是否需要输入自身密码来使用特权，若省略则代表需要输入自身的密码，如果为NOPASSWD:则表示不需要E代表允许执行的命令，如果是ALL就代表允许执行所有命令，多个命令之间逗号分隔，必须为绝对路径# 例子：# A B = (C) Eroot ALL=(ALL) ALL# NOPASSWD: ALL 可以免密码以root身份执行所有命令# A B = (C) D Ecentos ALL=(ALL) NOPASSWD: ALL# A B = Ewap ALL=/bin/chown,/usr/sbin/useradd# %wheel 表示 wheel 这个组下的所有用户%wheel ALL=(ALL) ALL visudo :编辑/etc/sudoers sudo command :执行命令，需要输入当前用户密码 sudo -l :查看当前用户可以使用sudo执行哪些命令 七.批量添加用户，适用于少量添加，大量可以编写个脚步 1234561.编辑一个用户信息文件，比如user.info,格式与/etc/passwd相同2.newusers &lt; user.info :写入/etc/passwd，会自动创建宿主目录3.pwunconv :关闭shadow passwd功能4.创建一个密码文件，比如passwd.info,格式与/etc/shadow相同,但密码是明文5.chpasswd &lt; passwd.info :写入/etc/shadow6.pwconv :开启shadow passwd功能，写入password密文","summary":"摘要 文本介绍linux中用户的维护及其相关命令 本文基于CentOS8(x86_64)","date_published":"2023-04-20T14:40:05.000Z","tags":["技术","linux","linux常用命令","linux常用命令"]},{"id":"https://blog.hanqunfeng.com/2023/03/27/linux-command10-ps/","url":"https://blog.hanqunfeng.com/2023/03/27/linux-command10-ps/","title":"Linux常用命令--进程管理","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度 ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍Linux进程管理等相关命令</p>\n</li>\n<li class=\"lvl-2\">\n<p>本文基于<code>CentOS8(x86_64)</code></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"ps-查看进程\">ps :查看进程</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 与top命令类似，可以查看进程信息</span></span><br><span class=\"line\">$ ps -aux</span><br><span class=\"line\">    -a:所有用户</span><br><span class=\"line\">    -x:没有控制终端的</span><br><span class=\"line\">    -u:显示用户名和启动时间</span><br><span class=\"line\"><span class=\"comment\"># 根据关键字过滤</span></span><br><span class=\"line\">$ ps -aux | grep nginx</span><br><span class=\"line\"></span><br><span class=\"line\">$ ps -ef</span><br><span class=\"line\">    -e:显示所有进程，包括用户和没有控制终端</span><br><span class=\"line\">    -f:显示所有信息</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看线程，相同PID表示的是同一个进程启动的线程</span></span><br><span class=\"line\">$ ps -eLf</span><br><span class=\"line\">    -L:显示线程</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看进程优先级 NI</span></span><br><span class=\"line\">$ ps -el</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看进程运行在第几个cpu逻辑核心上</span></span><br><span class=\"line\">$ ps -eo psr,user,pid,ppid,pri,ni,pgid,<span class=\"built_in\">command</span> | grep nginx</span><br><span class=\"line\">    psr：cpu逻辑核号</span><br><span class=\"line\">    pri :默认19，优先级 0~99，越大优先级越高，pri(new) = pri(old) + <span class=\"built_in\">nice</span></span><br><span class=\"line\">    ni :默认0，影响优先级的因子 -20~19，越小优先级越高，改变<span class=\"built_in\">nice</span>值可以改变pri</span><br><span class=\"line\">    pgid :进程组<span class=\"built_in\">id</span>，等同于 pgrp</span><br><span class=\"line\"><span class=\"comment\"># 绑定PID为10288的进程到第一块CPU，这样该进程就不会占用其它的CPU资源了</span></span><br><span class=\"line\">$ taskset -<span class=\"built_in\">cp</span> 1 10288</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 按pid排序</span></span><br><span class=\"line\">$ ps -aux --<span class=\"built_in\">sort</span> pid</span><br><span class=\"line\"><span class=\"comment\"># 按用户排序</span></span><br><span class=\"line\">$ ps -aux --<span class=\"built_in\">sort</span> user</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 说明：</span></span><br><span class=\"line\">    USER:进程的执行用户</span><br><span class=\"line\">    PID:进程号</span><br><span class=\"line\">    PPID:父进程号</span><br><span class=\"line\">    TTY:进程启动的终端</span><br><span class=\"line\">    STAT:进程的当前状态，S:休眠 D:不可中断的休眠 R:运行 Z:僵死 T:停止 I:空闲内核线程</span><br><span class=\"line\">    NI:进程优先级</span><br><span class=\"line\">    TIME:进程自启动以来占用CPU的总时间</span><br><span class=\"line\">    CMD/COMMAND:执行的命令</span><br><span class=\"line\">    %CPU:占用CPU时间和总时间的百分比</span><br><span class=\"line\">    %MEM:占用内存与系统内存总量的百分比</span><br></pre></td></tr></table></figure>\n<h2 id=\"pstree-树状查看进行信息\">pstree :树状查看进行信息</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 折叠展示，只展示父进程和子进程的数量</span></span><br><span class=\"line\">$ pstree</span><br><span class=\"line\"><span class=\"comment\"># 展开所有子进程，并显示完整命令</span></span><br><span class=\"line\">$ pstree -a</span><br><span class=\"line\"><span class=\"comment\"># 展开所有子进程，并显示PID</span></span><br><span class=\"line\">$ pstree -p</span><br></pre></td></tr></table></figure>\n<h2 id=\"kill-终止进程\">kill :终止进程</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 正常关闭进程</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> 进程号</span><br><span class=\"line\"><span class=\"comment\"># 强行关闭，遇到进程不能正常关闭时使用</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> -9 进程号</span><br><span class=\"line\"><span class=\"comment\"># 查看所有信号</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> -l</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 杀死进程名称所关联的全部进程</span></span><br><span class=\"line\">killall 进程名称</span><br><span class=\"line\">killall -9 进程名称</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 杀死进程名称所关联的全部进程，同killall</span></span><br><span class=\"line\">pkill 进程名称</span><br><span class=\"line\">pkill -9 进程名称</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查找服务的进程号</span></span><br><span class=\"line\">pgrep 进程名称  : 效果同 ps -aux | grep 进程名 | grep -v grep| awk <span class=\"string\">&#x27;&#123;print $2&#125;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 终止进程名称含有mysql的全部进程</span></span><br><span class=\"line\">pgrep mysql | xargs <span class=\"built_in\">kill</span> -s 9</span><br></pre></td></tr></table></figure>\n<h2 id=\"进程的挂起和恢复\">进程的挂起和恢复</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctrl+c :终止</span><br><span class=\"line\"></span><br><span class=\"line\">ctrl+z :挂起，暂停</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">bg</span> num :转到后台继续运行</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">fg</span> num :从后台恢复到前台继续运行</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">jobs</span> :查看被挂起或正在后台运行的进程，会显示编号num</span><br><span class=\"line\"></span><br><span class=\"line\">commond &amp; :后台运行，只在当前终端下有效</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">nohup</span> commond &amp; :后台执行，退出终端依然继续执行</span><br></pre></td></tr></table></figure>\n<h2 id=\"进程运行优先级\">进程运行优先级</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>进程优先级是 PRI(top中的PR)，其表示程序被 CPU 执行的先后顺序，此值越小进程的优先级别越高</p>\n</li>\n<li class=\"lvl-2\">\n<p>PRI 值不是 Nice 值，但是 Nice 值会影响优先级，<code>PRI(new) = PRI(old) + nice</code>，所以我们调整 Nice 值，就可以改变进程的优先级</p>\n</li>\n<li class=\"lvl-2\">\n<p>linux下的进程调度优先级 Nice 是从 -20 到 19 ，一共 40 个级别，数字越大，表示进程的优先级越低。默认时候，进程的调度优先级是0。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 指定命令的运行优先级</span></span><br><span class=\"line\"><span class=\"built_in\">nice</span> -n commond</span><br><span class=\"line\"><span class=\"comment\"># 改变一个正在运行的进程的优先级</span></span><br><span class=\"line\">renice n pid</span><br><span class=\"line\"><span class=\"comment\"># 改变进程组内全部进程的优先级</span></span><br><span class=\"line\">renice n -g pid</span><br><span class=\"line\"><span class=\"comment\"># 说明</span></span><br><span class=\"line\">    n :取值范围（-20,19），越小优先级越高</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\"><span class=\"comment\"># 默认启动nginx</span></span><br><span class=\"line\">$ nginx</span><br><span class=\"line\"><span class=\"comment\"># 查看优先级，可以看到此时默认优先级是0</span></span><br><span class=\"line\">ps -eo pgid,user,pid,pri,ni,<span class=\"built_in\">command</span> | grep nginx | grep -v grep</span><br><span class=\"line\">23348 root     23348  19   0 nginx: master process nginx</span><br><span class=\"line\">23348 nginx    23349  19   0 nginx: worker process</span><br><span class=\"line\">23348 nginx    23350  19   0 nginx: worker process</span><br><span class=\"line\"><span class=\"comment\"># 终止nginx进程</span></span><br><span class=\"line\">$ pkill nginx</span><br><span class=\"line\"><span class=\"comment\"># 重新指定优先级启动，指定优先级为10</span></span><br><span class=\"line\">$ <span class=\"built_in\">nice</span> -10 nginx</span><br><span class=\"line\"><span class=\"comment\"># 查看优先级，可以看到此时默认优先级是10</span></span><br><span class=\"line\">$ ps -eo pgid,user,pid,pri,ni,<span class=\"built_in\">command</span> | grep nginx | grep -v grep</span><br><span class=\"line\">23388 root     23388   9  10 nginx: master process nginx</span><br><span class=\"line\">23388 nginx    23389   9  10 nginx: worker process</span><br><span class=\"line\">23388 nginx    23390   9  10 nginx: worker process</span><br><span class=\"line\"><span class=\"comment\"># 改变运行中的nginx的优先级为-10，此时只会改变master的优先级</span></span><br><span class=\"line\">$ renice -10 23388</span><br><span class=\"line\">23388 (进程 ID) 旧优先级为 10，新优先级为 -10</span><br><span class=\"line\">$ ps -eo pgid,user,pid,pri,ni,<span class=\"built_in\">command</span> | grep nginx | grep -v grep</span><br><span class=\"line\">23388 root     23388  29 -10 nginx: master process nginx</span><br><span class=\"line\">23388 nginx    23389   9  10 nginx: worker process</span><br><span class=\"line\">23388 nginx    23390   9  10 nginx: worker process</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 改变运行中的nginx的优先级为-10，此时只会改变master的优先级</span></span><br><span class=\"line\">$ renice -10 -g 23388</span><br><span class=\"line\">23388 (进程组 ID) 旧优先级为 -10，新优先级为 -10</span><br><span class=\"line\">$ ps -eo pgid,user,pid,pri,ni,<span class=\"built_in\">command</span> | grep nginx | grep -v grep</span><br><span class=\"line\">23388 root     23388  29 -10 nginx: master process nginx</span><br><span class=\"line\">23388 nginx    23389  29 -10 nginx: worker process</span><br><span class=\"line\">23388 nginx    23390  29 -10 nginx: worker process</span><br></pre></td></tr></table></figure>\n<h2 id=\"at-执行一次的计划任务\">at :执行一次的计划任务</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>/var/spool/at：at任务存放在该目录下</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启动at服务</span></span><br><span class=\"line\">systemctl start atd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 今天10:46执行 test.sh</span></span><br><span class=\"line\">at -f test.sh 10:46</span><br><span class=\"line\"><span class=\"comment\"># 时间格式：</span></span><br><span class=\"line\">    5:30pm :今天下午5点30分</span><br><span class=\"line\">    17:30 :今天下午5点30分</span><br><span class=\"line\">    17:30 today :今天下午5点30分</span><br><span class=\"line\">    now +3 hours :3小时后</span><br><span class=\"line\">    now +180 minutes :3小时后</span><br><span class=\"line\">    17:30 23.2.28 :2023年2月28日下午5点30分</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看当前at队列，显示编号num</span></span><br><span class=\"line\">at -l ==== atq</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除指定编号的任务</span></span><br><span class=\"line\">at -d num ==== atrm num</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>用户限制：<br>\n<code>/etc/at.allow</code> :如果文件存在，则只有此文件中列出的用户可以使用at命令<br>\n<code>/etc/at.deny</code> :如果文件存在，则此文件中列出的用户不可以使用at命令<br>\n如果以上两个文件都不存在，则只有root用户可以使用at命令<br>\n如果以上两个文件都存在，但是都为空，则所有用户都可以使用at命令</p>\n</li>\n</ul>\n<h2 id=\"crontab-周期性计划任务\">crontab :周期性计划任务</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>systemctl start crond</code> :启动cron服务，默认启动</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>crontab -l</code> :显示当前用户下的计划任务</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>crontab -e</code> :编辑当前用户下的计划任务</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>/var/spool/cron</code> :计划任务保存在该路径下</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>/etc/cron.allow</code> 与 <code>/etc/cron.deny</code> :用户限制，规则同 <code>at</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>格式：<code>分钟[0~59] 小时[0~23] 日期[1~31] 月份[1~12] 星期[0~6] commands</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 每5分钟执行一次</span></span><br><span class=\"line\">*/5 * * * * <span class=\"built_in\">command</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 每天2点执行一次</span></span><br><span class=\"line\">0 2 * * * <span class=\"built_in\">command</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 每天2、3、4、5点各执行一次</span></span><br><span class=\"line\">0 2-5 * * * <span class=\"built_in\">command</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 周一至周五每天9点和18点各执行一次</span></span><br><span class=\"line\">0 9,18 * * 1-5 <span class=\"built_in\">command</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"systemctl-服务管理\">systemctl :服务管理</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>centOS7以后使用<code>systemd</code>进行服务管理，其命令接口为<code>systemctl</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>systemctl</code>兼容了<code>service</code>，即<code>systemctl</code>也会去<code>/etc/init.d</code>目录下，查看、执行相关程序</p>\n</li>\n<li class=\"lvl-2\">\n<p>如下centOS6及之前的服务启动方式，centOS7及之后仍然可以通过这种方式管理服务，实际上会重定向到systemctl命令</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service redis start</span><br><span class=\"line\">service redis stop</span><br><span class=\"line\">service redis restart</span><br><span class=\"line\">service redis status</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>systemd</code>的服务配置放在目录<code>/usr/lib/systemd/system  (Centos)</code> 或 <code>/etc/systemd/system  (Ubuntu)</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>配置目录下有多种类型文件<code>.mount</code>,<code>.service</code>,<code>.target</code>,<code>.socket</code>,<code>.timer</code>等等</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">不同的文件类型代表不同的资源，统称为 Unit（单位），Unit 一共分成12种类型</li>\n</ul>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Service unit：系统服务</span><br><span class=\"line\">Target unit：多个 Unit 构成的一个组</span><br><span class=\"line\">Device Unit：硬件设备</span><br><span class=\"line\">Mount Unit：文件系统的挂载点</span><br><span class=\"line\">Automount Unit：自动挂载点</span><br><span class=\"line\">Path Unit：文件或路径</span><br><span class=\"line\">Scope Unit：不是由 Systemd 启动的外部进程</span><br><span class=\"line\">Slice Unit：进程组</span><br><span class=\"line\">Snapshot Unit：Systemd 快照，可以切回某个快照</span><br><span class=\"line\">Socket Unit：进程间通信的 socket</span><br><span class=\"line\">Swap Unit：swap 文件</span><br><span class=\"line\">Timer Unit：定时器</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">重点学习<code>.service</code>文件，其定义了一个服务，分为[Unit]，[Service]，[Install]三个小节</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Unit]</span><br><span class=\"line\">Description:描述，</span><br><span class=\"line\">After：在哪些服务启动后才启动</span><br><span class=\"line\">ConditionPathExists: 执行条件</span><br><span class=\"line\">[Service]</span><br><span class=\"line\">EnvironmentFile:变量所在文件</span><br><span class=\"line\">ExecStart: 执行启动脚本</span><br><span class=\"line\">Restart: fail时重启</span><br><span class=\"line\">[Install]</span><br><span class=\"line\">Alias:服务别名</span><br><span class=\"line\">WangtedBy: 多用户模式下需要的</span><br></pre></td></tr></table></figure>\n</li>\n<li class=\"lvl-2\">\n<p>查看服务</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出当前已经启动的 unit，如果添加 -all 选项会同时列出没有启动的 unit</span></span><br><span class=\"line\">systemctl ==== systemctl list-units</span><br><span class=\"line\">systemctl -all</span><br><span class=\"line\"><span class=\"comment\"># 只查看服务类型为service的服务</span></span><br><span class=\"line\">systemctl list-units --<span class=\"built_in\">type</span>=service -all</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 根据 /lib/systemd/system/ 目录内的文件列出所有的服务及其当前的状态</span></span><br><span class=\"line\">systemctl list-unit-files</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果发现某个 服务 不工作，可以查看是否有 服务 加载失败</span></span><br><span class=\"line\">systemctl --failed</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>service :系统服务</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启动redis服务</span></span><br><span class=\"line\">systemctl start redis</span><br><span class=\"line\"><span class=\"comment\"># 重新启动redis服务</span></span><br><span class=\"line\">systemctl restart redis</span><br><span class=\"line\"><span class=\"comment\"># 关闭redis服务</span></span><br><span class=\"line\">systemctl stop redis</span><br><span class=\"line\"><span class=\"comment\"># 不关闭redis的情况下重新加载配置文件，让新的设置生效</span></span><br><span class=\"line\">systemctl reload redis</span><br><span class=\"line\"><span class=\"comment\"># 加入开机自启动</span></span><br><span class=\"line\">systemctl <span class=\"built_in\">enable</span> redis</span><br><span class=\"line\"><span class=\"comment\"># 关闭开机自启动</span></span><br><span class=\"line\">systemctl <span class=\"built_in\">disable</span> redis</span><br><span class=\"line\"><span class=\"comment\"># 查看redis服务状态</span></span><br><span class=\"line\">systemctl status redis</span><br><span class=\"line\"><span class=\"comment\"># 目前有没有正在运行中</span></span><br><span class=\"line\">systemctl is-active redis</span><br><span class=\"line\"><span class=\"comment\"># 开机时有没有默认要启用</span></span><br><span class=\"line\">systemctl is-enabled redis</span><br><span class=\"line\"><span class=\"comment\"># 是否启动失败</span></span><br><span class=\"line\">systemctl is-failed redis</span><br><span class=\"line\"><span class=\"comment\"># 列出 redis服务 的配置</span></span><br><span class=\"line\">systemctl show redis</span><br><span class=\"line\"><span class=\"comment\"># 注销 redis服务 ，注销后就无法启动</span></span><br><span class=\"line\">systemctl mask redis</span><br><span class=\"line\"><span class=\"comment\"># 取消 redis服务 的注销</span></span><br><span class=\"line\">systemctl unmask redis</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>target :类似于运行级别，支持多个target同时启动。target其实是多个unit的组合，系统启动说白了就是启动多个unit</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 只查看服务类型为target的服务</span></span><br><span class=\"line\">systemctl list-units --<span class=\"built_in\">type</span>=target -all</span><br><span class=\"line\"><span class=\"comment\"># 取得目前缺省的 target</span></span><br><span class=\"line\">systemctl get-default :multi-user.target</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 几个常用的 target。</span></span><br><span class=\"line\">    graphical.target：多人模式，支持图形和命令行两种登录，对应之前的3,5级别。</span><br><span class=\"line\">    multi-user.target：多人模式，只支持命令行登录，对应3级别！</span><br><span class=\"line\">    rescue.target：单人模式，对应1级别，在无法使用 root 登陆的情况下，systemd 在开机时会多加一个额外的临时系统，与你原本的系统无关。这时你可以取得 root 的权限来维护你的系统。</span><br><span class=\"line\">    emergency.target：单人模式，不过系统进入后根目录是只读的，紧急处理系统的错误，在无法使用 rescue.target 时，可以尝试使用这种模式！</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置缺省的 target</span></span><br><span class=\"line\">systemctl set-default multi-user.target</span><br><span class=\"line\"><span class=\"comment\"># 切换到指定的 target</span></span><br><span class=\"line\">systemctl isolate multi-user.target</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看依赖关系，查看 multi-user.target 依赖哪些服务</span></span><br><span class=\"line\">systemctl list-dependencies multi-user.target</span><br><span class=\"line\"><span class=\"comment\"># 反向查看依赖关系， --reverse 选项查看 multi-user.target 被谁使用</span></span><br><span class=\"line\">systemctl list-dependencies multi-user.target --reverse</span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>小贴士</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">1.<code>systemd</code> 主配置文件 <code>/etc/systemd/system.conf</code></li>\n<li class=\"lvl-2\">2.开机会先加载 <code>/etc/systemd/system/default.target</code></li>\n<li class=\"lvl-2\">3.所有的 <code>service</code> 和 <code>target</code> 都在 <code>/usr/lib/systemd/system/</code>目录下</li>\n<li class=\"lvl-2\">4.<code>/etc/systemd/system/defaut.target</code> 是一个软连接，软连接到了<code>/usr/lib/systemd/system/multi-user.target</code>，它会加载<code>/usr/lib/systemd/system/multi-user.target.wants</code>下面的<code>service</code></li>\n<li class=\"lvl-2\">5.查看一个<code>service</code>属于哪个<code>target</code>，需要查看具体的service文件，如：<code>cat /usr/lib/systemd/system/sshd.service</code>，看里面<code>[install]</code>部分</li>\n</ul>\n</div>\n<h2 id=\"chkconfig-设置系统服务在哪些运行级别下开机启动\">chkconfig :设置系统服务在哪些运行级别下开机启动</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>centOS7之后不再使用这种方式，而是使用<code>systemctl</code>，但是仍然可以在<code>/etc/init.d</code>目录下创建管理脚本，然后通过<code>chkconfig</code>进行管理</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chkconfig --list ：查看全部系统服务的运行级别</span><br><span class=\"line\">chkconfig --list sshd ：查看sshd系统服务的运行级别</span><br><span class=\"line\">chkconfig --level 2345 sshd on ：修改sshd服务的运行级别为2345都启动，on/off</span><br><span class=\"line\">chkconfig sshd on ：默认就是开启2345运行级别</span><br><span class=\"line\">chkconfig --add nginx :添加服务到管理列表中，需要在`/etc/init.d`目录下有对应的nginx文件</span><br><span class=\"line\">chkconfig --del nginx :从管理列表中删除</span><br></pre></td></tr></table></figure>\n<h2 id=\"ntsysv-通过界面设置服务是否开机启动\">ntsysv :通过界面设置服务是否开机启动</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>centOS7之后不再使用这种方式，而是使用<code>systemctl</code>，但是仍然可以使用其管理当前运行级别下的服务</p>\n</li>\n<li class=\"lvl-2\">\n<p>运行命令后会弹出设置界面，服务前面有*号的表示开机启动，使用空格修改，Tab键进行跳转</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 修改当前的运行级别下的服务</span></span><br><span class=\"line\">ntsysv</span><br><span class=\"line\"><span class=\"comment\"># 修改3运行级别下的服务</span></span><br><span class=\"line\">ntsysv --level 3</span><br><span class=\"line\"><span class=\"comment\"># 同时修改3和5运行级别下的服务</span></span><br><span class=\"line\">ntsysv --level 35</span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>Linux运行级别</strong></em><br>\n0：系统关机模式，系统默认运行级别不能设置为0，否则无法正常启动系统<br>\n1：单用户模式，也称为救援模式，root权限，用于系统维护，禁止远程登陆，类似Windows下的安全模式登录。<br>\n2：无网络支持的多用户模式<br>\n3：有网络支持的多用户模式(文本模式，工作中最常使用的模式)<br>\n4：保留，未使用<br>\n5：有网络支持的图形化模式，支持多用户模式，登陆后进入图形GUI模式或GNOME、KDE图形化界面，如X Window系统。<br>\n6：重启模式，重新引导系统，即重启</p>\n<p><strong>运行级别切换</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看当前的运行级别，输出结果为: 上一次运行级别 当前运行级别</span></span><br><span class=\"line\">runlevel</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 切换运行级别</span></span><br><span class=\"line\">init 0\t====  systemctl isolate poweroff.target\t====  systemctl poweroff</span><br><span class=\"line\">init 1\t====  systemctl isolate rescue.target</span><br><span class=\"line\">init 3\t====  systemctl isolate multi-user.target</span><br><span class=\"line\">init 5\t====  systemctl isolate graphical.target</span><br><span class=\"line\">init 6\t====  systemctl isolate reboot.target  ====  systemctl reboot</span><br></pre></td></tr></table></figure>\n</div>\n<h2 id=\"fuser-可以显示出当前哪个程序在使用磁盘上的某个文件、挂载点、甚至网络端口，并给出程序进程的详细信息\">fuser :可以显示出当前哪个程序在使用磁盘上的某个文件、挂载点、甚至网络端口，并给出程序进程的详细信息</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>fuser通常被用在诊断系统的<code>resource busy</code>问题，通常是在你希望<code>umount</code>指定的挂载点得时候遇到</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看哪个进程在访问/mnt目录</span></span><br><span class=\"line\">fuser /mnt :只显示PID和权限</span><br><span class=\"line\">fuser -u /mnt :-u，在每个PID后面添加进程拥有者的用户名称</span><br><span class=\"line\">fuser -v /mnt :-v，显示详细信息，包含PID,USER,COMMAND等许多域</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 把访问mnt目录的进程杀掉</span></span><br><span class=\"line\">fuser -kv /mnt :-k，杀掉进程</span><br><span class=\"line\">fuser -kvi /mnt :-i，会询问你是否杀掉对应的进程</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看80端口被哪个进程占用</span></span><br><span class=\"line\">fuser -n tcp 80 :-n，指定协议和端口</span><br><span class=\"line\">fuser 80/tcp :不加-n，需要这样指定协议和端口</span><br><span class=\"line\"></span><br><span class=\"line\">fuser -un tcp 80</span><br><span class=\"line\">fuser -u 80/tcp</span><br><span class=\"line\"></span><br><span class=\"line\">fuser -vn tcp 80</span><br><span class=\"line\">fuser -v 80/tcp</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 杀掉占用80端口的进程</span></span><br><span class=\"line\">fuser -kvn tcp 80</span><br><span class=\"line\">fuser -kvin tcp 80</span><br><span class=\"line\">fuser -kvi 80/tcp</span><br></pre></td></tr></table></figure>\n","content_text":"摘要 本文介绍Linux进程管理等相关命令 本文基于CentOS8(x86_64) ps :查看进程 1234567891011121314151617181920212223242526272829303132333435363738394041424344# 与top命令类似，可以查看进程信息$ ps -aux -a:所有用户 -x:没有控制终端的 -u:显示用户名和启动时间# 根据关键字过滤$ ps -aux | grep nginx$ ps -ef -e:显示所有进程，包括用户和没有控制终端 -f:显示所有信息# 查看线程，相同PID表示的是同一个进程启动的线程$ ps -eLf -L:显示线程# 查看进程优先级 NI$ ps -el# 查看进程运行在第几个cpu逻辑核心上$ ps -eo psr,user,pid,ppid,pri,ni,pgid,command | grep nginx psr：cpu逻辑核号 pri :默认19，优先级 0~99，越大优先级越高，pri(new) = pri(old) + nice ni :默认0，影响优先级的因子 -20~19，越小优先级越高，改变nice值可以改变pri pgid :进程组id，等同于 pgrp# 绑定PID为10288的进程到第一块CPU，这样该进程就不会占用其它的CPU资源了$ taskset -cp 1 10288# 按pid排序$ ps -aux --sort pid# 按用户排序$ ps -aux --sort user# 说明： USER:进程的执行用户 PID:进程号 PPID:父进程号 TTY:进程启动的终端 STAT:进程的当前状态，S:休眠 D:不可中断的休眠 R:运行 Z:僵死 T:停止 I:空闲内核线程 NI:进程优先级 TIME:进程自启动以来占用CPU的总时间 CMD/COMMAND:执行的命令 %CPU:占用CPU时间和总时间的百分比 %MEM:占用内存与系统内存总量的百分比 pstree :树状查看进行信息 123456# 折叠展示，只展示父进程和子进程的数量$ pstree# 展开所有子进程，并显示完整命令$ pstree -a# 展开所有子进程，并显示PID$ pstree -p kill :终止进程 12345678910111213141516171819# 正常关闭进程kill 进程号# 强行关闭，遇到进程不能正常关闭时使用kill -9 进程号# 查看所有信号kill -l# 杀死进程名称所关联的全部进程killall 进程名称killall -9 进程名称# 杀死进程名称所关联的全部进程，同killallpkill 进程名称pkill -9 进程名称# 查找服务的进程号pgrep 进程名称 : 效果同 ps -aux | grep 进程名 | grep -v grep| awk &#x27;&#123;print $2&#125;&#x27;# 终止进程名称含有mysql的全部进程pgrep mysql | xargs kill -s 9 进程的挂起和恢复 12345678910111213ctrl+c :终止ctrl+z :挂起，暂停bg num :转到后台继续运行fg num :从后台恢复到前台继续运行jobs :查看被挂起或正在后台运行的进程，会显示编号numcommond &amp; :后台运行，只在当前终端下有效nohup commond &amp; :后台执行，退出终端依然继续执行 进程运行优先级 进程优先级是 PRI(top中的PR)，其表示程序被 CPU 执行的先后顺序，此值越小进程的优先级别越高 PRI 值不是 Nice 值，但是 Nice 值会影响优先级，PRI(new) = PRI(old) + nice，所以我们调整 Nice 值，就可以改变进程的优先级 linux下的进程调度优先级 Nice 是从 -20 到 19 ，一共 40 个级别，数字越大，表示进程的优先级越低。默认时候，进程的调度优先级是0。 1234567891011121314151617181920212223242526272829303132333435363738394041# 指定命令的运行优先级nice -n commond# 改变一个正在运行的进程的优先级renice n pid# 改变进程组内全部进程的优先级renice n -g pid# 说明 n :取值范围（-20,19），越小优先级越高# 示例# 默认启动nginx$ nginx# 查看优先级，可以看到此时默认优先级是0ps -eo pgid,user,pid,pri,ni,command | grep nginx | grep -v grep23348 root 23348 19 0 nginx: master process nginx23348 nginx 23349 19 0 nginx: worker process23348 nginx 23350 19 0 nginx: worker process# 终止nginx进程$ pkill nginx# 重新指定优先级启动，指定优先级为10$ nice -10 nginx# 查看优先级，可以看到此时默认优先级是10$ ps -eo pgid,user,pid,pri,ni,command | grep nginx | grep -v grep23388 root 23388 9 10 nginx: master process nginx23388 nginx 23389 9 10 nginx: worker process23388 nginx 23390 9 10 nginx: worker process# 改变运行中的nginx的优先级为-10，此时只会改变master的优先级$ renice -10 2338823388 (进程 ID) 旧优先级为 10，新优先级为 -10$ ps -eo pgid,user,pid,pri,ni,command | grep nginx | grep -v grep23388 root 23388 29 -10 nginx: master process nginx23388 nginx 23389 9 10 nginx: worker process23388 nginx 23390 9 10 nginx: worker process# 改变运行中的nginx的优先级为-10，此时只会改变master的优先级$ renice -10 -g 2338823388 (进程组 ID) 旧优先级为 -10，新优先级为 -10$ ps -eo pgid,user,pid,pri,ni,command | grep nginx | grep -v grep23388 root 23388 29 -10 nginx: master process nginx23388 nginx 23389 29 -10 nginx: worker process23388 nginx 23390 29 -10 nginx: worker process at :执行一次的计划任务 /var/spool/at：at任务存放在该目录下 123456789101112131415161718# 启动at服务systemctl start atd# 今天10:46执行 test.shat -f test.sh 10:46# 时间格式： 5:30pm :今天下午5点30分 17:30 :今天下午5点30分 17:30 today :今天下午5点30分 now +3 hours :3小时后 now +180 minutes :3小时后 17:30 23.2.28 :2023年2月28日下午5点30分# 查看当前at队列，显示编号numat -l ==== atq# 删除指定编号的任务at -d num ==== atrm num 用户限制： /etc/at.allow :如果文件存在，则只有此文件中列出的用户可以使用at命令 /etc/at.deny :如果文件存在，则此文件中列出的用户不可以使用at命令 如果以上两个文件都不存在，则只有root用户可以使用at命令 如果以上两个文件都存在，但是都为空，则所有用户都可以使用at命令 crontab :周期性计划任务 systemctl start crond :启动cron服务，默认启动 crontab -l :显示当前用户下的计划任务 crontab -e :编辑当前用户下的计划任务 /var/spool/cron :计划任务保存在该路径下 /etc/cron.allow 与 /etc/cron.deny :用户限制，规则同 at 格式：分钟[0~59] 小时[0~23] 日期[1~31] 月份[1~12] 星期[0~6] commands 1234567891011# 每5分钟执行一次*/5 * * * * command# 每天2点执行一次0 2 * * * command# 每天2、3、4、5点各执行一次0 2-5 * * * command# 周一至周五每天9点和18点各执行一次0 9,18 * * 1-5 command systemctl :服务管理 centOS7以后使用systemd进行服务管理，其命令接口为systemctl systemctl兼容了service，即systemctl也会去/etc/init.d目录下，查看、执行相关程序 如下centOS6及之前的服务启动方式，centOS7及之后仍然可以通过这种方式管理服务，实际上会重定向到systemctl命令 1234service redis startservice redis stopservice redis restartservice redis status systemd的服务配置放在目录/usr/lib/systemd/system (Centos) 或 /etc/systemd/system (Ubuntu) 配置目录下有多种类型文件.mount,.service,.target,.socket,.timer等等 不同的文件类型代表不同的资源，统称为 Unit（单位），Unit 一共分成12种类型 123456789101112Service unit：系统服务Target unit：多个 Unit 构成的一个组Device Unit：硬件设备Mount Unit：文件系统的挂载点Automount Unit：自动挂载点Path Unit：文件或路径Scope Unit：不是由 Systemd 启动的外部进程Slice Unit：进程组Snapshot Unit：Systemd 快照，可以切回某个快照Socket Unit：进程间通信的 socketSwap Unit：swap 文件Timer Unit：定时器 重点学习.service文件，其定义了一个服务，分为[Unit]，[Service]，[Install]三个小节 1234567891011[Unit]Description:描述，After：在哪些服务启动后才启动ConditionPathExists: 执行条件[Service]EnvironmentFile:变量所在文件ExecStart: 执行启动脚本Restart: fail时重启[Install]Alias:服务别名WangtedBy: 多用户模式下需要的 查看服务 1234567891011# 列出当前已经启动的 unit，如果添加 -all 选项会同时列出没有启动的 unitsystemctl ==== systemctl list-unitssystemctl -all# 只查看服务类型为service的服务systemctl list-units --type=service -all# 根据 /lib/systemd/system/ 目录内的文件列出所有的服务及其当前的状态systemctl list-unit-files# 如果发现某个 服务 不工作，可以查看是否有 服务 加载失败systemctl --failed service :系统服务 1234567891011121314151617181920212223242526# 启动redis服务systemctl start redis# 重新启动redis服务systemctl restart redis# 关闭redis服务systemctl stop redis# 不关闭redis的情况下重新加载配置文件，让新的设置生效systemctl reload redis# 加入开机自启动systemctl enable redis# 关闭开机自启动systemctl disable redis# 查看redis服务状态systemctl status redis# 目前有没有正在运行中systemctl is-active redis# 开机时有没有默认要启用systemctl is-enabled redis# 是否启动失败systemctl is-failed redis# 列出 redis服务 的配置systemctl show redis# 注销 redis服务 ，注销后就无法启动systemctl mask redis# 取消 redis服务 的注销systemctl unmask redis target :类似于运行级别，支持多个target同时启动。target其实是多个unit的组合，系统启动说白了就是启动多个unit 123456789101112131415161718192021# 只查看服务类型为target的服务systemctl list-units --type=target -all# 取得目前缺省的 targetsystemctl get-default :multi-user.target# 几个常用的 target。 graphical.target：多人模式，支持图形和命令行两种登录，对应之前的3,5级别。 multi-user.target：多人模式，只支持命令行登录，对应3级别！ rescue.target：单人模式，对应1级别，在无法使用 root 登陆的情况下，systemd 在开机时会多加一个额外的临时系统，与你原本的系统无关。这时你可以取得 root 的权限来维护你的系统。 emergency.target：单人模式，不过系统进入后根目录是只读的，紧急处理系统的错误，在无法使用 rescue.target 时，可以尝试使用这种模式！# 设置缺省的 targetsystemctl set-default multi-user.target# 切换到指定的 targetsystemctl isolate multi-user.target# 查看依赖关系，查看 multi-user.target 依赖哪些服务systemctl list-dependencies multi-user.target# 反向查看依赖关系， --reverse 选项查看 multi-user.target 被谁使用systemctl list-dependencies multi-user.target --reverse 小贴士 1.systemd 主配置文件 /etc/systemd/system.conf 2.开机会先加载 /etc/systemd/system/default.target 3.所有的 service 和 target 都在 /usr/lib/systemd/system/目录下 4./etc/systemd/system/defaut.target 是一个软连接，软连接到了/usr/lib/systemd/system/multi-user.target，它会加载/usr/lib/systemd/system/multi-user.target.wants下面的service 5.查看一个service属于哪个target，需要查看具体的service文件，如：cat /usr/lib/systemd/system/sshd.service，看里面[install]部分 chkconfig :设置系统服务在哪些运行级别下开机启动 centOS7之后不再使用这种方式，而是使用systemctl，但是仍然可以在/etc/init.d目录下创建管理脚本，然后通过chkconfig进行管理 123456chkconfig --list ：查看全部系统服务的运行级别chkconfig --list sshd ：查看sshd系统服务的运行级别chkconfig --level 2345 sshd on ：修改sshd服务的运行级别为2345都启动，on/offchkconfig sshd on ：默认就是开启2345运行级别chkconfig --add nginx :添加服务到管理列表中，需要在`/etc/init.d`目录下有对应的nginx文件chkconfig --del nginx :从管理列表中删除 ntsysv :通过界面设置服务是否开机启动 centOS7之后不再使用这种方式，而是使用systemctl，但是仍然可以使用其管理当前运行级别下的服务 运行命令后会弹出设置界面，服务前面有*号的表示开机启动，使用空格修改，Tab键进行跳转 123456# 修改当前的运行级别下的服务ntsysv# 修改3运行级别下的服务ntsysv --level 3# 同时修改3和5运行级别下的服务ntsysv --level 35 Linux运行级别 0：系统关机模式，系统默认运行级别不能设置为0，否则无法正常启动系统 1：单用户模式，也称为救援模式，root权限，用于系统维护，禁止远程登陆，类似Windows下的安全模式登录。 2：无网络支持的多用户模式 3：有网络支持的多用户模式(文本模式，工作中最常使用的模式) 4：保留，未使用 5：有网络支持的图形化模式，支持多用户模式，登陆后进入图形GUI模式或GNOME、KDE图形化界面，如X Window系统。 6：重启模式，重新引导系统，即重启 运行级别切换 123456789# 查看当前的运行级别，输出结果为: 上一次运行级别 当前运行级别runlevel# 切换运行级别init 0 ==== systemctl isolate poweroff.target ==== systemctl poweroffinit 1 ==== systemctl isolate rescue.targetinit 3 ==== systemctl isolate multi-user.targetinit 5 ==== systemctl isolate graphical.targetinit 6 ==== systemctl isolate reboot.target ==== systemctl reboot fuser :可以显示出当前哪个程序在使用磁盘上的某个文件、挂载点、甚至网络端口，并给出程序进程的详细信息 fuser通常被用在诊断系统的resource busy问题，通常是在你希望umount指定的挂载点得时候遇到 1234567891011121314151617181920212223# 查看哪个进程在访问/mnt目录fuser /mnt :只显示PID和权限fuser -u /mnt :-u，在每个PID后面添加进程拥有者的用户名称fuser -v /mnt :-v，显示详细信息，包含PID,USER,COMMAND等许多域# 把访问mnt目录的进程杀掉fuser -kv /mnt :-k，杀掉进程fuser -kvi /mnt :-i，会询问你是否杀掉对应的进程# 查看80端口被哪个进程占用fuser -n tcp 80 :-n，指定协议和端口fuser 80/tcp :不加-n，需要这样指定协议和端口fuser -un tcp 80fuser -u 80/tcpfuser -vn tcp 80fuser -v 80/tcp# 杀掉占用80端口的进程fuser -kvn tcp 80fuser -kvin tcp 80fuser -kvi 80/tcp","summary":"摘要 本文介绍Linux进程管理等相关命令 本文基于CentOS8(x86_64)","date_published":"2023-03-27T14:45:05.000Z","tags":["技术","linux","linux常用命令","linux常用命令"]},{"id":"https://blog.hanqunfeng.com/2023/03/27/linux-command10-stat/","url":"https://blog.hanqunfeng.com/2023/03/27/linux-command10-stat/","title":"Linux常用命令--系统硬件信息及其监控","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度 ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍Linux查看系统硬件信息及其监控等相关命令</p>\n</li>\n<li class=\"lvl-2\">\n<p>本文基于<code>CentOS8(x86_64)</code></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"uname-查看系统版本信息\">uname :查看系统版本信息</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">uname</span> -a</span><br></pre></td></tr></table></figure>\n<h2 id=\"查看网卡和路由信息\">查看网卡和路由信息</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 网卡</span></span><br><span class=\"line\">$ ifconfig</span><br><span class=\"line\"><span class=\"comment\"># 路由</span></span><br><span class=\"line\">$ route</span><br></pre></td></tr></table></figure>\n<h2 id=\"查看cpu信息\">查看cpu信息</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cat</span> /proc/cpuinfo</span><br><span class=\"line\"></span><br><span class=\"line\">processor\t: 0</span><br><span class=\"line\">vendor_id\t: GenuineIntel</span><br><span class=\"line\">cpu family\t: 6</span><br><span class=\"line\">model\t\t: 85</span><br><span class=\"line\">model name\t: Intel(R) Xeon(R) Platinum 8269CY CPU @ 2.50GHz</span><br><span class=\"line\">stepping\t: 7</span><br><span class=\"line\">microcode\t: 0x1</span><br><span class=\"line\">cpu MHz\t\t: 2499.998</span><br><span class=\"line\">cache size\t: 36608 KB</span><br><span class=\"line\">physical <span class=\"built_in\">id</span>\t: 0</span><br><span class=\"line\">siblings\t: 2</span><br><span class=\"line\">core <span class=\"built_in\">id</span>\t\t: 0</span><br><span class=\"line\">cpu cores\t: 1</span><br><span class=\"line\">apicid\t\t: 0</span><br><span class=\"line\">initial apicid\t: 0</span><br><span class=\"line\">fpu\t\t: <span class=\"built_in\">yes</span></span><br><span class=\"line\">fpu_exception\t: <span class=\"built_in\">yes</span></span><br><span class=\"line\">cpuid level\t: 22</span><br><span class=\"line\">wp\t\t: <span class=\"built_in\">yes</span></span><br><span class=\"line\">flags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc rep_good nopl xtopology nonstop_tsc cpuid tsc_known_freq pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch invpcid_single pti fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 erms invpcid rtm mpx avx512f avx512dq rdseed adx smap clflushopt clwb avx512cd avx512bw avx512vl xsaveopt xsavec xgetbv1 xsaves arat avx512_vnni</span><br><span class=\"line\">bugs\t\t: cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs taa itlb_multihit</span><br><span class=\"line\">bogomips\t: 4999.99</span><br><span class=\"line\">clflush size\t: 64</span><br><span class=\"line\">cache_alignment\t: 64</span><br><span class=\"line\">address sizes\t: 46 bits physical, 48 bits virtual</span><br><span class=\"line\">power management:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 解释如下：</span></span><br><span class=\"line\">processor：系统中逻辑处理核心的数量。对于单核处理器，该类将其视为 CPU 编号，对于多核处理器，它可以是物理内核，也可以是使用超线程技术的虚拟逻辑内核。（processor内核内部使用的对象，不一定绑定到物理设备，它们可能都具有相同的 physical <span class=\"built_in\">id</span>）</span><br><span class=\"line\">vendor_id：CPU制造商。</span><br><span class=\"line\">cpu family：CPU 产品系列代号。</span><br><span class=\"line\">mode：cpu属于其系列中的哪一代。</span><br><span class=\"line\">model name：CPU的名称及其编号，标称频率。</span><br><span class=\"line\">stepping：CPU属于生产更新版本。</span><br><span class=\"line\">cpu MHz：实际CPU频率。</span><br><span class=\"line\">cache size：CPU二级缓存的大小。</span><br><span class=\"line\">physical <span class=\"built_in\">id</span>：单个物理CPU标号。</span><br><span class=\"line\">siblings：单个物理 CPU 的逻辑 CPU 数量。siblings = cpu 核心 * [2]。</span><br><span class=\"line\">core <span class=\"built_in\">id</span>：当前所在CPU中的物理内核<span class=\"built_in\">id</span>。</span><br><span class=\"line\">cpu cores：逻辑核所在CPU的物理核数。比如这里有2个cpu core，对应的core <span class=\"built_in\">id</span>是0、1。</span><br><span class=\"line\">apicid：用于区分不同逻辑核心的编号。系统中每个逻辑核的编号必须不同，编号不一定是连续的。</span><br><span class=\"line\">fpu：是否有浮点单元。（Floating Point Unit）</span><br><span class=\"line\">fpu_exception：是否支持浮点计算异常。</span><br><span class=\"line\">cpuid level：在执行cpuid指令之前，eax寄存器中的值会根据不同的值返回不同的内容。</span><br><span class=\"line\">wp：表示当前CPU是否支持内核态用户空间写保护。（Write Protection）</span><br><span class=\"line\">flags：当前CPU支持的功能，例如浮点单元 (FPU) 的存在和处理 MMX 指令的能力。。</span><br><span class=\"line\">bogomips：粗略测量的 CPU 速度（每秒百万条指令）。</span><br><span class=\"line\">clflush size：每个flush缓存的大小单位。</span><br><span class=\"line\">cache_alignment：缓存地址对齐单元。</span><br><span class=\"line\">address sizes：可访问地址空间的数量。</span><br><span class=\"line\">power management：支持电源管理。</span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>小贴士</strong></em><br>\n<code>/proc</code>：目录中存放进程PID命名的目录以及系统相关信息文件，如：<br>\n<code>cpuinfo</code> :cup信息<br>\n<code>meminfo</code> :内存信息<br>\n<code>partitions</code> :硬盘分区</p>\n</div>\n<h2 id=\"uptime-查看系统运行时间和cpu负载\">uptime :查看系统运行时间和cpu负载</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">uptime</span></span><br><span class=\"line\"> 14:12:52 up 2 days, 20:41,  1 user,  load average: 0.06, 0.03, 0.01</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 说明：</span></span><br><span class=\"line\"> 14:12:52    当前时间</span><br><span class=\"line\"> up 2 days, 20:41    系统运行了多久</span><br><span class=\"line\"> 1 user    当前登录用户数</span><br><span class=\"line\"> load average: 0.06, 0.03, 0.01   系统负载，即任务队列的平均长度。三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。</span><br></pre></td></tr></table></figure>\n<h2 id=\"w-查看系统运行时间和cpu负载以及当前用户登录信息\">w :查看系统运行时间和cpu负载以及当前用户登录信息</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ w</span><br><span class=\"line\"> 17:35:25 up 3 days, 3 min,  1 user,  load average: 0.00, 0.00, 0.00</span><br><span class=\"line\">USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class=\"line\">root     pts/0    1.120.160.30     13:58    0.00s  0.12s  0.12s -bash</span><br></pre></td></tr></table></figure>\n<h2 id=\"free-查看内存信息\">free :查看内存信息</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 显示内存使用情况，默认单位k</span></span><br><span class=\"line\">$ free</span><br><span class=\"line\">              total        used        free      shared  buff/cache   available</span><br><span class=\"line\">Mem:         912836      100016       72608         460      740212      667376</span><br><span class=\"line\">Swap:             0           0           0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 说明：</span></span><br><span class=\"line\">    total :物理内存总量</span><br><span class=\"line\">    used  :已经使用的物理内存总量</span><br><span class=\"line\">    free  :空闲内存总量</span><br><span class=\"line\">    shared :是多个进程共享的内存总数；</span><br><span class=\"line\">    buff/cache :用作内核缓存的内存量</span><br><span class=\"line\"></span><br><span class=\"line\">选项\t含义</span><br><span class=\"line\">-b\t以 Byte（字节）为单位，显示内存使用情况。</span><br><span class=\"line\">-k\t以 KB 为单位，显示内存使用情况，此选项是 free 命令的默认选项。</span><br><span class=\"line\">-m\t以 MB 为单位，显示内存使用情况。</span><br><span class=\"line\">-g\t以 GB 为单位，显示内存使用情况。</span><br><span class=\"line\">-t\t在输出的最终结果中，输出内存和 swap 分区的总量。</span><br><span class=\"line\">-o\t不显示系统缓冲区这一列。</span><br><span class=\"line\">-s  间隔秒数\t根据指定的间隔时间，持续显示内存使用情况。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"df-查看硬盘信息\">df :查看硬盘信息</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">df</span> -hT</span><br><span class=\"line\">文件系统          类型      容量  已用  可用   已用% 挂载点</span><br><span class=\"line\">devtmpfs       devtmpfs  436M     0  436M    0% /dev</span><br><span class=\"line\">tmpfs          tmpfs     446M     0  446M    0% /dev/shm</span><br><span class=\"line\">tmpfs          tmpfs     446M  456K  446M    1% /run</span><br><span class=\"line\">tmpfs          tmpfs     446M     0  446M    0% /sys/fs/cgroup</span><br><span class=\"line\">/dev/vda1      ext4       20G   14G  5.3G   72% /</span><br><span class=\"line\">tmpfs          tmpfs      90M     0   90M    0% /run/user/0</span><br></pre></td></tr></table></figure>\n<h2 id=\"top-动态显示进程状态\">top :动态显示进程状态</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 动态显示进程状态，默认每3秒刷新一次</span></span><br><span class=\"line\">$ top</span><br><span class=\"line\">top - 14:08:03 up 2 days, 20:36,  1 user,  load average: 0.06, 0.03, 0.01</span><br><span class=\"line\">Tasks:  87 total,   1 running,  47 sleeping,   0 stopped,   0 zombie</span><br><span class=\"line\">%Cpu(s):  0.1 us,  0.0 sy,  0.0 ni, 99.9 <span class=\"built_in\">id</span>,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class=\"line\">KiB Mem :   912836 total,    65564 free,    99648 used,   747624 buff/cache</span><br><span class=\"line\">KiB Swap:        0 total,        0 free,        0 used.   667600 avail Mem</span><br><span class=\"line\"></span><br><span class=\"line\">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class=\"line\">  558 root      20   0   17832   1772   1288 S   0.1  0.2   0:45.25 assist_daemon</span><br><span class=\"line\">  585 root      20   0  813912  10888   5104 S   0.1  1.2   3:51.47 aliyun-service</span><br><span class=\"line\">  587 root      20   0  733348   9636   4604 S   0.1  1.1   0:11.96 rsyslogd</span><br><span class=\"line\">    1 root      20   0   51640   4432   3156 S   0.0  0.5   0:33.44 systemd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 说明：</span></span><br><span class=\"line\">    第一行为任务队列信息，同 <span class=\"built_in\">uptime</span></span><br><span class=\"line\">    第二行为进程信息:</span><br><span class=\"line\">        total :进程总数</span><br><span class=\"line\">        running :正在运行的进程数</span><br><span class=\"line\">        sleeping :睡眠的进程数</span><br><span class=\"line\">        stopped :停止的进程数</span><br><span class=\"line\">        zombie :僵尸进程数</span><br><span class=\"line\">    第三行为CPU信息:</span><br><span class=\"line\">        0.1 us :用户空间占用CPU百分比</span><br><span class=\"line\">        0.0 sy :内核空间占用CPU百分比</span><br><span class=\"line\">        0.0 ni :用户进程空间内改变过优先级的进程占用CPU百分比</span><br><span class=\"line\">        99.9 <span class=\"built_in\">id</span> :空闲CPU百分比</span><br><span class=\"line\">        0.0 wa :等待输入输出的CPU时间百分比，通过查看 CPU 的 wa% 值来判断当前磁盘 IO 性能，如果这个数值过大，很可能是磁盘 IO 太高了，当然也可能是其他原因，例如网络 IO 过高等。</span><br><span class=\"line\">        0.0 hi :硬件CPU中断占用百分比</span><br><span class=\"line\">        0.0 si :软中断占用百分比</span><br><span class=\"line\">        0.0 st :虚拟机占用百分比</span><br><span class=\"line\">    第四行和第五行为内存信息:</span><br><span class=\"line\">        Mem:</span><br><span class=\"line\">        912836 total    物理内存总量</span><br><span class=\"line\">        65564 free    空闲内存总量</span><br><span class=\"line\">        99648 used    使用的物理内存总量</span><br><span class=\"line\">        747624 buff/cache    用作内核缓存的内存量</span><br><span class=\"line\">        Swap:</span><br><span class=\"line\">        0 total    交换区总量</span><br><span class=\"line\">        0 free    空闲交换区总量</span><br><span class=\"line\">        0 used    使用的交换区总量</span><br><span class=\"line\">        667600 avail Mem    缓冲的交换区总量,内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖，该数值即为这些内容已存在于内存中的交换区的大小,相应的内存再次被换出时可不必再对交换区写入。</span><br><span class=\"line\"></span><br><span class=\"line\">    之后是进程信息区：默认情况下仅显示比较重要的 PID、USER、PR、NI、VIRT、RES、SHR、S、%CPU、%MEM、TIME+、COMMAND 列。</span><br><span class=\"line\">    运行top后按f会查看到全部的展示项，这里只对部分展示项进行说明</span><br><span class=\"line\">        序号  列名    含义</span><br><span class=\"line\">        a    PID     进程<span class=\"built_in\">id</span></span><br><span class=\"line\">        b    PPID    父进程<span class=\"built_in\">id</span></span><br><span class=\"line\">        c    RUSER   Real user name</span><br><span class=\"line\">        d    UID     进程所有者的用户<span class=\"built_in\">id</span></span><br><span class=\"line\">        e    USER    进程所有者的用户名</span><br><span class=\"line\">        f    GROUP   进程所有者的组名</span><br><span class=\"line\">        g    TTY     启动进程的终端名。不是从终端启动的进程则显示为 ?</span><br><span class=\"line\">        h    PR      优先级。默认20。这个优先级对应实时进程，只使用1-99号优先级队列，序号越大优先级越高，0号留给普通进程使用</span><br><span class=\"line\">        i    NI      <span class=\"built_in\">nice</span>值。默认0。负值表示高优先级，正值表示低优先级</span><br><span class=\"line\">        j    P       最后使用的CPU，仅在多CPU环境下有意义</span><br><span class=\"line\">        k    %CPU    上次更新到现在的CPU时间占用百分比</span><br><span class=\"line\">        l    TIME    进程使用的CPU时间总计，单位精确到秒， 3:51 表示 3分51秒</span><br><span class=\"line\">        m    TIME+   进程使用的CPU时间总计，单位精确到1/100秒，3:51.47 表示 3分51秒多</span><br><span class=\"line\">        n    %MEM    进程使用的物理内存百分比</span><br><span class=\"line\">        o    VIRT    进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</span><br><span class=\"line\">        p    SWAP    进程使用的虚拟内存中，被换出的大小，单位kb。</span><br><span class=\"line\">        q    RES     进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</span><br><span class=\"line\">        r    CODE    可执行代码占用的物理内存大小，单位kb</span><br><span class=\"line\">        s    DATA    可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb</span><br><span class=\"line\">        t    SHR     共享内存大小，单位kb</span><br><span class=\"line\">        u    nFLT    页面错误次数</span><br><span class=\"line\">        v    nDRT    最后一次写入到现在，被修改过的页面数。</span><br><span class=\"line\">        w    S       进程状态(D=不可中断的睡眠状态,I=空闲内核线程,R=运行,S=睡眠,T=因作业控制信号而停止,Z=僵尸进程)</span><br><span class=\"line\">        x    COMMAND 命令名/命令行</span><br><span class=\"line\">        y    WCHAN   若该进程在睡眠，则显示睡眠中的系统函数名</span><br><span class=\"line\">        z    Flags   任务标志，参考 sched.h</span><br><span class=\"line\">        0    PGRP    进程组<span class=\"built_in\">id</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 交互命令：运行top后，可以键入如下指令与top进行交互</span></span><br><span class=\"line\">    h :获得帮助</span><br><span class=\"line\">    q :退出程序。</span><br><span class=\"line\">    d :指定刷新时间</span><br><span class=\"line\">    m :切换内存信息显示效果</span><br><span class=\"line\">    t :切换显示进程和CPU状态信息。</span><br><span class=\"line\">    c :切换显示命令名称和完整命令行。</span><br><span class=\"line\">    u :查看指定用户的进程</span><br><span class=\"line\">    k :终止执行中的进程 pid，系统将提示用户输入需要终止的进程PID，以及需要发送给该进程什么样的信号。一般的终止进程可以使用15信号；如果不能正常结束那就使用信号9强制结束该进程。默认值是信号15。在安全模式中此命令被屏蔽。</span><br><span class=\"line\">    r :重新设置进程优先级 n pid，系统提示用户输入需要改变的进程PID以及需要设置的进程优先级值。输入一个正值将使优先级降低，反之则可以使该进程拥有更高的优先权。默认值是10。</span><br><span class=\"line\">    翻页:</span><br><span class=\"line\">    Shift + &lt;  :上翻</span><br><span class=\"line\">    Shift + &gt;  :下翻</span><br><span class=\"line\">    Ctrl+L 擦除并且重写屏幕。</span><br><span class=\"line\">    i :忽略闲置和僵死进程。这是一个开关式命令。</span><br><span class=\"line\">    l :切换显示平均负载和启动时间信息。</span><br><span class=\"line\">    M :根据驻留内存大小进行排序。</span><br><span class=\"line\">    P :根据CPU使用百分比大小进行排序。</span><br><span class=\"line\">    T :根据时间/累计时间进行排序。</span><br><span class=\"line\">    W :将当前设置写入~/.toprc文件中。这是写top配置文件的推荐方法。</span><br><span class=\"line\">    f :从当前显示中添加或者删除项目。按d添加或删除，esc返回。此时也可以调整每一列的显示顺序，按右键会将当前项全选，然后上下调整位置后按回车即可。默认情况下仅显示比较重要的 PID、USER、PR、NI、VIRT、RES、SHR、S、%CPU、%MEM、TIME+、COMMAND 列</span><br><span class=\"line\">    o :过滤指定的内容，如过滤用户则输入：USER=username，匹配时采用模糊匹配，多次输入o会在当前过滤基础上增加新的过滤条件，q退出</span><br><span class=\"line\">    S :切换到累计模式。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># top使用格式</span></span><br><span class=\"line\">top [-] [d] [p] [q] [c] [C] [S] [s]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#参数说明</span></span><br><span class=\"line\">    d 指定每两次屏幕信息刷新之间的时间间隔。当然用户可以使用s交互命令来改变之。</span><br><span class=\"line\">    p 通过指定监控进程ID来仅仅监控某个进程的状态。</span><br><span class=\"line\">    S 指定累计模式</span><br><span class=\"line\">    s 使top命令在安全模式中运行。这将去除交互命令所带来的潜在危险。</span><br><span class=\"line\">    i 使top不显示任何闲置或者僵死进程。</span><br><span class=\"line\">    c 显示整个命令行而不只是显示命令名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\">top   //每隔5秒显式所有进程的资源占用情况</span><br><span class=\"line\">top -d 2  //每隔2秒显式所有进程的资源占用情况</span><br><span class=\"line\">top -c  //每隔5秒显式进程的资源占用情况，并显示进程的命令行参数(默认只有进程名)</span><br><span class=\"line\">top -p 12345 -p 6789//每隔5秒显示pid是12345和pid是6789的两个进程的资源占用情况</span><br><span class=\"line\">top -d 2 -c -p 123456 //每隔2秒显示pid是12345的进程的资源使用情况，并显式该进程启动的命令行参数</span><br><span class=\"line\">top -p进程1的ID  -p进程2的<span class=\"built_in\">id</span> -p进程3的<span class=\"built_in\">id</span> …… //查看某几个进程的状态</span><br></pre></td></tr></table></figure>\n<h2 id=\"sar-查看-CPU-、内存、磁盘、网络等性能指标\">sar :查看 CPU 、内存、磁盘、网络等性能指标</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>sar 命令是分析系统瓶颈的神器，可以用来查看 CPU 、内存、磁盘、网络等性能。</p>\n</li>\n<li class=\"lvl-2\">\n<p>查看磁盘性能</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看当前磁盘性能，-d参数代表查看磁盘性能，-p参数代表将 dev 设备按照 sda，sdb……名称显示，1是间隔1秒，2是采集2次</span></span><br><span class=\"line\">$ sar -d -p 1 2</span><br><span class=\"line\"></span><br><span class=\"line\">07时35分57秒       DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util</span><br><span class=\"line\">07时35分58秒      xvda      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class=\"line\"></span><br><span class=\"line\">07时35分58秒       DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util</span><br><span class=\"line\">07时35分59秒      xvda     12.00      0.00    155.00     12.92      0.01      0.67      1.67      2.00</span><br><span class=\"line\"></span><br><span class=\"line\">平均时间:       DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util</span><br><span class=\"line\">平均时间:      xvda      6.00      0.00     77.50     12.92      0.00      0.67      1.67      1.00</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 说明：</span></span><br><span class=\"line\">    tps :每秒从物理磁盘I/O的次数.多个逻辑请求会被合并为一个I/O磁盘请求， 一次传输的大小是不确定的.</span><br><span class=\"line\">    rd_sec/s :每秒读扇区的次数.</span><br><span class=\"line\">    wr_sec/s :每秒写扇区的次数.</span><br><span class=\"line\">    avgrq-sz :平均每次设备I/O操作的数据大小（扇区）.</span><br><span class=\"line\">    avgqu-sz :磁盘请求队列的平均长度.</span><br><span class=\"line\">    await :从请求磁盘操作到 系统完成处理，每次请求的平均消耗时间 包括请求队列等待时间，单位是毫秒（1秒=1000毫秒）.</span><br><span class=\"line\">    svctm :系统处理每次请求的平均时间 不包括在请求队列中消耗的时间.</span><br><span class=\"line\">    %util :I/O请求占CPU的百分比，比率越大，说明越饱和.</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    avgqu-sz 的值较低时，设备的利用率较高</span><br><span class=\"line\">    %util I/O请求占用的CPU百分比，值越高，说明I/O越慢。</span><br><span class=\"line\"></span><br><span class=\"line\">    对于磁盘 IO 性能，一般有如下评判标准：</span><br><span class=\"line\">    正常情况下 svctm 应该是小于 await 值的，而 svctm 的大小和磁盘性能有关，CPU 、内存的负荷也会对 svctm 值造成影响，过多的请求也会间接的导致 svctm 值的增加。</span><br><span class=\"line\">    await 值的大小一般取决与 svctm 的值和 I/O 队列长度以 及I/O 请求模式，如果 svctm 的值与 await 很接近，表示几乎没有 I/O 等待，磁盘性能很好，如果 await 的值远高于 svctm 的值，则表示 I/O 队列等待太长，系统上运行的应用程序将变慢，此时可以通过更换更快的硬盘来解决问题。</span><br><span class=\"line\">    %util 项的值也是衡量磁盘 I/O 的一个重要指标，如果 %util 接近 100% ，表示磁盘产生的 I/O 请求太多，I/O 系统已经满负荷的在工作，该磁盘可能存在瓶颈。长期下去，势必影响系统的性能，可以通过优化程序或者通过更换更高、更快的磁盘来解决此问题。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果想继续查看以前的报告；可以查看保存在/var/log/sa/下的sar日志，保留最近30天的日志: 日志名称以sa开头，日期号结尾，如11号的日志为sa11</span></span><br><span class=\"line\">$ sar -d -p -f  /var/log/sa/sa11  | more</span><br><span class=\"line\"></span><br><span class=\"line\">00时00分01秒       DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util</span><br><span class=\"line\">00时10分01秒      xvda     10.67      0.13    190.20     17.84      0.12     11.08      3.33      3.55</span><br><span class=\"line\">00时20分01秒      xvda     11.40      0.08    234.10     20.54      0.07      6.07      3.26      3.72</span><br><span class=\"line\">00时30分01秒      xvda     11.05      0.19    200.59     18.17      0.03      2.82      2.51      2.77</span><br><span class=\"line\">00时40分01秒      xvda     10.78      0.00    225.89     20.96      0.14     12.59      4.64      5.00</span><br><span class=\"line\">00时50分01秒      xvda     10.53      0.00    183.95     17.47      0.04      4.16      3.04      3.20</span><br><span class=\"line\">01时00分01秒      xvda     10.58      0.00    187.13     17.68      0.12     11.18      4.52      4.78</span><br><span class=\"line\">01时10分01秒      xvda     10.74      0.00    187.12     17.42      0.09      8.20      4.76      5.11</span><br><span class=\"line\">01时20分01秒      xvda     11.52      0.05    212.70     18.47      0.06      4.83      2.52      2.90</span><br><span class=\"line\">01时30分01秒      xvda     10.69      0.05    191.77     17.94      0.04      3.43      2.65      2.83</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看cpu使用率指标</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看当前的cpu指标，-u指cpu使用率，默认就是-u，1是间隔1秒，3是采集3次</span></span><br><span class=\"line\">$ sar -u 1 3</span><br><span class=\"line\"></span><br><span class=\"line\">15时48分53秒     CPU     %user     %<span class=\"built_in\">nice</span>   %system   %iowait    %steal     %idle</span><br><span class=\"line\">15时48分54秒     all      0.50      0.00      0.50      0.00      0.00     99.00</span><br><span class=\"line\">15时48分55秒     all      0.00      0.00      0.00      0.00      0.00    100.00</span><br><span class=\"line\">15时48分56秒     all      0.00      0.00      0.00      0.00      0.00    100.00</span><br><span class=\"line\">平均时间:     all      0.17      0.00      0.17      0.00      0.00     99.67</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看全天的cpu指标</span></span><br><span class=\"line\">$ sar -u -p</span><br><span class=\"line\"></span><br><span class=\"line\">00时00分01秒     CPU     %user     %<span class=\"built_in\">nice</span>   %system   %iowait    %steal     %idle</span><br><span class=\"line\">00时10分01秒     all      0.08      0.00      0.08      0.00      0.00     99.84</span><br><span class=\"line\">00时20分01秒     all      0.08      0.00      0.07      0.00      0.00     99.85</span><br><span class=\"line\">00时30分01秒     all      0.07      0.00      0.08      0.00      0.00     99.84</span><br><span class=\"line\">00时40分01秒     all      0.15      0.00      0.08      0.00      0.00     99.78</span><br><span class=\"line\">00时50分01秒     all      0.07      0.00      0.07      0.00      0.00     99.85</span><br><span class=\"line\">01时00分01秒     all      0.07      0.00      0.08      0.00      0.00     99.85</span><br><span class=\"line\">01时10分01秒     all      0.67      0.00      0.12      0.01      0.00     99.20</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 说明：</span></span><br><span class=\"line\">    CPU :all表示统计所有CPU的平均值</span><br><span class=\"line\">    %user :显示在用户级别（application）运行使用 CPU 总时间的百分比</span><br><span class=\"line\">    %<span class=\"built_in\">nice</span> :改变过优先级的进程的CPU使用率</span><br><span class=\"line\">    %system :内核空间的CPU使用率， 在核心级别（kernel）运行所使用CPU总时间的百分比</span><br><span class=\"line\">    %iowait :显示用于等待I/O操作占用CPU总时间的百分比</span><br><span class=\"line\">    %steal :管理程序（hypervisor）为另一个虚拟进程提供服务而等待虚拟CPU的百分比</span><br><span class=\"line\">    %idle :显示 CPU空闲时间占用CPU总时间的百分比</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 主要监控如下两项：</span></span><br><span class=\"line\">    %iowait 过高表示存在I/O瓶颈，即磁盘IO无法满足业务需求</span><br><span class=\"line\">    %idle 过低表示CPU使用比较严重，需要结合内存使用等情况判断CPU是否瓶颈。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看以前的报告,保存在/var/log/sa/下的sar日志，保留最近30天的日志: 日志名称以sa开头，日期号结尾，如11号的日志为sa11</span></span><br><span class=\"line\">sar -u -f  /var/log/sa/sa11  | more</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看cpu负载指标</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看当前的cpu的负载指标，-q指cpu负载，1是间隔1秒，3是采集3次</span></span><br><span class=\"line\">$ sar -q 1 3</span><br><span class=\"line\"></span><br><span class=\"line\">16时00分32秒   runq-sz  plist-sz   ldavg-1   ldavg-5  ldavg-15   blocked</span><br><span class=\"line\">16时00分33秒         0       127      0.00      0.00      0.00         0</span><br><span class=\"line\">16时00分34秒         0       127      0.00      0.00      0.00         0</span><br><span class=\"line\">16时00分35秒         0       127      0.00      0.00      0.00         0</span><br><span class=\"line\">平均时间:         0       127      0.00      0.00      0.00         0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 说明：</span></span><br><span class=\"line\">    runq-sz :运行队列的长度（等待运行的进程数）</span><br><span class=\"line\">    plist_sz :进程列表中进程（processes）和线程（threads）的数量</span><br><span class=\"line\">    Idavg-1 :最后1分钟的CPU平均负载，即将多核CPU过去一分钟的负载相加再除以核心数得出的平均值</span><br><span class=\"line\">    ldavg_5 :最后5分钟的CPU平均负载</span><br><span class=\"line\">    ldavg-15 :最后15分钟的CPU平均负载</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看以前的报告,保存在/var/log/sa/下的sar日志，保留最近30天的日志: 日志名称以sa开头，日期号结尾，如11号的日志为sa11</span></span><br><span class=\"line\">sar -q -f  /var/log/sa/sa11  | more</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>内存监控</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sar -r 1 3</span><br><span class=\"line\"></span><br><span class=\"line\">16时05分03秒 kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty</span><br><span class=\"line\">16时05分04秒     75000    837836     91.78     48728    649444    471312     51.63    180868    577236        36</span><br><span class=\"line\">16时05分05秒     75000    837836     91.78     48728    649444    471312     51.63    180868    577240        36</span><br><span class=\"line\">16时05分06秒     75000    837836     91.78     48728    649444    471312     51.63    180868    577240        36</span><br><span class=\"line\">平均时间:     75000    837836     91.78     48728    649444    471312     51.63    180868    577239        36</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 说明：</span></span><br><span class=\"line\">kbmemfree :这个值和free命令中的free值基本一致， 所以它不包括buffer和cache的空间。</span><br><span class=\"line\">kbmemused :这个值和free命令中的used值基本一致， 所以它包括buffer和cache的空间。</span><br><span class=\"line\">%memused :这个值是kbmemused和内存总量（不包括swap）的一个百分比。</span><br><span class=\"line\">kbbuffers和kbcached :这两个值就是free命令中的buffer和cache.</span><br><span class=\"line\">kbcommit :保证当前系统所需要的内存，即为了确保不溢出而需要的内存(RAM+swap)。</span><br><span class=\"line\">%commit :这个值是kbcommit与内存总量（包括swap）的一个百分比。（可以看做内存使用量的百分比）</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看以前的报告,保存在/var/log/sa/下的sar日志，保留最近30天的日志: 日志名称以sa开头，日期号结尾，如11号的日志为sa11</span></span><br><span class=\"line\">sar -r -f  /var/log/sa/sa11  | more</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>网络监控</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -n选项可以汇报网络相关信息，可用的值有很多，我们查询最多的就是 DEV（网卡信息）</span></span><br><span class=\"line\">$ sar -n DEV 1 2</span><br><span class=\"line\"></span><br><span class=\"line\">16时23分03秒     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s</span><br><span class=\"line\">16时23分04秒        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class=\"line\">16时23分04秒      eth0      2.00      0.00      0.13      0.00      0.00      0.00      0.00</span><br><span class=\"line\"></span><br><span class=\"line\">16时23分04秒     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s</span><br><span class=\"line\">16时23分05秒        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class=\"line\">16时23分05秒      eth0      3.00      3.00      0.19      0.32      0.00      0.00      0.00</span><br><span class=\"line\"></span><br><span class=\"line\">平均时间:     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s</span><br><span class=\"line\">平均时间:        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class=\"line\">平均时间:      eth0      2.50      1.50      0.16      0.16      0.00      0.00      0.00</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 说明：</span></span><br><span class=\"line\">    IFACE：就是网络设备的名称；</span><br><span class=\"line\">    rxpck/s：每秒钟接收到的包数目</span><br><span class=\"line\">    txpck/s：每秒钟发送出去的包数目</span><br><span class=\"line\">    rxbyt/s：每秒钟接收到的字节数</span><br><span class=\"line\">    txbyt/s：每秒钟发送出去的字节数</span><br><span class=\"line\">    rxcmp/s：每秒钟接收到的压缩包数目</span><br><span class=\"line\">    txcmp/s：每秒钟发送出去的压缩包数目</span><br><span class=\"line\">    txmcst/s：每秒钟接收到的多播包的包数目</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># -n 的值：</span></span><br><span class=\"line\">    1.DEV :网卡，主要查看这一项</span><br><span class=\"line\">    2.EDEV :网卡 (错误)</span><br><span class=\"line\">    3.NFS :NFS 客户端</span><br><span class=\"line\">    4.NFSD :NFS 服务器</span><br><span class=\"line\">    5.SOCK :Sockets (套接字) (v4)</span><br><span class=\"line\">    6.IP :IP 流 (v4)</span><br><span class=\"line\">    7.EIP :IP 流 (v4) (错误)</span><br><span class=\"line\">    8.ICMP :ICMP 流 (v4)</span><br><span class=\"line\">    9.EICMP :ICMP 流 (v4) (错误)</span><br><span class=\"line\">    10.TCP :TCP 流 (v4)</span><br><span class=\"line\">    11.ETCP :TCP 流 (v4) (错误)</span><br><span class=\"line\">    12.UDP :UDP 流 (v4)</span><br><span class=\"line\">    13.SOCK6 :Sockets (套接字) (v6)</span><br><span class=\"line\">    14.IP6 :IP 流 (v6)</span><br><span class=\"line\">    15.EIP6 :IP 流 (v6) (错误)</span><br><span class=\"line\">    16.ICMP6 :ICMP 流 (v6)</span><br><span class=\"line\">    17.EICMP6 :ICMP 流 (v6) (错误)</span><br><span class=\"line\">    18.UDP6 :UDP 流 (v6)</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>通过 <code>-o</code> 将监控信息输出到文件，然后通过 <code>-f</code> 查看</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sar -u 1 3 -o sar.txt</span><br><span class=\"line\">$ sar -f sar.txt</span><br></pre></td></tr></table></figure>\n","content_text":"摘要 本文介绍Linux查看系统硬件信息及其监控等相关命令 本文基于CentOS8(x86_64) uname :查看系统版本信息 1$ uname -a 查看网卡和路由信息 1234# 网卡$ ifconfig# 路由$ route 查看cpu信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253$ cat /proc/cpuinfoprocessor : 0vendor_id : GenuineIntelcpu family : 6model : 85model name : Intel(R) Xeon(R) Platinum 8269CY CPU @ 2.50GHzstepping : 7microcode : 0x1cpu MHz : 2499.998cache size : 36608 KBphysical id : 0siblings : 2core id : 0cpu cores : 1apicid : 0initial apicid : 0fpu : yesfpu_exception : yescpuid level : 22wp : yesflags : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc rep_good nopl xtopology nonstop_tsc cpuid tsc_known_freq pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch invpcid_single pti fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 erms invpcid rtm mpx avx512f avx512dq rdseed adx smap clflushopt clwb avx512cd avx512bw avx512vl xsaveopt xsavec xgetbv1 xsaves arat avx512_vnnibugs : cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs taa itlb_multihitbogomips : 4999.99clflush size : 64cache_alignment : 64address sizes : 46 bits physical, 48 bits virtualpower management:# 解释如下：processor：系统中逻辑处理核心的数量。对于单核处理器，该类将其视为 CPU 编号，对于多核处理器，它可以是物理内核，也可以是使用超线程技术的虚拟逻辑内核。（processor内核内部使用的对象，不一定绑定到物理设备，它们可能都具有相同的 physical id）vendor_id：CPU制造商。cpu family：CPU 产品系列代号。mode：cpu属于其系列中的哪一代。model name：CPU的名称及其编号，标称频率。stepping：CPU属于生产更新版本。cpu MHz：实际CPU频率。cache size：CPU二级缓存的大小。physical id：单个物理CPU标号。siblings：单个物理 CPU 的逻辑 CPU 数量。siblings = cpu 核心 * [2]。core id：当前所在CPU中的物理内核id。cpu cores：逻辑核所在CPU的物理核数。比如这里有2个cpu core，对应的core id是0、1。apicid：用于区分不同逻辑核心的编号。系统中每个逻辑核的编号必须不同，编号不一定是连续的。fpu：是否有浮点单元。（Floating Point Unit）fpu_exception：是否支持浮点计算异常。cpuid level：在执行cpuid指令之前，eax寄存器中的值会根据不同的值返回不同的内容。wp：表示当前CPU是否支持内核态用户空间写保护。（Write Protection）flags：当前CPU支持的功能，例如浮点单元 (FPU) 的存在和处理 MMX 指令的能力。。bogomips：粗略测量的 CPU 速度（每秒百万条指令）。clflush size：每个flush缓存的大小单位。cache_alignment：缓存地址对齐单元。address sizes：可访问地址空间的数量。power management：支持电源管理。 小贴士 /proc：目录中存放进程PID命名的目录以及系统相关信息文件，如： cpuinfo :cup信息 meminfo :内存信息 partitions :硬盘分区 uptime :查看系统运行时间和cpu负载 12345678$ uptime 14:12:52 up 2 days, 20:41, 1 user, load average: 0.06, 0.03, 0.01# 说明： 14:12:52 当前时间 up 2 days, 20:41 系统运行了多久 1 user 当前登录用户数 load average: 0.06, 0.03, 0.01 系统负载，即任务队列的平均长度。三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。 w :查看系统运行时间和cpu负载以及当前用户登录信息 1234$ w 17:35:25 up 3 days, 3 min, 1 user, load average: 0.00, 0.00, 0.00USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATroot pts/0 1.120.160.30 13:58 0.00s 0.12s 0.12s -bash free :查看内存信息 12345678910111213141516171819202122# 显示内存使用情况，默认单位k$ free total used free shared buff/cache availableMem: 912836 100016 72608 460 740212 667376Swap: 0 0 0# 说明： total :物理内存总量 used :已经使用的物理内存总量 free :空闲内存总量 shared :是多个进程共享的内存总数； buff/cache :用作内核缓存的内存量选项 含义-b 以 Byte（字节）为单位，显示内存使用情况。-k 以 KB 为单位，显示内存使用情况，此选项是 free 命令的默认选项。-m 以 MB 为单位，显示内存使用情况。-g 以 GB 为单位，显示内存使用情况。-t 在输出的最终结果中，输出内存和 swap 分区的总量。-o 不显示系统缓冲区这一列。-s 间隔秒数 根据指定的间隔时间，持续显示内存使用情况。 df :查看硬盘信息 12345678$ df -hT文件系统 类型 容量 已用 可用 已用% 挂载点devtmpfs devtmpfs 436M 0 436M 0% /devtmpfs tmpfs 446M 0 446M 0% /dev/shmtmpfs tmpfs 446M 456K 446M 1% /runtmpfs tmpfs 446M 0 446M 0% /sys/fs/cgroup/dev/vda1 ext4 20G 14G 5.3G 72% /tmpfs tmpfs 90M 0 90M 0% /run/user/0 top :动态显示进程状态 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117# 动态显示进程状态，默认每3秒刷新一次$ toptop - 14:08:03 up 2 days, 20:36, 1 user, load average: 0.06, 0.03, 0.01Tasks: 87 total, 1 running, 47 sleeping, 0 stopped, 0 zombie%Cpu(s): 0.1 us, 0.0 sy, 0.0 ni, 99.9 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 stKiB Mem : 912836 total, 65564 free, 99648 used, 747624 buff/cacheKiB Swap: 0 total, 0 free, 0 used. 667600 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 558 root 20 0 17832 1772 1288 S 0.1 0.2 0:45.25 assist_daemon 585 root 20 0 813912 10888 5104 S 0.1 1.2 3:51.47 aliyun-service 587 root 20 0 733348 9636 4604 S 0.1 1.1 0:11.96 rsyslogd 1 root 20 0 51640 4432 3156 S 0.0 0.5 0:33.44 systemd# 说明： 第一行为任务队列信息，同 uptime 第二行为进程信息: total :进程总数 running :正在运行的进程数 sleeping :睡眠的进程数 stopped :停止的进程数 zombie :僵尸进程数 第三行为CPU信息: 0.1 us :用户空间占用CPU百分比 0.0 sy :内核空间占用CPU百分比 0.0 ni :用户进程空间内改变过优先级的进程占用CPU百分比 99.9 id :空闲CPU百分比 0.0 wa :等待输入输出的CPU时间百分比，通过查看 CPU 的 wa% 值来判断当前磁盘 IO 性能，如果这个数值过大，很可能是磁盘 IO 太高了，当然也可能是其他原因，例如网络 IO 过高等。 0.0 hi :硬件CPU中断占用百分比 0.0 si :软中断占用百分比 0.0 st :虚拟机占用百分比 第四行和第五行为内存信息: Mem: 912836 total 物理内存总量 65564 free 空闲内存总量 99648 used 使用的物理内存总量 747624 buff/cache 用作内核缓存的内存量 Swap: 0 total 交换区总量 0 free 空闲交换区总量 0 used 使用的交换区总量 667600 avail Mem 缓冲的交换区总量,内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖，该数值即为这些内容已存在于内存中的交换区的大小,相应的内存再次被换出时可不必再对交换区写入。 之后是进程信息区：默认情况下仅显示比较重要的 PID、USER、PR、NI、VIRT、RES、SHR、S、%CPU、%MEM、TIME+、COMMAND 列。 运行top后按f会查看到全部的展示项，这里只对部分展示项进行说明 序号 列名 含义 a PID 进程id b PPID 父进程id c RUSER Real user name d UID 进程所有者的用户id e USER 进程所有者的用户名 f GROUP 进程所有者的组名 g TTY 启动进程的终端名。不是从终端启动的进程则显示为 ? h PR 优先级。默认20。这个优先级对应实时进程，只使用1-99号优先级队列，序号越大优先级越高，0号留给普通进程使用 i NI nice值。默认0。负值表示高优先级，正值表示低优先级 j P 最后使用的CPU，仅在多CPU环境下有意义 k %CPU 上次更新到现在的CPU时间占用百分比 l TIME 进程使用的CPU时间总计，单位精确到秒， 3:51 表示 3分51秒 m TIME+ 进程使用的CPU时间总计，单位精确到1/100秒，3:51.47 表示 3分51秒多 n %MEM 进程使用的物理内存百分比 o VIRT 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES p SWAP 进程使用的虚拟内存中，被换出的大小，单位kb。 q RES 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA r CODE 可执行代码占用的物理内存大小，单位kb s DATA 可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb t SHR 共享内存大小，单位kb u nFLT 页面错误次数 v nDRT 最后一次写入到现在，被修改过的页面数。 w S 进程状态(D=不可中断的睡眠状态,I=空闲内核线程,R=运行,S=睡眠,T=因作业控制信号而停止,Z=僵尸进程) x COMMAND 命令名/命令行 y WCHAN 若该进程在睡眠，则显示睡眠中的系统函数名 z Flags 任务标志，参考 sched.h 0 PGRP 进程组id# 交互命令：运行top后，可以键入如下指令与top进行交互 h :获得帮助 q :退出程序。 d :指定刷新时间 m :切换内存信息显示效果 t :切换显示进程和CPU状态信息。 c :切换显示命令名称和完整命令行。 u :查看指定用户的进程 k :终止执行中的进程 pid，系统将提示用户输入需要终止的进程PID，以及需要发送给该进程什么样的信号。一般的终止进程可以使用15信号；如果不能正常结束那就使用信号9强制结束该进程。默认值是信号15。在安全模式中此命令被屏蔽。 r :重新设置进程优先级 n pid，系统提示用户输入需要改变的进程PID以及需要设置的进程优先级值。输入一个正值将使优先级降低，反之则可以使该进程拥有更高的优先权。默认值是10。 翻页: Shift + &lt; :上翻 Shift + &gt; :下翻 Ctrl+L 擦除并且重写屏幕。 i :忽略闲置和僵死进程。这是一个开关式命令。 l :切换显示平均负载和启动时间信息。 M :根据驻留内存大小进行排序。 P :根据CPU使用百分比大小进行排序。 T :根据时间/累计时间进行排序。 W :将当前设置写入~/.toprc文件中。这是写top配置文件的推荐方法。 f :从当前显示中添加或者删除项目。按d添加或删除，esc返回。此时也可以调整每一列的显示顺序，按右键会将当前项全选，然后上下调整位置后按回车即可。默认情况下仅显示比较重要的 PID、USER、PR、NI、VIRT、RES、SHR、S、%CPU、%MEM、TIME+、COMMAND 列 o :过滤指定的内容，如过滤用户则输入：USER=username，匹配时采用模糊匹配，多次输入o会在当前过滤基础上增加新的过滤条件，q退出 S :切换到累计模式。# top使用格式top [-] [d] [p] [q] [c] [C] [S] [s]#参数说明 d 指定每两次屏幕信息刷新之间的时间间隔。当然用户可以使用s交互命令来改变之。 p 通过指定监控进程ID来仅仅监控某个进程的状态。 S 指定累计模式 s 使top命令在安全模式中运行。这将去除交互命令所带来的潜在危险。 i 使top不显示任何闲置或者僵死进程。 c 显示整个命令行而不只是显示命令名# 示例top //每隔5秒显式所有进程的资源占用情况top -d 2 //每隔2秒显式所有进程的资源占用情况top -c //每隔5秒显式进程的资源占用情况，并显示进程的命令行参数(默认只有进程名)top -p 12345 -p 6789//每隔5秒显示pid是12345和pid是6789的两个进程的资源占用情况top -d 2 -c -p 123456 //每隔2秒显示pid是12345的进程的资源使用情况，并显式该进程启动的命令行参数top -p进程1的ID -p进程2的id -p进程3的id …… //查看某几个进程的状态 sar :查看 CPU 、内存、磁盘、网络等性能指标 sar 命令是分析系统瓶颈的神器，可以用来查看 CPU 、内存、磁盘、网络等性能。 查看磁盘性能 1234567891011121314151617181920212223242526272829303132333435363738394041424344# 查看当前磁盘性能，-d参数代表查看磁盘性能，-p参数代表将 dev 设备按照 sda，sdb……名称显示，1是间隔1秒，2是采集2次$ sar -d -p 1 207时35分57秒 DEV tps rd_sec/s wr_sec/s avgrq-sz avgqu-sz await svctm %util07时35分58秒 xvda 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.0007时35分58秒 DEV tps rd_sec/s wr_sec/s avgrq-sz avgqu-sz await svctm %util07时35分59秒 xvda 12.00 0.00 155.00 12.92 0.01 0.67 1.67 2.00平均时间: DEV tps rd_sec/s wr_sec/s avgrq-sz avgqu-sz await svctm %util平均时间: xvda 6.00 0.00 77.50 12.92 0.00 0.67 1.67 1.00# 说明： tps :每秒从物理磁盘I/O的次数.多个逻辑请求会被合并为一个I/O磁盘请求， 一次传输的大小是不确定的. rd_sec/s :每秒读扇区的次数. wr_sec/s :每秒写扇区的次数. avgrq-sz :平均每次设备I/O操作的数据大小（扇区）. avgqu-sz :磁盘请求队列的平均长度. await :从请求磁盘操作到 系统完成处理，每次请求的平均消耗时间 包括请求队列等待时间，单位是毫秒（1秒=1000毫秒）. svctm :系统处理每次请求的平均时间 不包括在请求队列中消耗的时间. %util :I/O请求占CPU的百分比，比率越大，说明越饱和. avgqu-sz 的值较低时，设备的利用率较高 %util I/O请求占用的CPU百分比，值越高，说明I/O越慢。 对于磁盘 IO 性能，一般有如下评判标准： 正常情况下 svctm 应该是小于 await 值的，而 svctm 的大小和磁盘性能有关，CPU 、内存的负荷也会对 svctm 值造成影响，过多的请求也会间接的导致 svctm 值的增加。 await 值的大小一般取决与 svctm 的值和 I/O 队列长度以 及I/O 请求模式，如果 svctm 的值与 await 很接近，表示几乎没有 I/O 等待，磁盘性能很好，如果 await 的值远高于 svctm 的值，则表示 I/O 队列等待太长，系统上运行的应用程序将变慢，此时可以通过更换更快的硬盘来解决问题。 %util 项的值也是衡量磁盘 I/O 的一个重要指标，如果 %util 接近 100% ，表示磁盘产生的 I/O 请求太多，I/O 系统已经满负荷的在工作，该磁盘可能存在瓶颈。长期下去，势必影响系统的性能，可以通过优化程序或者通过更换更高、更快的磁盘来解决此问题。# 如果想继续查看以前的报告；可以查看保存在/var/log/sa/下的sar日志，保留最近30天的日志: 日志名称以sa开头，日期号结尾，如11号的日志为sa11$ sar -d -p -f /var/log/sa/sa11 | more00时00分01秒 DEV tps rd_sec/s wr_sec/s avgrq-sz avgqu-sz await svctm %util00时10分01秒 xvda 10.67 0.13 190.20 17.84 0.12 11.08 3.33 3.5500时20分01秒 xvda 11.40 0.08 234.10 20.54 0.07 6.07 3.26 3.7200时30分01秒 xvda 11.05 0.19 200.59 18.17 0.03 2.82 2.51 2.7700时40分01秒 xvda 10.78 0.00 225.89 20.96 0.14 12.59 4.64 5.0000时50分01秒 xvda 10.53 0.00 183.95 17.47 0.04 4.16 3.04 3.2001时00分01秒 xvda 10.58 0.00 187.13 17.68 0.12 11.18 4.52 4.7801时10分01秒 xvda 10.74 0.00 187.12 17.42 0.09 8.20 4.76 5.1101时20分01秒 xvda 11.52 0.05 212.70 18.47 0.06 4.83 2.52 2.9001时30分01秒 xvda 10.69 0.05 191.77 17.94 0.04 3.43 2.65 2.83 查看cpu使用率指标 123456789101112131415161718192021222324252627282930313233343536# 查看当前的cpu指标，-u指cpu使用率，默认就是-u，1是间隔1秒，3是采集3次$ sar -u 1 315时48分53秒 CPU %user %nice %system %iowait %steal %idle15时48分54秒 all 0.50 0.00 0.50 0.00 0.00 99.0015时48分55秒 all 0.00 0.00 0.00 0.00 0.00 100.0015时48分56秒 all 0.00 0.00 0.00 0.00 0.00 100.00平均时间: all 0.17 0.00 0.17 0.00 0.00 99.67# 查看全天的cpu指标$ sar -u -p00时00分01秒 CPU %user %nice %system %iowait %steal %idle00时10分01秒 all 0.08 0.00 0.08 0.00 0.00 99.8400时20分01秒 all 0.08 0.00 0.07 0.00 0.00 99.8500时30分01秒 all 0.07 0.00 0.08 0.00 0.00 99.8400时40分01秒 all 0.15 0.00 0.08 0.00 0.00 99.7800时50分01秒 all 0.07 0.00 0.07 0.00 0.00 99.8501时00分01秒 all 0.07 0.00 0.08 0.00 0.00 99.8501时10分01秒 all 0.67 0.00 0.12 0.01 0.00 99.20# 说明： CPU :all表示统计所有CPU的平均值 %user :显示在用户级别（application）运行使用 CPU 总时间的百分比 %nice :改变过优先级的进程的CPU使用率 %system :内核空间的CPU使用率， 在核心级别（kernel）运行所使用CPU总时间的百分比 %iowait :显示用于等待I/O操作占用CPU总时间的百分比 %steal :管理程序（hypervisor）为另一个虚拟进程提供服务而等待虚拟CPU的百分比 %idle :显示 CPU空闲时间占用CPU总时间的百分比# 主要监控如下两项： %iowait 过高表示存在I/O瓶颈，即磁盘IO无法满足业务需求 %idle 过低表示CPU使用比较严重，需要结合内存使用等情况判断CPU是否瓶颈。# 查看以前的报告,保存在/var/log/sa/下的sar日志，保留最近30天的日志: 日志名称以sa开头，日期号结尾，如11号的日志为sa11sar -u -f /var/log/sa/sa11 | more 查看cpu负载指标 123456789101112131415161718# 查看当前的cpu的负载指标，-q指cpu负载，1是间隔1秒，3是采集3次$ sar -q 1 316时00分32秒 runq-sz plist-sz ldavg-1 ldavg-5 ldavg-15 blocked16时00分33秒 0 127 0.00 0.00 0.00 016时00分34秒 0 127 0.00 0.00 0.00 016时00分35秒 0 127 0.00 0.00 0.00 0平均时间: 0 127 0.00 0.00 0.00 0# 说明： runq-sz :运行队列的长度（等待运行的进程数） plist_sz :进程列表中进程（processes）和线程（threads）的数量 Idavg-1 :最后1分钟的CPU平均负载，即将多核CPU过去一分钟的负载相加再除以核心数得出的平均值 ldavg_5 :最后5分钟的CPU平均负载 ldavg-15 :最后15分钟的CPU平均负载# 查看以前的报告,保存在/var/log/sa/下的sar日志，保留最近30天的日志: 日志名称以sa开头，日期号结尾，如11号的日志为sa11sar -q -f /var/log/sa/sa11 | more 内存监控 123456789101112131415161718$ sar -r 1 316时05分03秒 kbmemfree kbmemused %memused kbbuffers kbcached kbcommit %commit kbactive kbinact kbdirty16时05分04秒 75000 837836 91.78 48728 649444 471312 51.63 180868 577236 3616时05分05秒 75000 837836 91.78 48728 649444 471312 51.63 180868 577240 3616时05分06秒 75000 837836 91.78 48728 649444 471312 51.63 180868 577240 36平均时间: 75000 837836 91.78 48728 649444 471312 51.63 180868 577239 36# 说明：kbmemfree :这个值和free命令中的free值基本一致， 所以它不包括buffer和cache的空间。kbmemused :这个值和free命令中的used值基本一致， 所以它包括buffer和cache的空间。%memused :这个值是kbmemused和内存总量（不包括swap）的一个百分比。kbbuffers和kbcached :这两个值就是free命令中的buffer和cache.kbcommit :保证当前系统所需要的内存，即为了确保不溢出而需要的内存(RAM+swap)。%commit :这个值是kbcommit与内存总量（包括swap）的一个百分比。（可以看做内存使用量的百分比）# 查看以前的报告,保存在/var/log/sa/下的sar日志，保留最近30天的日志: 日志名称以sa开头，日期号结尾，如11号的日志为sa11sar -r -f /var/log/sa/sa11 | more 网络监控 1234567891011121314151617181920212223242526272829303132333435363738394041424344# -n选项可以汇报网络相关信息，可用的值有很多，我们查询最多的就是 DEV（网卡信息）$ sar -n DEV 1 216时23分03秒 IFACE rxpck/s txpck/s rxkB/s txkB/s rxcmp/s txcmp/s rxmcst/s16时23分04秒 lo 0.00 0.00 0.00 0.00 0.00 0.00 0.0016时23分04秒 eth0 2.00 0.00 0.13 0.00 0.00 0.00 0.0016时23分04秒 IFACE rxpck/s txpck/s rxkB/s txkB/s rxcmp/s txcmp/s rxmcst/s16时23分05秒 lo 0.00 0.00 0.00 0.00 0.00 0.00 0.0016时23分05秒 eth0 3.00 3.00 0.19 0.32 0.00 0.00 0.00平均时间: IFACE rxpck/s txpck/s rxkB/s txkB/s rxcmp/s txcmp/s rxmcst/s平均时间: lo 0.00 0.00 0.00 0.00 0.00 0.00 0.00平均时间: eth0 2.50 1.50 0.16 0.16 0.00 0.00 0.00# 说明： IFACE：就是网络设备的名称； rxpck/s：每秒钟接收到的包数目 txpck/s：每秒钟发送出去的包数目 rxbyt/s：每秒钟接收到的字节数 txbyt/s：每秒钟发送出去的字节数 rxcmp/s：每秒钟接收到的压缩包数目 txcmp/s：每秒钟发送出去的压缩包数目 txmcst/s：每秒钟接收到的多播包的包数目# -n 的值： 1.DEV :网卡，主要查看这一项 2.EDEV :网卡 (错误) 3.NFS :NFS 客户端 4.NFSD :NFS 服务器 5.SOCK :Sockets (套接字) (v4) 6.IP :IP 流 (v4) 7.EIP :IP 流 (v4) (错误) 8.ICMP :ICMP 流 (v4) 9.EICMP :ICMP 流 (v4) (错误) 10.TCP :TCP 流 (v4) 11.ETCP :TCP 流 (v4) (错误) 12.UDP :UDP 流 (v4) 13.SOCK6 :Sockets (套接字) (v6) 14.IP6 :IP 流 (v6) 15.EIP6 :IP 流 (v6) (错误) 16.ICMP6 :ICMP 流 (v6) 17.EICMP6 :ICMP 流 (v6) (错误) 18.UDP6 :UDP 流 (v6) 通过 -o 将监控信息输出到文件，然后通过 -f 查看 12$ sar -u 1 3 -o sar.txt$ sar -f sar.txt","summary":"摘要 本文介绍Linux查看系统硬件信息及其监控等相关命令 本文基于CentOS8(x86_64)","date_published":"2023-03-27T13:45:05.000Z","tags":["技术","linux","linux常用命令","linux常用命令"]},{"id":"https://blog.hanqunfeng.com/2023/03/21/linux-command09-makeinstall-nginx/","url":"https://blog.hanqunfeng.com/2023/03/21/linux-command09-makeinstall-nginx/","title":"Linux常用命令--源代码安装nginx","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度 ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>虽然绝大部分软件都可以通过<code>rpm</code>或者<code>yum</code>的方式进行安装，但是由于yum中的版本不一定是最新版，或者软件开发商没有将软件放到yum源中，所有也有一些软件需要通过源代码的方式进行安装。</p>\n</li>\n<li class=\"lvl-2\">\n<p>本文以源代码安装nginx为例说明如何通过源代码安装软件。</p>\n</li>\n<li class=\"lvl-2\">\n<p>本文基于<code>CentOS8(x86_64)</code></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"安装nginx\">安装nginx</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装nginx最小依赖</span></span><br><span class=\"line\">yum install gcc zlib zlib-devel pcre-devel openssl openssl-devel</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果通过yum安装nginx，只需要执行如下命令</span></span><br><span class=\"line\">yum install nginx -y <span class=\"comment\"># 本文不通过yum安装</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下载nginx最新稳定版</span></span><br><span class=\"line\">wget https://nginx.org/download/nginx-1.22.1.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 解压</span></span><br><span class=\"line\">tar -zxvf nginx-1.22.1.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 进入解压后的目录</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> nginx-1.22.1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查配置并指定安装参数</span></span><br><span class=\"line\">./configure --with-http_stub_status_module --with-http_ssl_module</span><br><span class=\"line\">    <span class=\"comment\"># 参数说明</span></span><br><span class=\"line\">    --with-http_ssl_module :安装ssl模块</span><br><span class=\"line\">    --with-http_stub_status_module :查看nginx的客户端状态模块</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 输出内容，所有文件的默认路径</span></span><br><span class=\"line\">    Configuration summary</span><br><span class=\"line\">    + using system PCRE library</span><br><span class=\"line\">    + using system OpenSSL library</span><br><span class=\"line\">    + using system zlib library</span><br><span class=\"line\"></span><br><span class=\"line\">    nginx path prefix: <span class=\"string\">&quot;/usr/local/nginx&quot;</span></span><br><span class=\"line\">    nginx binary file: <span class=\"string\">&quot;/usr/local/nginx/sbin/nginx&quot;</span></span><br><span class=\"line\">    nginx modules path: <span class=\"string\">&quot;/usr/local/nginx/modules&quot;</span></span><br><span class=\"line\">    nginx configuration prefix: <span class=\"string\">&quot;/usr/local/nginx/conf&quot;</span></span><br><span class=\"line\">    nginx configuration file: <span class=\"string\">&quot;/usr/local/nginx/conf/nginx.conf&quot;</span></span><br><span class=\"line\">    nginx pid file: <span class=\"string\">&quot;/usr/local/nginx/logs/nginx.pid&quot;</span></span><br><span class=\"line\">    nginx error <span class=\"built_in\">log</span> file: <span class=\"string\">&quot;/usr/local/nginx/logs/error.log&quot;</span></span><br><span class=\"line\">    nginx http access <span class=\"built_in\">log</span> file: <span class=\"string\">&quot;/usr/local/nginx/logs/access.log&quot;</span></span><br><span class=\"line\">    nginx http client request body temporary files: <span class=\"string\">&quot;client_body_temp&quot;</span></span><br><span class=\"line\">    nginx http proxy temporary files: <span class=\"string\">&quot;proxy_temp&quot;</span></span><br><span class=\"line\">    nginx http fastcgi temporary files: <span class=\"string\">&quot;fastcgi_temp&quot;</span></span><br><span class=\"line\">    nginx http uwsgi temporary files: <span class=\"string\">&quot;uwsgi_temp&quot;</span></span><br><span class=\"line\">    nginx http scgi temporary files: <span class=\"string\">&quot;scgi_temp&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 也可以自定义安装路径</span></span><br><span class=\"line\">./configure --prefix=/usr/local/nginx-1.22.1 --with-http_stub_status_module --with-http_ssl_module</span><br><span class=\"line\">    <span class=\"comment\"># 参数说明</span></span><br><span class=\"line\">    --prefix=/usr/local/nginx-1.22.1 :安装路径</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#输出内容，此时看到所有文件都会被安装到指定的路径</span></span><br><span class=\"line\">    Configuration summary</span><br><span class=\"line\">    + using system PCRE library</span><br><span class=\"line\">    + using system OpenSSL library</span><br><span class=\"line\">    + using system zlib library</span><br><span class=\"line\"></span><br><span class=\"line\">    nginx path prefix: <span class=\"string\">&quot;/usr/local/nginx-1.22.1&quot;</span></span><br><span class=\"line\">    nginx binary file: <span class=\"string\">&quot;/usr/local/nginx-1.22.1/sbin/nginx&quot;</span></span><br><span class=\"line\">    nginx modules path: <span class=\"string\">&quot;/usr/local/nginx-1.22.1/modules&quot;</span></span><br><span class=\"line\">    nginx configuration prefix: <span class=\"string\">&quot;/usr/local/nginx-1.22.1/conf&quot;</span></span><br><span class=\"line\">    nginx configuration file: <span class=\"string\">&quot;/usr/local/nginx-1.22.1/conf/nginx.conf&quot;</span></span><br><span class=\"line\">    nginx pid file: <span class=\"string\">&quot;/usr/local/nginx-1.22.1/logs/nginx.pid&quot;</span></span><br><span class=\"line\">    nginx error <span class=\"built_in\">log</span> file: <span class=\"string\">&quot;/usr/local/nginx-1.22.1/logs/error.log&quot;</span></span><br><span class=\"line\">    nginx http access <span class=\"built_in\">log</span> file: <span class=\"string\">&quot;/usr/local/nginx-1.22.1/logs/access.log&quot;</span></span><br><span class=\"line\">    nginx http client request body temporary files: <span class=\"string\">&quot;client_body_temp&quot;</span></span><br><span class=\"line\">    nginx http proxy temporary files: <span class=\"string\">&quot;proxy_temp&quot;</span></span><br><span class=\"line\">    nginx http fastcgi temporary files: <span class=\"string\">&quot;fastcgi_temp&quot;</span></span><br><span class=\"line\">    nginx http uwsgi temporary files: <span class=\"string\">&quot;uwsgi_temp&quot;</span></span><br><span class=\"line\">    nginx http scgi temporary files: <span class=\"string\">&quot;scgi_temp&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 编译</span></span><br><span class=\"line\">make</span><br><span class=\"line\"><span class=\"comment\"># 将相关文件拷贝到 --prefix 指定的安装目录中</span></span><br><span class=\"line\">make install</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置和管理nginx\">配置和管理nginx</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>上面就完成了nginx安装，之后我们可以根据需要对配置文件进行修改，并启动nginx</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 假设我们将nginx安装到了自定义安装路径/usr/local/nginx-1.22.1下</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /usr/local/nginx-1.22.1</span><br><span class=\"line\"><span class=\"built_in\">ls</span> -1</span><br><span class=\"line\">conf :nginx配置文件目录</span><br><span class=\"line\">html :默认web根目录</span><br><span class=\"line\">logs :默认日志输出目录</span><br><span class=\"line\">sbin :启动命令nginx所在目录，make后真正有用的就这个nginx命令，重新编译就是为了重新生成新的nginx命令</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将nginx命令软连接到系统命令路径下，因为/usr/bin/已经被加入到PATH中了</span></span><br><span class=\"line\"><span class=\"built_in\">ln</span> -s /usr/local/nginx-1.22.1/sbin/nginx /usr/bin/</span><br><span class=\"line\"><span class=\"comment\"># 查看nginx版本，测试nginx命令是否全局可用</span></span><br><span class=\"line\">nginx -v</span><br><span class=\"line\">nginx version: nginx/1.22.1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建nginx用户和组</span></span><br><span class=\"line\">$ groupadd nginx</span><br><span class=\"line\">$ useradd -g nginx nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 修改配置文件</span></span><br><span class=\"line\">vim /usr/local/nginx-1.22.1/conf/nginx.conf</span><br><span class=\"line\">    <span class=\"comment\"># 为了方便演示，这里仅仅修改如下两项内容</span></span><br><span class=\"line\">    <span class=\"comment\"># worker用户，这里配置为我们上面创建的nginx用户和nginx组</span></span><br><span class=\"line\">    user  nginx nginx;</span><br><span class=\"line\">    <span class=\"comment\"># 启动2个worker进程</span></span><br><span class=\"line\">    worker_processes  2;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查配置文件是否正确</span></span><br><span class=\"line\">nginx -t</span><br><span class=\"line\">nginx: the configuration file /usr/local/nginx-1.22.1/conf/nginx.conf syntax is ok</span><br><span class=\"line\">nginx: configuration file /usr/local/nginx-1.22.1/conf/nginx.conf <span class=\"built_in\">test</span> is successful</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果配置文件被修改了，可以通过该命令重新加载新的配置，而不需要重新启动nginx</span></span><br><span class=\"line\">nginx -s reload</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动nginx</span></span><br><span class=\"line\"><span class=\"comment\"># 会使用默认的配置文件</span></span><br><span class=\"line\">nginx</span><br><span class=\"line\"><span class=\"comment\"># 启动时指定配置文件</span></span><br><span class=\"line\">nginx -c /usr/local/nginx-1.22.1/conf/nginx.conf</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看进程</span></span><br><span class=\"line\">ps -ef | grep nginx</span><br><span class=\"line\">root     18538     1  0 11:11 ?        00:00:00 nginx: master process nginx</span><br><span class=\"line\">nginx    18592 18538  0 11:22 ?        00:00:00 nginx: worker process</span><br><span class=\"line\">nginx    18593 18538  0 11:22 ?        00:00:00 nginx: worker process</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看端口</span></span><br><span class=\"line\">netstat -tunpl | grep nginx</span><br><span class=\"line\">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      18538/nginx: master</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 立即停止nginx</span></span><br><span class=\"line\">nginx -s stop</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从容停止nginx</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> -QUIT `<span class=\"built_in\">cat</span> /usr/local/nginx-1.22.1/logs/nginx.pid`</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 立即重启nginx</span></span><br><span class=\"line\">nginx -s stop</span><br><span class=\"line\">nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 平滑重启nginx</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> -HUP `<span class=\"built_in\">cat</span> /usr/local/nginx-1.22.1/logs/nginx.pid` <span class=\"comment\"># 只会重启worker进程</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"为nginx添加新的模块\">为nginx添加新的模块</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>nginx安装成功后，发现有一些其他模块没有编译进去，或者想额外添加一些模块，这时候就要重新编译nginx。</p>\n</li>\n<li class=\"lvl-2\">\n<p>重新编译之前，需要查看之前安装时的参数</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ nginx -V</span><br><span class=\"line\">nginx version: nginx/1.22.1</span><br><span class=\"line\">built by gcc 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC)</span><br><span class=\"line\">built with OpenSSL 1.0.2k-fips  26 Jan 2017</span><br><span class=\"line\">TLS SNI support enabled</span><br><span class=\"line\">configure arguments: --prefix=/usr/local/nginx-1.22.1 --with-http_stub_status_module --with-http_ssl_module</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>configure arguments</code>中就是之前编译安装时配置的参数</p>\n</li>\n<li class=\"lvl-2\">\n<p>如添加新的模块<code>http_gzip_static_module</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 进入nginx源码目录</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /usr/local/soft/nginx-1.22.1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查配置并指定安装参数，使用上面得到的上一次安装的参数，还要将新的模块也加上</span></span><br><span class=\"line\">./configure --prefix=/usr/local/nginx-1.22.1 --with-http_stub_status_module --with-http_ssl_module --with-http_gzip_static_module</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 编译，注意不要执行 make install，因为我们只需要得到nginx命令，运行make install会覆盖之前的所有目录</span></span><br><span class=\"line\">make</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 先备份原先的nginx命令</span></span><br><span class=\"line\"><span class=\"built_in\">cp</span> /usr/local/nginx-1.22.1/sbin/nginx /usr/local/nginx-1.22.1/sbin/nginx.bak</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将新生成的nginx命令复制到安装目录中</span></span><br><span class=\"line\"><span class=\"built_in\">cp</span> ./objs/nginx /usr/local/nginx-1.22.1/sbin/nginx</span><br><span class=\"line\"><span class=\"comment\"># 此时如果遇到提示 cp: 无法创建普通文件&quot;/usr/local/nginx-1.22.1/sbin/nginx&quot;: 文本文件忙 , 可以通过如下命令进行复制</span></span><br><span class=\"line\"><span class=\"built_in\">cp</span> -rfp ./objs/nginx /usr/local/nginx-1.22.1/sbin/nginx</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重启nginx</span></span><br><span class=\"line\">nginx -s stop</span><br><span class=\"line\">nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 平滑重启nginx(没好使)</span></span><br><span class=\"line\">make upgrade</span><br><span class=\"line\">    <span class=\"comment\"># 会执行Makefile下的如下命令，也可以手工按如下命令进行平滑重启</span></span><br><span class=\"line\">    upgrade:</span><br><span class=\"line\">\t/usr/local/nginx-1.22.1/sbin/nginx -t</span><br><span class=\"line\">    <span class=\"comment\"># 原因是执行如下命令没有创建新的master进程</span></span><br><span class=\"line\">\t<span class=\"built_in\">kill</span> -USR2 `<span class=\"built_in\">cat</span> /usr/local/nginx-1.22.1/logs/nginx.pid`</span><br><span class=\"line\">\t<span class=\"built_in\">sleep</span> 1</span><br><span class=\"line\">\t<span class=\"built_in\">test</span> -f /usr/local/nginx-1.22.1/logs/nginx.pid.oldbin</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">kill</span> -QUIT `<span class=\"built_in\">cat</span> /usr/local/nginx-1.22.1/logs/nginx.pid.oldbin`</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看是否是新的nginx</span></span><br><span class=\"line\">nginx -V</span><br><span class=\"line\">nginx version: nginx/1.22.1</span><br><span class=\"line\">built by gcc 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC)</span><br><span class=\"line\">built with OpenSSL 1.0.2k-fips  26 Jan 2017</span><br><span class=\"line\">TLS SNI support enabled</span><br><span class=\"line\">configure arguments: --prefix=/usr/local/nginx-1.22.1 --with-http_stub_status_module --with-http_ssl_module --with-http_gzip_static_module</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>安装第三方模块，<code>configure</code>中需要添加<code>--add-module=module_dir</code>，具体查看第三方模块官网说明即可</p>\n</li>\n</ul>\n<h2 id=\"nginx编译时可以添加哪些参数\">nginx编译时可以添加哪些参数</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>以下是通过<code>yum</code>安装nginx时的编译参数</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 指定nginx安装路径，至少web根目录在该路径下</span></span><br><span class=\"line\">--prefix=/usr/share/nginx</span><br><span class=\"line\"><span class=\"comment\"># 指定nginx命令安装路径</span></span><br><span class=\"line\">--sbin-path=/usr/sbin/nginx</span><br><span class=\"line\"><span class=\"comment\"># 指定模块安装路径</span></span><br><span class=\"line\">--modules-path=/usr/lib64/nginx/modules</span><br><span class=\"line\"><span class=\"comment\"># 指定主配置文件</span></span><br><span class=\"line\">--conf-path=/etc/nginx/nginx.conf</span><br><span class=\"line\"><span class=\"comment\"># 指定错误日志</span></span><br><span class=\"line\">--error-log-path=/var/log/nginx/error.log</span><br><span class=\"line\"><span class=\"comment\"># 指定访问日志</span></span><br><span class=\"line\">--http-log-path=/var/log/nginx/access.log</span><br><span class=\"line\"><span class=\"comment\"># 设定http客户端请求临时文件路径</span></span><br><span class=\"line\">--http-client-body-temp-path=/var/lib/nginx/tmp/client_body</span><br><span class=\"line\"><span class=\"comment\"># 设定http代理临时文件路径</span></span><br><span class=\"line\">--http-proxy-temp-path=/var/lib/nginx/tmp/proxy</span><br><span class=\"line\"><span class=\"comment\"># 设定http fastcgi临时文件路径，基本就是php缓存</span></span><br><span class=\"line\">--http-fastcgi-temp-path=/var/lib/nginx/tmp/fastcgi</span><br><span class=\"line\"><span class=\"comment\"># 设定http uwsgi临时文件路径，python缓存路径</span></span><br><span class=\"line\">--http-uwsgi-temp-path=/var/lib/nginx/tmp/uwsgi</span><br><span class=\"line\"><span class=\"comment\"># 设定http scgi临时文件路径</span></span><br><span class=\"line\">--http-scgi-temp-path=/var/lib/nginx/tmp/scgi</span><br><span class=\"line\"><span class=\"comment\"># master进程ID</span></span><br><span class=\"line\">--pid-path=/run/nginx.pid</span><br><span class=\"line\"><span class=\"comment\"># 锁路径，防止重复启动nginx</span></span><br><span class=\"line\">--lock-path=/run/lock/subsys/nginx</span><br><span class=\"line\"><span class=\"comment\"># worker进程的用户和组</span></span><br><span class=\"line\">--user=nginx --group=nginx</span><br><span class=\"line\"><span class=\"comment\"># 启用动态模块兼容性</span></span><br><span class=\"line\">--with-compat</span><br><span class=\"line\"><span class=\"comment\"># 启用debug日志</span></span><br><span class=\"line\">--with-debug</span><br><span class=\"line\"><span class=\"comment\"># 使用nginx的aio特性会大大提高性能，比如图片站的特点是大量的读io操作，nginx aio不用等待每次io的结果，有助于并发处理大量io和提高nginx处理效率。</span></span><br><span class=\"line\"><span class=\"comment\"># aio的优点就是能够同时提交多个io请求给内核，然后直接由内核的io调度算法去处理这些请求(directio)，这样的话，内核就有可能执行一些合并，节约了读取文件的处理时间。</span></span><br><span class=\"line\"><span class=\"comment\"># 异步非阻塞</span></span><br><span class=\"line\">--with-file-aio</span><br><span class=\"line\"><span class=\"comment\"># 调试用，剖析程序性能瓶颈</span></span><br><span class=\"line\">--with-google_perftools_module</span><br><span class=\"line\"><span class=\"comment\"># 作为一个输出过滤器，支持不完全缓冲，分部分响应请求。在nginx响应之前或者之后追加文本内容，比如想在站点底部追加一个js广告或者新增的css样式</span></span><br><span class=\"line\">--with-http_addition_module</span><br><span class=\"line\"><span class=\"comment\"># 认证模块，实现基于一个子请求的结果的客户端授权。如果该子请求返回的2xx响应代码，所述接入是允许的。如果它返回401或403中，访问被拒绝与相应的错误代码。由子请求返回的任何其他响应代码被认为是一个错误。</span></span><br><span class=\"line\">--with-http_auth_request_module</span><br><span class=\"line\"><span class=\"comment\"># WebDAV模块，增加 PUT,DELETE,MKCOL,COPY和MOVE方法。默认情况下为关闭</span></span><br><span class=\"line\"><span class=\"comment\"># 扩展了HTTP 1.1，在GET、POST、HEAD等几个HTTP标准方法以外添加了一些新的方法，使应用程序可直接对Web Server直接读写，并支持写文件锁定(Locking)及解锁(Unlock)，还可以支持文件的版本控制。</span></span><br><span class=\"line\">--with-http_dav_module</span><br><span class=\"line\"><span class=\"comment\"># 允许在内存不足的情况下返回204或444码</span></span><br><span class=\"line\">--with-http_degradation_module</span><br><span class=\"line\"><span class=\"comment\"># 提供寻求内存使用基于时间的偏移量文件</span></span><br><span class=\"line\">--with-http_flv_module</span><br><span class=\"line\"><span class=\"comment\"># 它为不支持“gzip”编码方法的客户端解压具有“Content-Encoding: gzip”头的响应。</span></span><br><span class=\"line\">--with-http_gunzip_module</span><br><span class=\"line\"><span class=\"comment\"># 在线实时压缩输出数据流</span></span><br><span class=\"line\">--with-http_gzip_static_module</span><br><span class=\"line\"><span class=\"comment\"># 传输JPEG/GIF/PNG 图片的一个过滤器）（默认为不启用。gd库要用到）</span></span><br><span class=\"line\">--with-http_image_filter_module=dynamic</span><br><span class=\"line\"><span class=\"comment\"># 多媒体模块</span></span><br><span class=\"line\">--with-http_mp4_module</span><br><span class=\"line\">--with-http_perl_module=dynamic</span><br><span class=\"line\"><span class=\"comment\"># nginx显示随机首页模块</span></span><br><span class=\"line\">--with-http_random_index_module</span><br><span class=\"line\"><span class=\"comment\"># Nginx获取真实IP模块，这个模块允许从请求标头更改客户端的IP地址值，默认为关</span></span><br><span class=\"line\">--with-http_realip_module</span><br><span class=\"line\"><span class=\"comment\"># nginx安全下载模块</span></span><br><span class=\"line\">--with-http_secure_link_module</span><br><span class=\"line\"><span class=\"comment\"># nginx中文文档</span></span><br><span class=\"line\">--with-http_slice_module</span><br><span class=\"line\"><span class=\"comment\"># 安装ssl模块</span></span><br><span class=\"line\">--with-http_ssl_module</span><br><span class=\"line\"><span class=\"comment\"># 查看nginx客户端状态模块</span></span><br><span class=\"line\">--with-http_stub_status_module</span><br><span class=\"line\"><span class=\"comment\"># 允许用一些其他文本替换nginx响应中的一些文本</span></span><br><span class=\"line\">--with-http_sub_module</span><br><span class=\"line\"><span class=\"comment\"># 提供HTTP2支持，要使用http2，还需要同时启用ssl服务，nginx1.19.1之前的版本不支持http2</span></span><br><span class=\"line\">--with-http_v2_module</span><br><span class=\"line\"><span class=\"comment\"># 过滤转换XML请求</span></span><br><span class=\"line\">--with-http_xslt_module=dynamic</span><br><span class=\"line\"><span class=\"comment\"># 启用POP3/IMAP4/SMTP代理模块支持</span></span><br><span class=\"line\">--with-mail=dynamic --with-mail_ssl_module</span><br><span class=\"line\"><span class=\"comment\"># 支持正则，使nginx支持http rewrite模块</span></span><br><span class=\"line\">--with-pcre</span><br><span class=\"line\"><span class=\"comment\"># 编译PCRE包含“just-in-time compilation”</span></span><br><span class=\"line\">--with-pcre-jit</span><br><span class=\"line\"><span class=\"comment\"># TCP\\UDP负载均衡模块。nginx从1.9.0开始，新增加了一个stream模块，用来实现四层协议的转发、代理或者负载均衡等。</span></span><br><span class=\"line\">--with-stream=dynamic --with-stream_ssl_module --with-stream_ssl_preread_module</span><br><span class=\"line\"><span class=\"comment\"># 支持多线程模块</span></span><br><span class=\"line\">--with-threads</span><br><span class=\"line\"><span class=\"comment\"># 设置C编译器参数</span></span><br><span class=\"line\">--with-cc-opt=<span class=\"string\">&#x27;-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches -specs=/usr/lib/rpm/redhat/redhat-hardened-cc1 -m64 -mtune=generic&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 设置连接文件参数</span></span><br><span class=\"line\">--with-ld-opt=<span class=\"string\">&#x27;-Wl,-z,relro -specs=/usr/lib/rpm/redhat/redhat-hardened-ld -Wl,-E&#x27;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>其它参数</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启用ipv6支持</span></span><br><span class=\"line\">--with-ipv6</span><br><span class=\"line\"><span class=\"comment\"># SPDY可以缩短网页的加载时间</span></span><br><span class=\"line\">--with-http_spdy_module</span><br><span class=\"line\"><span class=\"comment\"># 该模块创建基于与MaxMind GeoIP二进制文件相配的客户端IP地址的ngx_http_geoip_module变量</span></span><br><span class=\"line\">--with-http_geoip_module</span><br><span class=\"line\"><span class=\"comment\"># 计算和检查要求所需的安全链接网址</span></span><br><span class=\"line\">--with-http_secure_link_module</span><br><span class=\"line\"><span class=\"comment\"># 禁用http cache功能</span></span><br><span class=\"line\">--without-http-cache</span><br><span class=\"line\"><span class=\"comment\"># 启用外部模块支持</span></span><br><span class=\"line\">--add-module=module_dir</span><br></pre></td></tr></table></figure>\n<h2 id=\"nginx编译安装出现的常见错误\">nginx编译安装出现的常见错误</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>参照<code>yum</code>安装nginx的配置进行手工编译</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./configure --prefix=/usr/local/nginx-1.22.1  --user=nginx --group=nginx --with-compat --with-debug \\</span><br><span class=\"line\">--with-file-aio --with-google_perftools_module --with-http_addition_module --with-http_auth_request_module \\</span><br><span class=\"line\">--with-http_dav_module --with-http_degradation_module --with-http_flv_module --with-http_gunzip_module \\</span><br><span class=\"line\">--with-http_gzip_static_module --with-http_image_filter_module=dynamic --with-http_mp4_module \\</span><br><span class=\"line\">--with-http_perl_module=dynamic --with-http_random_index_module --with-http_realip_module \\</span><br><span class=\"line\">--with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module \\</span><br><span class=\"line\">--with-http_sub_module --with-http_v2_module --with-http_xslt_module=dynamic --with-mail=dynamic --with-mail_ssl_module \\</span><br><span class=\"line\">--with-pcre --with-pcre-jit --with-stream=dynamic --with-stream_ssl_module --with-stream_ssl_preread_module --with-threads</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>./configure: error: the HTTP rewrite module requires the PCRE library.You can either disable the module by using --without-http_rewrite_module option, or install the PCRE library into the system, or build the PCRE library statically from the source with nginx by using --with-pcre= option.</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install pcre pcre-devel</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>./configure: error: SSL modules require the OpenSSL library.You can either do not enable the modules, or install the OpenSSL library into the system, or build the OpenSSL library statically from the source with nginx by using --with-openssl= option.</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install openssl openssl-devel</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>./configure: error: the HTTP XSLT module requires the libxml2/libxslt libraries. You can either do not enable the module or install the libraries.</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install libxml2 libxml2-devel libxslt libxslt-devel</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>./configure: error: the HTTP image filter module requires the GD library. You can either do not enable the module or install the libraries.</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install gd gd-devel</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>./configure: error: perl module ExtUtils::Embed is required</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install perl-ExtUtils-Embed</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>./configure: error: the Google perftools module requires the Google perftools library. You can either do not enable the module or install the library</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install google-perftools google-perftools-devel</span><br></pre></td></tr></table></figure>\n<h2 id=\"Nginx-配置文件\">Nginx 配置文件</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 全局参数设置</span></span><br><span class=\"line\"><span class=\"comment\">#user  nobody;</span></span><br><span class=\"line\">user nginx;            <span class=\"comment\"># worker进程用户</span></span><br><span class=\"line\">worker_processes  2;          <span class=\"comment\"># 设置nginx启动进程的数量，一般设置成与逻辑cpu数量相同</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#error_log  logs/error.log;         # 指定错误日志</span></span><br><span class=\"line\"><span class=\"comment\">#error_log  logs/error.log  notice;</span></span><br><span class=\"line\"><span class=\"comment\">#error_log  logs/error.log  info;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># worker_rlimit_nofile 102400;  # 设置一个nginx进程能打开的最大文件数</span></span><br><span class=\"line\"><span class=\"comment\"># pid        /run/nginx.pid;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 加载模块配置文件</span></span><br><span class=\"line\"><span class=\"comment\"># include conf.d/modules/*.conf;</span></span><br><span class=\"line\">load_module modules/ngx_stream_module.so; <span class=\"comment\"># 加载stream模块</span></span><br><span class=\"line\"></span><br><span class=\"line\">events &#123;                      <span class=\"comment\"># 事件配置</span></span><br><span class=\"line\">    worker_connections  1024; <span class=\"comment\"># 设置一个进程的最大并发连接数</span></span><br><span class=\"line\">    <span class=\"comment\"># use epoll;                # 事件驱动类型</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># tcp反向代理示例，与http配置同级</span></span><br><span class=\"line\">stream &#123;</span><br><span class=\"line\">    <span class=\"comment\"># include conf.d/stream/*.conf</span></span><br><span class=\"line\">    include conf.d/stream/redis.conf</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># http 服务相关设置</span></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    include             mime.types;  <span class=\"comment\"># 关联mime类型，关联资源的媒体类型(不同的媒体类型的打开方式)</span></span><br><span class=\"line\">    default_type        application/octet-stream;  <span class=\"comment\"># 根据文件的后缀来匹配相应的MIME类型，并写入Response header，导致浏览器播放文件而不是下载</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 访问日志格式</span></span><br><span class=\"line\">    log_format  main  <span class=\"string\">&#x27;remote_addr - remote_user [time_local] &quot;request&quot; &#x27;</span></span><br><span class=\"line\">                      <span class=\"string\">&#x27;status body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class=\"line\">                      <span class=\"string\">&#x27;&quot;http_user_agent&quot; &quot;http_x_forwarded_for&quot;&#x27;</span>;</span><br><span class=\"line\">    access_log  logs/access.log  main;    <span class=\"comment\">#设置访问日志的位置和格式</span></span><br><span class=\"line\">    sendfile          on;      <span class=\"comment\"># 用于开启文件高效传输模式，一般设置为on，若nginx是用来进行磁盘IO负载应用时，可以设置为off，降低系统负载</span></span><br><span class=\"line\">    tcp_nopush        on;      <span class=\"comment\"># 减少网络报文段数量，当有数据时，先别着急发送, 确保数据包已经装满数据, 避免了网络拥塞</span></span><br><span class=\"line\">    tcp_nodelay       on;      <span class=\"comment\"># 提高I/O性能，确保数据尽快发送, 提高可数据传输效率</span></span><br><span class=\"line\">    <span class=\"comment\"># gzip              on;      # 是否开启 gzip 压缩</span></span><br><span class=\"line\">    keepalive_timeout  65;     <span class=\"comment\"># 设置长连接的超时时间，请求完成之后还要保持连接多久，不是请求时间多久，目的是保持长连接，减少创建连接过程给系统带来的性能损耗，类似于线程池，数据库连接池</span></span><br><span class=\"line\">    types_hash_max_size 4096;  <span class=\"comment\"># 影响散列表的冲突率。types_hash_max_size 越大，就会消耗更多的内存，但散列key的冲突率会降低，检索速度就更快。types_hash_max_size越小，消耗的内存就越小，但散列key的冲突率可能上升</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 加载子配置文件</span></span><br><span class=\"line\">    <span class=\"comment\"># include /usr/local/nginx-1.22.1/conf/conf.d/*.conf;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># http反向代理示例</span></span><br><span class=\"line\">    include conf.d/http/tomcat.conf</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 虚拟服务器的相关设置</span></span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen      80;        <span class=\"comment\"># 设置监听的端口</span></span><br><span class=\"line\">        server_name  localhost;        <span class=\"comment\"># 设置绑定的主机名、域名或ip地址</span></span><br><span class=\"line\">        <span class=\"comment\">#charset koi8-r;        # 设置编码字符</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#access_log  logs/host.access.log  main;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">            root  html;           <span class=\"comment\"># 设置服务器默认网站的根目录位置</span></span><br><span class=\"line\">            index  index.html index.htm;    <span class=\"comment\"># 设置默认打开的文档</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\"># error_page 404 /404.html;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        error_page  500 502 503 504  /50x.html; <span class=\"comment\"># 设置错误信息返回页面</span></span><br><span class=\"line\">        location = /50x.html &#123;</span><br><span class=\"line\">            root html</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class=\"line\">        <span class=\"comment\">#</span></span><br><span class=\"line\">        <span class=\"comment\">#location ~ \\.php$ &#123;</span></span><br><span class=\"line\">        <span class=\"comment\">#    proxy_pass   http://127.0.0.1;</span></span><br><span class=\"line\">        <span class=\"comment\">#&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class=\"line\">        <span class=\"comment\">#</span></span><br><span class=\"line\">        <span class=\"comment\">#location ~ \\.php$ &#123;</span></span><br><span class=\"line\">        <span class=\"comment\">#    root           html;</span></span><br><span class=\"line\">        <span class=\"comment\">#    fastcgi_pass   127.0.0.1:9000;</span></span><br><span class=\"line\">        <span class=\"comment\">#    fastcgi_index  index.php;</span></span><br><span class=\"line\">        <span class=\"comment\">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span></span><br><span class=\"line\">        <span class=\"comment\">#    include        fastcgi_params;</span></span><br><span class=\"line\">        <span class=\"comment\">#&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># deny access to .htaccess files, if Apache&#x27;s document root</span></span><br><span class=\"line\">        <span class=\"comment\"># concurs with nginx&#x27;s one</span></span><br><span class=\"line\">        <span class=\"comment\">#</span></span><br><span class=\"line\">        <span class=\"comment\">#location ~ /\\.ht &#123;</span></span><br><span class=\"line\">        <span class=\"comment\">#    deny  all;</span></span><br><span class=\"line\">        <span class=\"comment\">#&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># HTTPS server</span></span><br><span class=\"line\">    <span class=\"comment\">#</span></span><br><span class=\"line\">    <span class=\"comment\">#server &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">#    listen       443 ssl;</span></span><br><span class=\"line\">    <span class=\"comment\">#    server_name  localhost;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#    ssl_certificate      cert.pem;</span></span><br><span class=\"line\">    <span class=\"comment\">#    ssl_certificate_key  cert.key;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#    ssl_session_cache    shared:SSL:1m;</span></span><br><span class=\"line\">    <span class=\"comment\">#    ssl_session_timeout  5m;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#    ssl_ciphers  HIGH:!aNULL:!MD5;</span></span><br><span class=\"line\">    <span class=\"comment\">#    ssl_prefer_server_ciphers  on;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#    location / &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">#        root   html;</span></span><br><span class=\"line\">    <span class=\"comment\">#        index  index.html index.htm;</span></span><br><span class=\"line\">    <span class=\"comment\">#    &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">#&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>tomcat.conf</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream tomcats &#123;</span><br><span class=\"line\">    server 192.168.0.1:8080;</span><br><span class=\"line\">    server 192.168.0.2:8080;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">        listen       8088;</span><br><span class=\"line\">        server_name  localhost tomcat.domain;</span><br><span class=\"line\"></span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">            proxy_pass http://tomcats; <span class=\"comment\">#这个名称和要上面 upstream tomcats 对应</span></span><br><span class=\"line\">            proxy_redirect     default;</span><br><span class=\"line\">            proxy_http_version 1.1;</span><br><span class=\"line\"></span><br><span class=\"line\">            proxy_set_header   Host              <span class=\"variable\">$host</span>;</span><br><span class=\"line\">            proxy_set_header   X-Real-IP         <span class=\"variable\">$remote_addr</span>;</span><br><span class=\"line\">            proxy_set_header   X-Forwarded-For   <span class=\"variable\">$proxy_add_x_forwarded_for</span>;</span><br><span class=\"line\">            proxy_set_header   X-Forwarded-Proto <span class=\"variable\">$scheme</span>;</span><br><span class=\"line\">            proxy_max_temp_file_size 0;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">#this is the maximum upload size</span></span><br><span class=\"line\">            client_max_body_size       10m;</span><br><span class=\"line\">            client_body_buffer_size    128k;</span><br><span class=\"line\"></span><br><span class=\"line\">            proxy_connect_timeout      90;</span><br><span class=\"line\">            proxy_send_timeout         90;</span><br><span class=\"line\">            proxy_read_timeout         90;</span><br><span class=\"line\">            proxy_buffering            off;</span><br><span class=\"line\">            proxy_request_buffering    off; <span class=\"comment\"># Required for HTTP CLI commands</span></span><br><span class=\"line\">            proxy_set_header Connection <span class=\"string\">&quot;&quot;</span>; <span class=\"comment\"># Clear for keepalive</span></span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>redis.conf</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream redis&#123;</span><br><span class=\"line\">    server 192.168.0.1:6379;</span><br><span class=\"line\">    server 192.168.0.2:6379;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 8888; <span class=\"comment\">#监听本机所有IP的8888端口</span></span><br><span class=\"line\">    proxy_connect_timeout 10s; <span class=\"comment\">#连接超时时间</span></span><br><span class=\"line\">    proxy_timeout 10s; <span class=\"comment\">#转发超时时间</span></span><br><span class=\"line\">    proxy_pass redis; <span class=\"comment\">#这个名称和要上面 upstream redis 对应</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>upstream</code>配置说明</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream还可以为每个设备设置状态值，这些状态值的含义分别如下：</span><br><span class=\"line\">- down：表示当前的server暂时不参与负载.</span><br><span class=\"line\">- weight：默认为1，weight越大，负载的权重就越大。</span><br><span class=\"line\">- max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误.</span><br><span class=\"line\">- fail_timeout : max_fails次失败后，暂停的时间。</span><br><span class=\"line\">- backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。</span><br><span class=\"line\">- ip_hash（访问ip）:每个请求按访问ip的<span class=\"built_in\">hash</span>结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</span><br><span class=\"line\"></span><br><span class=\"line\">示例：</span><br><span class=\"line\">upstream tomcats&#123;</span><br><span class=\"line\">    ip_hash;</span><br><span class=\"line\">    server 127.0.0.1:9001 down;</span><br><span class=\"line\">    server 127.0.0.1:9002 backup;</span><br><span class=\"line\">    server 127.0.0.1:9003 weight=2;</span><br><span class=\"line\">    server 127.0.0.1:9004 max_fails=2 fail_timeout=60s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置为系统服务\">配置为系统服务</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>yum安装自带系统服务</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 进入service服务目录</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /etc/init.d</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建并编辑nginx文件</span></span><br><span class=\"line\">vim nginx</span><br><span class=\"line\"><span class=\"comment\"># 写入如下内容：</span></span><br><span class=\"line\">    <span class=\"built_in\">set</span> -e</span><br><span class=\"line\">    PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class=\"line\">    DESC=<span class=\"string\">&quot;nginx daemon&quot;</span></span><br><span class=\"line\">    NAME=nginx</span><br><span class=\"line\">    DAEMON=/usr/local/nginx-1.22.1/sbin/<span class=\"variable\">$NAME</span></span><br><span class=\"line\">    SCRIPTNAME=/etc/init.d/<span class=\"variable\">$NAME</span></span><br><span class=\"line\">    <span class=\"built_in\">test</span> -x <span class=\"variable\">$DAEMON</span> || <span class=\"built_in\">exit</span> 0</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">d_start</span></span>()&#123;</span><br><span class=\"line\">        <span class=\"variable\">$DAEMON</span> || <span class=\"built_in\">echo</span> -n <span class=\"string\">&quot; already running&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">d_stop</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"variable\">$DAEMON</span> -s quit || <span class=\"built_in\">echo</span> -n <span class=\"string\">&quot; not running&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">d_reload</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"variable\">$DAEMON</span> -s reload || <span class=\"built_in\">echo</span> -n <span class=\"string\">&quot; counld not reload&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">d_status</span></span>() &#123;</span><br><span class=\"line\">        pid=`ps ax | grep -i <span class=\"string\">&#x27;nginx: master&#x27;</span> | grep -v grep | awk <span class=\"string\">&#x27;&#123;print $1&#125;&#x27;</span>`</span><br><span class=\"line\">        <span class=\"keyword\">if</span> [ -z <span class=\"string\">&quot;<span class=\"variable\">$pid</span>&quot;</span> ] ; <span class=\"keyword\">then</span></span><br><span class=\"line\">            <span class=\"built_in\">echo</span> -n <span class=\"string\">&quot;No nginx-server running.&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">echo</span> -n <span class=\"string\">&quot;The nginx-server(<span class=\"variable\">$&#123;pid&#125;</span>) is running&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">fi</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;<span class=\"variable\">$1</span>&quot;</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        start)</span><br><span class=\"line\">            <span class=\"built_in\">echo</span> -n <span class=\"string\">&quot;Starting <span class=\"variable\">$DESC</span>:<span class=\"variable\">$NAME</span>&quot;</span></span><br><span class=\"line\">            d_start</span><br><span class=\"line\">            <span class=\"built_in\">echo</span> <span class=\"string\">&quot;.&quot;</span></span><br><span class=\"line\">        ;;</span><br><span class=\"line\">        stop)</span><br><span class=\"line\">            <span class=\"built_in\">echo</span> -n <span class=\"string\">&quot;Stopping <span class=\"variable\">$DESC</span>:<span class=\"variable\">$NAME</span>&quot;</span></span><br><span class=\"line\">            d_stop</span><br><span class=\"line\">            <span class=\"built_in\">echo</span> <span class=\"string\">&quot;.&quot;</span></span><br><span class=\"line\">        ;;</span><br><span class=\"line\">        reload)</span><br><span class=\"line\">            <span class=\"built_in\">echo</span> -n <span class=\"string\">&quot;Reloading <span class=\"variable\">$DESC</span> configuration...&quot;</span></span><br><span class=\"line\">            d_reload</span><br><span class=\"line\">            <span class=\"built_in\">echo</span> <span class=\"string\">&quot;reloaded.&quot;</span></span><br><span class=\"line\">        ;;</span><br><span class=\"line\">        restart)</span><br><span class=\"line\">            <span class=\"built_in\">echo</span> -n <span class=\"string\">&quot;Restarting <span class=\"variable\">$DESC</span>: <span class=\"variable\">$NAME</span>&quot;</span></span><br><span class=\"line\">            d_stop</span><br><span class=\"line\">            <span class=\"built_in\">sleep</span> 2</span><br><span class=\"line\">            d_start</span><br><span class=\"line\">            <span class=\"built_in\">echo</span> <span class=\"string\">&quot;.&quot;</span></span><br><span class=\"line\">        ;;</span><br><span class=\"line\">        status)</span><br><span class=\"line\">            <span class=\"built_in\">echo</span> -n <span class=\"string\">&quot;Check <span class=\"variable\">$DESC</span> status...&quot;</span></span><br><span class=\"line\">            d_status</span><br><span class=\"line\">            <span class=\"built_in\">echo</span> <span class=\"string\">&quot;.&quot;</span></span><br><span class=\"line\">        ;;</span><br><span class=\"line\">        *)</span><br><span class=\"line\">            <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Usage: <span class=\"variable\">$SCRIPTNAME</span> &#123;start|stop|restart|reload|status&#125;&quot;</span> &gt;&amp;2</span><br><span class=\"line\">            <span class=\"built_in\">exit</span> 3</span><br><span class=\"line\">        ;;</span><br><span class=\"line\">    <span class=\"keyword\">esac</span></span><br><span class=\"line\">    <span class=\"built_in\">exit</span> 0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 授予执行权限</span></span><br><span class=\"line\"><span class=\"built_in\">chmod</span> +x nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 服务管理</span></span><br><span class=\"line\">service nginx start</span><br><span class=\"line\">service nginx stop</span><br><span class=\"line\">service nginx status</span><br><span class=\"line\">service nginx reload</span><br><span class=\"line\">service nginx restart</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 这里使用 systemctl 同样可以，因为systemctl兼容service</span></span><br><span class=\"line\">systemctl start nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 加入开机启动</span></span><br><span class=\"line\">chkconfig nginx on</span><br><span class=\"line\">systemctl <span class=\"built_in\">enable</span> nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 关闭开启启动</span></span><br><span class=\"line\">chkconfig nginx off</span><br><span class=\"line\">systemctl <span class=\"built_in\">disable</span> nginx</span><br></pre></td></tr></table></figure>","content_text":"摘要 虽然绝大部分软件都可以通过rpm或者yum的方式进行安装，但是由于yum中的版本不一定是最新版，或者软件开发商没有将软件放到yum源中，所有也有一些软件需要通过源代码的方式进行安装。 本文以源代码安装nginx为例说明如何通过源代码安装软件。 本文基于CentOS8(x86_64) 安装nginx 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# 安装nginx最小依赖yum install gcc zlib zlib-devel pcre-devel openssl openssl-devel# 如果通过yum安装nginx，只需要执行如下命令yum install nginx -y # 本文不通过yum安装# 下载nginx最新稳定版wget https://nginx.org/download/nginx-1.22.1.tar.gz# 解压tar -zxvf nginx-1.22.1.tar.gz# 进入解压后的目录cd nginx-1.22.1# 检查配置并指定安装参数./configure --with-http_stub_status_module --with-http_ssl_module # 参数说明 --with-http_ssl_module :安装ssl模块 --with-http_stub_status_module :查看nginx的客户端状态模块 # 输出内容，所有文件的默认路径 Configuration summary + using system PCRE library + using system OpenSSL library + using system zlib library nginx path prefix: &quot;/usr/local/nginx&quot; nginx binary file: &quot;/usr/local/nginx/sbin/nginx&quot; nginx modules path: &quot;/usr/local/nginx/modules&quot; nginx configuration prefix: &quot;/usr/local/nginx/conf&quot; nginx configuration file: &quot;/usr/local/nginx/conf/nginx.conf&quot; nginx pid file: &quot;/usr/local/nginx/logs/nginx.pid&quot; nginx error log file: &quot;/usr/local/nginx/logs/error.log&quot; nginx http access log file: &quot;/usr/local/nginx/logs/access.log&quot; nginx http client request body temporary files: &quot;client_body_temp&quot; nginx http proxy temporary files: &quot;proxy_temp&quot; nginx http fastcgi temporary files: &quot;fastcgi_temp&quot; nginx http uwsgi temporary files: &quot;uwsgi_temp&quot; nginx http scgi temporary files: &quot;scgi_temp&quot;# 也可以自定义安装路径./configure --prefix=/usr/local/nginx-1.22.1 --with-http_stub_status_module --with-http_ssl_module # 参数说明 --prefix=/usr/local/nginx-1.22.1 :安装路径 #输出内容，此时看到所有文件都会被安装到指定的路径 Configuration summary + using system PCRE library + using system OpenSSL library + using system zlib library nginx path prefix: &quot;/usr/local/nginx-1.22.1&quot; nginx binary file: &quot;/usr/local/nginx-1.22.1/sbin/nginx&quot; nginx modules path: &quot;/usr/local/nginx-1.22.1/modules&quot; nginx configuration prefix: &quot;/usr/local/nginx-1.22.1/conf&quot; nginx configuration file: &quot;/usr/local/nginx-1.22.1/conf/nginx.conf&quot; nginx pid file: &quot;/usr/local/nginx-1.22.1/logs/nginx.pid&quot; nginx error log file: &quot;/usr/local/nginx-1.22.1/logs/error.log&quot; nginx http access log file: &quot;/usr/local/nginx-1.22.1/logs/access.log&quot; nginx http client request body temporary files: &quot;client_body_temp&quot; nginx http proxy temporary files: &quot;proxy_temp&quot; nginx http fastcgi temporary files: &quot;fastcgi_temp&quot; nginx http uwsgi temporary files: &quot;uwsgi_temp&quot; nginx http scgi temporary files: &quot;scgi_temp&quot;# 编译make# 将相关文件拷贝到 --prefix 指定的安装目录中make install 配置和管理nginx 上面就完成了nginx安装，之后我们可以根据需要对配置文件进行修改，并启动nginx 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# 假设我们将nginx安装到了自定义安装路径/usr/local/nginx-1.22.1下cd /usr/local/nginx-1.22.1ls -1conf :nginx配置文件目录html :默认web根目录logs :默认日志输出目录sbin :启动命令nginx所在目录，make后真正有用的就这个nginx命令，重新编译就是为了重新生成新的nginx命令# 将nginx命令软连接到系统命令路径下，因为/usr/bin/已经被加入到PATH中了ln -s /usr/local/nginx-1.22.1/sbin/nginx /usr/bin/# 查看nginx版本，测试nginx命令是否全局可用nginx -vnginx version: nginx/1.22.1# 创建nginx用户和组$ groupadd nginx$ useradd -g nginx nginx# 修改配置文件vim /usr/local/nginx-1.22.1/conf/nginx.conf # 为了方便演示，这里仅仅修改如下两项内容 # worker用户，这里配置为我们上面创建的nginx用户和nginx组 user nginx nginx; # 启动2个worker进程 worker_processes 2;# 检查配置文件是否正确nginx -tnginx: the configuration file /usr/local/nginx-1.22.1/conf/nginx.conf syntax is oknginx: configuration file /usr/local/nginx-1.22.1/conf/nginx.conf test is successful# 如果配置文件被修改了，可以通过该命令重新加载新的配置，而不需要重新启动nginxnginx -s reload# 启动nginx# 会使用默认的配置文件nginx# 启动时指定配置文件nginx -c /usr/local/nginx-1.22.1/conf/nginx.conf# 查看进程ps -ef | grep nginxroot 18538 1 0 11:11 ? 00:00:00 nginx: master process nginxnginx 18592 18538 0 11:22 ? 00:00:00 nginx: worker processnginx 18593 18538 0 11:22 ? 00:00:00 nginx: worker process# 查看端口netstat -tunpl | grep nginxtcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 18538/nginx: master# 立即停止nginxnginx -s stop# 从容停止nginxkill -QUIT `cat /usr/local/nginx-1.22.1/logs/nginx.pid`# 立即重启nginxnginx -s stopnginx# 平滑重启nginxkill -HUP `cat /usr/local/nginx-1.22.1/logs/nginx.pid` # 只会重启worker进程 为nginx添加新的模块 nginx安装成功后，发现有一些其他模块没有编译进去，或者想额外添加一些模块，这时候就要重新编译nginx。 重新编译之前，需要查看之前安装时的参数 123456$ nginx -Vnginx version: nginx/1.22.1built by gcc 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC)built with OpenSSL 1.0.2k-fips 26 Jan 2017TLS SNI support enabledconfigure arguments: --prefix=/usr/local/nginx-1.22.1 --with-http_stub_status_module --with-http_ssl_module configure arguments中就是之前编译安装时配置的参数 如添加新的模块http_gzip_static_module 123456789101112131415161718192021222324252627282930313233343536373839404142# 进入nginx源码目录cd /usr/local/soft/nginx-1.22.1# 检查配置并指定安装参数，使用上面得到的上一次安装的参数，还要将新的模块也加上./configure --prefix=/usr/local/nginx-1.22.1 --with-http_stub_status_module --with-http_ssl_module --with-http_gzip_static_module# 编译，注意不要执行 make install，因为我们只需要得到nginx命令，运行make install会覆盖之前的所有目录make# 先备份原先的nginx命令cp /usr/local/nginx-1.22.1/sbin/nginx /usr/local/nginx-1.22.1/sbin/nginx.bak# 将新生成的nginx命令复制到安装目录中cp ./objs/nginx /usr/local/nginx-1.22.1/sbin/nginx# 此时如果遇到提示 cp: 无法创建普通文件&quot;/usr/local/nginx-1.22.1/sbin/nginx&quot;: 文本文件忙 , 可以通过如下命令进行复制cp -rfp ./objs/nginx /usr/local/nginx-1.22.1/sbin/nginx# 重启nginxnginx -s stopnginx# 平滑重启nginx(没好使)make upgrade # 会执行Makefile下的如下命令，也可以手工按如下命令进行平滑重启 upgrade: /usr/local/nginx-1.22.1/sbin/nginx -t # 原因是执行如下命令没有创建新的master进程 kill -USR2 `cat /usr/local/nginx-1.22.1/logs/nginx.pid` sleep 1 test -f /usr/local/nginx-1.22.1/logs/nginx.pid.oldbin kill -QUIT `cat /usr/local/nginx-1.22.1/logs/nginx.pid.oldbin`# 查看是否是新的nginxnginx -Vnginx version: nginx/1.22.1built by gcc 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC)built with OpenSSL 1.0.2k-fips 26 Jan 2017TLS SNI support enabledconfigure arguments: --prefix=/usr/local/nginx-1.22.1 --with-http_stub_status_module --with-http_ssl_module --with-http_gzip_static_module 安装第三方模块，configure中需要添加--add-module=module_dir，具体查看第三方模块官网说明即可 nginx编译时可以添加哪些参数 以下是通过yum安装nginx时的编译参数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990# 指定nginx安装路径，至少web根目录在该路径下--prefix=/usr/share/nginx# 指定nginx命令安装路径--sbin-path=/usr/sbin/nginx# 指定模块安装路径--modules-path=/usr/lib64/nginx/modules# 指定主配置文件--conf-path=/etc/nginx/nginx.conf# 指定错误日志--error-log-path=/var/log/nginx/error.log# 指定访问日志--http-log-path=/var/log/nginx/access.log# 设定http客户端请求临时文件路径--http-client-body-temp-path=/var/lib/nginx/tmp/client_body# 设定http代理临时文件路径--http-proxy-temp-path=/var/lib/nginx/tmp/proxy# 设定http fastcgi临时文件路径，基本就是php缓存--http-fastcgi-temp-path=/var/lib/nginx/tmp/fastcgi# 设定http uwsgi临时文件路径，python缓存路径--http-uwsgi-temp-path=/var/lib/nginx/tmp/uwsgi# 设定http scgi临时文件路径--http-scgi-temp-path=/var/lib/nginx/tmp/scgi# master进程ID--pid-path=/run/nginx.pid# 锁路径，防止重复启动nginx--lock-path=/run/lock/subsys/nginx# worker进程的用户和组--user=nginx --group=nginx# 启用动态模块兼容性--with-compat# 启用debug日志--with-debug# 使用nginx的aio特性会大大提高性能，比如图片站的特点是大量的读io操作，nginx aio不用等待每次io的结果，有助于并发处理大量io和提高nginx处理效率。# aio的优点就是能够同时提交多个io请求给内核，然后直接由内核的io调度算法去处理这些请求(directio)，这样的话，内核就有可能执行一些合并，节约了读取文件的处理时间。# 异步非阻塞--with-file-aio# 调试用，剖析程序性能瓶颈--with-google_perftools_module# 作为一个输出过滤器，支持不完全缓冲，分部分响应请求。在nginx响应之前或者之后追加文本内容，比如想在站点底部追加一个js广告或者新增的css样式--with-http_addition_module# 认证模块，实现基于一个子请求的结果的客户端授权。如果该子请求返回的2xx响应代码，所述接入是允许的。如果它返回401或403中，访问被拒绝与相应的错误代码。由子请求返回的任何其他响应代码被认为是一个错误。--with-http_auth_request_module# WebDAV模块，增加 PUT,DELETE,MKCOL,COPY和MOVE方法。默认情况下为关闭# 扩展了HTTP 1.1，在GET、POST、HEAD等几个HTTP标准方法以外添加了一些新的方法，使应用程序可直接对Web Server直接读写，并支持写文件锁定(Locking)及解锁(Unlock)，还可以支持文件的版本控制。--with-http_dav_module# 允许在内存不足的情况下返回204或444码--with-http_degradation_module# 提供寻求内存使用基于时间的偏移量文件--with-http_flv_module# 它为不支持“gzip”编码方法的客户端解压具有“Content-Encoding: gzip”头的响应。--with-http_gunzip_module# 在线实时压缩输出数据流--with-http_gzip_static_module# 传输JPEG/GIF/PNG 图片的一个过滤器）（默认为不启用。gd库要用到）--with-http_image_filter_module=dynamic# 多媒体模块--with-http_mp4_module--with-http_perl_module=dynamic# nginx显示随机首页模块--with-http_random_index_module# Nginx获取真实IP模块，这个模块允许从请求标头更改客户端的IP地址值，默认为关--with-http_realip_module# nginx安全下载模块--with-http_secure_link_module# nginx中文文档--with-http_slice_module# 安装ssl模块--with-http_ssl_module# 查看nginx客户端状态模块--with-http_stub_status_module# 允许用一些其他文本替换nginx响应中的一些文本--with-http_sub_module# 提供HTTP2支持，要使用http2，还需要同时启用ssl服务，nginx1.19.1之前的版本不支持http2--with-http_v2_module# 过滤转换XML请求--with-http_xslt_module=dynamic# 启用POP3/IMAP4/SMTP代理模块支持--with-mail=dynamic --with-mail_ssl_module# 支持正则，使nginx支持http rewrite模块--with-pcre# 编译PCRE包含“just-in-time compilation”--with-pcre-jit# TCP\\UDP负载均衡模块。nginx从1.9.0开始，新增加了一个stream模块，用来实现四层协议的转发、代理或者负载均衡等。--with-stream=dynamic --with-stream_ssl_module --with-stream_ssl_preread_module# 支持多线程模块--with-threads# 设置C编译器参数--with-cc-opt=&#x27;-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches -specs=/usr/lib/rpm/redhat/redhat-hardened-cc1 -m64 -mtune=generic&#x27;# 设置连接文件参数--with-ld-opt=&#x27;-Wl,-z,relro -specs=/usr/lib/rpm/redhat/redhat-hardened-ld -Wl,-E&#x27; 其它参数 123456789101112# 启用ipv6支持--with-ipv6# SPDY可以缩短网页的加载时间--with-http_spdy_module# 该模块创建基于与MaxMind GeoIP二进制文件相配的客户端IP地址的ngx_http_geoip_module变量--with-http_geoip_module# 计算和检查要求所需的安全链接网址--with-http_secure_link_module# 禁用http cache功能--without-http-cache# 启用外部模块支持--add-module=module_dir nginx编译安装出现的常见错误 参照yum安装nginx的配置进行手工编译 12345678./configure --prefix=/usr/local/nginx-1.22.1 --user=nginx --group=nginx --with-compat --with-debug \\--with-file-aio --with-google_perftools_module --with-http_addition_module --with-http_auth_request_module \\--with-http_dav_module --with-http_degradation_module --with-http_flv_module --with-http_gunzip_module \\--with-http_gzip_static_module --with-http_image_filter_module=dynamic --with-http_mp4_module \\--with-http_perl_module=dynamic --with-http_random_index_module --with-http_realip_module \\--with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module \\--with-http_sub_module --with-http_v2_module --with-http_xslt_module=dynamic --with-mail=dynamic --with-mail_ssl_module \\--with-pcre --with-pcre-jit --with-stream=dynamic --with-stream_ssl_module --with-stream_ssl_preread_module --with-threads ./configure: error: the HTTP rewrite module requires the PCRE library.You can either disable the module by using --without-http_rewrite_module option, or install the PCRE library into the system, or build the PCRE library statically from the source with nginx by using --with-pcre= option. 1yum install pcre pcre-devel ./configure: error: SSL modules require the OpenSSL library.You can either do not enable the modules, or install the OpenSSL library into the system, or build the OpenSSL library statically from the source with nginx by using --with-openssl= option. 1yum install openssl openssl-devel ./configure: error: the HTTP XSLT module requires the libxml2/libxslt libraries. You can either do not enable the module or install the libraries. 1yum install libxml2 libxml2-devel libxslt libxslt-devel ./configure: error: the HTTP image filter module requires the GD library. You can either do not enable the module or install the libraries. 1yum install gd gd-devel ./configure: error: perl module ExtUtils::Embed is required 1yum install perl-ExtUtils-Embed ./configure: error: the Google perftools module requires the Google perftools library. You can either do not enable the module or install the library 1yum install google-perftools google-perftools-devel Nginx 配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118# 全局参数设置#user nobody;user nginx; # worker进程用户worker_processes 2; # 设置nginx启动进程的数量，一般设置成与逻辑cpu数量相同#error_log logs/error.log; # 指定错误日志#error_log logs/error.log notice;#error_log logs/error.log info;# worker_rlimit_nofile 102400; # 设置一个nginx进程能打开的最大文件数# pid /run/nginx.pid;# 加载模块配置文件# include conf.d/modules/*.conf;load_module modules/ngx_stream_module.so; # 加载stream模块events &#123; # 事件配置 worker_connections 1024; # 设置一个进程的最大并发连接数 # use epoll; # 事件驱动类型&#125;# tcp反向代理示例，与http配置同级stream &#123; # include conf.d/stream/*.conf include conf.d/stream/redis.conf&#125;# http 服务相关设置http &#123; include mime.types; # 关联mime类型，关联资源的媒体类型(不同的媒体类型的打开方式) default_type application/octet-stream; # 根据文件的后缀来匹配相应的MIME类型，并写入Response header，导致浏览器播放文件而不是下载 # 访问日志格式 log_format main &#x27;remote_addr - remote_user [time_local] &quot;request&quot; &#x27; &#x27;status body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;http_user_agent&quot; &quot;http_x_forwarded_for&quot;&#x27;; access_log logs/access.log main; #设置访问日志的位置和格式 sendfile on; # 用于开启文件高效传输模式，一般设置为on，若nginx是用来进行磁盘IO负载应用时，可以设置为off，降低系统负载 tcp_nopush on; # 减少网络报文段数量，当有数据时，先别着急发送, 确保数据包已经装满数据, 避免了网络拥塞 tcp_nodelay on; # 提高I/O性能，确保数据尽快发送, 提高可数据传输效率 # gzip on; # 是否开启 gzip 压缩 keepalive_timeout 65; # 设置长连接的超时时间，请求完成之后还要保持连接多久，不是请求时间多久，目的是保持长连接，减少创建连接过程给系统带来的性能损耗，类似于线程池，数据库连接池 types_hash_max_size 4096; # 影响散列表的冲突率。types_hash_max_size 越大，就会消耗更多的内存，但散列key的冲突率会降低，检索速度就更快。types_hash_max_size越小，消耗的内存就越小，但散列key的冲突率可能上升 # 加载子配置文件 # include /usr/local/nginx-1.22.1/conf/conf.d/*.conf; # http反向代理示例 include conf.d/http/tomcat.conf # 虚拟服务器的相关设置 server &#123; listen 80; # 设置监听的端口 server_name localhost; # 设置绑定的主机名、域名或ip地址 #charset koi8-r; # 设置编码字符 #access_log logs/host.access.log main; location / &#123; root html; # 设置服务器默认网站的根目录位置 index index.html index.htm; # 设置默认打开的文档 &#125; # error_page 404 /404.html; error_page 500 502 503 504 /50x.html; # 设置错误信息返回页面 location = /50x.html &#123; root html &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&#x27;s document root # concurs with nginx&#x27;s one # #location ~ /\\.ht &#123; # deny all; #&#125; &#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125; tomcat.conf 1234567891011121314151617181920212223242526272829303132upstream tomcats &#123; server 192.168.0.1:8080; server 192.168.0.2:8080;&#125;server &#123; listen 8088; server_name localhost tomcat.domain; location / &#123; proxy_pass http://tomcats; #这个名称和要上面 upstream tomcats 对应 proxy_redirect default; proxy_http_version 1.1; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_max_temp_file_size 0; #this is the maximum upload size client_max_body_size 10m; client_body_buffer_size 128k; proxy_connect_timeout 90; proxy_send_timeout 90; proxy_read_timeout 90; proxy_buffering off; proxy_request_buffering off; # Required for HTTP CLI commands proxy_set_header Connection &quot;&quot;; # Clear for keepalive &#125;&#125; redis.conf 1234567891011upstream redis&#123; server 192.168.0.1:6379; server 192.168.0.2:6379;&#125;server &#123; listen 8888; #监听本机所有IP的8888端口 proxy_connect_timeout 10s; #连接超时时间 proxy_timeout 10s; #转发超时时间 proxy_pass redis; #这个名称和要上面 upstream redis 对应&#125; upstream配置说明 12345678910111213141516upstream还可以为每个设备设置状态值，这些状态值的含义分别如下：- down：表示当前的server暂时不参与负载.- weight：默认为1，weight越大，负载的权重就越大。- max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误.- fail_timeout : max_fails次失败后，暂停的时间。- backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。- ip_hash（访问ip）:每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。示例：upstream tomcats&#123; ip_hash; server 127.0.0.1:9001 down; server 127.0.0.1:9002 backup; server 127.0.0.1:9003 weight=2; server 127.0.0.1:9004 max_fails=2 fail_timeout=60s;&#125; 配置为系统服务 yum安装自带系统服务 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586# 进入service服务目录cd /etc/init.d# 创建并编辑nginx文件vim nginx# 写入如下内容： set -e PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin DESC=&quot;nginx daemon&quot; NAME=nginx DAEMON=/usr/local/nginx-1.22.1/sbin/$NAME SCRIPTNAME=/etc/init.d/$NAME test -x $DAEMON || exit 0 d_start()&#123; $DAEMON || echo -n &quot; already running&quot; &#125; d_stop() &#123; $DAEMON -s quit || echo -n &quot; not running&quot; &#125; d_reload() &#123; $DAEMON -s reload || echo -n &quot; counld not reload&quot; &#125; d_status() &#123; pid=`ps ax | grep -i &#x27;nginx: master&#x27; | grep -v grep | awk &#x27;&#123;print $1&#125;&#x27;` if [ -z &quot;$pid&quot; ] ; then echo -n &quot;No nginx-server running.&quot; else echo -n &quot;The nginx-server($&#123;pid&#125;) is running&quot; fi &#125; case &quot;$1&quot; in start) echo -n &quot;Starting $DESC:$NAME&quot; d_start echo &quot;.&quot; ;; stop) echo -n &quot;Stopping $DESC:$NAME&quot; d_stop echo &quot;.&quot; ;; reload) echo -n &quot;Reloading $DESC configuration...&quot; d_reload echo &quot;reloaded.&quot; ;; restart) echo -n &quot;Restarting $DESC: $NAME&quot; d_stop sleep 2 d_start echo &quot;.&quot; ;; status) echo -n &quot;Check $DESC status...&quot; d_status echo &quot;.&quot; ;; *) echo &quot;Usage: $SCRIPTNAME &#123;start|stop|restart|reload|status&#125;&quot; &gt;&amp;2 exit 3 ;; esac exit 0# 授予执行权限chmod +x nginx# 服务管理service nginx startservice nginx stopservice nginx statusservice nginx reloadservice nginx restart# 这里使用 systemctl 同样可以，因为systemctl兼容servicesystemctl start nginx# 加入开机启动chkconfig nginx onsystemctl enable nginx# 关闭开启启动chkconfig nginx offsystemctl disable nginx","summary":"摘要 虽然绝大部分软件都可以通过rpm或者yum的方式进行安装，但是由于yum中的版本不一定是最新版，或者软件开发商没有将软件放到yum源中，所有也有一些软件需要通过源代码的方式进行安装。 本文以源代码安装nginx为例说明如何通过源代码安装软件。 本文基于CentOS8(x86_64)","date_published":"2023-03-21T13:30:05.000Z","tags":["技术","linux","linux常用命令","linux常用命令"]},{"id":"https://blog.hanqunfeng.com/2023/03/17/linux-command08-rpm-yum/","url":"https://blog.hanqunfeng.com/2023/03/17/linux-command08-rpm-yum/","title":"Linux常用命令--rpm与yum","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度 ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在Linux发行版中，几乎每一个发行版都有自己的软件包管理系统。</p>\n</li>\n<li class=\"lvl-2\">\n<p>常见的有适用于<code>debian</code>、<code>Ubuntu</code>等系统的<code>dpkg</code>、<code>apt-get</code>以及它们的前端<code>aptitude</code>，以及适用于<code>RedHat</code>、<code>Fedora</code>系统的<code>rpm</code>以及它的前端<code>yum</code>。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>CentOS</code>系统从属于<code>RedHat</code>系列，其软件包管理系统有RPM和YUM，本文基于<code>CentOS8(x86_64)</code>介绍它们的使用方法。</p>\n</li>\n<li class=\"lvl-2\">\n<p>从CentOS 8开始，系统默认的软件包管理器是<code>dnf</code>，系统提供的<code>yum</code>命令仅为<code>dnf</code>命令的软链接。<code>dnf</code>是<code>dandified yum</code>的简称，是基于rpm软件包的Linux发行版本的软件包管理器。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"RPM\">RPM</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>RPM，全称RPM Package Manager，是由Red Hat推出的软件包管理系统，现在在各种发行版中普遍适用。</p>\n</li>\n<li class=\"lvl-2\">\n<p>RRM软件包是将程序源代码经过编译和封装以后形成的包文件，在软件包里面会封装软件的二进制程序、配置文件、帮助手册、库文件以及头文件等。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>rpm</code>默认安装，但是RPM存在依赖关系问题</p>\n</li>\n</ul>\n<h3 id=\"rpm参数说明\">rpm参数说明</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm ［options］ /path/to/rpmfile</span><br><span class=\"line\">　　</span><br><span class=\"line\">option：</span><br><span class=\"line\">　　-i|--install：      安装指定软件</span><br><span class=\"line\">　　-v|--verbose：      显示安装过程</span><br><span class=\"line\">　　-e|--erase：        卸载指定的软件</span><br><span class=\"line\">　　-h|--<span class=\"built_in\">hash</span>：         以<span class=\"comment\">#的方式显示安装进度条，一个#为2%</span></span><br><span class=\"line\">　　-q|--query：        查询rpm相关信息</span><br><span class=\"line\">　　--nodeps：          不检测依赖性安装。软件安装时会检测依赖性，确定所需的底层软件是否安装，如果没有安装则会报错。如果不管依赖性，想强制安装，则可以使用这个选项。注意，这样不检测依赖性安装的软件基本上是不能使用的，所以不建议这样做。</span><br><span class=\"line\">　　--<span class=\"built_in\">test</span>：            测试安装。不会实际安装，只是检测一下依赖性。</span><br><span class=\"line\">　　-U：                升级+安装（如果之前有安装则升级，如果之前没有安装则安装）</span><br><span class=\"line\">　　-F：                升级（如果之前有安装则升级，如果之前没安装则不做任何操作）</span><br><span class=\"line\">　　--replacepkgs：     替换软件包安装。如果软件包已经安装，那么此选项可以把软件包重复安装一遍。</span><br><span class=\"line\">　　--replacefiles：    替换文件安装。如果要安装软件包，但是包中的部分文件已经存在，那么在正常安装时会报<span class=\"string\">&quot;某个文件已经存在&quot;</span>的错误，从而导致软件无法安装。使用这个选项可以忽略这个报错而覆盖安装。</span><br><span class=\"line\">　　--force：           在软件包的安装或升级过程中，如果出现某个文件已经安装或者某一个软件已经安装时</span><br><span class=\"line\">　　                    可以使用 --force 选项强制安装，等同于 --replacepkgs --replacefiles --oldpackage 同时使用</span><br></pre></td></tr></table></figure>\n<h3 id=\"安装rpm\">安装rpm</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 这里以安装jdk举例，先下载jdk的rpm包</span></span><br><span class=\"line\">curl -o ./jdk-17_linux-x64_bin.rpm https://download.oracle.com/java/17/latest/jdk-17_linux-x64_bin.rpm</span><br><span class=\"line\"><span class=\"comment\"># -ivh 安装rpm包，建议安装前先查询当前系统是否已经安装了相关的软件包</span></span><br><span class=\"line\">rpm -ivh jdk-17_linux-x64_bin.rpm</span><br><span class=\"line\"><span class=\"comment\"># --test 只对安装进行测试，不实际安装</span></span><br><span class=\"line\">rpm -ivh --<span class=\"built_in\">test</span> jdk-17_linux-x64_bin.rpm</span><br><span class=\"line\"><span class=\"comment\"># --nodeps 安装时忽略依赖，软件有可能不可用</span></span><br><span class=\"line\">rpm -ivh --nodeps jdk-17_linux-x64_bin.rpm</span><br><span class=\"line\"><span class=\"comment\"># --force 强制安装，如果已经安装过该软件或者有文件冲突都进行强制安装</span></span><br><span class=\"line\">rpm -ivh --force jdk-17_linux-x64_bin.rpm</span><br><span class=\"line\"><span class=\"comment\"># --prefix 指定安装路径，而不使用默认的安装路径，不推荐</span></span><br><span class=\"line\">rpm -ivh --prefix /usr/local/soft/jdk17 jdk-17_linux-x64_bin.rpm</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 升级安装</span></span><br><span class=\"line\">rpm -Uvh jdk-17_linux-x64_bin.rpm</span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>RPM 包默认安装路径</strong></em></p>\n<table>\n<thead>\n<tr>\n<th>安装路径</th>\n<th>含 义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>/etc/</td>\n<td>配置文件安装目录</td>\n</tr>\n<tr>\n<td>/usr/bin/</td>\n<td>可执行的命令安装目录</td>\n</tr>\n<tr>\n<td>/usr/lib/</td>\n<td>程序所使用的函数库保存位置</td>\n</tr>\n<tr>\n<td>/usr/share/doc/</td>\n<td>基本的软件使用手册保存位置</td>\n</tr>\n<tr>\n<td>/usr/share/man/</td>\n<td>帮助文件保存位置</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"rpm-q：查询软件包是否安装\">rpm -q：查询软件包是否安装</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查询当前系统已经安装的所有包</span></span><br><span class=\"line\">rpm -qa</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查询当前系统是否安装了软件包名称中含有jdk的软件包</span></span><br><span class=\"line\">rpm -qa | grep jdk</span><br><span class=\"line\"><span class=\"comment\"># 也可以通过包名查询，就是版本号前面那部分，这里版本号就是17.0.6，与包名之间用-分隔</span></span><br><span class=\"line\">rpm -q jdk-17</span><br><span class=\"line\"><span class=\"comment\"># 通过命令查询是否安装，一般通过yum安装的软件可以通过这种方式进行查询</span></span><br><span class=\"line\">rpm -q zip</span><br></pre></td></tr></table></figure>\n<h3 id=\"rpm-qp：查询rpm包安装后的软件包名称\">rpm -qp：查询rpm包安装后的软件包名称</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查询rpm包安装后的软件包名称，p 表示查询的是rpm文件</span></span><br><span class=\"line\">rpm -qp jdk-17_linux-x64_bin.rpm</span><br></pre></td></tr></table></figure>\n<h3 id=\"rpm-qi：查询软件包的详细信息\">rpm -qi：查询软件包的详细信息</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查询软件包描述信息，通过rpm文件名称</span></span><br><span class=\"line\">rpm -qip jdk-17_linux-x64_bin.rpm</span><br><span class=\"line\"><span class=\"comment\"># 查询软件包描述信息，通过安装后的软件包名称，此时可以不加后面的.x86_64后缀，下面的命令也是这样</span></span><br><span class=\"line\">rpm -qi jdk-17-17.0.6-9.x86_64</span><br><span class=\"line\"><span class=\"comment\"># 也可以通过包名查询，就是版本号前面那部分，这里版本号就是17.0.6，与包名之间用-分隔</span></span><br><span class=\"line\">rpm -qi jdk-17</span><br><span class=\"line\"><span class=\"comment\"># 通过命令查询，一般通过yum安装的软件可以通过这种方式进行查询</span></span><br><span class=\"line\">rpm -qi zip</span><br></pre></td></tr></table></figure>\n<h3 id=\"rpm-ql：命令查询软件包的文件列表\">rpm -ql：命令查询软件包的文件列表</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查询软件包中的文件列表，通过rpm文件名称</span></span><br><span class=\"line\">rpm -qlp jdk-17_linux-x64_bin.rpm</span><br><span class=\"line\"><span class=\"comment\"># 查询软件包中的文件列表，通过安装后的软件包名称</span></span><br><span class=\"line\">rpm -ql jdk-17-17.0.6-9.x86_64</span><br><span class=\"line\"><span class=\"comment\"># 也可以通过包名查询，就是版本号前面那部分，这里版本号就是17.0.6，与包名之间用-分隔</span></span><br><span class=\"line\">rpm -ql jdk-17</span><br><span class=\"line\"><span class=\"comment\"># 通过命令查询，一般通过yum安装的软件可以通过这种方式进行查询</span></span><br><span class=\"line\">rpm -ql zip</span><br></pre></td></tr></table></figure>\n<h3 id=\"rpm-qd：查询被标注为文档的文件列表\">rpm -qd：查询被标注为文档的文件列表</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 显示被标注为文档的文件列表</span></span><br><span class=\"line\">rpm -qdp jdk-17_linux-x64_bin.rpm</span><br><span class=\"line\">rpm -qd jdk-17-17.0.6-9.x86_64</span><br><span class=\"line\"><span class=\"comment\"># 也可以通过包名查询，就是版本号前面那部分，这里版本号就是17.0.6，与包名之间用-分隔</span></span><br><span class=\"line\">rpm -qd jdk-17</span><br><span class=\"line\"><span class=\"comment\"># 通过命令查询，一般通过yum安装的软件可以通过这种方式进行查询</span></span><br><span class=\"line\">rpm -qd zip</span><br></pre></td></tr></table></figure>\n<h3 id=\"rpm-qc：查询被标注为配置文件的文件列表\">rpm -qc：查询被标注为配置文件的文件列表</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 显示被标注为配置文件的文件列表</span></span><br><span class=\"line\">rpm -qcp jdk-17_linux-x64_bin.rpm</span><br><span class=\"line\">rpm -qc jdk-17-17.0.6-9.x86_64</span><br><span class=\"line\"><span class=\"comment\"># 也可以通过包名查询，就是版本号前面那部分，这里版本号就是17.0.6，与包名之间用-分隔</span></span><br><span class=\"line\">rpm -qc jdk-17</span><br><span class=\"line\"><span class=\"comment\"># 通过命令查询，一般通过yum安装的软件可以通过这种方式进行查询</span></span><br><span class=\"line\">rpm -qc zip</span><br></pre></td></tr></table></figure>\n<h3 id=\"rpm-qf：命令查询系统文件属于哪个RPM包\">rpm -qf：命令查询系统文件属于哪个RPM包</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查询系统文件属于哪个RPM包</span></span><br><span class=\"line\">rpm -qf /usr/lib/jvm/jdk-17-oracle-x64/bin/java</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这里注意，只能通过真实文件进行查询，软连接是查询不到的</p>\n</li>\n</ul>\n<h3 id=\"rpm-qR：查询软件包的依赖关系\">rpm -qR：查询软件包的依赖关系</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查询软件包的依赖关系</span></span><br><span class=\"line\">rpm -qRp jdk-17_linux-x64_bin.rpm</span><br><span class=\"line\">rpm -qR jdk-17-17.0.6-9.x86_64</span><br><span class=\"line\"><span class=\"comment\"># 也可以通过包名查询，就是版本号前面那部分，这里版本号就是17.0.6，与包名之间用-分隔</span></span><br><span class=\"line\">rpm -qR jdk-17</span><br><span class=\"line\"><span class=\"comment\"># 通过命令查询，一般通过yum安装的软件可以通过这种方式进行查询</span></span><br><span class=\"line\">rpm -qR zip</span><br></pre></td></tr></table></figure>\n<h3 id=\"卸载rpm\">卸载rpm</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 通过包名卸载指定的软件，此时会检查是否有其它软件对该软件有依赖，如果有依赖则不允许卸载</span></span><br><span class=\"line\">rpm -e jdk-17-17.0.6-9.x86_64</span><br><span class=\"line\"><span class=\"comment\"># 也可以通过包名查询，就是版本号前面那部分，这里版本号就是17.0.6，与包名之间用-分隔</span></span><br><span class=\"line\">rpm -e jdk-17</span><br><span class=\"line\"><span class=\"comment\"># --nodeps :不考虑依赖，强行卸载，不推荐使用，因为这样会导致其它依赖该软件的软件不可用</span></span><br><span class=\"line\">rpm -e --nodeps jdk-17-17.0.6-9.x86_64</span><br></pre></td></tr></table></figure>\n<h3 id=\"解压rpm\">解压rpm</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 解压安装包中的全部文件到当前目录</span></span><br><span class=\"line\">rpm2cpio jdk-17_linux-x64_bin.rpm | cpio -idv</span><br><span class=\"line\"><span class=\"comment\"># 解压安装包中的指定文件到当前目录，/usr/lib/jvm/jdk-17-oracle-x64/bin/java是rpm包中的文件路径，注意前面要加一个点</span></span><br><span class=\"line\">rpm2cpio jdk-17_linux-x64_bin.rpm | cpio -idv ./usr/lib/jvm/jdk-17-oracle-x64/bin/java</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>说明</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\"><code>rpm2cpio</code> : 将rpm包转换为<code>cpio</code>命令能处理的归档包格式。归档包，也可称为文件库，其实就是 <code>cpio</code> 或 <code>tar</code> 格式的文件。</li>\n<li class=\"lvl-6\"><code>cpio</code> 命令可以看做是备份或还原命令，因为它可以将数据（文件）备份到 cpio 归档包，也可以利用 cpio 文档库对数据进行恢复。</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">各选项的含义为：</span><br><span class=\"line\">-i：copy-in 模式，还原；</span><br><span class=\"line\">-v：显示还原过程；</span><br><span class=\"line\">-d：还原时自动新建目录；</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"rpm查看已安装的文件是否被修改过\">rpm查看已安装的文件是否被修改过</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>通过该命令可以快速查询通过<code>rpm</code>或<code>yum</code>安装的软件的相关文件(一般为配置文件)被修改过。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查询系统中已安装的所有软件包</span></span><br><span class=\"line\">$ rpm -Va</span><br><span class=\"line\">.M....G..  g /var/log/lastlog</span><br><span class=\"line\">S.5....T.  c /etc/ssh/sshd_config</span><br><span class=\"line\">S.5....T.  c /etc/NetworkManager/NetworkManager.conf</span><br><span class=\"line\">S.5....T.  c /etc/sudoers</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查询指定软件包</span></span><br><span class=\"line\">$ rpm -V openssh-server</span><br><span class=\"line\">S.5....T.  c /etc/ssh/sshd_config  <span class=\"comment\"># 配置文件 sshd_config 的大小、内容、修改时间被人为修改过。因为我们修改了端口。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 校验某个系统文件是否被修改</span></span><br><span class=\"line\">$ rpm -Vf /etc/ssh/sshd_config</span><br><span class=\"line\">S.5....T.  c /etc/ssh/sshd_config</span><br><span class=\"line\"></span><br><span class=\"line\">可以看到，结果显示了文件被修改的信息。该信息可分为以下 3 部分：</span><br><span class=\"line\">1.最前面的 8 个字符（S.5....T）都属于验证信息，各字符的具体含义如下：</span><br><span class=\"line\">S：文件大小是否改变。</span><br><span class=\"line\">M：文件的类型或文件的权限（rwx）是否改变。</span><br><span class=\"line\">5：文件MD5校验和是否改变（可以看成文件内容是否改变）。</span><br><span class=\"line\">D：设备的主从代码是否改变。</span><br><span class=\"line\">L：文件路径是否改变。</span><br><span class=\"line\">U：文件的属主（所有者）是否改变。</span><br><span class=\"line\">G：文件的属组是否改变。</span><br><span class=\"line\">T：文件的修改时间是否改变。</span><br><span class=\"line\">.：若相关项没发生改变，用 . 表示。</span><br><span class=\"line\"></span><br><span class=\"line\">2.被修改文件类型，大致可分为以下几类：</span><br><span class=\"line\">c：配置文件（configuration file）。</span><br><span class=\"line\">d：普通文档（documentation）。</span><br><span class=\"line\">g：<span class=\"string\">&quot;鬼&quot;</span>文件（ghost file），很少见，就是该文件不应该被这个 RPM 包包含。</span><br><span class=\"line\">l：授权文件（license file）。</span><br><span class=\"line\">r：描述文件（<span class=\"built_in\">read</span> me）。</span><br><span class=\"line\"></span><br><span class=\"line\">3.被修改文件所在绝对路径（包含文件名）。</span><br></pre></td></tr></table></figure>\n<h3 id=\"rpm导入-安装-数字证书-公钥\">rpm导入(安装)数字证书(公钥)</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>数字证书，又称数字签名，由软件开发商直接发布。Linux 系统安装数字证书后，若 RPM 包做了修改，此包携带的数字证书也会改变，将无法与系统成功匹配，软件无法安装。</p>\n</li>\n<li class=\"lvl-2\">\n<p>系统默认证书在 <code>/efc/pki/rpm-gpg/</code> 下</p>\n</li>\n<li class=\"lvl-2\">\n<p>导入证书</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装本机证书，一般这个都会默认安装</span></span><br><span class=\"line\">rpm --import /efc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial</span><br><span class=\"line\"><span class=\"comment\"># 安装第三方证书，如jenkins</span></span><br><span class=\"line\">rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>可以通过 <code>rpm -qa|grep gpg-pubkey</code> 查看已经导入的证书</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rpm -qa|grep gpg-pubkey</span><br><span class=\"line\">gpg-pubkey-8483c65d-5ccc5b19</span><br><span class=\"line\">gpg-pubkey-45f2c3d5-5e81efb9</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>数字证书本身也是一个 RPM 包，因此可以用 rpm 命令查询数字证书的详细信息，也可以将其卸载。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看证书信息</span></span><br><span class=\"line\">rpm -qi gpg-pubkey-8483c65d-5ccc5b19</span><br><span class=\"line\"><span class=\"comment\"># 卸载证书</span></span><br><span class=\"line\">rpm -e gpg-pubkey-8483c65d-5ccc5b19</span><br></pre></td></tr></table></figure>\n<h2 id=\"YUM\">YUM</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>yum</code>，全称<code>Yellow dog Updater, Modified</code>，是一个专门为了解决包的依赖关系而存在的软件包管理器。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>yum</code>是Linux中的 <em><strong>应用市场</strong></em> ，不仅可以通过<code>yum</code>完成软件包的下载、安装、卸载等，还解决了软件之间的依赖，当安装的软件包需要依赖其它软件包时，会一并进行安装。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>yum</code>命令一般为默认安装，<code>yum</code>底层就是基于<code>rpm</code>实现的软件包管理</p>\n</li>\n<li class=\"lvl-2\">\n<p>使用 yum 安装软件包之前，需指定好 yum 下载 RPM 包的位置，此位置称为 yum 源。换句话说，yum 源指的就是软件安装包的来源</p>\n</li>\n<li class=\"lvl-2\">\n<p>yum 源既可以使用网络 yum 源，也可以将本地光盘作为 yum 源。</p>\n</li>\n<li class=\"lvl-2\">\n<p>yum 源默认都是配置好的网络 yum 源，配置文件位于 <code>/etc/yum.repos.d/</code> 目录下，文件扩展名为 <code>*.repo</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>但是CentOS Linux 8 已经于 2021年12月31日 到期，Linux社区已不再维护该操作系统版本和软件源，所以我们可以将yum源切换到阿里云。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 备份原有的源文件</span></span><br><span class=\"line\">rename <span class=\"string\">&#x27;.repo&#x27;</span> <span class=\"string\">&#x27;.repo.bak&#x27;</span> /etc/yum.repos.d/*.repo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下载阿里云的yum源文件，这里下载Centos-8的源文件，其它版本可以在 https://mirrors.aliyun.com/repo/ 中查找</span></span><br><span class=\"line\">curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-8.repo</span><br><span class=\"line\"><span class=\"comment\"># 非官方扩展源，这个也可以不提前下载，可以在配置好yum源后，通过 yum install -y epel-release 进行安装</span></span><br><span class=\"line\"><span class=\"comment\"># 如果在安装软件的时候，没有在Centos-8.repo中找到官方的下载链接，那么yum会自动去epel-release指向的链接处去查找，相当于epel-release给yum提供了更多的下载渠道。</span></span><br><span class=\"line\">curl -o /etc/yum.repos.d/epel-archive-8.repo https://mirrors.aliyun.com/repo/epel-archive-8.repo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清理yum缓存并重新建立缓存</span></span><br><span class=\"line\">yum clean all &amp;&amp; yum makecache</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看当前的yum源信息</span></span><br><span class=\"line\">yum repolist</span><br><span class=\"line\"></span><br><span class=\"line\">仓库 <span class=\"built_in\">id</span>                      仓库名称</span><br><span class=\"line\">AppStream                    CentOS-8 - AppStream - mirrors.aliyun.com</span><br><span class=\"line\">base                         CentOS-8 - Base - mirrors.aliyun.com</span><br><span class=\"line\">epel-archive                 Extra Packages <span class=\"keyword\">for</span> Enterprise Linux 8 - x86_64</span><br><span class=\"line\">extras                       CentOS-8 - Extras - mirrors.aliyun.com</span><br></pre></td></tr></table></figure>\n<h3 id=\"yum配置文件\">yum配置文件</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> /etc/yum.conf</span><br><span class=\"line\"></span><br><span class=\"line\">[main]</span><br><span class=\"line\">cachedir=/var/cache/yum    <span class=\"comment\">#yum下载的RPM包的缓存目录</span></span><br><span class=\"line\">keepcache=0                <span class=\"comment\">#缓存的RPM是否保存，1保存，0不保存。</span></span><br><span class=\"line\">reposdir=/etc/yum.repos.d/ <span class=\"comment\">#指定 .repo 文件的绝对路径</span></span><br><span class=\"line\">debuglevel=2               <span class=\"comment\">#调试级别(0-10)，默认为2(具体调试级别的应用，我也不了解)。</span></span><br><span class=\"line\">logfile=/var/log/yum.log   <span class=\"comment\">#yum的日志文件所在的位置</span></span><br><span class=\"line\">exactarch=1                <span class=\"comment\">#在更新的时候，是否允许更新不同版本的RPM包，</span></span><br><span class=\"line\">                           <span class=\"comment\">#比如是否在i386上更新i686的RPM包。</span></span><br><span class=\"line\">obsoletes=1                <span class=\"comment\">#这是一个update的参数，具体请参阅yum(8)，</span></span><br><span class=\"line\">                           <span class=\"comment\">#简单的说就是相当于upgrade，允许更新陈旧的RPM包。</span></span><br><span class=\"line\">gpgcheck=1                 <span class=\"comment\">#是否检查GPG(GNU Private Guard)，一种密钥方式签名。</span></span><br><span class=\"line\">plugins=1                  <span class=\"comment\">#是否允许使用插件，默认是0不允许，</span></span><br><span class=\"line\">                           <span class=\"comment\">#但是我们一般会用yum-fastestmirror这个插件。</span></span><br><span class=\"line\">installonly_limit=3        <span class=\"comment\">#允许保留多少个内核包。</span></span><br><span class=\"line\">exclude=selinux*           <span class=\"comment\">#屏蔽不想更新的RPM包，可用通配符，多个RPM包之间使用空格分离。</span></span><br><span class=\"line\">distroverpkg=system-release <span class=\"comment\">#指定一个软件包，yum 会根据这个包判断你的发行版本</span></span><br><span class=\"line\"><span class=\"built_in\">timeout</span>=5                  <span class=\"comment\">#下载超时，秒</span></span><br><span class=\"line\">retries=7                  <span class=\"comment\">#下载重试次数</span></span><br><span class=\"line\">proxy=http://0.0.0.0:8080  <span class=\"comment\">#配置代理</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"yum搜索软件\">yum搜索软件</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 显示yum源中可以安装的全部软件</span></span><br><span class=\"line\">yum list</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 搜索指定软件，显示软件名称、版本，以及所属仓库名称</span></span><br><span class=\"line\">yum list zip</span><br><span class=\"line\"><span class=\"comment\"># 默认安装都是安装最新版本，有时我们需要安装某个特定版本的软件包，此时可以使用以下命令列出所有可用的Python 3软件包</span></span><br><span class=\"line\">yum list available python3*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 搜索指定软件，显示软件名称和简介</span></span><br><span class=\"line\">yum search zip</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>搜索时推荐使用<code>yum list zip</code>的形式</p>\n</li>\n</ul>\n<h3 id=\"yum安装\">yum安装</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装过程中需要确认是否安装</span></span><br><span class=\"line\">yum install zip</span><br><span class=\"line\"><span class=\"comment\"># 不需要确认直接安装</span></span><br><span class=\"line\">yum install zip -y</span><br><span class=\"line\"><span class=\"comment\"># 重新安装yum</span></span><br><span class=\"line\">yum reinstall zip</span><br></pre></td></tr></table></figure>\n<h3 id=\"yum卸载\">yum卸载</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 卸载软件，会询问是否卸载</span></span><br><span class=\"line\">yum remove zip</span><br><span class=\"line\"><span class=\"comment\"># 不询问直接卸载</span></span><br><span class=\"line\">yum remove zip -y</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>yum</code>卸载会同时卸载掉依赖包，可以使用<code>rpm</code>卸载单独的软件</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm -qa | grep ^zip</span><br><span class=\"line\">zip-3.0-23.el8.x86_64</span><br><span class=\"line\"></span><br><span class=\"line\">rpm -e --nodeps zip-3.0-23.el8.x86_64</span><br></pre></td></tr></table></figure>\n<h3 id=\"yum升级与降级\">yum升级与降级</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 检查是否有软件需要升级</span></span><br><span class=\"line\">yum check-update</span><br><span class=\"line\"><span class=\"comment\"># 检测指定软件是否可以升级</span></span><br><span class=\"line\">yum check-update zip</span><br><span class=\"line\"><span class=\"comment\"># 升级指定软件包，-y 不询问</span></span><br><span class=\"line\">yum upgrade zip -y</span><br><span class=\"line\"><span class=\"comment\"># 升级全部软件包，-y 不询问</span></span><br><span class=\"line\">yum upgrade -y</span><br><span class=\"line\"><span class=\"comment\"># 升级指定软件包，-y 不询问</span></span><br><span class=\"line\">yum update zip -y</span><br><span class=\"line\"><span class=\"comment\"># 升级全部软件包，-y 不询问</span></span><br><span class=\"line\">yum update -y</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 降级，降回到升级前的版本，-y 不询问</span></span><br><span class=\"line\">yum downgrade zip -y</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装软件包时可能会遇到冲突，比如要安装的软件包与当前已经安装的软件包存在冲突，可以添加  --allowerasing 进行替换安装</span></span><br><span class=\"line\">yum install --allowerasing curl</span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong><code>yum upgrade</code>与<code>yum update</code>的区别</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\"><code>yum</code>配置文件<code>/etc/yum.conf</code>中，如果<code>obsoletes=1</code>，此时两者没有区别，都表示更新旧的rpm包的同时会删除旧包</li>\n<li class=\"lvl-2\">如果<code>obsoletes=0</code>，<code>yum upgrade</code>会删除旧版本的包，而<code>yum update</code>则会保留旧版本的包</li>\n<li class=\"lvl-2\">生产环境中建议使用<code>yum update</code>，防止因为替换，导致旧的软件包依赖出现问题</li>\n</ul>\n</div>\n<h3 id=\"yum查看软件依赖关系\">yum查看软件依赖关系</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum deplist zip</span><br></pre></td></tr></table></figure>\n<h3 id=\"yum查看软件包描述信息\">yum查看软件包描述信息</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 类似于 rpm -qi</span></span><br><span class=\"line\">yum info zip</span><br></pre></td></tr></table></figure>\n<h3 id=\"yum下载rpm包\">yum下载rpm包</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># yumdownloader 命令在软件包 yum-utils 里面</span></span><br><span class=\"line\">yum -y install yum-utils</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 会将docker的rpm包及其相关依赖的rpm包都下载到当前目录</span></span><br><span class=\"line\">yumdownloader --resolve docker</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># --destdir 下载到指定目录</span></span><br><span class=\"line\">yumdownloader --resolve docker --destdir dockerDir</span><br></pre></td></tr></table></figure>\n<h3 id=\"yum组：一次安装一组软件\">yum组：一次安装一组软件</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看可用组，会列出可用组名称</span></span><br><span class=\"line\">yum grouplist</span><br><span class=\"line\">yum group list</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查询组信息，会列出组内包含的所有软件，比如这里查询组名为 Development Tools 的信息</span></span><br><span class=\"line\">yum groupinfo <span class=\"string\">&quot;Development Tools&quot;</span></span><br><span class=\"line\">yum group info <span class=\"string\">&quot;Development Tools&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装组内所有软件</span></span><br><span class=\"line\">yum groupinstall <span class=\"string\">&quot;Development Tools&quot;</span></span><br><span class=\"line\">yum group install <span class=\"string\">&quot;Development Tools&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 卸载组内所有软件</span></span><br><span class=\"line\">yum groupremove <span class=\"string\">&quot;Development Tools&quot;</span></span><br><span class=\"line\">yum group remove <span class=\"string\">&quot;Development Tools&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 升级软件组</span></span><br><span class=\"line\">yum groupupdate <span class=\"string\">&quot;Development Tools&quot;</span></span><br><span class=\"line\">yum group update <span class=\"string\">&quot;Development Tools&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"重建yum元数据缓存\">重建yum元数据缓存</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 清理无效信息</span></span><br><span class=\"line\">yum clean all</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重建缓存</span></span><br><span class=\"line\">yum makecache</span><br><span class=\"line\"><span class=\"comment\"># 或者</span></span><br><span class=\"line\">yum --refresh -v repolist</span><br></pre></td></tr></table></figure>\n<h3 id=\"yum查看仓库配置\">yum查看仓库配置</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 显示启用的仓库简介信息</span></span><br><span class=\"line\">yum repolist</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示全部的仓库简介信息，包括禁用的</span></span><br><span class=\"line\">yum repolist all</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示详细信息</span></span><br><span class=\"line\">yum -v repolist</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># --refresh 显示信息前先重建缓存</span></span><br><span class=\"line\">yum --refresh -v repolist</span><br></pre></td></tr></table></figure>\n<h3 id=\"yum源配置\">yum源配置</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>参数说明</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[xxx]：xxx为源仓库名称，一定要放在[]中。</span><br><span class=\"line\">name：源仓库说明，可以自己随便写。</span><br><span class=\"line\">mirrorlist：镜像站点列表，配置了这个就不需要配置baseurl</span><br><span class=\"line\">baseurl：yum 源仓库服务的地址。</span><br><span class=\"line\">enabled：此源仓库是否生效，如果不写或写成 enabled=1 则表示生效，写成 enabled=0 则表示不生效。</span><br><span class=\"line\">gpgcheck：如果为 1 则表示 RPM 的数字证书生效；如果为 0 则表示 RPM 的数字证书不生效。</span><br><span class=\"line\">gpgkey：数字证书的公钥文件保存位置。gpgcheck=1时需要指定地址，gpgcheck=0时，可以不配置。</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>使用光盘配置本地源</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> /mnt/cdrom</span><br><span class=\"line\"><span class=\"comment\"># 挂载光盘到/mnt/cdrom目录下，也可以将cdrom下的文件拷贝到任意路径下</span></span><br><span class=\"line\">mount /dev/cdrom /mnt/cdrom/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /etc/yum.repos.d</span><br><span class=\"line\"><span class=\"comment\"># 备份原有的源文件</span></span><br><span class=\"line\">rename <span class=\"string\">&#x27;.repo&#x27;</span> <span class=\"string\">&#x27;.repo.bak&#x27;</span> /etc/yum.repos.d/*.repo</span><br><span class=\"line\"></span><br><span class=\"line\">vi local-yum.repo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 内容为：可以参考 CentOS-Linux-Media.repo进行配置</span></span><br><span class=\"line\">[local-yum]</span><br><span class=\"line\">name=local-yum,<span class=\"built_in\">source</span> from cdrom</span><br><span class=\"line\"><span class=\"comment\">#使用光盘挂载的方式  mount /dev/cdrom /mnt/cdrom ，也可以将cdrom下的文件拷贝到任意路径下</span></span><br><span class=\"line\">baseurl=file:///mnt/cdrom</span><br><span class=\"line\"><span class=\"comment\"># 假若你不想软件库缺省是被启用的，可以配置为 enabled=0，此时可以通过 yum --enablerepo mlocal-yum install zip 的方式访问该软件库。</span></span><br><span class=\"line\">enabled=1</span><br><span class=\"line\"><span class=\"comment\"># 不进行数字证书校验</span></span><br><span class=\"line\">gpgcheck=0</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清理yum缓存并重新建立缓存</span></span><br><span class=\"line\">yum clean all &amp;&amp; yum makecache</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看当前的yum源信息</span></span><br><span class=\"line\">yum repolist</span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>小贴士</strong></em><br>\n如果没有光驱，可将系统iso文件上传到服务器，比如在/mnt下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> /mnt/os</span><br><span class=\"line\">mount -t iso9660 -o loop /mnt/CentOS-6.5-x86_64-bin-DVD1.iso /mnt/os</span><br></pre></td></tr></table></figure>\n<p>然后将 baseurl 配置为 file:///mnt/os 即可。</p>\n</div>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>增加网络仓库源<br>\n有些时候，我们安装的软件并不在我们配置好的yum源中，此时我们可以在软件的官方网站上查看到yum安装的相关说明，比如jenkins: <a href=\"https://pkg.jenkins.io/redhat/\">https://pkg.jenkins.io/redhat/</a>，我们只需要按照说明将对应的源添加到系统中即可。</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">1.添加镜像源</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">2.导入jenkins公钥</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">3.安装依赖</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装依赖，如果已经安装则可以跳过此步，jdk版本大于1.8即可</span></span><br><span class=\"line\">yum install fontconfig java-11-openjdk</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">4.安装jenkins</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install -y jenkins</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">5.查看jenkins安装目录</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm -ql jenkins</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">6.启动jenkins</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 默认8080端口，用户：admin 初始密码在 /var/lib/jenkins/secrets/initialAdminPassword</span></span><br><span class=\"line\">systemctl start jenkins</span><br><span class=\"line\">systemctl status jenkins</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">7.插件下载源更换(海外服务器不需要更换)</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Dashboard--Manage Jenkins--Manage Plugins--Advanced settings--Update Site</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># jenkins插件默认下载站点</span></span><br><span class=\"line\">https://updates.jenkins.io/update-center.json</span><br><span class=\"line\"><span class=\"comment\"># 清华源</span></span><br><span class=\"line\">https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"DNF\">DNF</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>从CentOS 8开始，系统默认的软件包管理器是<code>dnf</code>，系统提供的<code>yum</code>命令仅为<code>dnf</code>命令的软链接。<code>dnf</code>是<code>dandified yum</code>的简称，是基于rpm软件包的Linux发行版本的软件包管理器。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>dnf</code>与<code>yum</code>命令的使用和配置方式基本一致，上面介绍的<code>yum</code>命令，直接替换为<code>dnf</code>即可</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>dnf</code>与<code>yum</code>的区别在于：</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">(1)yum禁止删除正在使用的内核，而dnf允许删除所有内核，包括正在使用的内核；</li>\n<li class=\"lvl-6\">(2)在更新软件包时，yum不进行依赖包相关性的检查，而dnf如果检查到存在不相关的依赖包，则不会进行软件包更新。</li>\n<li class=\"lvl-6\">(3)yum在解决依赖包问题时，存在性能较差、内存占用大等问题，而dnf采用了由 SUSE 开发的“libsolv”库，用以提升依赖包解析性能，其依赖包解析速度比yum更快，且比yum消耗更少内存。</li>\n<li class=\"lvl-6\">(4)dnf代码比yum简单，约有29000行代码，而yum代码有59000多行。</li>\n</ul>\n</li>\n</ul>\n","content_text":"摘要 在Linux发行版中，几乎每一个发行版都有自己的软件包管理系统。 常见的有适用于debian、Ubuntu等系统的dpkg、apt-get以及它们的前端aptitude，以及适用于RedHat、Fedora系统的rpm以及它的前端yum。 CentOS系统从属于RedHat系列，其软件包管理系统有RPM和YUM，本文基于CentOS8(x86_64)介绍它们的使用方法。 从CentOS 8开始，系统默认的软件包管理器是dnf，系统提供的yum命令仅为dnf命令的软链接。dnf是dandified yum的简称，是基于rpm软件包的Linux发行版本的软件包管理器。 RPM RPM，全称RPM Package Manager，是由Red Hat推出的软件包管理系统，现在在各种发行版中普遍适用。 RRM软件包是将程序源代码经过编译和封装以后形成的包文件，在软件包里面会封装软件的二进制程序、配置文件、帮助手册、库文件以及头文件等。 rpm默认安装，但是RPM存在依赖关系问题 rpm参数说明 12345678910111213141516rpm ［options］ /path/to/rpmfile option： -i|--install： 安装指定软件 -v|--verbose： 显示安装过程 -e|--erase： 卸载指定的软件 -h|--hash： 以#的方式显示安装进度条，一个#为2% -q|--query： 查询rpm相关信息 --nodeps： 不检测依赖性安装。软件安装时会检测依赖性，确定所需的底层软件是否安装，如果没有安装则会报错。如果不管依赖性，想强制安装，则可以使用这个选项。注意，这样不检测依赖性安装的软件基本上是不能使用的，所以不建议这样做。 --test： 测试安装。不会实际安装，只是检测一下依赖性。 -U： 升级+安装（如果之前有安装则升级，如果之前没有安装则安装） -F： 升级（如果之前有安装则升级，如果之前没安装则不做任何操作） --replacepkgs： 替换软件包安装。如果软件包已经安装，那么此选项可以把软件包重复安装一遍。 --replacefiles： 替换文件安装。如果要安装软件包，但是包中的部分文件已经存在，那么在正常安装时会报&quot;某个文件已经存在&quot;的错误，从而导致软件无法安装。使用这个选项可以忽略这个报错而覆盖安装。 --force： 在软件包的安装或升级过程中，如果出现某个文件已经安装或者某一个软件已经安装时 可以使用 --force 选项强制安装，等同于 --replacepkgs --replacefiles --oldpackage 同时使用 安装rpm 123456789101112131415# 这里以安装jdk举例，先下载jdk的rpm包curl -o ./jdk-17_linux-x64_bin.rpm https://download.oracle.com/java/17/latest/jdk-17_linux-x64_bin.rpm# -ivh 安装rpm包，建议安装前先查询当前系统是否已经安装了相关的软件包rpm -ivh jdk-17_linux-x64_bin.rpm# --test 只对安装进行测试，不实际安装rpm -ivh --test jdk-17_linux-x64_bin.rpm# --nodeps 安装时忽略依赖，软件有可能不可用rpm -ivh --nodeps jdk-17_linux-x64_bin.rpm# --force 强制安装，如果已经安装过该软件或者有文件冲突都进行强制安装rpm -ivh --force jdk-17_linux-x64_bin.rpm# --prefix 指定安装路径，而不使用默认的安装路径，不推荐rpm -ivh --prefix /usr/local/soft/jdk17 jdk-17_linux-x64_bin.rpm# 升级安装rpm -Uvh jdk-17_linux-x64_bin.rpm RPM 包默认安装路径 安装路径 含 义 /etc/ 配置文件安装目录 /usr/bin/ 可执行的命令安装目录 /usr/lib/ 程序所使用的函数库保存位置 /usr/share/doc/ 基本的软件使用手册保存位置 /usr/share/man/ 帮助文件保存位置 rpm -q：查询软件包是否安装 123456789# 查询当前系统已经安装的所有包rpm -qa# 查询当前系统是否安装了软件包名称中含有jdk的软件包rpm -qa | grep jdk# 也可以通过包名查询，就是版本号前面那部分，这里版本号就是17.0.6，与包名之间用-分隔rpm -q jdk-17# 通过命令查询是否安装，一般通过yum安装的软件可以通过这种方式进行查询rpm -q zip rpm -qp：查询rpm包安装后的软件包名称 12# 查询rpm包安装后的软件包名称，p 表示查询的是rpm文件rpm -qp jdk-17_linux-x64_bin.rpm rpm -qi：查询软件包的详细信息 12345678# 查询软件包描述信息，通过rpm文件名称rpm -qip jdk-17_linux-x64_bin.rpm# 查询软件包描述信息，通过安装后的软件包名称，此时可以不加后面的.x86_64后缀，下面的命令也是这样rpm -qi jdk-17-17.0.6-9.x86_64# 也可以通过包名查询，就是版本号前面那部分，这里版本号就是17.0.6，与包名之间用-分隔rpm -qi jdk-17# 通过命令查询，一般通过yum安装的软件可以通过这种方式进行查询rpm -qi zip rpm -ql：命令查询软件包的文件列表 12345678# 查询软件包中的文件列表，通过rpm文件名称rpm -qlp jdk-17_linux-x64_bin.rpm# 查询软件包中的文件列表，通过安装后的软件包名称rpm -ql jdk-17-17.0.6-9.x86_64# 也可以通过包名查询，就是版本号前面那部分，这里版本号就是17.0.6，与包名之间用-分隔rpm -ql jdk-17# 通过命令查询，一般通过yum安装的软件可以通过这种方式进行查询rpm -ql zip rpm -qd：查询被标注为文档的文件列表 1234567# 显示被标注为文档的文件列表rpm -qdp jdk-17_linux-x64_bin.rpmrpm -qd jdk-17-17.0.6-9.x86_64# 也可以通过包名查询，就是版本号前面那部分，这里版本号就是17.0.6，与包名之间用-分隔rpm -qd jdk-17# 通过命令查询，一般通过yum安装的软件可以通过这种方式进行查询rpm -qd zip rpm -qc：查询被标注为配置文件的文件列表 1234567# 显示被标注为配置文件的文件列表rpm -qcp jdk-17_linux-x64_bin.rpmrpm -qc jdk-17-17.0.6-9.x86_64# 也可以通过包名查询，就是版本号前面那部分，这里版本号就是17.0.6，与包名之间用-分隔rpm -qc jdk-17# 通过命令查询，一般通过yum安装的软件可以通过这种方式进行查询rpm -qc zip rpm -qf：命令查询系统文件属于哪个RPM包 12# 查询系统文件属于哪个RPM包rpm -qf /usr/lib/jvm/jdk-17-oracle-x64/bin/java 这里注意，只能通过真实文件进行查询，软连接是查询不到的 rpm -qR：查询软件包的依赖关系 1234567# 查询软件包的依赖关系rpm -qRp jdk-17_linux-x64_bin.rpmrpm -qR jdk-17-17.0.6-9.x86_64# 也可以通过包名查询，就是版本号前面那部分，这里版本号就是17.0.6，与包名之间用-分隔rpm -qR jdk-17# 通过命令查询，一般通过yum安装的软件可以通过这种方式进行查询rpm -qR zip 卸载rpm 123456# 通过包名卸载指定的软件，此时会检查是否有其它软件对该软件有依赖，如果有依赖则不允许卸载rpm -e jdk-17-17.0.6-9.x86_64# 也可以通过包名查询，就是版本号前面那部分，这里版本号就是17.0.6，与包名之间用-分隔rpm -e jdk-17# --nodeps :不考虑依赖，强行卸载，不推荐使用，因为这样会导致其它依赖该软件的软件不可用rpm -e --nodeps jdk-17-17.0.6-9.x86_64 解压rpm 1234# 解压安装包中的全部文件到当前目录rpm2cpio jdk-17_linux-x64_bin.rpm | cpio -idv# 解压安装包中的指定文件到当前目录，/usr/lib/jvm/jdk-17-oracle-x64/bin/java是rpm包中的文件路径，注意前面要加一个点rpm2cpio jdk-17_linux-x64_bin.rpm | cpio -idv ./usr/lib/jvm/jdk-17-oracle-x64/bin/java 说明 rpm2cpio : 将rpm包转换为cpio命令能处理的归档包格式。归档包，也可称为文件库，其实就是 cpio 或 tar 格式的文件。 cpio 命令可以看做是备份或还原命令，因为它可以将数据（文件）备份到 cpio 归档包，也可以利用 cpio 文档库对数据进行恢复。 1234各选项的含义为：-i：copy-in 模式，还原；-v：显示还原过程；-d：还原时自动新建目录； rpm查看已安装的文件是否被修改过 通过该命令可以快速查询通过rpm或yum安装的软件的相关文件(一般为配置文件)被修改过。 1234567891011121314151617181920212223242526272829303132333435# 查询系统中已安装的所有软件包$ rpm -Va.M....G.. g /var/log/lastlogS.5....T. c /etc/ssh/sshd_configS.5....T. c /etc/NetworkManager/NetworkManager.confS.5....T. c /etc/sudoers# 查询指定软件包$ rpm -V openssh-serverS.5....T. c /etc/ssh/sshd_config # 配置文件 sshd_config 的大小、内容、修改时间被人为修改过。因为我们修改了端口。# 校验某个系统文件是否被修改$ rpm -Vf /etc/ssh/sshd_configS.5....T. c /etc/ssh/sshd_config可以看到，结果显示了文件被修改的信息。该信息可分为以下 3 部分：1.最前面的 8 个字符（S.5....T）都属于验证信息，各字符的具体含义如下：S：文件大小是否改变。M：文件的类型或文件的权限（rwx）是否改变。5：文件MD5校验和是否改变（可以看成文件内容是否改变）。D：设备的主从代码是否改变。L：文件路径是否改变。U：文件的属主（所有者）是否改变。G：文件的属组是否改变。T：文件的修改时间是否改变。.：若相关项没发生改变，用 . 表示。2.被修改文件类型，大致可分为以下几类：c：配置文件（configuration file）。d：普通文档（documentation）。g：&quot;鬼&quot;文件（ghost file），很少见，就是该文件不应该被这个 RPM 包包含。l：授权文件（license file）。r：描述文件（read me）。3.被修改文件所在绝对路径（包含文件名）。 rpm导入(安装)数字证书(公钥) 数字证书，又称数字签名，由软件开发商直接发布。Linux 系统安装数字证书后，若 RPM 包做了修改，此包携带的数字证书也会改变，将无法与系统成功匹配，软件无法安装。 系统默认证书在 /efc/pki/rpm-gpg/ 下 导入证书 1234# 安装本机证书，一般这个都会默认安装rpm --import /efc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial# 安装第三方证书，如jenkinsrpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key 可以通过 rpm -qa|grep gpg-pubkey 查看已经导入的证书 123$ rpm -qa|grep gpg-pubkeygpg-pubkey-8483c65d-5ccc5b19gpg-pubkey-45f2c3d5-5e81efb9 数字证书本身也是一个 RPM 包，因此可以用 rpm 命令查询数字证书的详细信息，也可以将其卸载。 1234# 查看证书信息rpm -qi gpg-pubkey-8483c65d-5ccc5b19# 卸载证书rpm -e gpg-pubkey-8483c65d-5ccc5b19 YUM yum，全称Yellow dog Updater, Modified，是一个专门为了解决包的依赖关系而存在的软件包管理器。 yum是Linux中的 应用市场 ，不仅可以通过yum完成软件包的下载、安装、卸载等，还解决了软件之间的依赖，当安装的软件包需要依赖其它软件包时，会一并进行安装。 yum命令一般为默认安装，yum底层就是基于rpm实现的软件包管理 使用 yum 安装软件包之前，需指定好 yum 下载 RPM 包的位置，此位置称为 yum 源。换句话说，yum 源指的就是软件安装包的来源 yum 源既可以使用网络 yum 源，也可以将本地光盘作为 yum 源。 yum 源默认都是配置好的网络 yum 源，配置文件位于 /etc/yum.repos.d/ 目录下，文件扩展名为 *.repo 但是CentOS Linux 8 已经于 2021年12月31日 到期，Linux社区已不再维护该操作系统版本和软件源，所以我们可以将yum源切换到阿里云。 1234567891011121314151617181920# 备份原有的源文件rename &#x27;.repo&#x27; &#x27;.repo.bak&#x27; /etc/yum.repos.d/*.repo# 下载阿里云的yum源文件，这里下载Centos-8的源文件，其它版本可以在 https://mirrors.aliyun.com/repo/ 中查找curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-8.repo# 非官方扩展源，这个也可以不提前下载，可以在配置好yum源后，通过 yum install -y epel-release 进行安装# 如果在安装软件的时候，没有在Centos-8.repo中找到官方的下载链接，那么yum会自动去epel-release指向的链接处去查找，相当于epel-release给yum提供了更多的下载渠道。curl -o /etc/yum.repos.d/epel-archive-8.repo https://mirrors.aliyun.com/repo/epel-archive-8.repo# 清理yum缓存并重新建立缓存yum clean all &amp;&amp; yum makecache# 查看当前的yum源信息yum repolist仓库 id 仓库名称AppStream CentOS-8 - AppStream - mirrors.aliyun.combase CentOS-8 - Base - mirrors.aliyun.comepel-archive Extra Packages for Enterprise Linux 8 - x86_64extras CentOS-8 - Extras - mirrors.aliyun.com yum配置文件 123456789101112131415161718192021cat /etc/yum.conf[main]cachedir=/var/cache/yum #yum下载的RPM包的缓存目录keepcache=0 #缓存的RPM是否保存，1保存，0不保存。reposdir=/etc/yum.repos.d/ #指定 .repo 文件的绝对路径debuglevel=2 #调试级别(0-10)，默认为2(具体调试级别的应用，我也不了解)。logfile=/var/log/yum.log #yum的日志文件所在的位置exactarch=1 #在更新的时候，是否允许更新不同版本的RPM包， #比如是否在i386上更新i686的RPM包。obsoletes=1 #这是一个update的参数，具体请参阅yum(8)， #简单的说就是相当于upgrade，允许更新陈旧的RPM包。gpgcheck=1 #是否检查GPG(GNU Private Guard)，一种密钥方式签名。plugins=1 #是否允许使用插件，默认是0不允许， #但是我们一般会用yum-fastestmirror这个插件。installonly_limit=3 #允许保留多少个内核包。exclude=selinux* #屏蔽不想更新的RPM包，可用通配符，多个RPM包之间使用空格分离。distroverpkg=system-release #指定一个软件包，yum 会根据这个包判断你的发行版本timeout=5 #下载超时，秒retries=7 #下载重试次数proxy=http://0.0.0.0:8080 #配置代理 yum搜索软件 12345678910# 显示yum源中可以安装的全部软件yum list# 搜索指定软件，显示软件名称、版本，以及所属仓库名称yum list zip# 默认安装都是安装最新版本，有时我们需要安装某个特定版本的软件包，此时可以使用以下命令列出所有可用的Python 3软件包yum list available python3*# 搜索指定软件，显示软件名称和简介yum search zip 搜索时推荐使用yum list zip的形式 yum安装 123456# 安装过程中需要确认是否安装yum install zip# 不需要确认直接安装yum install zip -y# 重新安装yumyum reinstall zip yum卸载 1234# 卸载软件，会询问是否卸载yum remove zip# 不询问直接卸载yum remove zip -y yum卸载会同时卸载掉依赖包，可以使用rpm卸载单独的软件 1234rpm -qa | grep ^zipzip-3.0-23.el8.x86_64rpm -e --nodeps zip-3.0-23.el8.x86_64 yum升级与降级 123456789101112131415161718# 检查是否有软件需要升级yum check-update# 检测指定软件是否可以升级yum check-update zip# 升级指定软件包，-y 不询问yum upgrade zip -y# 升级全部软件包，-y 不询问yum upgrade -y# 升级指定软件包，-y 不询问yum update zip -y# 升级全部软件包，-y 不询问yum update -y# 降级，降回到升级前的版本，-y 不询问yum downgrade zip -y# 安装软件包时可能会遇到冲突，比如要安装的软件包与当前已经安装的软件包存在冲突，可以添加 --allowerasing 进行替换安装yum install --allowerasing curl yum upgrade与yum update的区别 yum配置文件/etc/yum.conf中，如果obsoletes=1，此时两者没有区别，都表示更新旧的rpm包的同时会删除旧包 如果obsoletes=0，yum upgrade会删除旧版本的包，而yum update则会保留旧版本的包 生产环境中建议使用yum update，防止因为替换，导致旧的软件包依赖出现问题 yum查看软件依赖关系 1yum deplist zip yum查看软件包描述信息 12# 类似于 rpm -qiyum info zip yum下载rpm包 12345678# yumdownloader 命令在软件包 yum-utils 里面yum -y install yum-utils# 会将docker的rpm包及其相关依赖的rpm包都下载到当前目录yumdownloader --resolve docker# --destdir 下载到指定目录yumdownloader --resolve docker --destdir dockerDir yum组：一次安装一组软件 12345678910111213141516171819# 查看可用组，会列出可用组名称yum grouplistyum group list# 查询组信息，会列出组内包含的所有软件，比如这里查询组名为 Development Tools 的信息yum groupinfo &quot;Development Tools&quot;yum group info &quot;Development Tools&quot;# 安装组内所有软件yum groupinstall &quot;Development Tools&quot;yum group install &quot;Development Tools&quot;# 卸载组内所有软件yum groupremove &quot;Development Tools&quot;yum group remove &quot;Development Tools&quot;# 升级软件组yum groupupdate &quot;Development Tools&quot;yum group update &quot;Development Tools&quot; 重建yum元数据缓存 1234567# 清理无效信息yum clean all# 重建缓存yum makecache# 或者yum --refresh -v repolist yum查看仓库配置 1234567891011# 显示启用的仓库简介信息yum repolist# 显示全部的仓库简介信息，包括禁用的yum repolist all# 显示详细信息yum -v repolist# --refresh 显示信息前先重建缓存yum --refresh -v repolist yum源配置 参数说明 1234567[xxx]：xxx为源仓库名称，一定要放在[]中。name：源仓库说明，可以自己随便写。mirrorlist：镜像站点列表，配置了这个就不需要配置baseurlbaseurl：yum 源仓库服务的地址。enabled：此源仓库是否生效，如果不写或写成 enabled=1 则表示生效，写成 enabled=0 则表示不生效。gpgcheck：如果为 1 则表示 RPM 的数字证书生效；如果为 0 则表示 RPM 的数字证书不生效。gpgkey：数字证书的公钥文件保存位置。gpgcheck=1时需要指定地址，gpgcheck=0时，可以不配置。 使用光盘配置本地源 1234567891011121314151617181920212223242526mkdir /mnt/cdrom# 挂载光盘到/mnt/cdrom目录下，也可以将cdrom下的文件拷贝到任意路径下mount /dev/cdrom /mnt/cdrom/cd /etc/yum.repos.d# 备份原有的源文件rename &#x27;.repo&#x27; &#x27;.repo.bak&#x27; /etc/yum.repos.d/*.repovi local-yum.repo# 内容为：可以参考 CentOS-Linux-Media.repo进行配置[local-yum]name=local-yum,source from cdrom#使用光盘挂载的方式 mount /dev/cdrom /mnt/cdrom ，也可以将cdrom下的文件拷贝到任意路径下baseurl=file:///mnt/cdrom# 假若你不想软件库缺省是被启用的，可以配置为 enabled=0，此时可以通过 yum --enablerepo mlocal-yum install zip 的方式访问该软件库。enabled=1# 不进行数字证书校验gpgcheck=0# 清理yum缓存并重新建立缓存yum clean all &amp;&amp; yum makecache# 查看当前的yum源信息yum repolist 小贴士 如果没有光驱，可将系统iso文件上传到服务器，比如在/mnt下： 12mkdir /mnt/osmount -t iso9660 -o loop /mnt/CentOS-6.5-x86_64-bin-DVD1.iso /mnt/os 然后将 baseurl 配置为 file:///mnt/os 即可。 增加网络仓库源 有些时候，我们安装的软件并不在我们配置好的yum源中，此时我们可以在软件的官方网站上查看到yum安装的相关说明，比如jenkins: https://pkg.jenkins.io/redhat/，我们只需要按照说明将对应的源添加到系统中即可。 1.添加镜像源 1wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo 2.导入jenkins公钥 1rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key 3.安装依赖 12# 安装依赖，如果已经安装则可以跳过此步，jdk版本大于1.8即可yum install fontconfig java-11-openjdk 4.安装jenkins 1yum install -y jenkins 5.查看jenkins安装目录 1rpm -ql jenkins 6.启动jenkins 123# 默认8080端口，用户：admin 初始密码在 /var/lib/jenkins/secrets/initialAdminPasswordsystemctl start jenkinssystemctl status jenkins 7.插件下载源更换(海外服务器不需要更换) 123456Dashboard--Manage Jenkins--Manage Plugins--Advanced settings--Update Site# jenkins插件默认下载站点https://updates.jenkins.io/update-center.json# 清华源https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json DNF 从CentOS 8开始，系统默认的软件包管理器是dnf，系统提供的yum命令仅为dnf命令的软链接。dnf是dandified yum的简称，是基于rpm软件包的Linux发行版本的软件包管理器。 dnf与yum命令的使用和配置方式基本一致，上面介绍的yum命令，直接替换为dnf即可 dnf与yum的区别在于： (1)yum禁止删除正在使用的内核，而dnf允许删除所有内核，包括正在使用的内核； (2)在更新软件包时，yum不进行依赖包相关性的检查，而dnf如果检查到存在不相关的依赖包，则不会进行软件包更新。 (3)yum在解决依赖包问题时，存在性能较差、内存占用大等问题，而dnf采用了由 SUSE 开发的“libsolv”库，用以提升依赖包解析性能，其依赖包解析速度比yum更快，且比yum消耗更少内存。 (4)dnf代码比yum简单，约有29000行代码，而yum代码有59000多行。","summary":"摘要 在Linux发行版中，几乎每一个发行版都有自己的软件包管理系统。 常见的有适用于debian、Ubuntu等系统的dpkg、apt-get以及它们的前端aptitude，以及适用于RedHat、Fedora系统的rpm以及它的前端yum。 CentOS系统从属于RedHat系列，其软件包管理系统有RPM和YUM，本文基于CentOS8(x86_64)介绍它们的使用方法。 从CentOS 8开始，系统默认的软件包管理器是dnf，系统提供的yum命令仅为dnf命令的软链接。dnf是dandified yum的简称，是基于rpm软件包的Linux发行版本的软件包管理器。","date_published":"2023-03-17T13:30:05.000Z","tags":["技术","linux","linux常用命令","linux常用命令"]},{"id":"https://blog.hanqunfeng.com/2023/03/15/linux-command07-xargs/","url":"https://blog.hanqunfeng.com/2023/03/15/linux-command07-xargs/","title":"Linux常用命令--管道符\"|\"、\"xargs\"、文件描述符与重定向","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度 ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍管道符&quot;|&quot;与&quot;xargs&quot;的使用方法。</p>\n</li>\n<li class=\"lvl-2\">\n<p>以及文件描述符与重定向操作符的使用方法。</p>\n</li>\n<li class=\"lvl-2\">\n<p>本文基于<code>CentOS8(x86_64)</code></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"管道符\">管道符&quot;|&quot;</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>管道符主要用于多重命令处理，前面命令的输出结果作为后面命令的输入</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 该命令的作用就是查看文本后排序，然后再去重，最后过滤出含有hello的行并输出</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> test.txt | <span class=\"built_in\">sort</span> | <span class=\"built_in\">uniq</span> | grep <span class=\"string\">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>以上的cat、sort、uniq、grep等命令均支持管道符，一般情况下，处理文本的命令，例如sort、uniq、grep、awk、sed等命令均支持管道，是因为这些命令均可从标准输入中读取要处理的文本（即从标准输入中读取参数）</p>\n</li>\n<li class=\"lvl-2\">\n<p>而对于不是处理文本的命令，例如ls、rm、kill等则不支持从标准输入中读取参数，只支持从命令行中读取参数，而要使其也能从标准输入中读取参数则需要使用<code>xargs</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>命令行参数优先于标准输入即管道符，如<code>cat a.txt | sort b.txt</code>，此时<code>sort</code>仅仅会处理<code>b.txt</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>- </code> 表示标准输入，例如 <code>cat a.txt | sort b.txt -</code>，相当于 <code>sort a.txt b.txt</code></p>\n</li>\n</ul>\n<div class=\"tips\">\n<p><em><strong>命令行参数和标准输入的区别</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">命令行参数\n<blockquote>\n<p>命令行参数就是命令后面的参数<br>\n例如<code>rm test.sh</code>，<code>rm</code>是命令，<code>test.sh</code>就是命令行参数</p>\n</blockquote>\n</li>\n<li class=\"lvl-2\">标准输入\n<blockquote>\n<p>标准输入一般指的是键盘输入，也可用于表示管道符之前命令的输出结果（即打印在屏幕的文本）作为之后命令的标准输入</p>\n</blockquote>\n</li>\n</ul>\n</div>\n<h2 id=\"xargs\">xargs</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>xargs</code>的作用是接收管道符前面命令的输出进行处理后作为命令行参数传递给后续命令，而并不是作为标准输入传递给后续命令。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>xargs</code>以空白字符（空格，tap，换行符均算空白字符）分隔从管道接收的文本，并且将分隔后文本均作为参数</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>xargs</code>常用选项</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">参数\t    解释</span><br><span class=\"line\">-d\t    指定分隔符，不指定默认为空白字符</span><br><span class=\"line\">-p\t    先打印即将执行的命令并询问是否执行</span><br><span class=\"line\">-n\t    指定每次传输给后续命令的参数个数，不指定则全部传递</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 假设当前目录下有a.txt和b.txt，则该命令的含义就是 cat a.txt b.txt</span></span><br><span class=\"line\"><span class=\"built_in\">ls</span> *.txt | xargs <span class=\"built_in\">cat</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 等价于 按顺序执行 cat a.txt 和 cat b.txt</span></span><br><span class=\"line\"><span class=\"built_in\">ls</span> *.txt | xargs -n 1 <span class=\"built_in\">cat</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除文件，执行前先打印命令并询问是否执行，输入y回车后可以执行，仅仅回车不执行</span></span><br><span class=\"line\"><span class=\"built_in\">ls</span> *.txt | xargs -p <span class=\"built_in\">rm</span> -rf</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 杀掉进程</span></span><br><span class=\"line\">ps -ef | grep <span class=\"string\">&#x27;test.sh&#x27;</span> | grep -v <span class=\"string\">&#x27;grep&#x27;</span>| awk <span class=\"string\">&#x27;&#123;print $2&#125;&#x27;</span> | xargs <span class=\"built_in\">kill</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"文件描述符\">文件描述符</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 Linux 系统中，进程通过文件描述符来管理文件，文件描述符就是一个数字以及与之相关联的一堆数据</p>\n</li>\n<li class=\"lvl-2\">\n<p>一个进程打开一个文件，就会创建一个新的文件描述符，这个数字一般是自增的，进程如果关闭文件，这个描述符是可以重复利用的</p>\n</li>\n<li class=\"lvl-2\">\n<p>查看进程关联的文件描述符</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 比如查看`mysqld`的文件描述符</span></span><br><span class=\"line\"><span class=\"comment\"># 先获得mysqld的PID，这里是823</span></span><br><span class=\"line\">$ ps aux | grep mysqld | grep -v <span class=\"string\">&quot;grep&quot;</span></span><br><span class=\"line\">mysql      823  0.0  7.0 1653908 64080 ?       Ssl  3月01   7:50 /usr/sbin/mysqld</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 进入如下目录</span></span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> /proc/823/fd</span><br><span class=\"line\"><span class=\"comment\"># 列出PID为823的进程关联的文件描述符</span></span><br><span class=\"line\">$ <span class=\"built_in\">ls</span></span><br><span class=\"line\">0   12  16  2   23  27  30  34  38  41  45  49  52  56  6   63  67  70  9</span><br><span class=\"line\">1   13  17  20  24  28  31  35  39  42  46  5   53  57  60  64  68  71</span><br><span class=\"line\">10  14  18  21  25  29  32  36  4   43  47  50  54  58  61  65  69  72</span><br><span class=\"line\">11  15  19  22  26  3   33  37  40  44  48  51  55  59  62  66  7   8</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 通过ls -l可以查看到实际关联的文件，这里对文件描述符按数字大小做了排序</span></span><br><span class=\"line\">$ <span class=\"built_in\">ls</span> -l | grep <span class=\"string\">&quot;^l&quot;</span> | <span class=\"built_in\">sort</span> -k 9n | <span class=\"built_in\">head</span> -n 5</span><br><span class=\"line\">lr-x------ 1 mysql mysql 64 3月  13 04:06 0 -&gt; /dev/null</span><br><span class=\"line\">lrwx------ 1 mysql mysql 64 3月  13 04:06 1 -&gt; socket:[16837]</span><br><span class=\"line\">lrwx------ 1 mysql mysql 64 3月  13 04:06 2 -&gt; socket:[16837]</span><br><span class=\"line\">lrwx------ 1 mysql mysql 64 3月  13 04:06 3 -&gt; /var/lib/mysql/aria_log_control</span><br><span class=\"line\">lr-x------ 1 mysql mysql 64 3月  13 04:06 4 -&gt; /var/lib/mysql</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>每一个进程启动的时候，都会默认打开三个文件，用<code>0,1,2</code>来当做他们的描述符</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0 : 标准输入文件(stdin)，代表标准输入，默认指键盘输入</span><br><span class=\"line\">1 : 标准输出文件(stdout)，代表标准输出，标准输出就是命令的输出，默认指向终端屏幕</span><br><span class=\"line\">2 : 标准错误文件(stderr)，代表错误输出，标准错误是命令错误信息的输出，默认指向终端屏幕</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>进程操作所有文件的过程都是一样的，都是先打开一个文件，给他一个文件描述符，然后针对这个描述符进行读或者写</p>\n</li>\n<li class=\"lvl-2\">\n<p>在Linux里，键盘输入这种操作会变成一个文件操作，就类似普通的文件那样，这就是Linux的设计，一切皆是文件</p>\n</li>\n<li class=\"lvl-2\">\n<p>不仅仅键盘操作和屏幕打印是文件操作，网络连接读取数据等等，也都是文件操作，这些也都会产生文件描述符</p>\n</li>\n<li class=\"lvl-2\">\n<p>一个进程同时拥有的文件描述符是有上限的，这个上限可以设置。</p>\n</li>\n<li class=\"lvl-2\">\n<p>我们来解读下面这个命令的执行过程</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> test.txt | grep <span class=\"string\">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">1.<code>cat</code>这个程序打开了test.txt这个文件，将其内容写入 <code>1</code> 这个文件(标准输出)，也就是屏幕上</li>\n<li class=\"lvl-6\">2.管道符<code>|</code>的作用就是将前一个程序的 <code>1</code> (标准输出)绑定到后一个程序的<code>0</code>(标准输入)，这里就是将<code>cat</code>的<code>1</code>绑定到<code>grep</code>的<code>0</code></li>\n<li class=\"lvl-6\">3.然后<code>grep</code> 这个程序就试图从 <code>0</code> 这个文件(标准输入)中读取数据，然后找到包含<code>hello</code>的行，然后把找到的行写入到 <code>1</code> 这个文件(标准输出)中，也就是屏幕上</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"设置文件描述符上限\">设置文件描述符上限</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>文件描述符上限设置分为三个限制级别：系统限制、用户限制、会话限制，最终的上限是这三个限制级别中最小的值</p>\n</li>\n<li class=\"lvl-2\">\n<p>查看及设置系统上限</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> /proc/sys/fs/file-max</span><br><span class=\"line\">或者</span><br><span class=\"line\">sysctl fs.file-max</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> fs.file-max=65535 &gt;&gt; /etc/sysctl.conf</span><br><span class=\"line\">sysctl -p <span class=\"comment\"># 立即生效</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看及设置用户上限</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> /etc/security/limits.conf</span><br><span class=\"line\"><span class=\"comment\"># 设置格式为：</span></span><br><span class=\"line\">　　　　　　username|@groupname <span class=\"built_in\">type</span> resource <span class=\"built_in\">limit</span></span><br><span class=\"line\">　　　　　　username|@groupname：设置需要被限制的用户名，组名前面加@和用户名区别。也可以用通配符*来做所有用户的限制。</span><br><span class=\"line\">　　　　　　<span class=\"built_in\">type</span>：有 soft，hard 和 -，soft 指的是当前系统生效的设置值。hard 表明系统中所能设定的最大值。soft 的限制不能比hard 限制高。用 - 就表明同时设置了 soft 和 hard 的值</span><br><span class=\"line\">　　　　　　resource: 为资源类型有多种。 nofile为最大打开文件数。</span><br><span class=\"line\">　　　　　　例如：* -  nofile 65535  将所有用户的最大打开文件数的soft和hard都设为65535</span><br><span class=\"line\"><span class=\"comment\"># 对/etc/security/limit.conf的修改会在新的会话期中生效</span></span><br><span class=\"line\"><span class=\"comment\"># 设置时一般在文件最后添加如下内容</span></span><br><span class=\"line\">root soft nofile 65535</span><br><span class=\"line\">root hard nofile 65535</span><br><span class=\"line\">* soft nofile 65535</span><br><span class=\"line\">* hard nofile 65535</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>查看及设置会话上限 :默认继承自用户限制级别</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看</span></span><br><span class=\"line\"><span class=\"built_in\">ulimit</span> -Sn :查看会话期最大文件描述符soft限制</span><br><span class=\"line\"><span class=\"built_in\">ulimit</span> -Hn :查看会话期最大文件描述符hard限制，hard限制是soft的上限。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置</span></span><br><span class=\"line\"><span class=\"comment\"># 用ulimit所做的修改在会话期结束后都将失效</span></span><br><span class=\"line\"><span class=\"built_in\">ulimit</span> -Sn 2046 :限制当前会话期内能打开的文件数为2046（如果其中一个进程打开了2046个，其他进程再打文件都将失败）</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>文件描述符使用上限最大能设置多大呢？当然你可以把它往大了设，但是同时打开的文件描述符越多，内存开销就越大。那怎样设置一个合理的上限呢？一个经验算法是 256个fd 需4M内存。例如8G内存，<code>8*1024/4*256=524288</code>。</p>\n</li>\n<li class=\"lvl-2\">\n<p>如果我们在一台机器上部署了自己的网络服务，我们只需按下面步骤修改就可以了：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　1. 计算 fdmax = 物理内存大小(m为单位) / 4 * 256  ,假设内存为8G,fdmax=524288</span><br><span class=\"line\">　　2. 执行命令: <span class=\"built_in\">echo</span> fs.file-max=524288 &gt;&gt; /etc/sysctl.conf</span><br><span class=\"line\">　　3. 执行命令: sysctl -p</span><br><span class=\"line\">　　4. 执行命令: <span class=\"built_in\">echo</span>  * soft nofile  524286 &gt;&gt; /etc/security/limits.conf</span><br><span class=\"line\">　　5. 执行命令: <span class=\"built_in\">echo</span>  * hard nofile 524287 &gt;&gt; /etc/security/limits.conf</span><br><span class=\"line\">　　6. 结束当前会话期</span><br><span class=\"line\">　　7. 启动新的会话</span><br><span class=\"line\">　　8. 启动我们的服务</span><br></pre></td></tr></table></figure>\n<h2 id=\"重定向操作符\">重定向操作符</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>所谓重定向，其含义就是将不同的文件描述符重新定向到其它文件描述符</p>\n</li>\n<li class=\"lvl-2\">\n<p>常用的重定向操作符有如下几种:</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\"><code>&lt;</code> :将文件作为命令的标准输入</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> &lt; test.txt</span><br><span class=\"line\">mysql -uroot -p &lt; databases.sql</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\"><code>&gt;</code> :将命令的输出结果输出到指定文件中，就是将标准输出重定向，且覆盖原文件内容</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 以下两个命令的作用是一样的，都是将标准输出重定向到文件</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> test.txt | grep <span class=\"string\">&quot;hello&quot;</span> &gt; result.txt</span><br><span class=\"line\"><span class=\"built_in\">cat</span> test.txt | grep <span class=\"string\">&quot;hello&quot;</span> 1&gt; result.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 标准输出与标准错误都重定向到文件</span></span><br><span class=\"line\">sh test.sh 1&gt; run.log 2&gt; error.log</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\"><code>&gt;&gt;</code> :将命令的输出结果以 <em><strong>追加</strong></em> 的方式输出到指定文件中</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 以下两个命令的作用是一样的，都是将标准输出重定向到文件</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> test.txt | grep <span class=\"string\">&quot;hello&quot;</span> &gt;&gt; result.txt</span><br><span class=\"line\"><span class=\"built_in\">cat</span> test.txt | grep <span class=\"string\">&quot;hello&quot;</span> 1&gt;&gt; result.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 标准输出与标准错误都重定向到文件</span></span><br><span class=\"line\">sh test.sh &gt;&gt; run.log 2&gt;&gt; error.log</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\"><code>&gt;&amp;</code> :将命令的输出结果或者一个文件描述符重新定向到另一个文件描述符</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 以下两个命令的作用是一样的，都是将标准输出重定向到文件，标准错误重定向且等同于标准输出</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> test.txt | grep <span class=\"string\">&quot;hello&quot;</span> &gt; result.txt 2&gt;&amp;1</span><br><span class=\"line\"><span class=\"built_in\">cat</span> test.txt | grep <span class=\"string\">&quot;hello&quot;</span> 1&gt; result.txt 2&gt;&amp;1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 标准输出重定向到文件，标准错误重定向且等同于标准输出</span></span><br><span class=\"line\">sh test.sh &gt;&gt; run.log 2&gt;&amp;1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 标准输出重定向到空设备文件，也就是不输出也不显示任何信息，标准错误重定向且等同于标准输出，也就是标准错误也重定向到空设备中</span></span><br><span class=\"line\">sh test.sh 1&gt;/dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>\n</li>\n<li class=\"lvl-2\">\n<p>使用重定向操作符时的注意事项</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.标准输入0、标准输出1、标准错误2 需要分别重定向，一个重定向只能改变它们其中一个。</span><br><span class=\"line\">2.文件描述符在重定向符号左侧时可以省略。</span><br><span class=\"line\">3.文件描述符与重定向符号之间不能有空格。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","content_text":"摘要 本文介绍管道符&quot;|&quot;与&quot;xargs&quot;的使用方法。 以及文件描述符与重定向操作符的使用方法。 本文基于CentOS8(x86_64) 管道符&quot;|&quot; 管道符主要用于多重命令处理，前面命令的输出结果作为后面命令的输入 12# 该命令的作用就是查看文本后排序，然后再去重，最后过滤出含有hello的行并输出cat test.txt | sort | uniq | grep &quot;hello&quot; 以上的cat、sort、uniq、grep等命令均支持管道符，一般情况下，处理文本的命令，例如sort、uniq、grep、awk、sed等命令均支持管道，是因为这些命令均可从标准输入中读取要处理的文本（即从标准输入中读取参数） 而对于不是处理文本的命令，例如ls、rm、kill等则不支持从标准输入中读取参数，只支持从命令行中读取参数，而要使其也能从标准输入中读取参数则需要使用xargs 命令行参数优先于标准输入即管道符，如cat a.txt | sort b.txt，此时sort仅仅会处理b.txt - 表示标准输入，例如 cat a.txt | sort b.txt -，相当于 sort a.txt b.txt 命令行参数和标准输入的区别 命令行参数 命令行参数就是命令后面的参数 例如rm test.sh，rm是命令，test.sh就是命令行参数 标准输入 标准输入一般指的是键盘输入，也可用于表示管道符之前命令的输出结果（即打印在屏幕的文本）作为之后命令的标准输入 xargs xargs的作用是接收管道符前面命令的输出进行处理后作为命令行参数传递给后续命令，而并不是作为标准输入传递给后续命令。 xargs以空白字符（空格，tap，换行符均算空白字符）分隔从管道接收的文本，并且将分隔后文本均作为参数 xargs常用选项 1234参数 解释-d 指定分隔符，不指定默认为空白字符-p 先打印即将执行的命令并询问是否执行-n 指定每次传输给后续命令的参数个数，不指定则全部传递 示例 1234567891011# 假设当前目录下有a.txt和b.txt，则该命令的含义就是 cat a.txt b.txtls *.txt | xargs cat# 等价于 按顺序执行 cat a.txt 和 cat b.txtls *.txt | xargs -n 1 cat# 删除文件，执行前先打印命令并询问是否执行，输入y回车后可以执行，仅仅回车不执行ls *.txt | xargs -p rm -rf# 杀掉进程ps -ef | grep &#x27;test.sh&#x27; | grep -v &#x27;grep&#x27;| awk &#x27;&#123;print $2&#125;&#x27; | xargs kill 文件描述符 在 Linux 系统中，进程通过文件描述符来管理文件，文件描述符就是一个数字以及与之相关联的一堆数据 一个进程打开一个文件，就会创建一个新的文件描述符，这个数字一般是自增的，进程如果关闭文件，这个描述符是可以重复利用的 查看进程关联的文件描述符 123456789101112131415161718192021# 比如查看`mysqld`的文件描述符# 先获得mysqld的PID，这里是823$ ps aux | grep mysqld | grep -v &quot;grep&quot;mysql 823 0.0 7.0 1653908 64080 ? Ssl 3月01 7:50 /usr/sbin/mysqld# 进入如下目录$ cd /proc/823/fd# 列出PID为823的进程关联的文件描述符$ ls0 12 16 2 23 27 30 34 38 41 45 49 52 56 6 63 67 70 91 13 17 20 24 28 31 35 39 42 46 5 53 57 60 64 68 7110 14 18 21 25 29 32 36 4 43 47 50 54 58 61 65 69 7211 15 19 22 26 3 33 37 40 44 48 51 55 59 62 66 7 8# 通过ls -l可以查看到实际关联的文件，这里对文件描述符按数字大小做了排序$ ls -l | grep &quot;^l&quot; | sort -k 9n | head -n 5lr-x------ 1 mysql mysql 64 3月 13 04:06 0 -&gt; /dev/nulllrwx------ 1 mysql mysql 64 3月 13 04:06 1 -&gt; socket:[16837]lrwx------ 1 mysql mysql 64 3月 13 04:06 2 -&gt; socket:[16837]lrwx------ 1 mysql mysql 64 3月 13 04:06 3 -&gt; /var/lib/mysql/aria_log_controllr-x------ 1 mysql mysql 64 3月 13 04:06 4 -&gt; /var/lib/mysql 每一个进程启动的时候，都会默认打开三个文件，用0,1,2来当做他们的描述符 1230 : 标准输入文件(stdin)，代表标准输入，默认指键盘输入1 : 标准输出文件(stdout)，代表标准输出，标准输出就是命令的输出，默认指向终端屏幕2 : 标准错误文件(stderr)，代表错误输出，标准错误是命令错误信息的输出，默认指向终端屏幕 进程操作所有文件的过程都是一样的，都是先打开一个文件，给他一个文件描述符，然后针对这个描述符进行读或者写 在Linux里，键盘输入这种操作会变成一个文件操作，就类似普通的文件那样，这就是Linux的设计，一切皆是文件 不仅仅键盘操作和屏幕打印是文件操作，网络连接读取数据等等，也都是文件操作，这些也都会产生文件描述符 一个进程同时拥有的文件描述符是有上限的，这个上限可以设置。 我们来解读下面这个命令的执行过程 1cat test.txt | grep &quot;hello&quot; 1.cat这个程序打开了test.txt这个文件，将其内容写入 1 这个文件(标准输出)，也就是屏幕上 2.管道符|的作用就是将前一个程序的 1 (标准输出)绑定到后一个程序的0(标准输入)，这里就是将cat的1绑定到grep的0 3.然后grep 这个程序就试图从 0 这个文件(标准输入)中读取数据，然后找到包含hello的行，然后把找到的行写入到 1 这个文件(标准输出)中，也就是屏幕上 设置文件描述符上限 文件描述符上限设置分为三个限制级别：系统限制、用户限制、会话限制，最终的上限是这三个限制级别中最小的值 查看及设置系统上限 12345678# 查看cat /proc/sys/fs/file-max或者sysctl fs.file-max# 设置echo fs.file-max=65535 &gt;&gt; /etc/sysctl.confsysctl -p # 立即生效 查看及设置用户上限 1234567891011121314# 查看cat /etc/security/limits.conf# 设置格式为： username|@groupname type resource limit username|@groupname：设置需要被限制的用户名，组名前面加@和用户名区别。也可以用通配符*来做所有用户的限制。 type：有 soft，hard 和 -，soft 指的是当前系统生效的设置值。hard 表明系统中所能设定的最大值。soft 的限制不能比hard 限制高。用 - 就表明同时设置了 soft 和 hard 的值 resource: 为资源类型有多种。 nofile为最大打开文件数。 例如：* - nofile 65535 将所有用户的最大打开文件数的soft和hard都设为65535# 对/etc/security/limit.conf的修改会在新的会话期中生效# 设置时一般在文件最后添加如下内容root soft nofile 65535root hard nofile 65535* soft nofile 65535* hard nofile 65535 查看及设置会话上限 :默认继承自用户限制级别 1234567# 查看ulimit -Sn :查看会话期最大文件描述符soft限制ulimit -Hn :查看会话期最大文件描述符hard限制，hard限制是soft的上限。# 设置# 用ulimit所做的修改在会话期结束后都将失效ulimit -Sn 2046 :限制当前会话期内能打开的文件数为2046（如果其中一个进程打开了2046个，其他进程再打文件都将失败） 文件描述符使用上限最大能设置多大呢？当然你可以把它往大了设，但是同时打开的文件描述符越多，内存开销就越大。那怎样设置一个合理的上限呢？一个经验算法是 256个fd 需4M内存。例如8G内存，8*1024/4*256=524288。 如果我们在一台机器上部署了自己的网络服务，我们只需按下面步骤修改就可以了： 12345678 1. 计算 fdmax = 物理内存大小(m为单位) / 4 * 256 ,假设内存为8G,fdmax=524288 2. 执行命令: echo fs.file-max=524288 &gt;&gt; /etc/sysctl.conf 3. 执行命令: sysctl -p 4. 执行命令: echo * soft nofile 524286 &gt;&gt; /etc/security/limits.conf 5. 执行命令: echo * hard nofile 524287 &gt;&gt; /etc/security/limits.conf 6. 结束当前会话期 7. 启动新的会话 8. 启动我们的服务 重定向操作符 所谓重定向，其含义就是将不同的文件描述符重新定向到其它文件描述符 常用的重定向操作符有如下几种: &lt; :将文件作为命令的标准输入 12cat &lt; test.txtmysql -uroot -p &lt; databases.sql &gt; :将命令的输出结果输出到指定文件中，就是将标准输出重定向，且覆盖原文件内容 123456# 以下两个命令的作用是一样的，都是将标准输出重定向到文件cat test.txt | grep &quot;hello&quot; &gt; result.txtcat test.txt | grep &quot;hello&quot; 1&gt; result.txt# 标准输出与标准错误都重定向到文件sh test.sh 1&gt; run.log 2&gt; error.log &gt;&gt; :将命令的输出结果以 追加 的方式输出到指定文件中 123456# 以下两个命令的作用是一样的，都是将标准输出重定向到文件cat test.txt | grep &quot;hello&quot; &gt;&gt; result.txtcat test.txt | grep &quot;hello&quot; 1&gt;&gt; result.txt# 标准输出与标准错误都重定向到文件sh test.sh &gt;&gt; run.log 2&gt;&gt; error.log &gt;&amp; :将命令的输出结果或者一个文件描述符重新定向到另一个文件描述符 123456789# 以下两个命令的作用是一样的，都是将标准输出重定向到文件，标准错误重定向且等同于标准输出cat test.txt | grep &quot;hello&quot; &gt; result.txt 2&gt;&amp;1cat test.txt | grep &quot;hello&quot; 1&gt; result.txt 2&gt;&amp;1# 标准输出重定向到文件，标准错误重定向且等同于标准输出sh test.sh &gt;&gt; run.log 2&gt;&amp;1# 标准输出重定向到空设备文件，也就是不输出也不显示任何信息，标准错误重定向且等同于标准输出，也就是标准错误也重定向到空设备中sh test.sh 1&gt;/dev/null 2&gt;&amp;1 使用重定向操作符时的注意事项 1231.标准输入0、标准输出1、标准错误2 需要分别重定向，一个重定向只能改变它们其中一个。2.文件描述符在重定向符号左侧时可以省略。3.文件描述符与重定向符号之间不能有空格。","summary":"摘要 本文介绍管道符&quot;|&quot;与&quot;xargs&quot;的使用方法。 以及文件描述符与重定向操作符的使用方法。 本文基于CentOS8(x86_64)","date_published":"2023-03-15T13:30:05.000Z","tags":["技术","linux","linux常用命令","linux常用命令"]},{"id":"https://blog.hanqunfeng.com/2023/03/13/linux-command06-$/","url":"https://blog.hanqunfeng.com/2023/03/13/linux-command06-$/","title":"Linux常用命令--各种符号","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度 ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>文本介绍linux编程中会用到的各种符号的使用方法</p>\n</li>\n<li class=\"lvl-2\">\n<p>特殊变量: $0、$?、$*、$@、$#、$$、$_、$!</p>\n</li>\n<li class=\"lvl-2\">\n<p>&amp;和&amp;&amp;、|和||</p>\n</li>\n<li class=\"lvl-2\">\n<p>命令替换: $( ) 与 ``</p>\n</li>\n<li class=\"lvl-2\">\n<p>整数运算: $(( )) 与 $[ ]</p>\n</li>\n<li class=\"lvl-2\">\n<p>条件判断: (( ))、[ ]与[[ ]]</p>\n</li>\n<li class=\"lvl-2\">\n<p>变量引用: $ 与 ${ }</p>\n</li>\n<li class=\"lvl-2\">\n<p>本文基于<code>CentOS8(x86_64)</code></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"特殊变量-0、-、-、-、-、-、\">特殊变量: <code>$0、$?、$*、$@、$#、$$、$!</code></h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>$0</code> : 当前脚本的文件名（间接运行时还包括绝对路径）。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>$n</code> : 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是 $1 。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>$#</code> : 传递给脚本或函数的参数个数。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>$*</code> : 传递给脚本或函数的所有参数。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>$@</code> : 传递给脚本或函数的所有参数。被双引号 <code>&quot;$@&quot;</code> 包含时，与 <code>&quot;$*&quot;</code> 不同，下面将会讲到。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>$?</code> : 上个命令的退出状态(0:success 非0:error)，或函数的返回值。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>$$</code> : 当前 Shell 进程 ID。对于 Shell 脚本，就是这些脚本所在的进程 ID。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>$_</code> : 上一个命令的最后一个参数</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>$!</code> : 后台运行的最后一个进程的 ID 号</p>\n</li>\n</ul>\n<blockquote>\n<p><code>$*</code> 和 <code>$@</code> 都表示传递给函数或脚本的所有参数，不被双引号 <code>&quot;&quot;</code> 包含时，都以独立个体<code>&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot;</code> 的形式输出所有参数。<br>\n但是当它们被双引号 <code>&quot;&quot;</code> 包含时，<code>&quot;$*&quot;</code>会将所有的参数作为一个整体输出，<code>&quot;$@&quot;</code>依旧会以独立个体<code>&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot;</code> 的形式输出所有参数。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># $*</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> $*</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"variable\">$i</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"comment\"># sh test.sh 1 2 3 4，此时输出</span></span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># &quot;$*&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"string\">&quot;$*&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"variable\">$i</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"comment\"># sh test.sh 1 2 3 4，此时输出</span></span><br><span class=\"line\">1 2 3 4</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># $@</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"variable\">$@</span></span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"variable\">$i</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"comment\"># sh test.sh 1 2 3 4，此时输出</span></span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># &quot;$@&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"string\">&quot;<span class=\"variable\">$@</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"variable\">$i</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"comment\"># sh test.sh 1 2 3 4，此时输出</span></span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>获取参数数量：</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">paramSize=<span class=\"variable\">$&#123;#@&#125;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"和-、-和\"><code>&amp;</code>和<code>&amp;&amp;</code>、<code>|</code>和<code>||</code></h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>&amp;</code>  表示任务在后台执行，如要在后台运行redis-server,则有 <code>redis-server &amp;</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>&amp;&amp;</code> 表示前一条命令执行成功时，才执行后一条命令 ，如 <code>make &amp;&amp; make install</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>|</code> 表示管道，上一条命令的输出，作为下一条命令参数，如 <code>cat text.txt | wc -l</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>||</code> 表示上一条命令执行失败后，才执行下一条命令，如 <code>grep &quot;success&quot; run.log || echo &quot;fail&quot;</code></p>\n</li>\n</ul>\n<h2 id=\"命令替换-与\">命令替换: <code>$( )</code> 与 ``</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>$( )</code> 与 `` 都是用来作命令替换的，优先执行括号或者反引号中的命令，并将结果替换出来组成新的命令</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 以下命令效果相同</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> today is `<span class=\"built_in\">date</span> <span class=\"string\">&quot;+%Y-%m-%d&quot;</span>`</span><br><span class=\"line\"><span class=\"built_in\">echo</span> today is $(<span class=\"built_in\">date</span> <span class=\"string\">&quot;+%Y-%m-%d&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">today=`<span class=\"built_in\">date</span> <span class=\"string\">&quot;+%Y-%m-%d&quot;</span>`</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$today</span></span><br><span class=\"line\">today=$(<span class=\"built_in\">date</span> <span class=\"string\">&quot;+%Y-%m-%d&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$today</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>推荐使用<code>$( )</code>，因为在多层次的复合替换中，内部的`` 必须要进行转义，而$( )比较直观</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#  cmd3 `cmd2 \\`cmd1\\``</span></span><br><span class=\"line\">sh echo.sh <span class=\"string\">&quot;`echo today is \\`date &quot;</span>+%Y-%m-%d<span class=\"string\">&quot;\\``&quot;</span></span><br><span class=\"line\"><span class=\"comment\">#  cmd3 $(cmd2 $(cmd1))</span></span><br><span class=\"line\">sh echo.sh <span class=\"string\">&quot;<span class=\"subst\">$(echo today is $(date <span class=\"string\">&quot;+%Y-%m-%d&quot;</span>)</span>)&quot;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"整数运算-与\">整数运算: <code>$(( ))</code> 与 <code>$[ ]</code></h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>$(( ))</code>用于执行整数计算，等价于<code>$[ ]</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> $(( <span class=\"number\">3</span>+<span class=\"number\">5</span> ))</span><br><span class=\"line\"><span class=\"built_in\">echo</span> $[ 3+5 ]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> $(( (<span class=\"number\">3</span>+<span class=\"number\">5</span>)*<span class=\"number\">4</span>/<span class=\"number\">2</span> ))</span><br><span class=\"line\"><span class=\"built_in\">echo</span> $[ (3+5)*4/2 ]</span><br></pre></td></tr></table></figure>\n<h2 id=\"条件判断-、-和\">条件判断: <code>(( ))</code>、<code>[ ]</code>和<code>[[ ]]</code></h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在使用<code>if</code>或<code>while</code>等语句时，需要进行条件判断，<code>(( ))</code>、<code>[ ]</code>和<code>[[ ]]</code>都可以用来进行条件判断，那么他们之间有什么区别吗？</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\"><code>[ ]</code>是<code>test</code>命令的另一种形式，例如 <code>test a == b</code> 等同于 <code>[ a == b ]</code>，注意 <code>[</code> 后和 <code>]</code> 前都需要有空格，并且<code>==</code>两边也都要有空格</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">test</span> <span class=\"string\">&#x27;hello&#x27;</span> != <span class=\"string\">&#x27;world&#x27;</span> ==&gt;  [ <span class=\"string\">&#x27;hello&#x27;</span> != <span class=\"string\">&#x27;world&#x27;</span> ]</span><br><span class=\"line\"><span class=\"built_in\">test</span> ! -e test.sh       ==&gt;  [ ! -e test.sh ]</span><br><span class=\"line\"><span class=\"built_in\">test</span> <span class=\"variable\">$i</span> -lt 5           ==&gt;  [ <span class=\"variable\">$i</span> -lt 5 ]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\"><code>[[ ]]</code>是<code>[ ]</code>的增强版，其在如下几个方面进行了增强:\n<ul class=\"lvl-4\">\n<li class=\"lvl-10\">1.在<code>[[ ]]</code>中使用<code>&gt;</code>、<code>&lt;</code> 进行数值比较时不需要转义，但是不支持<code>&gt;=</code>、<code>&lt;=</code></li>\n<li class=\"lvl-10\">2.支持<code>&amp;&amp;</code>和<code>||</code></li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 以下三种作用相同</span></span><br><span class=\"line\">[[ <span class=\"variable\">$a</span> &gt; 3 &amp;&amp; <span class=\"variable\">$a</span> != 10 ]]</span><br><span class=\"line\">[ <span class=\"variable\">$a</span> &gt; 3 -a <span class=\"variable\">$a</span> != 10 ]</span><br><span class=\"line\">[ <span class=\"variable\">$a</span> &gt; 3 ] &amp;&amp; [ <span class=\"variable\">$a</span> != 10 ]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-4\">\n<li class=\"lvl-10\">3.<code>[[ ]]</code>在比较字符串时支持正则匹配和通配符匹配</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 通配符匹配</span></span><br><span class=\"line\">a=<span class=\"string\">&quot;linux&quot;</span></span><br><span class=\"line\">[[ <span class=\"variable\">$a</span> == l?nu? ]] <span class=\"comment\"># 0</span></span><br><span class=\"line\">[[ <span class=\"variable\">$a</span> != li* ]]   <span class=\"comment\"># 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 正则匹配 `=~`</span></span><br><span class=\"line\">a=<span class=\"string\">&quot;linux&quot;</span></span><br><span class=\"line\">[[ <span class=\"variable\">$a</span> =~ ^li ]]</span><br><span class=\"line\">[[ <span class=\"variable\">$a</span> =~ ^li[abn]ux ]]</span><br></pre></td></tr></table></figure>\n</li>\n<li class=\"lvl-6\"><code>(( ))</code> 用于条件判断时只能进行数值比较，运算符不需要转义，而且不支持<code>-lt</code>、<code>-gt</code>等等  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(( <span class=\"variable\">$i</span> &lt;= 5 ))</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<div class=\"tips\">\n<p><em><strong>小贴士</strong></em><br>\n<code>(( ))</code>除了用于条件判断外，还有三种用法：<br>\n1.与<code>$</code>结合使用进行数学运算 : <code>$(( ))</code><br>\n2.在<code>for</code>循环命令中控制循环 : <code>for((i=1;i&lt;10;i++))</code><br>\n3.改变变量的值，且变量前不需要<code>$</code> : <code>((i++))</code></p>\n</div>\n</li>\n<li class=\"lvl-2\">\n<p>推荐在进行条件判断时使用<code>[[ ]]</code>，运算符不需要转义，而且支持正则</p>\n</li>\n</ul>\n<h2 id=\"变量引用-与\">变量引用: <code>$</code> 与 <code>$&#123; &#125;</code></h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>$</code>与<code>$&#123; &#125;</code>都是用来引用变量的，<code>$&#123; &#125;</code>通常用于划定变量名的边界，当执行 <code>echo &quot;$aa&quot;</code>的时候系统会打印变量<code>$aa</code>的值，当执行<code>echo &quot;$&#123;a&#125;a&quot;</code>时打印的是<code>$&#123;a&#125;</code>和字母a，如果不需要为变量名划分边界的话，<code>$a</code>和<code>$&#123;a&#125;</code>是完全相等的。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">today=`<span class=\"built_in\">date</span> <span class=\"string\">&quot;+%Y-%m-%d&quot;</span>`</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$today</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;today&#125;</span>_now</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>$&#123; &#125;</code>还有一个重要的功能，就是文本处理:</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">1.获取字符串长度</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str=<span class=\"string\">&#x27;hello&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;#str&#125;</span> <span class=\"comment\"># 5</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">2.字符串切片<code>$&#123;a:b:c&#125;</code>: 将字符串变量<code>a</code>从第<code>b</code>个位置开始向后截取<code>c</code>个字符，b是指下标，下标从0开始，<code>c</code>可以不指定，表示截取到字符串末尾</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=<span class=\"string\">&#x27;hello world!&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;a:0:5&#125;</span> <span class=\"comment\"># hello</span></span><br><span class=\"line\"><span class=\"comment\"># 不指定c，表示从第6个字符开始截取到字符串末尾</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;a:6&#125;</span> <span class=\"comment\"># world!</span></span><br><span class=\"line\"><span class=\"comment\"># 截取从倒数第一个字符开始到字符串末尾的字符</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;a:(-1)&#125;</span> <span class=\"comment\"># !</span></span><br><span class=\"line\"><span class=\"comment\"># 截取从倒数第 6 个字符后的 5 个字符</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;a:(-6):5&#125;</span> <span class=\"comment\"># world</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">3.替换字符串<code>$&#123;a/b/c&#125;</code>: 将变量<code>a</code>中的<code>b</code>全部替换为<code>c</code>，开头一个正斜杠为只匹配第一个字符串，两个正斜杠为匹配所有字符。</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=<span class=\"string\">&#x27;hello hello world&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$&#123;a/hello/hi&#125;</span>&quot;</span> <span class=\"comment\"># hi hello world</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$&#123;a//hello/hi&#125;</span>&quot;</span> <span class=\"comment\"># hi hi world</span></span><br><span class=\"line\"><span class=\"comment\"># 支持正则</span></span><br><span class=\"line\">str=123abc</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;str//[^0-9]/&#125;</span> <span class=\"comment\"># 123，将非数字替换为空</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;str//[0-9]/&#125;</span> <span class=\"comment\"># abc，将数字替换为空</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">4.字符串截取</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 格式：</span></span><br><span class=\"line\"><span class=\"comment\"># 删除匹配前缀</span></span><br><span class=\"line\"><span class=\"variable\">$&#123;parameter#word&#125;</span></span><br><span class=\"line\"><span class=\"variable\">$&#123;parameter##word&#125;</span></span><br><span class=\"line\"><span class=\"comment\"># 删除匹配后缀</span></span><br><span class=\"line\"><span class=\"variable\">$&#123;parameter%word&#125;</span></span><br><span class=\"line\"><span class=\"variable\">$&#123;parameter%%word&#125;</span></span><br><span class=\"line\"><span class=\"comment\"># 去掉左边，#最短匹配模式，##最长匹配模式。</span></span><br><span class=\"line\">% 去掉右边，%最短匹配模式，%%最长匹配模式。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\">URL=<span class=\"string\">&quot;http://www.baidu.com/baike/user.html&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 匹配http://，以//为分隔符截取出右边字符串</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;URL#*//&#125;</span> <span class=\"comment\"># www.baidu.com/baike/user.html</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 以/为分隔符截取右边字符串，##表示尽可能多的删除，保留最少内容</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;URL##*/&#125;</span> <span class=\"comment\"># user.html</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;URL#*/&#125;</span>  <span class=\"comment\"># /www.baidu.com/baike/user.html</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 以/为分隔符截取左边字符串，%%表示尽可能多的删除，即保留最少内容</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;URL%%/*&#125;</span> <span class=\"comment\"># http:</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;URL%/*&#125;</span> <span class=\"comment\"># http://www.baidu.com/baike</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">5.变量状态赋值</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 格式</span></span><br><span class=\"line\"><span class=\"variable\">$&#123;VAR:-string&#125;</span> <span class=\"comment\"># 如果 VAR 变量为空则返回 string</span></span><br><span class=\"line\"><span class=\"variable\">$&#123;VAR:+string&#125;</span> <span class=\"comment\"># 如果 VAR 变量不为空则返回 string</span></span><br><span class=\"line\"><span class=\"variable\">$&#123;VAR:=string&#125;</span> <span class=\"comment\"># 如果 VAR 变量为空则重新赋值 VAR 变量值为 string</span></span><br><span class=\"line\"><span class=\"variable\">$&#123;VAR:?string&#125;</span> <span class=\"comment\"># 如果 VAR 变量为空则将 string 输出到 stderr</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\"><span class=\"comment\"># 如果变量为空就返回 hello world!</span></span><br><span class=\"line\">VAR=</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;VAR:-&#x27;hello world!&#x27;&#125;</span> <span class=\"comment\"># hello world!</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$VAR</span> <span class=\"comment\"># 空</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果变量不为空就返回 hello world!</span></span><br><span class=\"line\">VAR=<span class=\"string\">&quot;hello&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;VAR:+&#x27;hello world!&#x27;&#125;</span> <span class=\"comment\"># hello world!</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$VAR</span> <span class=\"comment\"># hello</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#如果变量为空就重新赋值：</span></span><br><span class=\"line\">VAR=</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;VAR:=hello&#125;</span> <span class=\"comment\"># hello</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$VAR</span> <span class=\"comment\"># hello</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果变量为空就将信息输出 stderr</span></span><br><span class=\"line\">VAR=</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;VAR:?value is null&#125;</span> <span class=\"comment\"># -bash: VAR: value is null</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n","content_text":"摘要 文本介绍linux编程中会用到的各种符号的使用方法 特殊变量: $0、$?、$*、$@、$#、$$、$_、$! &amp;和&amp;&amp;、|和|| 命令替换: $( ) 与 `` 整数运算: $(( )) 与 $[ ] 条件判断: (( ))、[ ]与[[ ]] 变量引用: $ 与 ${ } 本文基于CentOS8(x86_64) 特殊变量: $0、$?、$*、$@、$#、$$、$! $0 : 当前脚本的文件名（间接运行时还包括绝对路径）。 $n : 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是 $1 。 $# : 传递给脚本或函数的参数个数。 $* : 传递给脚本或函数的所有参数。 $@ : 传递给脚本或函数的所有参数。被双引号 &quot;$@&quot; 包含时，与 &quot;$*&quot; 不同，下面将会讲到。 $? : 上个命令的退出状态(0:success 非0:error)，或函数的返回值。 $$ : 当前 Shell 进程 ID。对于 Shell 脚本，就是这些脚本所在的进程 ID。 $_ : 上一个命令的最后一个参数 $! : 后台运行的最后一个进程的 ID 号 $* 和 $@ 都表示传递给函数或脚本的所有参数，不被双引号 &quot;&quot; 包含时，都以独立个体&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; 的形式输出所有参数。 但是当它们被双引号 &quot;&quot; 包含时，&quot;$*&quot;会将所有的参数作为一个整体输出，&quot;$@&quot;依旧会以独立个体&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; 的形式输出所有参数。 12345678910111213141516171819202122232425262728293031323334353637383940# $*for i in $*do echo $idone# sh test.sh 1 2 3 4，此时输出1234# &quot;$*&quot;for i in &quot;$*&quot;do echo $idone# sh test.sh 1 2 3 4，此时输出1 2 3 4# $@for i in $@do echo $idone# sh test.sh 1 2 3 4，此时输出1234# &quot;$@&quot;for i in &quot;$@&quot;do echo $idone# sh test.sh 1 2 3 4，此时输出1234 获取参数数量： 1paramSize=$&#123;#@&#125; &amp;和&amp;&amp;、|和|| &amp; 表示任务在后台执行，如要在后台运行redis-server,则有 redis-server &amp; &amp;&amp; 表示前一条命令执行成功时，才执行后一条命令 ，如 make &amp;&amp; make install | 表示管道，上一条命令的输出，作为下一条命令参数，如 cat text.txt | wc -l || 表示上一条命令执行失败后，才执行下一条命令，如 grep &quot;success&quot; run.log || echo &quot;fail&quot; 命令替换: $( ) 与 `` $( ) 与 `` 都是用来作命令替换的，优先执行括号或者反引号中的命令，并将结果替换出来组成新的命令 12345678# 以下命令效果相同echo today is `date &quot;+%Y-%m-%d&quot;`echo today is $(date &quot;+%Y-%m-%d&quot;)today=`date &quot;+%Y-%m-%d&quot;`echo $todaytoday=$(date &quot;+%Y-%m-%d&quot;)echo $today 推荐使用$( )，因为在多层次的复合替换中，内部的`` 必须要进行转义，而$( )比较直观 1234# cmd3 `cmd2 \\`cmd1\\``sh echo.sh &quot;`echo today is \\`date &quot;+%Y-%m-%d&quot;\\``&quot;# cmd3 $(cmd2 $(cmd1))sh echo.sh &quot;$(echo today is $(date &quot;+%Y-%m-%d&quot;))&quot; 整数运算: $(( )) 与 $[ ] $(( ))用于执行整数计算，等价于$[ ] 12345echo $(( 3+5 ))echo $[ 3+5 ]echo $(( (3+5)*4/2 ))echo $[ (3+5)*4/2 ] 条件判断: (( ))、[ ]和[[ ]] 在使用if或while等语句时，需要进行条件判断，(( ))、[ ]和[[ ]]都可以用来进行条件判断，那么他们之间有什么区别吗？ [ ]是test命令的另一种形式，例如 test a == b 等同于 [ a == b ]，注意 [ 后和 ] 前都需要有空格，并且==两边也都要有空格 123test &#x27;hello&#x27; != &#x27;world&#x27; ==&gt; [ &#x27;hello&#x27; != &#x27;world&#x27; ]test ! -e test.sh ==&gt; [ ! -e test.sh ]test $i -lt 5 ==&gt; [ $i -lt 5 ] [[ ]]是[ ]的增强版，其在如下几个方面进行了增强: 1.在[[ ]]中使用&gt;、&lt; 进行数值比较时不需要转义，但是不支持&gt;=、&lt;= 2.支持&amp;&amp;和|| 1234# 以下三种作用相同[[ $a &gt; 3 &amp;&amp; $a != 10 ]][ $a &gt; 3 -a $a != 10 ][ $a &gt; 3 ] &amp;&amp; [ $a != 10 ] 3.[[ ]]在比较字符串时支持正则匹配和通配符匹配 123456789# 通配符匹配a=&quot;linux&quot;[[ $a == l?nu? ]] # 0[[ $a != li* ]] # 1# 正则匹配 `=~`a=&quot;linux&quot;[[ $a =~ ^li ]][[ $a =~ ^li[abn]ux ]] (( )) 用于条件判断时只能进行数值比较，运算符不需要转义，而且不支持-lt、-gt等等 1(( $i &lt;= 5 )) 小贴士 (( ))除了用于条件判断外，还有三种用法： 1.与$结合使用进行数学运算 : $(( )) 2.在for循环命令中控制循环 : for((i=1;i&lt;10;i++)) 3.改变变量的值，且变量前不需要$ : ((i++)) 推荐在进行条件判断时使用[[ ]]，运算符不需要转义，而且支持正则 变量引用: $ 与 $&#123; &#125; $与$&#123; &#125;都是用来引用变量的，$&#123; &#125;通常用于划定变量名的边界，当执行 echo &quot;$aa&quot;的时候系统会打印变量$aa的值，当执行echo &quot;$&#123;a&#125;a&quot;时打印的是$&#123;a&#125;和字母a，如果不需要为变量名划分边界的话，$a和$&#123;a&#125;是完全相等的。 123today=`date &quot;+%Y-%m-%d&quot;`echo $todayecho $&#123;today&#125;_now $&#123; &#125;还有一个重要的功能，就是文本处理: 1.获取字符串长度 12str=&#x27;hello&#x27;echo $&#123;#str&#125; # 5 2.字符串切片$&#123;a:b:c&#125;: 将字符串变量a从第b个位置开始向后截取c个字符，b是指下标，下标从0开始，c可以不指定，表示截取到字符串末尾 12345678a=&#x27;hello world!&#x27;echo $&#123;a:0:5&#125; # hello# 不指定c，表示从第6个字符开始截取到字符串末尾echo $&#123;a:6&#125; # world!# 截取从倒数第一个字符开始到字符串末尾的字符echo $&#123;a:(-1)&#125; # !# 截取从倒数第 6 个字符后的 5 个字符echo $&#123;a:(-6):5&#125; # world 3.替换字符串$&#123;a/b/c&#125;: 将变量a中的b全部替换为c，开头一个正斜杠为只匹配第一个字符串，两个正斜杠为匹配所有字符。 1234567a=&#x27;hello hello world&#x27;echo &quot;$&#123;a/hello/hi&#125;&quot; # hi hello worldecho &quot;$&#123;a//hello/hi&#125;&quot; # hi hi world# 支持正则str=123abcecho $&#123;str//[^0-9]/&#125; # 123，将非数字替换为空echo $&#123;str//[0-9]/&#125; # abc，将数字替换为空 4.字符串截取 12345678910111213141516171819202122# 格式：# 删除匹配前缀$&#123;parameter#word&#125;$&#123;parameter##word&#125;# 删除匹配后缀$&#123;parameter%word&#125;$&#123;parameter%%word&#125;# 去掉左边，#最短匹配模式，##最长匹配模式。% 去掉右边，%最短匹配模式，%%最长匹配模式。# 示例URL=&quot;http://www.baidu.com/baike/user.html&quot;# 匹配http://，以//为分隔符截取出右边字符串echo $&#123;URL#*//&#125; # www.baidu.com/baike/user.html# 以/为分隔符截取右边字符串，##表示尽可能多的删除，保留最少内容echo $&#123;URL##*/&#125; # user.htmlecho $&#123;URL#*/&#125; # /www.baidu.com/baike/user.html# 以/为分隔符截取左边字符串，%%表示尽可能多的删除，即保留最少内容echo $&#123;URL%%/*&#125; # http:echo $&#123;URL%/*&#125; # http://www.baidu.com/baike 5.变量状态赋值 12345678910111213141516171819202122232425# 格式$&#123;VAR:-string&#125; # 如果 VAR 变量为空则返回 string$&#123;VAR:+string&#125; # 如果 VAR 变量不为空则返回 string$&#123;VAR:=string&#125; # 如果 VAR 变量为空则重新赋值 VAR 变量值为 string$&#123;VAR:?string&#125; # 如果 VAR 变量为空则将 string 输出到 stderr# 示例# 如果变量为空就返回 hello world!VAR=echo $&#123;VAR:-&#x27;hello world!&#x27;&#125; # hello world!echo $VAR # 空# 如果变量不为空就返回 hello world!VAR=&quot;hello&quot;echo $&#123;VAR:+&#x27;hello world!&#x27;&#125; # hello world!echo $VAR # hello#如果变量为空就重新赋值：VAR=echo $&#123;VAR:=hello&#125; # helloecho $VAR # hello# 如果变量为空就将信息输出 stderrVAR=echo $&#123;VAR:?value is null&#125; # -bash: VAR: value is null","summary":"摘要 文本介绍linux编程中会用到的各种符号的使用方法 特殊变量: $0、$?、$*、$@、$#、$$、$_、$! &amp;和&amp;&amp;、|和|| 命令替换: $( ) 与 `` 整数运算: $(( )) 与 $[ ] 条件判断: (( ))、[ ]与[[ ]] 变量引用: $ 与 ${ } 本文基于CentOS8(x86_64)","date_published":"2023-03-13T14:40:05.000Z","tags":["技术","linux","linux常用命令","linux常用命令"]},{"id":"https://blog.hanqunfeng.com/2023/03/13/linux-command06-shell/","url":"https://blog.hanqunfeng.com/2023/03/13/linux-command06-shell/","title":"Linux常用命令--shell编程","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度 ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍shell编程的语法规则。</p>\n</li>\n<li class=\"lvl-2\">\n<p>本文基于<code>CentOS8(x86_64)</code></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"文件头\">文件头</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/sh :指定执行脚步的shell路径</span></span><br><span class=\"line\"><span class=\"comment\">#!/usr/bin/env bash :从env中查找指定的shell路径</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果没有为脚本设置文件头指定执行脚本的shell路径，则默认使用运行脚本的用户的shell</p>\n</blockquote>\n<h2 id=\"注释语法\">注释语法</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>#</code> : 使用<code>#</code>进行单行注释，要讲某行注释，就在该行行首添加<code>#</code></p>\n</li>\n</ul>\n<h2 id=\"特殊变量\">特殊变量</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>$0</code> : 当前脚本的文件名（间接运行时还包括绝对路径）。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>$n</code> : 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是 $1 。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>$#</code> : 传递给脚本或函数的参数个数。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>$*</code> : 传递给脚本或函数的所有参数。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>$@</code> : 传递给脚本或函数的所有参数。被双引号 <code>&quot;$@&quot;</code> 包含时，与 <code>&quot;$*&quot;</code> 不同，下面将会讲到。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>$?</code> : 上个命令的退出状态(0:success 非0:error)，或函数的返回值。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>$$</code> : 当前 Shell 进程 ID。对于 Shell 脚本，就是这些脚本所在的进程 ID。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>$_</code> : 上一个命令的最后一个参数</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>$!</code> : 后台运行的最后一个进程的 ID 号</p>\n</li>\n</ul>\n<div class=\"tips\">\n<p><em><strong>小贴士</strong></em><br>\n<code>$*</code> 和 <code>$@</code> 都表示传递给函数或脚本的所有参数，不被双引号 <code>&quot;&quot;</code> 包含时，都以独立个体<code>&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot;</code> 的形式输出所有参数。<br>\n但是当它们被双引号 <code>&quot;&quot;</code> 包含时，<code>&quot;$*&quot;</code>会将所有的参数作为一个整体输出，<code>&quot;$@&quot;</code>依旧会以独立个体<code>&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot;</code> 的形式输出所有参数。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># $*</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> $*</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"variable\">$i</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"comment\"># sh test.sh 1 2 3 4，此时输出</span></span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># &quot;$*&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"string\">&quot;$*&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"variable\">$i</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"comment\"># sh test.sh 1 2 3 4，此时输出</span></span><br><span class=\"line\">1 2 3 4</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># $@</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"variable\">$@</span></span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"variable\">$i</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"comment\"># sh test.sh 1 2 3 4，此时输出</span></span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># &quot;$@&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"string\">&quot;<span class=\"variable\">$@</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"variable\">$i</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"comment\"># sh test.sh 1 2 3 4，此时输出</span></span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td></tr></table></figure>\n<p>获取参数数量：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">paramSize=<span class=\"variable\">$&#123;#@&#125;</span></span><br></pre></td></tr></table></figure>\n</div>\n<h2 id=\"自定义变量\">自定义变量</h2>\n<h3 id=\"字符串\">字符串</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 定义一个字符串变量</span></span><br><span class=\"line\">s1=<span class=\"string\">&quot;content&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义一个变量接收之前定义过的变量，使用变量时需要使用 $+变量名称</span></span><br><span class=\"line\">s2=<span class=\"variable\">$s1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义一个变量为之前定义过的变量与其它字符串的组合，此时可以使用 &#123;&#125; 将变量名称括起来以避免歧义</span></span><br><span class=\"line\">s3=<span class=\"string\">&quot;<span class=\"variable\">$&#123;s1&#125;</span>_test&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义一个变量接收日期字符串，``括起来的内容会优先执行，并把结果赋值给变量</span></span><br><span class=\"line\">s4=`<span class=\"built_in\">date</span> +%F<span class=\"string\">&#x27; &#x27;</span>%T`</span><br><span class=\"line\">now=`<span class=\"built_in\">date</span> +%Y%m%d_%H%M%S`</span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>小贴士</strong></em><br>\n<code>$</code>与<code>$&#123; &#125;</code>都是用来引用变量的，<code>$&#123; &#125;</code>通常用于划定变量名的边界<br>\n当执行 <code>echo &quot;$aa&quot;</code>的时候系统会打印变量<code>$aa</code>的值，当执行<code>echo &quot;$&#123;a&#125;a&quot;</code>时打印的是<code>$&#123;a&#125;</code>和字母a，如果不需要为变量名划分边界的话，<code>$a</code>和<code>$&#123;a&#125;</code>是完全相等的。<br>\n除此之外，<code>$&#123; &#125;</code>还有一个重要的功能，就是文本处理:</p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">1.获取字符串长度</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str=<span class=\"string\">&#x27;hello&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;#str&#125;</span> <span class=\"comment\"># 5</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">2.字符串切片<code>$&#123;a:b:c&#125;</code>: 将字符串变量<code>a</code>从第<code>b</code>个位置开始向后截取<code>c</code>个字符，b是指下标，下标从0开始，<code>c</code>可以不指定，表示截取到字符串末尾</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=<span class=\"string\">&#x27;hello world!&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;a:0:5&#125;</span> <span class=\"comment\"># hello</span></span><br><span class=\"line\"><span class=\"comment\"># 不指定c，表示从第6个字符开始截取到字符串末尾</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;a:6&#125;</span> <span class=\"comment\"># world!</span></span><br><span class=\"line\"><span class=\"comment\"># 截取从倒数第一个字符开始到字符串末尾的字符</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;a:(-1)&#125;</span> <span class=\"comment\"># !</span></span><br><span class=\"line\"><span class=\"comment\"># 截取从倒数第 6 个字符后的 5 个字符</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;a:(-6):5&#125;</span> <span class=\"comment\"># world</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">3.替换字符串<code>$&#123;a/b/c&#125;</code>: 将变量<code>a</code>中的<code>b</code>全部替换为<code>c</code>，开头一个正斜杠为只匹配第一个字符串，两个正斜杠为匹配所有字符。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=<span class=\"string\">&#x27;hello hello world&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$&#123;a/hello/hi&#125;</span>&quot;</span> <span class=\"comment\"># hi hello world</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$&#123;a//hello/hi&#125;</span>&quot;</span> <span class=\"comment\"># hi hi world</span></span><br><span class=\"line\"><span class=\"comment\"># 支持正则</span></span><br><span class=\"line\">str=123abc</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;str//[^0-9]/&#125;</span> <span class=\"comment\"># 123，将非数字替换为空</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;str//[0-9]/&#125;</span> <span class=\"comment\"># abc，将数字替换为空</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">4.字符串截取</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 格式：</span></span><br><span class=\"line\"><span class=\"comment\"># 删除匹配前缀</span></span><br><span class=\"line\"><span class=\"variable\">$&#123;parameter#word&#125;</span></span><br><span class=\"line\"><span class=\"variable\">$&#123;parameter##word&#125;</span></span><br><span class=\"line\"><span class=\"comment\"># 删除匹配后缀</span></span><br><span class=\"line\"><span class=\"variable\">$&#123;parameter%word&#125;</span></span><br><span class=\"line\"><span class=\"variable\">$&#123;parameter%%word&#125;</span></span><br><span class=\"line\"><span class=\"comment\"># 去掉左边，#最短匹配模式，##最长匹配模式。</span></span><br><span class=\"line\">% 去掉右边，%最短匹配模式，%%最长匹配模式。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\">URL=<span class=\"string\">&quot;http://www.baidu.com/baike/user.html&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 匹配http://，以//为分隔符截取出右边字符串</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;URL#*//&#125;</span> <span class=\"comment\"># www.baidu.com/baike/user.html</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 以/为分隔符截取右边字符串，##表示尽可能多的删除，保留最少内容</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;URL##*/&#125;</span> <span class=\"comment\"># user.html</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;URL#*/&#125;</span>  <span class=\"comment\"># /www.baidu.com/baike/user.html</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 以/为分隔符截取左边字符串，%%表示尽可能多的删除，即保留最少内容</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;URL%%/*&#125;</span> <span class=\"comment\"># http:</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;URL%/*&#125;</span> <span class=\"comment\"># http://www.baidu.com/baike</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">5.变量状态赋值</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 格式</span></span><br><span class=\"line\"><span class=\"variable\">$&#123;VAR:-string&#125;</span> <span class=\"comment\"># 如果 VAR 变量为空则返回 string</span></span><br><span class=\"line\"><span class=\"variable\">$&#123;VAR:+string&#125;</span> <span class=\"comment\"># 如果 VAR 变量不为空则返回 string</span></span><br><span class=\"line\"><span class=\"variable\">$&#123;VAR:=string&#125;</span> <span class=\"comment\"># 如果 VAR 变量为空则重新赋值 VAR 变量值为 string</span></span><br><span class=\"line\"><span class=\"variable\">$&#123;VAR:?string&#125;</span> <span class=\"comment\"># 如果 VAR 变量为空则将 string 输出到 stderr</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\"><span class=\"comment\"># 如果变量为空就返回 hello world!</span></span><br><span class=\"line\">VAR=</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;VAR:-&#x27;hello world!&#x27;&#125;</span> <span class=\"comment\"># hello world!</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$VAR</span> <span class=\"comment\"># 空</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果变量不为空就返回 hello world!</span></span><br><span class=\"line\">VAR=<span class=\"string\">&quot;hello&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;VAR:+&#x27;hello world!&#x27;&#125;</span> <span class=\"comment\"># hello world!</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$VAR</span> <span class=\"comment\"># hello</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#如果变量为空就重新赋值：</span></span><br><span class=\"line\">VAR=</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;VAR:=hello&#125;</span> <span class=\"comment\"># hello</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$VAR</span> <span class=\"comment\"># hello</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果变量为空就将信息输出 stderr</span></span><br><span class=\"line\">VAR=</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;VAR:?value is null&#125;</span> <span class=\"comment\"># -bash: VAR: value is null</span></span><br></pre></td></tr></table></figure>\n</div>\n<h3 id=\"数字\">数字</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>整数运算</p>\n<blockquote>\n<p>支持<code>let</code>、<code>$(( ))</code>、<code>$[ ]</code>和<code>expr</code>四种方式</p>\n</blockquote>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 定义一个数字</span></span><br><span class=\"line\">a1=10</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 进行数字运算时，可以使用以下是几种运算方式中的一种</span></span><br><span class=\"line\"><span class=\"comment\"># 加法和减法</span></span><br><span class=\"line\">a2=$((<span class=\"variable\">$a1</span> + <span class=\"number\">5</span>)) or a2=$((a1 + <span class=\"number\">5</span>))</span><br><span class=\"line\">a3=$[<span class=\"variable\">$a1</span> + 5] or a3=$[a1 + 5]</span><br><span class=\"line\"><span class=\"comment\"># expr 要求运算符之间要有空格</span></span><br><span class=\"line\">a4=`<span class=\"built_in\">expr</span> <span class=\"variable\">$a1</span> - 5` or a4=$(<span class=\"built_in\">expr</span> <span class=\"variable\">$a1</span> - 5)</span><br><span class=\"line\"><span class=\"comment\"># let在引用变量时不需要$，另外运算符之间不能有空格</span></span><br><span class=\"line\"><span class=\"built_in\">let</span> a5=a1-5</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 乘法，注意使用expr方式时，* 要转义，</span></span><br><span class=\"line\">a2=$((a1 * <span class=\"number\">5</span>))</span><br><span class=\"line\">a3=$[a1 * 5]</span><br><span class=\"line\"><span class=\"comment\"># expr 要求运算符之间要有空格</span></span><br><span class=\"line\">a4=`<span class=\"built_in\">expr</span> <span class=\"variable\">$a1</span> \\* 5`</span><br><span class=\"line\"><span class=\"comment\"># let在引用变量时不需要$，另外运算符之间不能有空格</span></span><br><span class=\"line\"><span class=\"built_in\">let</span> a5=a1*5</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 除法</span></span><br><span class=\"line\">a2=$((a1 / <span class=\"number\">5</span>))</span><br><span class=\"line\">a3=$[a1 / 5]</span><br><span class=\"line\"><span class=\"comment\"># expr 要求运算符之间要有空格</span></span><br><span class=\"line\">a4=`<span class=\"built_in\">expr</span> <span class=\"variable\">$a1</span> / 5`</span><br><span class=\"line\"><span class=\"comment\"># let在引用变量时不能有$，运算符之间不能有空格</span></span><br><span class=\"line\"><span class=\"built_in\">let</span> a5=a1/5</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>let</code>、<code>$(( ))</code>或<code>$[ ]</code>中的变量都可以不加<code>$</code>前缀<br>\n在进行整数运算时，<code>$(( ))</code>和<code>$[ ]</code>的作用是等价的<br>\n建议使用<code>let</code>、<code>$(( ))</code>或<code>$[ ]</code>的形式进行运算，其支持正常的运算逻辑，expr稍显笨拙，比如在进行带括号的运算时</p>\n</blockquote>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a2=$(((a1 - <span class=\"number\">5</span>) * <span class=\"number\">5</span>))</span><br><span class=\"line\">a3=$[(a1 - 5) * 5]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># expr 要求运算符之间要有空格</span></span><br><span class=\"line\"><span class=\"comment\"># expr需要分开独立计算</span></span><br><span class=\"line\">a4_1=`<span class=\"built_in\">expr</span> <span class=\"variable\">$a1</span> - 5`</span><br><span class=\"line\">a4_2=`<span class=\"built_in\">expr</span> <span class=\"variable\">$&#123;a4_1&#125;</span> \\* 5`</span><br><span class=\"line\"><span class=\"comment\"># let在引用变量时不需要$，另外运算符之间不能有空格</span></span><br><span class=\"line\"><span class=\"built_in\">let</span> a5=(a1-5)*5</span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>小贴士</strong></em><br>\n<code>$()</code>和 `` 的作用一致，都是用来做命令替换用，一般用于将命令返回的结果传递给变量</p>\n</div>\n</li>\n<li class=\"lvl-2\">\n<p>浮点数计算</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x=10</span><br><span class=\"line\">y=3.211</span><br><span class=\"line\">a1=`<span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$x</span> * 2 / <span class=\"variable\">$y</span>&quot;</span> | bc`  <span class=\"comment\"># a1为6</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># scale=2 保留两位小数，相当于截断不会四舍五入</span></span><br><span class=\"line\">a2=`<span class=\"built_in\">echo</span> <span class=\"string\">&quot;scale=2; <span class=\"variable\">$x</span> * 2 / <span class=\"variable\">$y</span>&quot;</span> | bc` <span class=\"comment\"># a2为6.22</span></span><br><span class=\"line\"><span class=\"comment\"># awk的计算会四舍五入</span></span><br><span class=\"line\">a2=`<span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$x</span> <span class=\"variable\">$y</span>&quot;</span> | awk <span class=\"string\">&#x27;&#123;printf &quot;%.2f\\n&quot;,$1*2/$2&#125;&#x27;</span>` <span class=\"comment\">#a2为6.23</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># bc运算时，整数位小于1不会显示</span></span><br><span class=\"line\">a3=`<span class=\"built_in\">echo</span> <span class=\"string\">&quot;scale=2;  2 / 3&quot;</span> | bc` <span class=\"comment\"># a3为.66，不会显示为0.66</span></span><br><span class=\"line\"><span class=\"comment\"># awk可以正确显示</span></span><br><span class=\"line\">a3=`<span class=\"built_in\">echo</span> 2 3 | awk <span class=\"string\">&#x27;&#123;printf &quot;%.2f\\n&quot;,$1/$2&#125;&#x27;</span>` <span class=\"comment\">#a3为0.67</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>awk</code> 的计算方式比 <code>bc</code> 更好一些，支持精度更为准确<br>\n<code>bc</code>和<code>awk</code>的计算方式同样支持整数</p>\n</blockquote>\n<h3 id=\"数组\">数组</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#使用小括号定义数组，(元素之间用空格分隔)</span></span><br><span class=\"line\">array=(Zero One Two Three)</span><br><span class=\"line\"><span class=\"comment\"># 打印数组长度</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;#array[@]&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 遍历数组</span></span><br><span class=\"line\"><span class=\"comment\"># while遍历</span></span><br><span class=\"line\">i=0</span><br><span class=\"line\"><span class=\"keyword\">while</span> [ <span class=\"variable\">$i</span> -lt <span class=\"variable\">$&#123;#array[@]&#125;</span> ];<span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;array[$i]&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">let</span> i=i+1</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># for遍历</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>((i=0;i&lt;<span class=\"variable\">$&#123;#array[@]&#125;</span>;i++))</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;array[i]&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"从键盘设置变量-read\">从键盘设置变量:read</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>read命令格式</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">read</span> [选项] [变量名]</span><br><span class=\"line\">    选项：</span><br><span class=\"line\">    -p “提示信息”：在等待<span class=\"built_in\">read</span>输入时，输出提示信息</span><br><span class=\"line\">    -t “秒数”： <span class=\"built_in\">read</span>命令会一致等待用户输入，使用此选项可以指定等待时间</span><br><span class=\"line\">    -n “字符数”： <span class=\"built_in\">read</span>命令只接受指定的字符数，就会执行</span><br><span class=\"line\">    -s： 隐藏输入的数据，适用于机密信息的输入</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">read</span> a <span class=\"comment\"># 此时会等待用户键入变量值，比如此时输入: 3</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$a</span> <span class=\"comment\"># 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">read</span> -t 30 -p <span class=\"string\">&quot;Please input your username:&quot;</span> username</span><br><span class=\"line\"><span class=\"built_in\">read</span> -s -t 30 -p <span class=\"string\">&quot;Please input your passsword:&quot;</span> password</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">read</span> a b c <span class=\"comment\"># 可以设置多个变量，比如此时输入: 1 2 3</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$&#123;a&#125;</span>_<span class=\"variable\">$&#123;b&#125;</span>_<span class=\"variable\">$&#123;c&#125;</span>&quot;</span> <span class=\"comment\"># 1_2_3</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"test命令\"><code>test</code>命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>test</code>作用检查某个条件是否成立，返回值为<code>0</code>（真）或者其他值（假），可通过<code>echo $?</code>查看返回值，也常用于循环和条件语句。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>test</code>一般有三种用法：</p>\n<blockquote>\n<p>测试文件或者文件夹是否存在<br>\n字符串比较<br>\n数值比较</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"测试文件或者文件夹是否存在\">测试文件或者文件夹是否存在</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>参数说明</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-d dir :是否为目录，是目录为真</span><br><span class=\"line\">-f file :是否为常规文件，是文件为真</span><br><span class=\"line\">-x file/dir :是否可执行，可执行为真</span><br><span class=\"line\">-r file/dir :是否可读，可读为真</span><br><span class=\"line\">-w file/dir :是否可写，可写为真</span><br><span class=\"line\">-a file/dir :文件或目录是否存在，存在为真</span><br><span class=\"line\">-e file/dir :文件或目录是否存在，存在为真</span><br><span class=\"line\">-s file :文件大小是否非0，非0为真</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">test</span> -f test.sh</span><br><span class=\"line\">$ <span class=\"built_in\">echo</span> $?</span><br><span class=\"line\"></span><br><span class=\"line\">$ <span class=\"built_in\">test</span> -d <span class=\"built_in\">dir</span></span><br><span class=\"line\">$ <span class=\"built_in\">echo</span> $?</span><br></pre></td></tr></table></figure>\n<h3 id=\"字符串比较\">字符串比较</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>参数说明</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">参数\t    说明</span><br><span class=\"line\">-z      当str为空时返回真</span><br><span class=\"line\">-n\t    当str为非空时返回真</span><br><span class=\"line\">=\t    两个字符串相等时返回真</span><br><span class=\"line\">==\t    两个字符串相等时返回真，同=</span><br><span class=\"line\">!=\t    两个字符串不相等时返回真</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">test</span> -z <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">$ <span class=\"built_in\">echo</span> $?  <span class=\"comment\"># 输出0</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ <span class=\"built_in\">test</span> -n <span class=\"string\">&#x27;hello&#x27;</span></span><br><span class=\"line\">$ <span class=\"built_in\">echo</span> $?  <span class=\"comment\"># 输出0</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ <span class=\"built_in\">test</span> <span class=\"string\">&#x27;hello&#x27;</span> == <span class=\"string\">&#x27;world&#x27;</span></span><br><span class=\"line\">$ <span class=\"built_in\">echo</span> $?  <span class=\"comment\"># 输出1</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ <span class=\"built_in\">test</span> <span class=\"string\">&#x27;hello&#x27;</span> != <span class=\"string\">&#x27;world&#x27;</span></span><br><span class=\"line\">$ <span class=\"built_in\">echo</span> $?  <span class=\"comment\"># 输出0</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"数值比较\">数值比较</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>参数说明，使用<code>&gt;</code>、<code>&lt;</code>等运算符时需要转义 <code>\\&gt;</code>、<code>\\&lt;</code>，或者使用如下参数替换对应的运算符</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">参数\t    说明</span><br><span class=\"line\">-eq\t    等于时返回真 ==</span><br><span class=\"line\">-ne\t    不等于时返回真 !=</span><br><span class=\"line\">-lt\t    小于时返回真 &lt;</span><br><span class=\"line\">-le\t    小于等于时返回真 &lt;=</span><br><span class=\"line\">-gt\t    大于时返回真 &gt;</span><br><span class=\"line\">-ge\t    大于等于时返回真 &gt;=</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">test</span> 1 -lt 2</span><br><span class=\"line\">$ <span class=\"built_in\">echo</span> $?  <span class=\"comment\"># 输出0</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"逻辑运算\">逻辑运算</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>参数说明</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">参数\t  说明</span><br><span class=\"line\">-a\t    逻辑与，二者都为真则为真</span><br><span class=\"line\">-o\t    逻辑或，二者任意一个为真则为真</span><br><span class=\"line\">!\t    逻辑非</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">test</span> ! -e test.sh</span><br><span class=\"line\">$ <span class=\"built_in\">echo</span> $?</span><br><span class=\"line\"></span><br><span class=\"line\">$ <span class=\"built_in\">test</span> -f test.sh -a -d <span class=\"built_in\">dir</span></span><br><span class=\"line\">$ <span class=\"built_in\">echo</span> $?</span><br></pre></td></tr></table></figure>\n<h3 id=\"shell中的用法\">shell中的用法</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i=<span class=\"variable\">$1</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"built_in\">test</span> <span class=\"variable\">$i</span> -lt 5;<span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$i</span> &lt; 5&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$i</span> &gt;= 5&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"条件判断\">条件判断</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在使用<code>if</code>或<code>while</code>等语句时，需要进行条件判断，上面我们已经见到一个<code>while</code>的例子，其使用<code>[ ]</code>来定义条件判断</p>\n</li>\n<li class=\"lvl-2\">\n<p>实际上除了<code>[ ]</code>以外，我们还可以使用<code>test</code>、<code>(( ))</code>和<code>[[ ]]</code>来进行条件判断，那么他们之间有什么区别吗？</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\"><code>[ ]</code>是<code>test</code>命令的另一种形式，例如 <code>test a == b</code> 等同于 <code>[ a == b ]</code>，注意 <code>[</code> 后和 <code>]</code> 前都需要有空格，并且<code>==</code>两边也都要有空格</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">test</span> <span class=\"string\">&#x27;hello&#x27;</span> != <span class=\"string\">&#x27;world&#x27;</span> ==&gt;  [ <span class=\"string\">&#x27;hello&#x27;</span> != <span class=\"string\">&#x27;world&#x27;</span> ]</span><br><span class=\"line\"><span class=\"built_in\">test</span> ! -e test.sh       ==&gt;  [ ! -e test.sh ]</span><br><span class=\"line\"><span class=\"built_in\">test</span> <span class=\"variable\">$i</span> -lt 5           ==&gt;  [ <span class=\"variable\">$i</span> -lt 5 ]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\"><code>[[ ]]</code>是<code>[ ]</code>的增强版，其在如下几个方面进行了增强:\n<ul class=\"lvl-4\">\n<li class=\"lvl-10\">1.在<code>[[ ]]</code>中使用<code>&gt;</code>、<code>&lt;</code> 进行数值比较时不需要转义，但是不支持<code>&gt;=</code>、<code>&lt;=</code></li>\n<li class=\"lvl-10\">2.支持<code>&amp;&amp;</code>和<code>||</code></li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 以下三种作用相同</span></span><br><span class=\"line\">[[ <span class=\"variable\">$a</span> &gt; 3 &amp;&amp; <span class=\"variable\">$a</span> != 10 ]]</span><br><span class=\"line\">[ <span class=\"variable\">$a</span> &gt; 3 -a <span class=\"variable\">$a</span> != 10 ]</span><br><span class=\"line\">[ <span class=\"variable\">$a</span> &gt; 3 ] &amp;&amp; [ <span class=\"variable\">$a</span> != 10 ]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-4\">\n<li class=\"lvl-10\">3.<code>[[ ]]</code>在比较字符串时支持正则匹配和通配符匹配</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 通配符匹配</span></span><br><span class=\"line\">a=<span class=\"string\">&quot;linux&quot;</span></span><br><span class=\"line\">[[ <span class=\"variable\">$a</span> == l?nu? ]] <span class=\"comment\"># 0</span></span><br><span class=\"line\">[[ <span class=\"variable\">$a</span> != li* ]]   <span class=\"comment\"># 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 正则匹配 `=~`</span></span><br><span class=\"line\">a=<span class=\"string\">&quot;linux&quot;</span></span><br><span class=\"line\">[[ <span class=\"variable\">$a</span> =~ ^li ]]</span><br><span class=\"line\">[[ <span class=\"variable\">$a</span> =~ ^li[abn]ux ]]</span><br></pre></td></tr></table></figure>\n</li>\n<li class=\"lvl-6\"><code>(( ))</code> 用于条件判断时只能进行数值比较，运算符不需要转义，而且不支持<code>-lt</code>、<code>-gt</code>等等  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(( <span class=\"variable\">$i</span> &lt;= 5 ))</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<div class=\"tips\">\n<p><em><strong>小贴士</strong></em><br>\n<code>(( ))</code>除了用于条件判断外，还有三种用法：<br>\n1.与<code>$</code>结合使用进行数学运算 : <code>$(( ))</code><br>\n2.在<code>for</code>循环命令中控制循环 : <code>for((i=1;i&lt;10;i++))</code><br>\n3.改变变量的值，且变量前不需要<code>$</code> : <code>((i++))</code></p>\n</div>\n</li>\n<li class=\"lvl-2\">\n<p>推荐在进行条件判断时使用<code>[[ ]]</code>，运算符不需要转义，而且支持正则</p>\n</li>\n</ul>\n<h2 id=\"流程控制语句\">流程控制语句</h2>\n<h3 id=\"if语句\"><code>if</code>语句</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 语法1</span></span><br><span class=\"line\"><span class=\"comment\"># 因为多个语句写在同一行，所以要用;隔开</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [[ -d <span class=\"variable\">$path</span> ]];<span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;dir&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"comment\"># 其实也可以这样写</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [[ -d <span class=\"variable\">$path</span> ]]</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;dir&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 语法2</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [[ -d <span class=\"variable\">$path</span> ]];<span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;dir&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;not dir&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 语法3</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [[ -d <span class=\"variable\">$path</span> ]];<span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;dir&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">elif</span> [[ -f <span class=\"variable\">$path</span> ]];<span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;file&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;not match&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 判断参数个数是否正确，只允许输入一个参数</span></span><br><span class=\"line\">paramSize=<span class=\"variable\">$&#123;#@&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [[ <span class=\"variable\">$paramSize</span> == 0 || <span class=\"variable\">$paramSize</span> &gt; 1  ]];<span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;ERROR:需要一个参数!!!&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">exit</span> 1</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 判断参数是否为大于0的数字</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"string\">&quot;<span class=\"variable\">$1</span>&quot;</span> -gt 0 ] 2&gt;/dev/null ;<span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$1</span> id number&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;ERROR: <span class=\"variable\">$1</span> is not number!&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">exit</span> 1</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 判断参数是否为整数数字，包含正整数，0，负整数</span></span><br><span class=\"line\"><span class=\"built_in\">expr</span> <span class=\"variable\">$1</span> <span class=\"string\">&quot;+&quot;</span> 0 &amp;&gt; /dev/null</span><br><span class=\"line\"><span class=\"keyword\">if</span> [[ $? == 0 || <span class=\"variable\">$1</span> == 0 ]];<span class=\"keyword\">then</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$1</span> is number&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$1</span> not number&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果导出文件已经存在则先删除</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [[ -a <span class=\"variable\">$bookId</span>.tar.gz ]];<span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">rm</span> -rf <span class=\"variable\">$bookId</span>.tar.gz</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 判断字符串是否不为空</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [[ -n <span class=\"variable\">$str</span> ]];<span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$str</span> is not null&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$str</span> is null&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"case语句\"><code>case</code>语句</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"string\">&quot;<span class=\"variable\">$1</span>&quot;</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">start)</span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;start&quot;</span></span><br><span class=\"line\">;;</span><br><span class=\"line\">reload)</span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;reload&quot;</span></span><br><span class=\"line\">;;</span><br><span class=\"line\">stop)</span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;stop&quot;</span></span><br><span class=\"line\">;;</span><br><span class=\"line\">status)</span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;status&quot;</span></span><br><span class=\"line\">;;</span><br><span class=\"line\">*)</span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$0</span>: Usage: &#123;start|status|stop|reload&#125;&quot;</span></span><br><span class=\"line\">    <span class=\"comment\"># 非0，非正常退出，exit 0 :正常退出</span></span><br><span class=\"line\">    <span class=\"built_in\">exit</span> 1</span><br><span class=\"line\">;;</span><br><span class=\"line\"><span class=\"keyword\">esac</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"select语句\"><code>select</code>语句</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># select.sh</span></span><br><span class=\"line\">select var <span class=\"keyword\">in</span> <span class=\"string\">&quot;Linux&quot;</span> <span class=\"string\">&quot;UNIX&quot;</span> <span class=\"string\">&quot;Windows&quot;</span> <span class=\"string\">&quot;Other&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;You have selected <span class=\"variable\">$var</span>&quot;</span></span><br><span class=\"line\">    <span class=\"comment\"># 跳出循环</span></span><br><span class=\"line\">    <span class=\"built_in\">break</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 运行</span></span><br><span class=\"line\">$ sh select.sh</span><br><span class=\"line\">1) Linux</span><br><span class=\"line\">2) UNIX</span><br><span class=\"line\">3) Windows</span><br><span class=\"line\">4) Other</span><br><span class=\"line\"><span class=\"comment\">#? 2 # 输入2，表示选择第二个</span></span><br><span class=\"line\">You have selected UNIX</span><br></pre></td></tr></table></figure>\n<h3 id=\"while循环语句\"><code>while</code>循环语句</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=0</span><br><span class=\"line\"><span class=\"keyword\">while</span> [[ <span class=\"variable\">$a</span> &lt; 5 ]]</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"variable\">$a</span></span><br><span class=\"line\">    ((a++))</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"until循环语句\"><code>until</code>循环语句</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>类似<code>while</code>，不同点是条件判断为假时才执行</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=5</span><br><span class=\"line\"><span class=\"comment\"># 不满足条件时执行</span></span><br><span class=\"line\">until [[ <span class=\"variable\">$a</span> == 0 ]]</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"variable\">$a</span></span><br><span class=\"line\">    ((a--))</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"for循环语句\"><code>for</code>循环语句</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 语法1</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>((i=0;i&lt;=10;i++))</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"variable\">$i</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 语法2</span></span><br><span class=\"line\"><span class=\"comment\"># 使用&#123;&#125;和seq生成序列</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> &#123;1..9&#125;   <span class=\"comment\"># 1 2 3 4 5 6 7 8 9</span></span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;this is <span class=\"variable\">$i</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> &#123;1..9..2&#125;   <span class=\"comment\"># 1 3 5 7 9</span></span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;this is <span class=\"variable\">$i</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> `<span class=\"built_in\">seq</span> 1 9` <span class=\"comment\"># 1 2 3 4 5 6 7 8 9</span></span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;this is <span class=\"variable\">$i</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> `<span class=\"built_in\">seq</span> 1 2 9` <span class=\"comment\"># 1 3 5 7 9</span></span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;this is <span class=\"variable\">$i</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 直接列出要遍历的项</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> day <span class=\"keyword\">in</span> Sun Mon Tue Wed Thu Fri Sat</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;The day is : <span class=\"variable\">$day</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将命令执行结果作为要遍历的内容</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> `<span class=\"built_in\">cat</span> file`</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"variable\">$line</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 遍历所有参数</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> <span class=\"variable\">$@</span></span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"variable\">$p</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"其它语句\">其它语句</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>break</code> : 退出本层循环，继续执行本层循环体后面的代码，注意是退出本层循环体，如果是嵌套循环，则退出break所在层的循环，并非所有的循环</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>continue</code> : 跳过本次循环，不再执行continue下面的代码，回到循环判断式判断是否继续执行循环</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>((i=0;i&lt;=10;i++))</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> [[ <span class=\"variable\">$i</span> == 0 ]];<span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"comment\"># 不执行后面的语句直接进行下次循环</span></span><br><span class=\"line\">        <span class=\"built_in\">continue</span></span><br><span class=\"line\">    <span class=\"keyword\">fi</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"variable\">$i</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> [[ <span class=\"variable\">$i</span> == 8 ]];<span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"comment\"># 跳出循环体，不再进行循环</span></span><br><span class=\"line\">        <span class=\"built_in\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>exit 0</code> : 正常退出</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>exit 1</code> : 非0，非正常退出</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>shift</code> : 每执行一次，参数序列顺序左移一个位置，<code>$#</code>的值减1，移出去的参数不再可用</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># shift.sh</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (( <span class=\"variable\">$#</span> &lt;= 0 ));<span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Not enough parameters&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">exit</span> 0</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"built_in\">sum</span>=0</span><br><span class=\"line\"><span class=\"keyword\">while</span> [[ <span class=\"variable\">$#</span> &gt;= 0 ]]</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">sum</span>=$((sum + <span class=\"variable\">$1</span>))</span><br><span class=\"line\">    <span class=\"built_in\">shift</span> <span class=\"comment\">#因为每次执行shift，所以上面的$1永远都是下一个参数</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$sum</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 执行</span></span><br><span class=\"line\">$ sh shift.sh 1 2 3 4 5 <span class=\"comment\"># 输出 15</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"shell函数的定义与使用\">shell函数的定义与使用</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>shell函数定义</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 函数定义标准写法</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">name</span></span>() &#123;</span><br><span class=\"line\">    statements</span><br><span class=\"line\">    [<span class=\"built_in\">return</span> value]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> : Shell 中的关键字，专门用来定义函数</span><br><span class=\"line\">name : 函数名</span><br><span class=\"line\">statements : 函数要执行的代码，也就是一组语句；</span><br><span class=\"line\"><span class=\"built_in\">return</span> value : 函数的返回值，其中 <span class=\"built_in\">return</span> 是 Shell 关键字，专门用在函数中返回一个值，这一部分可以写也可以不写。</span><br><span class=\"line\">由&#123; &#125;包围的部分称为函数体，调用一个函数，实际上就是执行函数体中的代码。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 函数定义时也可以不写 function 关键字</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">name</span></span>() &#123;</span><br><span class=\"line\">    statements</span><br><span class=\"line\">    [<span class=\"built_in\">return</span> value]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\"># 如果写了 function 关键字，也可以省略函数名后面的小括号</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> name &#123;</span><br><span class=\"line\">    statements</span><br><span class=\"line\">    [<span class=\"built_in\">return</span> value]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>shell函数的调用</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果不传递参数，直接给出函数名字即可</span></span><br><span class=\"line\">name</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果传递参数，多个参数之间以空格分隔</span></span><br><span class=\"line\">name param1 param2 param3</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>和其它编程语言不同的是，Shell 函数在定义时不能指明参数，但是在调用时却可以传递参数，在方法体内引用时通过$1,$2,……来使用传递过来的参数</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 函数定义，不需要接收参数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">start</span></span>()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;start&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\"># 函数调用，在shell脚本中，可以将调用放在定义的前面</span></span><br><span class=\"line\">start</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 函数定义，需要接收参数，假设这里需要接收两个数字并求和</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">sum</span></span>()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> $(( <span class=\"variable\">$1</span> + <span class=\"variable\">$2</span> ))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\"># 函数调用</span></span><br><span class=\"line\"><span class=\"built_in\">sum</span> 1 2</span><br><span class=\"line\"><span class=\"comment\"># 输出结果</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> $?</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 多个参数求和</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">getsum</span></span>()&#123;</span><br><span class=\"line\">    <span class=\"comment\"># 定义局部变量，变量前面要加上local关键字</span></span><br><span class=\"line\">    <span class=\"built_in\">local</span> <span class=\"built_in\">sum</span>=0</span><br><span class=\"line\">    <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> <span class=\"variable\">$@</span></span><br><span class=\"line\">    <span class=\"keyword\">do</span></span><br><span class=\"line\">        ((<span class=\"built_in\">sum</span>+=n))</span><br><span class=\"line\">    <span class=\"keyword\">done</span></span><br><span class=\"line\">    <span class=\"built_in\">return</span> <span class=\"variable\">$sum</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\"># 函数调用</span></span><br><span class=\"line\">getsum 10 20 55 15  <span class=\"comment\">#调用函数并传递参数</span></span><br><span class=\"line\"><span class=\"comment\"># 输出结果</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> $?</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>shell函数中定义变量，也是全局变量，在函数体外也可以被调用，要是希望在函数体内定义的变量仅能被函数体内调用，则需要在变量前加上<code>local</code>关键字</p>\n</li>\n</ul>\n<h2 id=\"运行shell\">运行shell</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>sh test.sh</code> : 运行shell脚本</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>sh -x test.sh</code> : 执行脚本，并显示全部过程</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>sh -n test.sh</code> : 不执行脚本，只检查语法错误</p>\n</li>\n<li class=\"lvl-2\">\n<p>也可以为shell脚本授予执行权限，然后通过<code>.</code>关键字执行，比如<code>. ~/test.sh</code>，或者直接通过脚本路径运行<code>~/test.sh</code>(注意要设置文件头指定shell)</p>\n</li>\n</ul>\n<div class=\"tips\">\n<p><em><strong>小贴士</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">如果在windows环境下编写的脚步，上传到linux后需要先执行<code>dos2unix</code>进行编码转换，否则不能正确执行</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dos2unix test.sh</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">如果<code>dos2unix</code>命令不存在，可以通过<code>yum</code>进行安装</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install dos2unix -y</span><br></pre></td></tr></table></figure>\n</div>\n","content_text":"摘要 本文介绍shell编程的语法规则。 本文基于CentOS8(x86_64) 文件头 12#!/bin/sh :指定执行脚步的shell路径#!/usr/bin/env bash :从env中查找指定的shell路径 如果没有为脚本设置文件头指定执行脚本的shell路径，则默认使用运行脚本的用户的shell 注释语法 # : 使用#进行单行注释，要讲某行注释，就在该行行首添加# 特殊变量 $0 : 当前脚本的文件名（间接运行时还包括绝对路径）。 $n : 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是 $1 。 $# : 传递给脚本或函数的参数个数。 $* : 传递给脚本或函数的所有参数。 $@ : 传递给脚本或函数的所有参数。被双引号 &quot;$@&quot; 包含时，与 &quot;$*&quot; 不同，下面将会讲到。 $? : 上个命令的退出状态(0:success 非0:error)，或函数的返回值。 $$ : 当前 Shell 进程 ID。对于 Shell 脚本，就是这些脚本所在的进程 ID。 $_ : 上一个命令的最后一个参数 $! : 后台运行的最后一个进程的 ID 号 小贴士 $* 和 $@ 都表示传递给函数或脚本的所有参数，不被双引号 &quot;&quot; 包含时，都以独立个体&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; 的形式输出所有参数。 但是当它们被双引号 &quot;&quot; 包含时，&quot;$*&quot;会将所有的参数作为一个整体输出，&quot;$@&quot;依旧会以独立个体&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; 的形式输出所有参数。 12345678910111213141516171819202122232425262728293031323334353637383940# $*for i in $*do echo $idone# sh test.sh 1 2 3 4，此时输出1234# &quot;$*&quot;for i in &quot;$*&quot;do echo $idone# sh test.sh 1 2 3 4，此时输出1 2 3 4# $@for i in $@do echo $idone# sh test.sh 1 2 3 4，此时输出1234# &quot;$@&quot;for i in &quot;$@&quot;do echo $idone# sh test.sh 1 2 3 4，此时输出1234 获取参数数量： 1paramSize=$&#123;#@&#125; 自定义变量 字符串 123456789101112# 定义一个字符串变量s1=&quot;content&quot;# 定义一个变量接收之前定义过的变量，使用变量时需要使用 $+变量名称s2=$s1# 定义一个变量为之前定义过的变量与其它字符串的组合，此时可以使用 &#123;&#125; 将变量名称括起来以避免歧义s3=&quot;$&#123;s1&#125;_test&quot;# 定义一个变量接收日期字符串，``括起来的内容会优先执行，并把结果赋值给变量s4=`date +%F&#x27; &#x27;%T`now=`date +%Y%m%d_%H%M%S` 小贴士 $与$&#123; &#125;都是用来引用变量的，$&#123; &#125;通常用于划定变量名的边界 当执行 echo &quot;$aa&quot;的时候系统会打印变量$aa的值，当执行echo &quot;$&#123;a&#125;a&quot;时打印的是$&#123;a&#125;和字母a，如果不需要为变量名划分边界的话，$a和$&#123;a&#125;是完全相等的。 除此之外，$&#123; &#125;还有一个重要的功能，就是文本处理: 1.获取字符串长度 12str=&#x27;hello&#x27;echo $&#123;#str&#125; # 5 2.字符串切片$&#123;a:b:c&#125;: 将字符串变量a从第b个位置开始向后截取c个字符，b是指下标，下标从0开始，c可以不指定，表示截取到字符串末尾 12345678a=&#x27;hello world!&#x27;echo $&#123;a:0:5&#125; # hello# 不指定c，表示从第6个字符开始截取到字符串末尾echo $&#123;a:6&#125; # world!# 截取从倒数第一个字符开始到字符串末尾的字符echo $&#123;a:(-1)&#125; # !# 截取从倒数第 6 个字符后的 5 个字符echo $&#123;a:(-6):5&#125; # world 3.替换字符串$&#123;a/b/c&#125;: 将变量a中的b全部替换为c，开头一个正斜杠为只匹配第一个字符串，两个正斜杠为匹配所有字符。 1234567a=&#x27;hello hello world&#x27;echo &quot;$&#123;a/hello/hi&#125;&quot; # hi hello worldecho &quot;$&#123;a//hello/hi&#125;&quot; # hi hi world# 支持正则str=123abcecho $&#123;str//[^0-9]/&#125; # 123，将非数字替换为空echo $&#123;str//[0-9]/&#125; # abc，将数字替换为空 4.字符串截取 12345678910111213141516171819202122# 格式：# 删除匹配前缀$&#123;parameter#word&#125;$&#123;parameter##word&#125;# 删除匹配后缀$&#123;parameter%word&#125;$&#123;parameter%%word&#125;# 去掉左边，#最短匹配模式，##最长匹配模式。% 去掉右边，%最短匹配模式，%%最长匹配模式。# 示例URL=&quot;http://www.baidu.com/baike/user.html&quot;# 匹配http://，以//为分隔符截取出右边字符串echo $&#123;URL#*//&#125; # www.baidu.com/baike/user.html# 以/为分隔符截取右边字符串，##表示尽可能多的删除，保留最少内容echo $&#123;URL##*/&#125; # user.htmlecho $&#123;URL#*/&#125; # /www.baidu.com/baike/user.html# 以/为分隔符截取左边字符串，%%表示尽可能多的删除，即保留最少内容echo $&#123;URL%%/*&#125; # http:echo $&#123;URL%/*&#125; # http://www.baidu.com/baike 5.变量状态赋值 12345678910111213141516171819202122232425# 格式$&#123;VAR:-string&#125; # 如果 VAR 变量为空则返回 string$&#123;VAR:+string&#125; # 如果 VAR 变量不为空则返回 string$&#123;VAR:=string&#125; # 如果 VAR 变量为空则重新赋值 VAR 变量值为 string$&#123;VAR:?string&#125; # 如果 VAR 变量为空则将 string 输出到 stderr# 示例# 如果变量为空就返回 hello world!VAR=echo $&#123;VAR:-&#x27;hello world!&#x27;&#125; # hello world!echo $VAR # 空# 如果变量不为空就返回 hello world!VAR=&quot;hello&quot;echo $&#123;VAR:+&#x27;hello world!&#x27;&#125; # hello world!echo $VAR # hello#如果变量为空就重新赋值：VAR=echo $&#123;VAR:=hello&#125; # helloecho $VAR # hello# 如果变量为空就将信息输出 stderrVAR=echo $&#123;VAR:?value is null&#125; # -bash: VAR: value is null 数字 整数运算 支持let、$(( ))、$[ ]和expr四种方式 123456789101112131415161718192021222324252627# 定义一个数字a1=10# 进行数字运算时，可以使用以下是几种运算方式中的一种# 加法和减法a2=$(($a1 + 5)) or a2=$((a1 + 5))a3=$[$a1 + 5] or a3=$[a1 + 5]# expr 要求运算符之间要有空格a4=`expr $a1 - 5` or a4=$(expr $a1 - 5)# let在引用变量时不需要$，另外运算符之间不能有空格let a5=a1-5# 乘法，注意使用expr方式时，* 要转义，a2=$((a1 * 5))a3=$[a1 * 5]# expr 要求运算符之间要有空格a4=`expr $a1 \\* 5`# let在引用变量时不需要$，另外运算符之间不能有空格let a5=a1*5# 除法a2=$((a1 / 5))a3=$[a1 / 5]# expr 要求运算符之间要有空格a4=`expr $a1 / 5`# let在引用变量时不能有$，运算符之间不能有空格let a5=a1/5 let、$(( ))或$[ ]中的变量都可以不加$前缀 在进行整数运算时，$(( ))和$[ ]的作用是等价的 建议使用let、$(( ))或$[ ]的形式进行运算，其支持正常的运算逻辑，expr稍显笨拙，比如在进行带括号的运算时 123456789a2=$(((a1 - 5) * 5))a3=$[(a1 - 5) * 5]# expr 要求运算符之间要有空格# expr需要分开独立计算a4_1=`expr $a1 - 5`a4_2=`expr $&#123;a4_1&#125; \\* 5`# let在引用变量时不需要$，另外运算符之间不能有空格let a5=(a1-5)*5 小贴士 $()和 `` 的作用一致，都是用来做命令替换用，一般用于将命令返回的结果传递给变量 浮点数计算 12345678910111213x=10y=3.211a1=`echo &quot;$x * 2 / $y&quot; | bc` # a1为6# scale=2 保留两位小数，相当于截断不会四舍五入a2=`echo &quot;scale=2; $x * 2 / $y&quot; | bc` # a2为6.22# awk的计算会四舍五入a2=`echo &quot;$x $y&quot; | awk &#x27;&#123;printf &quot;%.2f\\n&quot;,$1*2/$2&#125;&#x27;` #a2为6.23# bc运算时，整数位小于1不会显示a3=`echo &quot;scale=2; 2 / 3&quot; | bc` # a3为.66，不会显示为0.66# awk可以正确显示a3=`echo 2 3 | awk &#x27;&#123;printf &quot;%.2f\\n&quot;,$1/$2&#125;&#x27;` #a3为0.67 awk 的计算方式比 bc 更好一些，支持精度更为准确 bc和awk的计算方式同样支持整数 数组 123456789101112131415161718#使用小括号定义数组，(元素之间用空格分隔)array=(Zero One Two Three)# 打印数组长度echo $&#123;#array[@]&#125;# 遍历数组# while遍历i=0while [ $i -lt $&#123;#array[@]&#125; ];do echo $&#123;array[$i]&#125; let i=i+1done# for遍历for((i=0;i&lt;$&#123;#array[@]&#125;;i++))do echo $&#123;array[i]&#125;done 从键盘设置变量:read read命令格式 123456read [选项] [变量名] 选项： -p “提示信息”：在等待read输入时，输出提示信息 -t “秒数”： read命令会一致等待用户输入，使用此选项可以指定等待时间 -n “字符数”： read命令只接受指定的字符数，就会执行 -s： 隐藏输入的数据，适用于机密信息的输入 示例 12345678read a # 此时会等待用户键入变量值，比如此时输入: 3echo $a # 3read -t 30 -p &quot;Please input your username:&quot; usernameread -s -t 30 -p &quot;Please input your passsword:&quot; passwordread a b c # 可以设置多个变量，比如此时输入: 1 2 3echo &quot;$&#123;a&#125;_$&#123;b&#125;_$&#123;c&#125;&quot; # 1_2_3 test命令 test作用检查某个条件是否成立，返回值为0（真）或者其他值（假），可通过echo $?查看返回值，也常用于循环和条件语句。 test一般有三种用法： 测试文件或者文件夹是否存在 字符串比较 数值比较 测试文件或者文件夹是否存在 参数说明 12345678-d dir :是否为目录，是目录为真-f file :是否为常规文件，是文件为真-x file/dir :是否可执行，可执行为真-r file/dir :是否可读，可读为真-w file/dir :是否可写，可写为真-a file/dir :文件或目录是否存在，存在为真-e file/dir :文件或目录是否存在，存在为真-s file :文件大小是否非0，非0为真 示例 12345$ test -f test.sh$ echo $?$ test -d dir$ echo $? 字符串比较 参数说明 123456参数 说明-z 当str为空时返回真-n 当str为非空时返回真= 两个字符串相等时返回真== 两个字符串相等时返回真，同=!= 两个字符串不相等时返回真 示例 1234567891011$ test -z &#x27;&#x27;$ echo $? # 输出0$ test -n &#x27;hello&#x27;$ echo $? # 输出0$ test &#x27;hello&#x27; == &#x27;world&#x27;$ echo $? # 输出1$ test &#x27;hello&#x27; != &#x27;world&#x27;$ echo $? # 输出0 数值比较 参数说明，使用&gt;、&lt;等运算符时需要转义 \\&gt;、\\&lt;，或者使用如下参数替换对应的运算符 1234567参数 说明-eq 等于时返回真 ==-ne 不等于时返回真 !=-lt 小于时返回真 &lt;-le 小于等于时返回真 &lt;=-gt 大于时返回真 &gt;-ge 大于等于时返回真 &gt;= 示例 12$ test 1 -lt 2$ echo $? # 输出0 逻辑运算 参数说明 1234参数 说明-a 逻辑与，二者都为真则为真-o 逻辑或，二者任意一个为真则为真! 逻辑非 示例 12345$ test ! -e test.sh$ echo $?$ test -f test.sh -a -d dir$ echo $? shell中的用法 123456i=$1if test $i -lt 5;then echo &quot;$i &lt; 5&quot;else echo &quot;$i &gt;= 5&quot;fi 条件判断 在使用if或while等语句时，需要进行条件判断，上面我们已经见到一个while的例子，其使用[ ]来定义条件判断 实际上除了[ ]以外，我们还可以使用test、(( ))和[[ ]]来进行条件判断，那么他们之间有什么区别吗？ [ ]是test命令的另一种形式，例如 test a == b 等同于 [ a == b ]，注意 [ 后和 ] 前都需要有空格，并且==两边也都要有空格 123test &#x27;hello&#x27; != &#x27;world&#x27; ==&gt; [ &#x27;hello&#x27; != &#x27;world&#x27; ]test ! -e test.sh ==&gt; [ ! -e test.sh ]test $i -lt 5 ==&gt; [ $i -lt 5 ] [[ ]]是[ ]的增强版，其在如下几个方面进行了增强: 1.在[[ ]]中使用&gt;、&lt; 进行数值比较时不需要转义，但是不支持&gt;=、&lt;= 2.支持&amp;&amp;和|| 1234# 以下三种作用相同[[ $a &gt; 3 &amp;&amp; $a != 10 ]][ $a &gt; 3 -a $a != 10 ][ $a &gt; 3 ] &amp;&amp; [ $a != 10 ] 3.[[ ]]在比较字符串时支持正则匹配和通配符匹配 123456789# 通配符匹配a=&quot;linux&quot;[[ $a == l?nu? ]] # 0[[ $a != li* ]] # 1# 正则匹配 `=~`a=&quot;linux&quot;[[ $a =~ ^li ]][[ $a =~ ^li[abn]ux ]] (( )) 用于条件判断时只能进行数值比较，运算符不需要转义，而且不支持-lt、-gt等等 1(( $i &lt;= 5 )) 小贴士 (( ))除了用于条件判断外，还有三种用法： 1.与$结合使用进行数学运算 : $(( )) 2.在for循环命令中控制循环 : for((i=1;i&lt;10;i++)) 3.改变变量的值，且变量前不需要$ : ((i++)) 推荐在进行条件判断时使用[[ ]]，运算符不需要转义，而且支持正则 流程控制语句 if语句 1234567891011121314151617181920212223242526# 语法1# 因为多个语句写在同一行，所以要用;隔开if [[ -d $path ]];then echo &quot;dir&quot;fi# 其实也可以这样写if [[ -d $path ]]then echo &quot;dir&quot;fi# 语法2if [[ -d $path ]];then echo &quot;dir&quot;else echo &quot;not dir&quot;fi# 语法3if [[ -d $path ]];then echo &quot;dir&quot;elif [[ -f $path ]];then echo &quot;file&quot;else echo &quot;not match&quot;fi 示例 12345678910111213141516171819202122232425262728293031323334# 判断参数个数是否正确，只允许输入一个参数paramSize=$&#123;#@&#125;if [[ $paramSize == 0 || $paramSize &gt; 1 ]];then echo &quot;ERROR:需要一个参数!!!&quot; exit 1fi# 判断参数是否为大于0的数字if [ &quot;$1&quot; -gt 0 ] 2&gt;/dev/null ;then echo &quot;$1 id number&quot;else echo &quot;ERROR: $1 is not number!&quot; exit 1fi# 判断参数是否为整数数字，包含正整数，0，负整数expr $1 &quot;+&quot; 0 &amp;&gt; /dev/nullif [[ $? == 0 || $1 == 0 ]];then echo &quot;$1 is number&quot;else echo &quot;$1 not number&quot;fi# 如果导出文件已经存在则先删除if [[ -a $bookId.tar.gz ]];then rm -rf $bookId.tar.gzfi# 判断字符串是否不为空if [[ -n $str ]];then echo &quot;$str is not null&quot;else echo &quot;$str is null&quot;fi case语句 12345678910111213141516171819case &quot;$1&quot; instart) echo &quot;start&quot;;;reload) echo &quot;reload&quot;;;stop) echo &quot;stop&quot;;;status) echo &quot;status&quot;;;*) echo &quot;$0: Usage: &#123;start|status|stop|reload&#125;&quot; # 非0，非正常退出，exit 0 :正常退出 exit 1;;esac select语句 12345678910111213141516# select.shselect var in &quot;Linux&quot; &quot;UNIX&quot; &quot;Windows&quot; &quot;Other&quot;do echo &quot;You have selected $var&quot; # 跳出循环 breakdone# 运行$ sh select.sh1) Linux2) UNIX3) Windows4) Other#? 2 # 输入2，表示选择第二个You have selected UNIX while循环语句 123456a=0while [[ $a &lt; 5 ]]do echo $a ((a++))done until循环语句 类似while，不同点是条件判断为假时才执行 1234567a=5# 不满足条件时执行until [[ $a == 0 ]]do echo $a ((a--))done for循环语句 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 语法1for((i=0;i&lt;=10;i++))do echo $idone# 语法2# 使用&#123;&#125;和seq生成序列for i in &#123;1..9&#125; # 1 2 3 4 5 6 7 8 9do echo &quot;this is $i&quot;donefor i in &#123;1..9..2&#125; # 1 3 5 7 9do echo &quot;this is $i&quot;donefor i in `seq 1 9` # 1 2 3 4 5 6 7 8 9do echo &quot;this is $i&quot;donefor i in `seq 1 2 9` # 1 3 5 7 9do echo &quot;this is $i&quot;done# 直接列出要遍历的项for day in Sun Mon Tue Wed Thu Fri Satdo echo &quot;The day is : $day&quot;done# 将命令执行结果作为要遍历的内容for line in `cat file`do echo $linedone# 遍历所有参数for p in $@do echo $pdone 其它语句 break : 退出本层循环，继续执行本层循环体后面的代码，注意是退出本层循环体，如果是嵌套循环，则退出break所在层的循环，并非所有的循环 continue : 跳过本次循环，不再执行continue下面的代码，回到循环判断式判断是否继续执行循环 123456789101112for((i=0;i&lt;=10;i++))do if [[ $i == 0 ]];then # 不执行后面的语句直接进行下次循环 continue fi echo $i if [[ $i == 8 ]];then # 跳出循环体，不再进行循环 break fidone exit 0 : 正常退出 exit 1 : 非0，非正常退出 shift : 每执行一次，参数序列顺序左移一个位置，$#的值减1，移出去的参数不再可用 123456789101112131415# shift.shif (( $# &lt;= 0 ));then echo &quot;Not enough parameters&quot; exit 0fisum=0while [[ $# &gt;= 0 ]]do sum=$((sum + $1)) shift #因为每次执行shift，所以上面的$1永远都是下一个参数doneecho $sum# 执行$ sh shift.sh 1 2 3 4 5 # 输出 15 shell函数的定义与使用 shell函数定义 12345678910111213141516171819202122# 函数定义标准写法function name() &#123; statements [return value]&#125;function : Shell 中的关键字，专门用来定义函数name : 函数名statements : 函数要执行的代码，也就是一组语句；return value : 函数的返回值，其中 return 是 Shell 关键字，专门用在函数中返回一个值，这一部分可以写也可以不写。由&#123; &#125;包围的部分称为函数体，调用一个函数，实际上就是执行函数体中的代码。# 函数定义时也可以不写 function 关键字name() &#123; statements [return value]&#125;# 如果写了 function 关键字，也可以省略函数名后面的小括号function name &#123; statements [return value]&#125; shell函数的调用 12345# 如果不传递参数，直接给出函数名字即可name# 如果传递参数，多个参数之间以空格分隔name param1 param2 param3 和其它编程语言不同的是，Shell 函数在定义时不能指明参数，但是在调用时却可以传递参数，在方法体内引用时通过$1,$2,……来使用传递过来的参数 示例 123456# 函数定义，不需要接收参数function start()&#123; echo &quot;start&quot;&#125;# 函数调用，在shell脚本中，可以将调用放在定义的前面start 12345678# 函数定义，需要接收参数，假设这里需要接收两个数字并求和function sum()&#123; return $(( $1 + $2 ))&#125;# 函数调用sum 1 2# 输出结果echo $? 1234567891011121314# 多个参数求和function getsum()&#123; # 定义局部变量，变量前面要加上local关键字 local sum=0 for n in $@ do ((sum+=n)) done return $sum&#125;# 函数调用getsum 10 20 55 15 #调用函数并传递参数# 输出结果echo $? shell函数中定义变量，也是全局变量，在函数体外也可以被调用，要是希望在函数体内定义的变量仅能被函数体内调用，则需要在变量前加上local关键字 运行shell sh test.sh : 运行shell脚本 sh -x test.sh : 执行脚本，并显示全部过程 sh -n test.sh : 不执行脚本，只检查语法错误 也可以为shell脚本授予执行权限，然后通过.关键字执行，比如. ~/test.sh，或者直接通过脚本路径运行~/test.sh(注意要设置文件头指定shell) 小贴士 如果在windows环境下编写的脚步，上传到linux后需要先执行dos2unix进行编码转换，否则不能正确执行 1dos2unix test.sh 如果dos2unix命令不存在，可以通过yum进行安装 1yum install dos2unix -y","summary":"摘要 本文介绍shell编程的语法规则。 本文基于CentOS8(x86_64)","date_published":"2023-03-13T13:30:05.000Z","tags":["技术","linux","linux常用命令","linux常用命令"]},{"id":"https://blog.hanqunfeng.com/2023/03/11/linux-command05-vim/","url":"https://blog.hanqunfeng.com/2023/03/11/linux-command05-vim/","title":"Linux常用命令--vim编辑器","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度 ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n引用本地其它文章连接{}\n 大括号开始% post_link 文件名称(不包含.md) %大括号结束\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍vim编辑器的使用方法。</p>\n</li>\n<li class=\"lvl-2\">\n<p>本文基于<code>CentOS8(x86_64)</code></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"vim操作模式\">vim操作模式</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>vim支持很多种操作模式，常用的有三种操作模式，分别是命令(正常、普通)模式<code>(Command Mode)</code>、插入模式<code>(Insert Mode)</code>和底行模式<code>(Last Line Mode)</code>。</p>\n</li>\n<li class=\"lvl-2\">\n<p>命令(正常、普通)模式<code>(Command Mode)</code></p>\n<blockquote>\n<p>进入vim之后，就处于<code>(Command Mode)</code>之中，在该模式下可以控制屏幕光标的移动，字符、字或行的删除，移动复制某区段以及进入<code>(Insert Mode)</code>或<code>(Last Line Mode)</code></p>\n</blockquote>\n</li>\n<li class=\"lvl-2\">\n<p>插入模式<code>(Insert Mode)</code></p>\n<blockquote>\n<p>在命令模式下输入如下字符即可切换至插入模式<br>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a:在光标后   A:在本行末</span><br><span class=\"line\">i:在光标前   I:在本行开始</span><br><span class=\"line\">o:在光标下新开一行   O:在光标上新开一行</span><br><span class=\"line\">此时就可以在光标所在处输入字符了</span><br></pre></td></tr></table></figure><br>\n只有在<code>(Insert Mode)</code>下，才可以做文字输入，按 <code>ESC</code> 键可回到<code>(Command Mode)</code>，该模式是我们用到的最频繁的模式</p>\n</blockquote>\n</li>\n<li class=\"lvl-2\">\n<p>底行(末行)模式<code>(Last Line Mode)</code></p>\n<blockquote>\n<p>在<code>(Command Mode)</code>下，输入<code>shift + :</code>，其实就是输入 <code>:</code> 即可进入<code>(Last Line Mode)</code><br>\n在<code>(Last Line Mode)</code>下，输入命令并回车即可执行相应的操作，无论输入的命令是否执行成功都会退出<code>(Last Line Mode)</code>并切换回<code>(Command Mode)</code>，<br>\n或者输入命令后不想执行，此时可以连按两次<code>Esc</code>键即可切换回<code>(Command Mode)</code>，或者按退格键直到取消<code>:</code>也会回到<code>(Command Mode)</code><br>\n在<code>(Last Line Mode)</code>下，可以进行文件保存或退出，也可以进行文件替换，找字符串，列出行号等操作</p>\n</blockquote>\n</li>\n<li class=\"lvl-2\">\n<p>要查看vim的所有操作模式，可以在命令行输入<code>vim</code>，然后在底行模式中输入<code>help vim-modes</code>命令即可。</p>\n</li>\n</ul>\n<h2 id=\"vim语法\">vim语法</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># fileName不存在则创建</span></span><br><span class=\"line\">vim fileName</span><br><span class=\"line\"><span class=\"comment\"># 也可以不加fileName直接打开vim编辑器，此时需要在保存时指定fileName</span></span><br><span class=\"line\">vim</span><br></pre></td></tr></table></figure>\n<h2 id=\"命令-正常、普通-模式-Command-Mode-相关指令\">命令(正常、普通)模式<code>(Command Mode)</code>相关指令</h2>\n<h3 id=\"移动光标\">移动光标</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>vim可以直接用键盘上的上下左右键来移动光标，但正规的vim是用小写英文字母 <code>h 、 j 、 k 、 l</code> ，分别控制光标左、下、上、右移一格</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>gg</code> :光标移动到第一行开始处</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>G</code> :光标移动到最后一行开始处</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>#G</code> : 例如，15G ，表示移动光标至第15行行首</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>$</code> :移动到光标所在行的行尾</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>^ (0)</code> :移动到光标所在行的行首</p>\n</li>\n</ul>\n<blockquote>\n<p>上面的比较常用</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>H</code> : 光标移动到当前屏幕中的第一行开始处</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>L</code> : 光标移动到当前屏幕中的最后一行开始处</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>M</code> : 光标移动到当前屏幕中的最中间一行开始处</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>w</code> :光标跳到下个字的开头</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>e</code> :光标跳到下个字的字尾</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>b</code> :光标回到上个字的开头</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>#l</code> :光标移到相对当前光标所在处后的第#个位置，如:当前光标在本行第3个字符处，则5l表示移动到本行第8个字符处</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>ctrl + b</code> :屏幕往后移动一页</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>ctrl + f</code> :屏幕往前移动一页</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>ctrl + u</code> :屏幕往后移动半页</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>ctrl + d</code> :屏幕往前移动半页</p>\n</li>\n</ul>\n<h3 id=\"删除文字\">删除文字</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>x</code> :每按一次，删除光标所在位置的一个字符</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>dd</code> :删除光标所在行</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>#dd</code> :从光标所在行开始删除#行</p>\n</li>\n</ul>\n<blockquote>\n<p>上面的比较常用</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>#x</code> :例如，6x 表示删除光标所在位置的后面（包含自己在内）6个字符</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>X</code> :大写的X，每按一次，删除光标所在位置的前面一个字符</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>#X</code> :例如，20X 表示删除光标所在位置的前面20个字符</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>dG</code> :删除光标所在行到末尾的内容</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>D</code> :删除光标所在处到行尾</p>\n</li>\n</ul>\n<h3 id=\"复制\">复制</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>yy</code> :复制光标所在行到缓冲区。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>#yy</code> :例如，6yy 表示拷贝从光标所在的该行往下数6行文字</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>p</code>:将缓冲区内的字符贴到光标所在位置。注意:所有与 <code>y</code> 有关的复制命令都必须与 <code>p</code> 配合才能完成复制与粘贴功能</p>\n</li>\n</ul>\n<blockquote>\n<p>上面的比较常用</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>yw</code> :将光标所在之处到字尾的字符复制到缓冲区中</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>#yw</code> :复制#个字到缓冲区</p>\n</li>\n</ul>\n<h3 id=\"替换\">替换</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>r</code> :替换光标所在处的字符，一次只能替换一个字符</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>R</code> :替换光标所到之处的字符，直到按下 <code>ESC</code> 键为止</p>\n</li>\n</ul>\n<blockquote>\n<p>不常用，直接进入插入模式修改就行</p>\n</blockquote>\n<h3 id=\"更改\">更改</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>cw</code> :更改光标所在处的字到字尾处，标点符号或空格分隔，此时进入<code>(Insert Mode)</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>c#w</code> :例如，c3w 表示更改3个字，标点符号或空格分隔，此时进入<code>(Insert Mode)</code></p>\n</li>\n</ul>\n<blockquote>\n<p>不常用，直接进入插入模式修改就行</p>\n</blockquote>\n<h3 id=\"撤销或恢复上一次操作\">撤销或恢复上一次操作</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>u</code> : 如果您误执行一个命令，可以马上按下 <code>u</code> ，回到上一个操作，按多次<code>u</code>可以执行多次恢复。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>ctrl + r</code> : 撤销恢复，多次执行<code>ctrl + r</code>，可以多次撤销</p>\n</li>\n</ul>\n<h2 id=\"底行-末行-模式-Last-Line-Mode-相关指令\">底行(末行)模式<code>(Last Line Mode)</code>相关指令</h2>\n<h3 id=\"列出或取消行号\">列出或取消行号</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>set nu</code> : 输入 <code>set nu</code> 后，会在文件中的每一行前面列出行号</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>set nonu</code> : 输入 <code>set nonu</code> 后，会取消文件中的每一行前面列出的行号</p>\n</li>\n</ul>\n<h3 id=\"跳到文件中的某一行\">跳到文件中的某一行</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>#</code> : <code>#</code> 号表示一个数字，再冒号后输入一个数字，再按回车键就会跳到该行</p>\n</li>\n</ul>\n<h3 id=\"查找字符\">查找字符</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>/ + key</code> : 先按 <code>/</code> 键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按 <code>n</code> 会往 <em><strong>后</strong></em> 寻找到您要的内容，循环往复。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>? + key1</code> : 先按 <code>?</code> 键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按 <code>n</code> 会往 <em><strong>前</strong></em> 寻找到您要的内容，循环往复。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>set ic</code> :搜索时忽略大小写</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>set noic</code> :搜索时区分大小写</p>\n</li>\n</ul>\n<h3 id=\"替换，语法类似于sed的s替换\">替换，语法类似于sed的s替换</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>n1s/source/target/</code> :<code>n1</code>代表行号，替换第n1行首次出现的source为target</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>n1s/source/target/i</code> :<code>n1</code>代表行号，替换第n1行首次出现的source为target，<code>i</code>表示不区分大小写</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>n1s/source/target/g</code> :<code>n1</code>代表行号，替换第n行出现的全部source为target</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>%s/source/target/g</code> :<code>%</code>代表所有行，配合<code>g</code>表示全文替换，将整个文档中的source替换为target</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>n1,n2s/source/target/ig</code> :<code>n1,n2</code>代表行号，在n1行到n2行范围内替换指定内容，不区分大小写</p>\n</li>\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n1,n2s/^/#/ :行首添加#</span><br><span class=\"line\">n1,n2s/^#// :去除行首#</span><br><span class=\"line\">n1,n2s/^/\\/\\// :行首添加//</span><br><span class=\"line\">n1,n2s/^\\/\\/// :去除行首//</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除，语法类似于sed的d删除\">删除，语法类似于sed的d删除</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>n1d</code> :n1代表行号，删除指定的行</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>n1,n2d</code> :n1,n2代表行号，删除指定范围的行</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>1,$d</code> :删除所有行的全部内容</p>\n</li>\n</ul>\n<h3 id=\"保存和退出\">保存和退出</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>w</code> :保存修改，不退出</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>w new_filename</code> :另存为，新的文件名称为new_filename</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>wq</code> :保存退出</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>q!</code> :不保存修改退出</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>wq!</code> :强制保存修改并退出，文件是只读的时候可以使用该命令强制保存（只有文件所有者有权限这样做）</p>\n</li>\n</ul>\n<h3 id=\"定义快捷键\">定义快捷键</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>我们可以自己定义快捷键，以定制化一个操作，比如在当前行行首添加<code>#</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>语法为：<code>map ^P I#&lt;ESC&gt;</code> : 定义<code>ctrl + p</code>，其含义为 输入大写字母<code>I</code>进入插入模式,输入<code>#</code>字符后按<code>Esc</code>切换回命令模式，注意，这里定义map时填写的<code>&lt;ESC&gt;</code>是一个字符一个字符写上的，而不是去按一次Esc按键</p>\n<blockquote>\n<p><code>^P</code> 的 输入方法为: <code>ctrl+v+p</code></p>\n</blockquote>\n</li>\n<li class=\"lvl-2\">\n<p>此时在当前vim的命令模式下，输入<code>ctrl + p</code>会在光标所在行的行首添加<code>#</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>unmap ^P</code> :取消该快捷键</p>\n</li>\n<li class=\"lvl-2\">\n<p>在底行模式下定义快捷键只对本次vim有效，退出vim就失效了，如要永久生效，可以配置到<code>~/.vimrc</code>中</p>\n</li>\n</ul>\n<h3 id=\"ab替换\">ab替换</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>ab替换可以让我们在使用vim的插入模式编辑内容时，输入指定的字符，vim会自动帮我们替换为指定的内容</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法为：<code>ab key1 key2</code>，此时我们输入key1,会自动被vim替换为key2</p>\n<blockquote>\n<p>如：<code>ab myemali hanqunfeng@xxx.com</code>，当输入myemail+空格后，会自动替换为hanqunfeng@xxx.com</p>\n</blockquote>\n</li>\n<li class=\"lvl-2\">\n<p><code>unab myemail</code> :取消</p>\n</li>\n<li class=\"lvl-2\">\n<p>在底行模式下定义ab替换只对本次vim有效，退出vim就失效了，如要永久生效，可以配置到<code>~/.vimrc</code>中</p>\n</li>\n</ul>\n<h2 id=\"vim配置\">vim配置</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>配置文件的位置</p>\n<blockquote>\n<p>在目录 <code>/etc</code>目录下面，有个名为<code>vimrc</code>的文件，这是系统中公共的vim配置文件，对所有用户都有效。<br>\n而在每个用户的home目录下，都可以自己建立私有的配置文件，命名为：<code>.vimrc</code><br>\n私有配置会覆盖公共配置中相同的内容，通常我们只修改私有配置文件</p>\n</blockquote>\n</li>\n<li class=\"lvl-2\">\n<p>常用配置，注释是行首双引号</p>\n</li>\n</ul>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&quot; 快捷键</span></span><br><span class=\"line\"><span class=\"keyword\">map</span> ^<span class=\"keyword\">P</span> I#<span class=\"symbol\">&lt;ESC&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&quot; ab替换</span></span><br><span class=\"line\"><span class=\"keyword\">ab</span> myemali hanqunfeng@xxx.<span class=\"keyword\">com</span></span><br><span class=\"line\"><span class=\"comment\">&quot; 显示行号</span></span><br><span class=\"line\"><span class=\"keyword\">set</span>  <span class=\"keyword\">nu</span></span><br><span class=\"line\"><span class=\"comment\">&quot; 语法高亮</span></span><br><span class=\"line\"><span class=\"keyword\">syntax</span> <span class=\"keyword\">on</span></span><br><span class=\"line\"><span class=\"comment\">&quot; 缩进为4</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"built_in\">shiftwidth</span>=<span class=\"number\">4</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&quot; 括号和引号的自动补全</span></span><br><span class=\"line\"><span class=\"keyword\">inoremap</span> ( ()<span class=\"symbol\">&lt;ESC&gt;</span>i</span><br><span class=\"line\"><span class=\"keyword\">inoremap</span> [ []<span class=\"symbol\">&lt;ESC&gt;</span>i</span><br><span class=\"line\"><span class=\"keyword\">inoremap</span> &#123; &#123;&#125;<span class=\"symbol\">&lt;ESC&gt;</span>i</span><br><span class=\"line\"><span class=\"keyword\">inoremap</span> <span class=\"string\">&#x27; &#x27;</span><span class=\"string\">&#x27;&lt;ESC&gt;i</span></span><br><span class=\"line\"><span class=\"string\">inoremap &quot; &quot;&quot;&lt;ESC&gt;i</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>关于vim更为详细的配置请参考 <a href=\"/2021/01/23/vimrc/\" title=\"vim配置\">vim配置</a></p>\n</li>\n</ul>\n","content_text":"摘要 本文介绍vim编辑器的使用方法。 本文基于CentOS8(x86_64) vim操作模式 vim支持很多种操作模式，常用的有三种操作模式，分别是命令(正常、普通)模式(Command Mode)、插入模式(Insert Mode)和底行模式(Last Line Mode)。 命令(正常、普通)模式(Command Mode) 进入vim之后，就处于(Command Mode)之中，在该模式下可以控制屏幕光标的移动，字符、字或行的删除，移动复制某区段以及进入(Insert Mode)或(Last Line Mode) 插入模式(Insert Mode) 在命令模式下输入如下字符即可切换至插入模式 1234a:在光标后 A:在本行末i:在光标前 I:在本行开始o:在光标下新开一行 O:在光标上新开一行此时就可以在光标所在处输入字符了 只有在(Insert Mode)下，才可以做文字输入，按 ESC 键可回到(Command Mode)，该模式是我们用到的最频繁的模式 底行(末行)模式(Last Line Mode) 在(Command Mode)下，输入shift + :，其实就是输入 : 即可进入(Last Line Mode) 在(Last Line Mode)下，输入命令并回车即可执行相应的操作，无论输入的命令是否执行成功都会退出(Last Line Mode)并切换回(Command Mode)， 或者输入命令后不想执行，此时可以连按两次Esc键即可切换回(Command Mode)，或者按退格键直到取消:也会回到(Command Mode) 在(Last Line Mode)下，可以进行文件保存或退出，也可以进行文件替换，找字符串，列出行号等操作 要查看vim的所有操作模式，可以在命令行输入vim，然后在底行模式中输入help vim-modes命令即可。 vim语法 1234# fileName不存在则创建vim fileName# 也可以不加fileName直接打开vim编辑器，此时需要在保存时指定fileNamevim 命令(正常、普通)模式(Command Mode)相关指令 移动光标 vim可以直接用键盘上的上下左右键来移动光标，但正规的vim是用小写英文字母 h 、 j 、 k 、 l ，分别控制光标左、下、上、右移一格 gg :光标移动到第一行开始处 G :光标移动到最后一行开始处 #G : 例如，15G ，表示移动光标至第15行行首 $ :移动到光标所在行的行尾 ^ (0) :移动到光标所在行的行首 上面的比较常用 H : 光标移动到当前屏幕中的第一行开始处 L : 光标移动到当前屏幕中的最后一行开始处 M : 光标移动到当前屏幕中的最中间一行开始处 w :光标跳到下个字的开头 e :光标跳到下个字的字尾 b :光标回到上个字的开头 #l :光标移到相对当前光标所在处后的第#个位置，如:当前光标在本行第3个字符处，则5l表示移动到本行第8个字符处 ctrl + b :屏幕往后移动一页 ctrl + f :屏幕往前移动一页 ctrl + u :屏幕往后移动半页 ctrl + d :屏幕往前移动半页 删除文字 x :每按一次，删除光标所在位置的一个字符 dd :删除光标所在行 #dd :从光标所在行开始删除#行 上面的比较常用 #x :例如，6x 表示删除光标所在位置的后面（包含自己在内）6个字符 X :大写的X，每按一次，删除光标所在位置的前面一个字符 #X :例如，20X 表示删除光标所在位置的前面20个字符 dG :删除光标所在行到末尾的内容 D :删除光标所在处到行尾 复制 yy :复制光标所在行到缓冲区。 #yy :例如，6yy 表示拷贝从光标所在的该行往下数6行文字 p:将缓冲区内的字符贴到光标所在位置。注意:所有与 y 有关的复制命令都必须与 p 配合才能完成复制与粘贴功能 上面的比较常用 yw :将光标所在之处到字尾的字符复制到缓冲区中 #yw :复制#个字到缓冲区 替换 r :替换光标所在处的字符，一次只能替换一个字符 R :替换光标所到之处的字符，直到按下 ESC 键为止 不常用，直接进入插入模式修改就行 更改 cw :更改光标所在处的字到字尾处，标点符号或空格分隔，此时进入(Insert Mode) c#w :例如，c3w 表示更改3个字，标点符号或空格分隔，此时进入(Insert Mode) 不常用，直接进入插入模式修改就行 撤销或恢复上一次操作 u : 如果您误执行一个命令，可以马上按下 u ，回到上一个操作，按多次u可以执行多次恢复。 ctrl + r : 撤销恢复，多次执行ctrl + r，可以多次撤销 底行(末行)模式(Last Line Mode)相关指令 列出或取消行号 set nu : 输入 set nu 后，会在文件中的每一行前面列出行号 set nonu : 输入 set nonu 后，会取消文件中的每一行前面列出的行号 跳到文件中的某一行 # : # 号表示一个数字，再冒号后输入一个数字，再按回车键就会跳到该行 查找字符 / + key : 先按 / 键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按 n 会往 后 寻找到您要的内容，循环往复。 ? + key1 : 先按 ? 键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按 n 会往 前 寻找到您要的内容，循环往复。 set ic :搜索时忽略大小写 set noic :搜索时区分大小写 替换，语法类似于sed的s替换 n1s/source/target/ :n1代表行号，替换第n1行首次出现的source为target n1s/source/target/i :n1代表行号，替换第n1行首次出现的source为target，i表示不区分大小写 n1s/source/target/g :n1代表行号，替换第n行出现的全部source为target %s/source/target/g :%代表所有行，配合g表示全文替换，将整个文档中的source替换为target n1,n2s/source/target/ig :n1,n2代表行号，在n1行到n2行范围内替换指定内容，不区分大小写 示例 1234n1,n2s/^/#/ :行首添加#n1,n2s/^#// :去除行首#n1,n2s/^/\\/\\// :行首添加//n1,n2s/^\\/\\/// :去除行首// 删除，语法类似于sed的d删除 n1d :n1代表行号，删除指定的行 n1,n2d :n1,n2代表行号，删除指定范围的行 1,$d :删除所有行的全部内容 保存和退出 w :保存修改，不退出 w new_filename :另存为，新的文件名称为new_filename wq :保存退出 q! :不保存修改退出 wq! :强制保存修改并退出，文件是只读的时候可以使用该命令强制保存（只有文件所有者有权限这样做） 定义快捷键 我们可以自己定义快捷键，以定制化一个操作，比如在当前行行首添加# 语法为：map ^P I#&lt;ESC&gt; : 定义ctrl + p，其含义为 输入大写字母I进入插入模式,输入#字符后按Esc切换回命令模式，注意，这里定义map时填写的&lt;ESC&gt;是一个字符一个字符写上的，而不是去按一次Esc按键 ^P 的 输入方法为: ctrl+v+p 此时在当前vim的命令模式下，输入ctrl + p会在光标所在行的行首添加# unmap ^P :取消该快捷键 在底行模式下定义快捷键只对本次vim有效，退出vim就失效了，如要永久生效，可以配置到~/.vimrc中 ab替换 ab替换可以让我们在使用vim的插入模式编辑内容时，输入指定的字符，vim会自动帮我们替换为指定的内容 语法为：ab key1 key2，此时我们输入key1,会自动被vim替换为key2 如：ab myemali hanqunfeng@xxx.com，当输入myemail+空格后，会自动替换为hanqunfeng@xxx.com unab myemail :取消 在底行模式下定义ab替换只对本次vim有效，退出vim就失效了，如要永久生效，可以配置到~/.vimrc中 vim配置 配置文件的位置 在目录 /etc目录下面，有个名为vimrc的文件，这是系统中公共的vim配置文件，对所有用户都有效。 而在每个用户的home目录下，都可以自己建立私有的配置文件，命名为：.vimrc 私有配置会覆盖公共配置中相同的内容，通常我们只修改私有配置文件 常用配置，注释是行首双引号 1234567891011121314151617&quot; 快捷键map ^P I#&lt;ESC&gt;&quot; ab替换ab myemali hanqunfeng@xxx.com&quot; 显示行号set nu&quot; 语法高亮syntax on&quot; 缩进为4set shiftwidth=4&quot; 括号和引号的自动补全inoremap ( ()&lt;ESC&gt;iinoremap [ []&lt;ESC&gt;iinoremap &#123; &#123;&#125;&lt;ESC&gt;iinoremap &#x27; &#x27;&#x27;&lt;ESC&gt;iinoremap &quot; &quot;&quot;&lt;ESC&gt;i 关于vim更为详细的配置请参考 vim配置","summary":"摘要 本文介绍vim编辑器的使用方法。 本文基于CentOS8(x86_64)","date_published":"2023-03-11T13:30:05.000Z","tags":["技术","linux","linux常用命令","linux常用命令"]},{"id":"https://blog.hanqunfeng.com/2023/03/10/linux-command04-ctrl/","url":"https://blog.hanqunfeng.com/2023/03/10/linux-command04-ctrl/","title":"Linux常用命令--命令行快捷键","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度 ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>本文介绍常用的命令行快捷键</p>\n</li>\n<li class=\"lvl-2\">\n<p>本文基于<code>CentOS8(x86_64)</code></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"最最常用的快捷键\">最最常用的快捷键</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>tab (ctrl + i)</code> : 命令补全</p>\n<blockquote>\n<p>有些命令如果想不起来怎么拼写了，可以只输入前面几个字符，然后按一次tab键，就会自动补全以输入前缀开头的命令<br>\n按两次tab键，就会显示以输入前缀开头的全部命令</p>\n</blockquote>\n</li>\n<li class=\"lvl-2\">\n<p><code>ctrl + c</code> : 停止正在执行的任务 或者 取消当前命令行编辑(删除整行)</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>ctrl + l</code> : 清除屏幕上所有内容，并开始新的一行，相当于执行<code>clear</code>命令</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>ctrl + a</code> : 光标回到命令行首</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>ctrl + e</code> : 光标回到命令行末</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>ctrl + insert</code> : 复制选中内容，mac下是 <code>command + c</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>alt + insert</code> : 粘贴刚才复制的内容到当前光标处，mac下是 <code>command + v</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>↑<code>(ctrl + p)</code> : 显示上一条历史命令</p>\n</li>\n<li class=\"lvl-2\">\n<p>↓<code>(ctrl + n )</code> : 显示下一条历史命令</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>!!</code> : 执行上一条命令，相当于 ↑ + <code>Enter</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>!key</code>  : 执行上一条以<code>key</code>开头的命令</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>backspace (ctrl + h)</code> : 删除光标前一个字符，mac下是 <code>delete</code>键</p>\n</li>\n</ul>\n<div class=\"success\">\n<p>记住上面的的这些快捷键，基本上日常操作就没啥问题了，下面的快捷键可以使我们的命令行操作更加高效和便捷，能记多少就记多少吧。</p>\n</div>\n<h2 id=\"剪切和删除\">剪切和删除</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>ctrl + k</code> : 剪切光标处到行尾处的字符（有删除的作用）</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>ctrl + u</code> : 剪切光标处到行首处的字符（有删除的作用）</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>ctrl + w</code> : 剪切光标前的一个单词（有删除的作用）</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>alt + d</code> : 剪切光标后的一个单词（有删除的作用），mac下是 <code>Esc + d</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>ctrl + y</code> : 粘贴<code>ctrl + k</code>、<code>ctrl + u</code>、<code>ctrl + w</code>、<code>alt + d</code> 剪切/删除的文本</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>ctrl + d</code> : 删除光标所在处字符</p>\n</li>\n</ul>\n<h2 id=\"搜索历史命令\">搜索历史命令</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>ctrl + r</code> : 搜索历史命令中的命令记录，输入一些关键字，会自动给出匹配到的结果，连续按<code>ctrl + r</code>，给出下一条匹配结果</p>\n<blockquote>\n<p>类似于 <code>history | grep key</code>，但是<code>ctrl + r</code>给出的结果会去重</p>\n</blockquote>\n</li>\n<li class=\"lvl-2\">\n<p><code>Enter (ctrl + o) (ctrl + m)</code> : 执行匹配结果中的命令</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>ctrl + g</code> : 从正在执行<code>ctrl + r</code>的搜索中退出，<code>ctrl + c</code>也行</p>\n</li>\n<li class=\"lvl-2\">\n<p>-&gt;<code>(Esc) (ctrl + j)</code> : 将<code>ctrl + r</code>的搜索中的匹配结果粘贴到命令行，其实好多快捷键都可以达到该效果，随便记住一个吧</p>\n</li>\n</ul>\n<h2 id=\"前台进程转到后台运行\">前台进程转到后台运行</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>假设你发现前台运行的一个进程需要很长的时间，但是你需要干其他的事情，你就可以将当前进程转到后台运行</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>ctrl + z</code> : 暂停正在运行行中的进程</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1]+ Stopped /root/bin/rsync.sh  <span class=\"comment\"># [1] 表示的是 jobnumber</span></span><br></pre></td></tr></table></figure>\n</li>\n<li class=\"lvl-2\">\n<p><code>bg</code> : 将暂停中的进程转到后台运行</p>\n<blockquote>\n<p>把当前进程暂停后，可以输入使用<code>bg</code>将该程序转到后台运行<br>\n如果有多个暂停中的程序，可以输入<code>bg + jobnumber</code>将指定序号的程序转到后台运行</p>\n</blockquote>\n</li>\n<li class=\"lvl-2\">\n<p><code>jobs</code> : 显示后台运行的进程信息</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>fg</code> : 将后台运行的进程转到前台运行</p>\n<blockquote>\n<p>把后台运行的进程转到前台运行，可以输入使用<code>fg</code>将该程序转到前台运行<br>\n如果有多个后台运行中的程序，可以输入<code>fg + jobnumber</code>将指定序号的程序转到前台运行</p>\n</blockquote>\n</li>\n<li class=\"lvl-2\">\n<p>要将一个进程在运行时就直接放到后台运行，可以在命令最后增加 <code>&amp;</code> 符号，但这个仅在当前会话中有效，一旦会话关闭，当前进程就会中断执行</p>\n</li>\n<li class=\"lvl-2\">\n<p>可以在命令最前面加上<code>nohup</code>命令，这样进程就会一直在后台运行直到程序运行结束，而不会因为会话关闭而中断</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">nohup</span> sh test.sh &amp;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"屏幕锁定、-解锁\">屏幕锁定、 解锁</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>ctrl + s</code> : 锁定界面，停止屏幕打印内容，使终端发呆，静止，可以使快速输出的终端屏幕停下来</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>ctrl + q</code> : 解开<code>ctrl + s</code> 的锁定界面，继续屏幕打印</p>\n</li>\n</ul>\n<h2 id=\"光标移动\">光标移动</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>Esc + .</code> : 获取上一条命令的最后部分（空格分隔）</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>Esc + b</code> : 移动到当前单词的开头</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>Esc + f</code> : 移动到当前单词的结尾</p>\n</li>\n<li class=\"lvl-2\">\n<p>-&gt;<code>(ctrl + f)</code> : 光标向右移动一个字符</p>\n</li>\n<li class=\"lvl-2\">\n<p>&lt;-<code>(ctrl + b)</code> : 光标向左移动一个字符</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>ctrl + t</code> : 交换光标位置前的两个字符</p>\n</li>\n</ul>\n<h2 id=\"其它\">其它</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>!$</code> : 显示最近的一个参数</p>\n<blockquote>\n<p>比如我先用 <code>cat /etc/sysconfig/network-scripts/ifcfg-eth0</code>，然后我想用 vim 编辑。<br>\n一般的做法是先用 ↑ 显示最后一条命令，然后用 <code>ctrl + a</code> 移动到命令最前，删除 cat，然后再输入 vim 命令。<br>\n其实完全可以用 <code>vim !$</code>来代替。</p>\n</blockquote>\n</li>\n</ul>\n","content_text":"摘要 本文介绍常用的命令行快捷键 本文基于CentOS8(x86_64) 最最常用的快捷键 tab (ctrl + i) : 命令补全 有些命令如果想不起来怎么拼写了，可以只输入前面几个字符，然后按一次tab键，就会自动补全以输入前缀开头的命令 按两次tab键，就会显示以输入前缀开头的全部命令 ctrl + c : 停止正在执行的任务 或者 取消当前命令行编辑(删除整行) ctrl + l : 清除屏幕上所有内容，并开始新的一行，相当于执行clear命令 ctrl + a : 光标回到命令行首 ctrl + e : 光标回到命令行末 ctrl + insert : 复制选中内容，mac下是 command + c alt + insert : 粘贴刚才复制的内容到当前光标处，mac下是 command + v ↑(ctrl + p) : 显示上一条历史命令 ↓(ctrl + n ) : 显示下一条历史命令 !! : 执行上一条命令，相当于 ↑ + Enter !key : 执行上一条以key开头的命令 backspace (ctrl + h) : 删除光标前一个字符，mac下是 delete键 记住上面的的这些快捷键，基本上日常操作就没啥问题了，下面的快捷键可以使我们的命令行操作更加高效和便捷，能记多少就记多少吧。 剪切和删除 ctrl + k : 剪切光标处到行尾处的字符（有删除的作用） ctrl + u : 剪切光标处到行首处的字符（有删除的作用） ctrl + w : 剪切光标前的一个单词（有删除的作用） alt + d : 剪切光标后的一个单词（有删除的作用），mac下是 Esc + d ctrl + y : 粘贴ctrl + k、ctrl + u、ctrl + w、alt + d 剪切/删除的文本 ctrl + d : 删除光标所在处字符 搜索历史命令 ctrl + r : 搜索历史命令中的命令记录，输入一些关键字，会自动给出匹配到的结果，连续按ctrl + r，给出下一条匹配结果 类似于 history | grep key，但是ctrl + r给出的结果会去重 Enter (ctrl + o) (ctrl + m) : 执行匹配结果中的命令 ctrl + g : 从正在执行ctrl + r的搜索中退出，ctrl + c也行 -&gt;(Esc) (ctrl + j) : 将ctrl + r的搜索中的匹配结果粘贴到命令行，其实好多快捷键都可以达到该效果，随便记住一个吧 前台进程转到后台运行 假设你发现前台运行的一个进程需要很长的时间，但是你需要干其他的事情，你就可以将当前进程转到后台运行 ctrl + z : 暂停正在运行行中的进程 1[1]+ Stopped /root/bin/rsync.sh # [1] 表示的是 jobnumber bg : 将暂停中的进程转到后台运行 把当前进程暂停后，可以输入使用bg将该程序转到后台运行 如果有多个暂停中的程序，可以输入bg + jobnumber将指定序号的程序转到后台运行 jobs : 显示后台运行的进程信息 fg : 将后台运行的进程转到前台运行 把后台运行的进程转到前台运行，可以输入使用fg将该程序转到前台运行 如果有多个后台运行中的程序，可以输入fg + jobnumber将指定序号的程序转到前台运行 要将一个进程在运行时就直接放到后台运行，可以在命令最后增加 &amp; 符号，但这个仅在当前会话中有效，一旦会话关闭，当前进程就会中断执行 可以在命令最前面加上nohup命令，这样进程就会一直在后台运行直到程序运行结束，而不会因为会话关闭而中断 1nohup sh test.sh &amp; 屏幕锁定、 解锁 ctrl + s : 锁定界面，停止屏幕打印内容，使终端发呆，静止，可以使快速输出的终端屏幕停下来 ctrl + q : 解开ctrl + s 的锁定界面，继续屏幕打印 光标移动 Esc + . : 获取上一条命令的最后部分（空格分隔） Esc + b : 移动到当前单词的开头 Esc + f : 移动到当前单词的结尾 -&gt;(ctrl + f) : 光标向右移动一个字符 &lt;-(ctrl + b) : 光标向左移动一个字符 ctrl + t : 交换光标位置前的两个字符 其它 !$ : 显示最近的一个参数 比如我先用 cat /etc/sysconfig/network-scripts/ifcfg-eth0，然后我想用 vim 编辑。 一般的做法是先用 ↑ 显示最后一条命令，然后用 ctrl + a 移动到命令最前，删除 cat，然后再输入 vim 命令。 其实完全可以用 vim !$来代替。","summary":"摘要 本文介绍常用的命令行快捷键 本文基于CentOS8(x86_64)","date_published":"2023-03-10T13:30:05.000Z","tags":["技术","linux","linux常用命令","linux常用命令"]},{"id":"https://blog.hanqunfeng.com/2023/03/06/linux-command03-sort/","url":"https://blog.hanqunfeng.com/2023/03/06/linux-command03-sort/","title":"Linux常用命令--文本排序和去重相关命令","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度 ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>文本的排序、去重和统计行数等相关命令，如sort、uniq、wc等等</p>\n</li>\n<li class=\"lvl-2\">\n<p>本文基于<code>CentOS8(x86_64)</code></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"sort\">sort</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>sort将文件的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按ASCII码值进行比较，最后将他们排序输出，默认升序。</p>\n</li>\n</ul>\n<h3 id=\"sort基本用法\">sort基本用法</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 文件内容按ASCII码值进行比较后升序输出</span></span><br><span class=\"line\"><span class=\"built_in\">sort</span> file</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 忽略大小写</span></span><br><span class=\"line\"><span class=\"built_in\">sort</span> -f file</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># -u去重</span></span><br><span class=\"line\"><span class=\"built_in\">sort</span> -u file</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># -r降序</span></span><br><span class=\"line\"><span class=\"built_in\">sort</span> -r file</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># -o结果输出到文件，类似于重定向 &gt; ，但是比重定向强的一点是可以输出到源文件</span></span><br><span class=\"line\"><span class=\"built_in\">sort</span> file -o newfile</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># -n 按数字大小排序，默认按字符比较，所以10比2小，此时可以加上 -n 来告诉sort要以数值来排序</span></span><br><span class=\"line\"><span class=\"built_in\">sort</span> -n file</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># -M 会以月份来排序，比如JAN小于FEB</span></span><br><span class=\"line\"><span class=\"built_in\">sort</span> -M file</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># -b 会忽略每一行前面的所有空白部分，从第一个可见字符开始比较</span></span><br><span class=\"line\"><span class=\"built_in\">sort</span> -b file</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># -c 检查文件是否已经排好序，如果乱序，则输出第一个乱序的行的相关信息，$?值为1</span></span><br><span class=\"line\"><span class=\"built_in\">sort</span> -c file</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># -C 检查文件是否已经排好序，如果乱序，则不输出任何内容，$?值为1</span></span><br><span class=\"line\"><span class=\"built_in\">sort</span> -C file</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 还有一些其它参数</span></span><br><span class=\"line\">-d 只考虑空白区域和字母字</span><br><span class=\"line\">-i 只针对可打印字符进行排序，有些ASCII就是不可打印字符，比如\\n是换行，\\r是回车等等</span><br></pre></td></tr></table></figure>\n<h3 id=\"sort高级用法\">sort高级用法</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>上面结束的sort用法都是从每行的第一个字符开始比较，如果文本可以被分隔为一列一列的内容，我们想按某一列进行排序该如何处理呢？</p>\n</li>\n<li class=\"lvl-2\">\n<p>为了说明这个用法，我准备了一份文件</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cat</span> file</span><br><span class=\"line\">tom,68,9.1</span><br><span class=\"line\">jack,71,18.7</span><br><span class=\"line\">alex,68,9.8</span><br><span class=\"line\">bar,100,30.6</span><br><span class=\"line\">foo,20,1.2</span><br><span class=\"line\">rucy,100,20.5</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>以第二列进行排序，并按数字大小排序</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -t 分隔符，-k 排序的列号</span></span><br><span class=\"line\">$ <span class=\"built_in\">sort</span> -n -t <span class=\"string\">&quot;,&quot;</span> -k 2 file</span><br><span class=\"line\">foo,20,1.2</span><br><span class=\"line\">tom,68,9.1</span><br><span class=\"line\">alex,68,9.8</span><br><span class=\"line\">jack,71,18.7</span><br><span class=\"line\">rucy,100,20.5</span><br><span class=\"line\">bar,100,30.6</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 这里 -n 可以写到 -k中</span></span><br><span class=\"line\"><span class=\"built_in\">sort</span> -t <span class=\"string\">&quot;,&quot;</span> -k 2n file</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 也可以将 -r 写到 -k中</span></span><br><span class=\"line\"><span class=\"built_in\">sort</span> -t <span class=\"string\">&quot;,&quot;</span> -k 2nr file</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>以第一列的第二个字符进行排序</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 这里 -k 1.2，表示按第一列的第二个字符排序</span></span><br><span class=\"line\">$ <span class=\"built_in\">sort</span> -t <span class=\"string\">&quot;,&quot;</span> -k 1.2 file</span><br><span class=\"line\">jack,71,18.7</span><br><span class=\"line\">bar,100,30.6</span><br><span class=\"line\">alex,68,9.8</span><br><span class=\"line\">tom,68,9.1</span><br><span class=\"line\">foo,20,1.2</span><br><span class=\"line\">rucy,100,20.5</span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>小贴士</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\"><code>-k</code> 的语法格式为<code>[ FStart [ .CStart ] ] [ Modifier ] [ , [ FEnd [ .CEnd ] ][ Modifier ] ]</code></li>\n<li class=\"lvl-2\">这个语法格式可以被其中的逗号（“，”）分为两大部分，Start部分和End部分。</li>\n<li class=\"lvl-2\">Start部分也由三部分组成，其中的Modifier部分就是我们之前说过的类似n和r的选项部分，比如<code>-k 2nr</code>，<code>b、d、f、i、n 或 r</code>都可以用在Modifier部分。</li>\n<li class=\"lvl-2\">FStart就是表示使用的域，而CStart则表示在FStart域中从第几个字符开始算“排序首字符”，CStart也是可以省略的，省略的话就表示从本域的开头部分开始。</li>\n<li class=\"lvl-2\">之前例子中的 <code>-k 2</code> 就是省略了CStart而只有FStart，而<code>-k 1.2</code>其中的 <code>1</code> 就是FStart，<code>.2</code> 就是CStart。</li>\n<li class=\"lvl-2\">End的部分的组成同Start。</li>\n<li class=\"lvl-2\">Start用于表示从第几个域的第几个字符开始，End用于表示到第几个域的第几个字符结束，如果不设定End部分，那么就认为End被设定为行尾。</li>\n</ul>\n</div>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>先按第二列升序排序，第二列相同则按第三列降序排序</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 看了上面的小贴士，应该可以理解这里的含义</span></span><br><span class=\"line\"><span class=\"comment\"># -k 2,2n 表示从第二个域开始到第二个域结束并按数字升序排序，</span></span><br><span class=\"line\"><span class=\"comment\"># -k 3,3nr 表示从第三个域开始到第三个域结束并按数字降序排序，</span></span><br><span class=\"line\">$ <span class=\"built_in\">sort</span> -t <span class=\"string\">&quot;,&quot;</span> -k 2,2n -k 3,3nr file</span><br><span class=\"line\">foo,20,1.2</span><br><span class=\"line\">alex,68,9.8</span><br><span class=\"line\">tom,68,9.1</span><br><span class=\"line\">jack,71,18.7</span><br><span class=\"line\">bar,100,30.6</span><br><span class=\"line\">rucy,100,20.5</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>-k</code> 和 <code>-u</code> 同时使用要注意，<code>-u</code> 去重时比较的是 <code>-k</code> 指定的区域</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 此时比较的是从第二个域到行尾是否重复，所以没有可以去掉的行</span></span><br><span class=\"line\">$ <span class=\"built_in\">sort</span> -t <span class=\"string\">&quot;,&quot;</span> -k 2n -u file</span><br><span class=\"line\">foo,20,1.2</span><br><span class=\"line\">tom,68,9.1</span><br><span class=\"line\">alex,68,9.8</span><br><span class=\"line\">jack,71,18.7</span><br><span class=\"line\">rucy,100,20.5</span><br><span class=\"line\">bar,100,30.6</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 此时比较的仅仅是第二个域，所以第二列重复的行会被去重</span></span><br><span class=\"line\">$ <span class=\"built_in\">sort</span> -t <span class=\"string\">&quot;,&quot;</span> -k 2,2n -u file</span><br><span class=\"line\">foo,20,1.2</span><br><span class=\"line\">tom,68,9.1</span><br><span class=\"line\">jack,71,18.7</span><br><span class=\"line\">bar,100,30.6</span><br></pre></td></tr></table></figure>\n<h2 id=\"uniq\">uniq</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>uniq命令用于报告或忽略文件中的重复行，一般与sort命令结合使用</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cat</span> file</span><br><span class=\"line\">alex; 68; 98</span><br><span class=\"line\">barr;hello; <span class=\"built_in\">test</span></span><br><span class=\"line\">barr;hello; <span class=\"built_in\">test</span></span><br><span class=\"line\">fooo;loveable;s</span><br><span class=\"line\">jack; 71; 87</span><br><span class=\"line\">jack; 71; 87</span><br><span class=\"line\">mytest; Mark; Percent</span><br><span class=\"line\">tom; 69; 91</span><br><span class=\"line\"></span><br><span class=\"line\">$ <span class=\"built_in\">sort</span> file | <span class=\"built_in\">uniq</span></span><br><span class=\"line\">alex; 68; 98</span><br><span class=\"line\">barr;hello; <span class=\"built_in\">test</span></span><br><span class=\"line\">fooo;loveable;s</span><br><span class=\"line\">jack; 71; 87</span><br><span class=\"line\">mytest; Mark; Percent</span><br><span class=\"line\">tom; 69; 91</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># -c,--count：在每列旁边显示该行重复出现的次数</span></span><br><span class=\"line\">$ <span class=\"built_in\">sort</span> file | <span class=\"built_in\">uniq</span> -c</span><br><span class=\"line\">1 alex; 68; 98</span><br><span class=\"line\">2 barr;hello; <span class=\"built_in\">test</span></span><br><span class=\"line\">1 fooo;loveable;s</span><br><span class=\"line\">2 jack; 71; 87</span><br><span class=\"line\">1 mytest; Mark; Percent</span><br><span class=\"line\">1 tom; 69; 91</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># -d,--repeated：仅显示重复出现的行</span></span><br><span class=\"line\">$ <span class=\"built_in\">sort</span> file | <span class=\"built_in\">uniq</span> -d</span><br><span class=\"line\">barr;hello; <span class=\"built_in\">test</span></span><br><span class=\"line\">jack; 71; 87</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># -D, --all-repeated[=delimit-method]，打印重复行的所有行。</span></span><br><span class=\"line\"><span class=\"comment\"># 其中 delimit-method 表示对重复行集合的分隔方式，有三种取值，分别为none、prepend和separate。</span></span><br><span class=\"line\"><span class=\"comment\"># 其中none表示不进行分隔，为默认选项，uniq -D等同于uniq --all-repeated=none；prepend表示在每一个重复行集合前面插入一个空行；separate表示在每个重复行集合间插入一个空行。</span></span><br><span class=\"line\">$ <span class=\"built_in\">sort</span> file | <span class=\"built_in\">uniq</span> -D</span><br><span class=\"line\">barr;hello; <span class=\"built_in\">test</span></span><br><span class=\"line\">barr;hello; <span class=\"built_in\">test</span></span><br><span class=\"line\">jack; 71; 87</span><br><span class=\"line\">jack; 71; 87</span><br><span class=\"line\"></span><br><span class=\"line\">$ <span class=\"built_in\">sort</span> file | <span class=\"built_in\">uniq</span> --all-repeated=separate</span><br><span class=\"line\">barr;hello; <span class=\"built_in\">test</span></span><br><span class=\"line\">barr;hello; <span class=\"built_in\">test</span></span><br><span class=\"line\"></span><br><span class=\"line\">jack; 71; 87</span><br><span class=\"line\">jack; 71; 87</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># -u,--unique：只显示唯一的行，即出现次数等于1的行</span></span><br><span class=\"line\">$ <span class=\"built_in\">sort</span> file | <span class=\"built_in\">uniq</span> -u</span><br><span class=\"line\">alex; 68; 98</span><br><span class=\"line\">fooo;loveable;s</span><br><span class=\"line\">mytest; Mark; Percent</span><br><span class=\"line\">tom; 69; 91</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 其它参数</span></span><br><span class=\"line\">-f, --skip-fields=N</span><br><span class=\"line\">\t忽略前N个字段。字段由空白字符（空格符、Tab）分隔。如果您的文档的行被编号，并且您希望比较行中除行号之外的所有内容。如果指定了选项 -f 1，那么下面相邻的两行：</span><br><span class=\"line\">\t1 这是一条线</span><br><span class=\"line\">\t2 这是一条线</span><br><span class=\"line\">\t将被认为是相同的。如果没有指定 -f 1 选项，它们将被认为是不同的。</span><br><span class=\"line\">-i, --ignore-case</span><br><span class=\"line\">\t忽略大小写字符的不同。</span><br><span class=\"line\">-s, --skip-chars=N</span><br><span class=\"line\">\t跳过前面N个字符不比较。</span><br><span class=\"line\">-w, --check-chars=N</span><br><span class=\"line\">\t指定每行要比较的前N个字符数。</span><br></pre></td></tr></table></figure>\n<h2 id=\"wc\">wc</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>wc（word count）命令用于统计文件字节、字符、单词与行的数量</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -l, --lines 统计行数，在统计记录数时，很常用</span></span><br><span class=\"line\">$ <span class=\"built_in\">wc</span> -l /etc/passwd</span><br><span class=\"line\">29 /etc/passwd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># -w, --words 统计单词出现次数</span></span><br><span class=\"line\">$ <span class=\"built_in\">wc</span> -w /etc/passwd</span><br><span class=\"line\">48 /etc/passwd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># -c, --bytes 统计文件的字节数</span></span><br><span class=\"line\">$ <span class=\"built_in\">wc</span> -c /etc/passwd</span><br><span class=\"line\">1387</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># -m, --chars 统计文件的字符数，如果是 ASCII、Latin-1 等单字节编码的字符，字符数等于字节数</span></span><br><span class=\"line\">$ <span class=\"built_in\">wc</span> -m /etc/passwd</span><br><span class=\"line\">1387</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># -L, --max-line-length 显示文件中最长行的字符数</span></span><br><span class=\"line\">$ <span class=\"built_in\">wc</span> -L /etc/passwd</span><br><span class=\"line\">85 /etc/passwd</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","content_text":"摘要 文本的排序、去重和统计行数等相关命令，如sort、uniq、wc等等 本文基于CentOS8(x86_64) sort sort将文件的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按ASCII码值进行比较，最后将他们排序输出，默认升序。 sort基本用法 123456789101112131415161718192021222324252627282930313233# 文件内容按ASCII码值进行比较后升序输出sort file# 忽略大小写sort -f file# -u去重sort -u file# -r降序sort -r file# -o结果输出到文件，类似于重定向 &gt; ，但是比重定向强的一点是可以输出到源文件sort file -o newfile# -n 按数字大小排序，默认按字符比较，所以10比2小，此时可以加上 -n 来告诉sort要以数值来排序sort -n file# -M 会以月份来排序，比如JAN小于FEBsort -M file# -b 会忽略每一行前面的所有空白部分，从第一个可见字符开始比较sort -b file# -c 检查文件是否已经排好序，如果乱序，则输出第一个乱序的行的相关信息，$?值为1sort -c file# -C 检查文件是否已经排好序，如果乱序，则不输出任何内容，$?值为1sort -C file# 还有一些其它参数-d 只考虑空白区域和字母字-i 只针对可打印字符进行排序，有些ASCII就是不可打印字符，比如\\n是换行，\\r是回车等等 sort高级用法 上面结束的sort用法都是从每行的第一个字符开始比较，如果文本可以被分隔为一列一列的内容，我们想按某一列进行排序该如何处理呢？ 为了说明这个用法，我准备了一份文件 1234567$ cat filetom,68,9.1jack,71,18.7alex,68,9.8bar,100,30.6foo,20,1.2rucy,100,20.5 以第二列进行排序，并按数字大小排序 1234567891011121314# -t 分隔符，-k 排序的列号$ sort -n -t &quot;,&quot; -k 2 filefoo,20,1.2tom,68,9.1alex,68,9.8jack,71,18.7rucy,100,20.5bar,100,30.6# 这里 -n 可以写到 -k中sort -t &quot;,&quot; -k 2n file# 也可以将 -r 写到 -k中sort -t &quot;,&quot; -k 2nr file 以第一列的第二个字符进行排序 12345678# 这里 -k 1.2，表示按第一列的第二个字符排序$ sort -t &quot;,&quot; -k 1.2 filejack,71,18.7bar,100,30.6alex,68,9.8tom,68,9.1foo,20,1.2rucy,100,20.5 小贴士 -k 的语法格式为[ FStart [ .CStart ] ] [ Modifier ] [ , [ FEnd [ .CEnd ] ][ Modifier ] ] 这个语法格式可以被其中的逗号（“，”）分为两大部分，Start部分和End部分。 Start部分也由三部分组成，其中的Modifier部分就是我们之前说过的类似n和r的选项部分，比如-k 2nr，b、d、f、i、n 或 r都可以用在Modifier部分。 FStart就是表示使用的域，而CStart则表示在FStart域中从第几个字符开始算“排序首字符”，CStart也是可以省略的，省略的话就表示从本域的开头部分开始。 之前例子中的 -k 2 就是省略了CStart而只有FStart，而-k 1.2其中的 1 就是FStart，.2 就是CStart。 End的部分的组成同Start。 Start用于表示从第几个域的第几个字符开始，End用于表示到第几个域的第几个字符结束，如果不设定End部分，那么就认为End被设定为行尾。 先按第二列升序排序，第二列相同则按第三列降序排序 12345678910# 看了上面的小贴士，应该可以理解这里的含义# -k 2,2n 表示从第二个域开始到第二个域结束并按数字升序排序，# -k 3,3nr 表示从第三个域开始到第三个域结束并按数字降序排序，$ sort -t &quot;,&quot; -k 2,2n -k 3,3nr filefoo,20,1.2alex,68,9.8tom,68,9.1jack,71,18.7bar,100,30.6rucy,100,20.5 -k 和 -u 同时使用要注意，-u 去重时比较的是 -k 指定的区域 123456789101112131415# 此时比较的是从第二个域到行尾是否重复，所以没有可以去掉的行$ sort -t &quot;,&quot; -k 2n -u filefoo,20,1.2tom,68,9.1alex,68,9.8jack,71,18.7rucy,100,20.5bar,100,30.6# 此时比较的仅仅是第二个域，所以第二列重复的行会被去重$ sort -t &quot;,&quot; -k 2,2n -u filefoo,20,1.2tom,68,9.1jack,71,18.7bar,100,30.6 uniq uniq命令用于报告或忽略文件中的重复行，一般与sort命令结合使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869$ cat filealex; 68; 98barr;hello; testbarr;hello; testfooo;loveable;sjack; 71; 87jack; 71; 87mytest; Mark; Percenttom; 69; 91$ sort file | uniqalex; 68; 98barr;hello; testfooo;loveable;sjack; 71; 87mytest; Mark; Percenttom; 69; 91# -c,--count：在每列旁边显示该行重复出现的次数$ sort file | uniq -c1 alex; 68; 982 barr;hello; test1 fooo;loveable;s2 jack; 71; 871 mytest; Mark; Percent1 tom; 69; 91# -d,--repeated：仅显示重复出现的行$ sort file | uniq -dbarr;hello; testjack; 71; 87# -D, --all-repeated[=delimit-method]，打印重复行的所有行。# 其中 delimit-method 表示对重复行集合的分隔方式，有三种取值，分别为none、prepend和separate。# 其中none表示不进行分隔，为默认选项，uniq -D等同于uniq --all-repeated=none；prepend表示在每一个重复行集合前面插入一个空行；separate表示在每个重复行集合间插入一个空行。$ sort file | uniq -Dbarr;hello; testbarr;hello; testjack; 71; 87jack; 71; 87$ sort file | uniq --all-repeated=separatebarr;hello; testbarr;hello; testjack; 71; 87jack; 71; 87# -u,--unique：只显示唯一的行，即出现次数等于1的行$ sort file | uniq -ualex; 68; 98fooo;loveable;smytest; Mark; Percenttom; 69; 91# 其它参数-f, --skip-fields=N 忽略前N个字段。字段由空白字符（空格符、Tab）分隔。如果您的文档的行被编号，并且您希望比较行中除行号之外的所有内容。如果指定了选项 -f 1，那么下面相邻的两行： 1 这是一条线 2 这是一条线 将被认为是相同的。如果没有指定 -f 1 选项，它们将被认为是不同的。-i, --ignore-case 忽略大小写字符的不同。-s, --skip-chars=N 跳过前面N个字符不比较。-w, --check-chars=N 指定每行要比较的前N个字符数。 wc wc（word count）命令用于统计文件字节、字符、单词与行的数量 1234567891011121314151617181920# -l, --lines 统计行数，在统计记录数时，很常用$ wc -l /etc/passwd29 /etc/passwd# -w, --words 统计单词出现次数$ wc -w /etc/passwd48 /etc/passwd# -c, --bytes 统计文件的字节数$ wc -c /etc/passwd1387# -m, --chars 统计文件的字符数，如果是 ASCII、Latin-1 等单字节编码的字符，字符数等于字节数$ wc -m /etc/passwd1387# -L, --max-line-length 显示文件中最长行的字符数$ wc -L /etc/passwd85 /etc/passwd","summary":"摘要 文本的排序、去重和统计行数等相关命令，如sort、uniq、wc等等 本文基于CentOS8(x86_64)","date_published":"2023-03-06T13:45:05.000Z","tags":["技术","linux","linux常用命令","linux常用命令"]},{"id":"https://blog.hanqunfeng.com/2023/03/06/linux-command03-split/","url":"https://blog.hanqunfeng.com/2023/03/06/linux-command03-split/","title":"Linux常用命令--文本分割相关命令","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度 ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>文本分割合并等相关命令，如tr、cut、paste和split等等</p>\n</li>\n<li class=\"lvl-2\">\n<p>本文基于<code>CentOS8(x86_64)</code></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"tr\">tr</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>tr用来从标准输入中替换、缩减和删除字符，并将结果写到标准输出</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">tr</span> [选项]... SET1 [SET2]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> file | <span class=\"built_in\">tr</span> <span class=\"string\">&#x27;do&#x27;</span> <span class=\"string\">&#x27;hp&#x27;</span> : 将file中内容为<span class=\"keyword\">do</span>替换为hp，替换内容与换内容长度一致</span><br><span class=\"line\"><span class=\"built_in\">cat</span> file | <span class=\"built_in\">tr</span> <span class=\"string\">&#x27;do&#x27;</span> <span class=\"string\">&#x27;hpa&#x27;</span> : 将file中内容为<span class=\"keyword\">do</span>替换为hp，多出的a会内忽略</span><br><span class=\"line\"><span class=\"built_in\">cat</span> file | <span class=\"built_in\">tr</span> <span class=\"string\">&#x27;doABC&#x27;</span> <span class=\"string\">&#x27;hp&#x27;</span> : 将file中内容为<span class=\"keyword\">do</span>替换为hp，ABC都是用替换内容的最后一个字符p进行替换，即doABC替换为hpppp</span><br><span class=\"line\"><span class=\"built_in\">cat</span> file | <span class=\"built_in\">tr</span> <span class=\"string\">&quot;a-z&quot;</span> <span class=\"string\">&quot;A-Z&quot;</span> : 将小写字符替换为大写字符</span><br><span class=\"line\"><span class=\"built_in\">cat</span> file | <span class=\"built_in\">tr</span> <span class=\"string\">&quot;\\t&quot;</span> <span class=\"string\">&quot;$&quot;</span> : 支持转义字符，这里将tab替换为$</span><br><span class=\"line\"><span class=\"built_in\">cat</span> file | <span class=\"built_in\">tr</span> -d <span class=\"string\">&#x27;do&#x27;</span> : 将file中内容为<span class=\"keyword\">do</span>的内容删除</span><br><span class=\"line\"><span class=\"built_in\">cat</span> file | <span class=\"built_in\">tr</span> -s <span class=\"string\">&#x27;a-z&#x27;</span> : 去除file中重复的小写字符，只保留第一个</span><br></pre></td></tr></table></figure>\n<h2 id=\"cut\">cut</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>cut命令可以用于分隔每行的内容</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cut</span> [选项]... [文件]...</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 以空格作为分隔符，打印第一组</span></span><br><span class=\"line\"><span class=\"built_in\">cut</span> -d <span class=\"string\">&quot; &quot;</span> -f1 file</span><br><span class=\"line\">    -d：分隔符，按照指定分隔符分割列。与 -f 一起使用</span><br><span class=\"line\">    -f：依据 -d 的分隔字符将一段信息分割成为数段，用 -f 取出第几段的意思（列号，提取第几列）</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 以;作为分隔符，打印第二组和第三组，注意打印多组时，分隔符也会打印</span></span><br><span class=\"line\"><span class=\"built_in\">cut</span> -d <span class=\"string\">&quot;;&quot;</span> -f2,3 file</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从file文件中取出每行的第5~8个字符</span></span><br><span class=\"line\"><span class=\"built_in\">cut</span> -c 5-8 file</span><br><span class=\"line\">    -c : 以字符 (characters) 的单位取出固定字符区间，可以用来分割中文</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从file文件中取出每行的第2,4,6个字节</span></span><br><span class=\"line\"><span class=\"built_in\">cut</span> -b 2,4,6 file</span><br><span class=\"line\">    -b : 以字节为单位进行分割</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从file文件中取出每行的第6个字节之前的内容</span></span><br><span class=\"line\"><span class=\"built_in\">cut</span> -b -6 file</span><br><span class=\"line\"><span class=\"comment\"># 从file文件中取出每行的第3，第4、第5和第8个字节，数字定位的顺序必须由小到大</span></span><br><span class=\"line\"><span class=\"built_in\">cut</span> -b 3-5,8 file</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果使用-b提取中文，如果提取到的不是一个完整的中文字符所占的字节，就会出现乱码</span></span><br><span class=\"line\"><span class=\"comment\"># 比如在utf8编码下，一个中文占3个字节</span></span><br><span class=\"line\"><span class=\"built_in\">cut</span> -b 1 file : 此时中文字符会出现乱码</span><br><span class=\"line\"><span class=\"comment\"># 如果希望中文也能完整的提取，可以加上 -n</span></span><br><span class=\"line\"><span class=\"built_in\">cut</span> -nb 1 file</span><br></pre></td></tr></table></figure>\n<h2 id=\"paste\">paste</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>将多个文件的相应行用制表符连接起来，并输出到标准输出</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cat</span> p1.txt</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">$ <span class=\"built_in\">cat</span> p2.txt</span><br><span class=\"line\">zhangsan</span><br><span class=\"line\">lisi</span><br><span class=\"line\">wangwu</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 默认分隔符为制表符</span></span><br><span class=\"line\">$ <span class=\"built_in\">paste</span> p1.txt p2.txt</span><br><span class=\"line\">1\tzhangsan</span><br><span class=\"line\">2\tlisi</span><br><span class=\"line\">3\twangwu</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定逗号为分隔符</span></span><br><span class=\"line\">$ <span class=\"built_in\">paste</span> -d <span class=\"string\">&quot;,&quot;</span> p1.txt p2.txt</span><br><span class=\"line\">1,zhangsan</span><br><span class=\"line\">2,lisi</span><br><span class=\"line\">3,wangwu</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 每个文件的内容作为一行</span></span><br><span class=\"line\">$ <span class=\"built_in\">paste</span> -s -d <span class=\"string\">&quot;,&quot;</span> p1.txt p2.txt</span><br><span class=\"line\">1,2,3</span><br><span class=\"line\">zhangsan,lisi,wangwu</span><br></pre></td></tr></table></figure>\n<h2 id=\"split\">split</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>split命令用于将一个文件分割成数个。该指令将大文件分割成较小的文件，在默认情况下将按照每1000行切割成一个小文件。默认前缀为“x”。没有输入，或者当输入为<code>-</code>，则读取标准输入。</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">split</span> [选项]... [输入 [前缀]]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 分割为1000行的小文件，文件名格式xaa,xab...</span></span><br><span class=\"line\"><span class=\"built_in\">split</span> file</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#prefix指定分割后的文件前缀，默认为x</span></span><br><span class=\"line\"><span class=\"built_in\">split</span> file prefix</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 分割为指定行数的文件，如100行</span></span><br><span class=\"line\"><span class=\"built_in\">split</span> -l 100 file</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 分割为500M大小的文件</span></span><br><span class=\"line\"><span class=\"built_in\">split</span> -b 500M file</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定分割后小文件名后缀</span></span><br><span class=\"line\"><span class=\"built_in\">split</span> --additional-suffix=.<span class=\"built_in\">log</span> file</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用数字代替字符文件名，分割后的文件名为x00,x01...的数字形式</span></span><br><span class=\"line\"><span class=\"built_in\">split</span> -d file</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定分割后小文件名前缀后跟的文件名长度(不含前缀和后缀)，默认长度为2，这里文件名格式为xaaa.log,xaab.log...</span></span><br><span class=\"line\"><span class=\"comment\"># 当分割后文件的数量大于文件名能表达的最大文件数时，会报错</span></span><br><span class=\"line\"><span class=\"built_in\">split</span> -a 3 --additional-suffix=.<span class=\"built_in\">log</span> file</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将分割后的文件合并，如文件名格式为xaaa.log,xaab.log</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> x*.<span class=\"built_in\">log</span> &gt; newfile</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>实战<br>\n使用split数字命名时，序号是从0开始的，如果希望从1开始，可以使用如下方法：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 拆分为每100行一个文件，5位数字序号命名，文件名称为: x00000,x00001 ...</span></span><br><span class=\"line\"><span class=\"built_in\">split</span> -a 5 -d -l 100 content.txt</span><br><span class=\"line\"><span class=\"comment\"># 将每个文件名称中的数字加1后重新命名为: new00001,new00002 ...</span></span><br><span class=\"line\"><span class=\"built_in\">ls</span> -1 | grep ^x | awk -F <span class=\"string\">&#x27;x&#x27;</span> <span class=\"string\">&#x27;&#123;d=sprintf(&quot;%05d&quot; ,$2+1);system(&quot;mv &quot;$0&quot; new&quot;d)&#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n","content_text":"摘要 文本分割合并等相关命令，如tr、cut、paste和split等等 本文基于CentOS8(x86_64) tr tr用来从标准输入中替换、缩减和删除字符，并将结果写到标准输出 语法 1tr [选项]... SET1 [SET2] 示例 1234567cat file | tr &#x27;do&#x27; &#x27;hp&#x27; : 将file中内容为do替换为hp，替换内容与换内容长度一致cat file | tr &#x27;do&#x27; &#x27;hpa&#x27; : 将file中内容为do替换为hp，多出的a会内忽略cat file | tr &#x27;doABC&#x27; &#x27;hp&#x27; : 将file中内容为do替换为hp，ABC都是用替换内容的最后一个字符p进行替换，即doABC替换为hppppcat file | tr &quot;a-z&quot; &quot;A-Z&quot; : 将小写字符替换为大写字符cat file | tr &quot;\\t&quot; &quot;$&quot; : 支持转义字符，这里将tab替换为$cat file | tr -d &#x27;do&#x27; : 将file中内容为do的内容删除cat file | tr -s &#x27;a-z&#x27; : 去除file中重复的小写字符，只保留第一个 cut cut命令可以用于分隔每行的内容 语法 1cut [选项]... [文件]... 示例 1234567891011121314151617181920212223242526# 以空格作为分隔符，打印第一组cut -d &quot; &quot; -f1 file -d：分隔符，按照指定分隔符分割列。与 -f 一起使用 -f：依据 -d 的分隔字符将一段信息分割成为数段，用 -f 取出第几段的意思（列号，提取第几列）# 以;作为分隔符，打印第二组和第三组，注意打印多组时，分隔符也会打印cut -d &quot;;&quot; -f2,3 file# 从file文件中取出每行的第5~8个字符cut -c 5-8 file -c : 以字符 (characters) 的单位取出固定字符区间，可以用来分割中文# 从file文件中取出每行的第2,4,6个字节cut -b 2,4,6 file -b : 以字节为单位进行分割# 从file文件中取出每行的第6个字节之前的内容cut -b -6 file# 从file文件中取出每行的第3，第4、第5和第8个字节，数字定位的顺序必须由小到大cut -b 3-5,8 file# 如果使用-b提取中文，如果提取到的不是一个完整的中文字符所占的字节，就会出现乱码# 比如在utf8编码下，一个中文占3个字节cut -b 1 file : 此时中文字符会出现乱码# 如果希望中文也能完整的提取，可以加上 -ncut -nb 1 file paste 将多个文件的相应行用制表符连接起来，并输出到标准输出 12345678910111213141516171819202122232425$ cat p1.txt123$ cat p2.txtzhangsanlisiwangwu# 默认分隔符为制表符$ paste p1.txt p2.txt1 zhangsan2 lisi3 wangwu# 指定逗号为分隔符$ paste -d &quot;,&quot; p1.txt p2.txt1,zhangsan2,lisi3,wangwu# 每个文件的内容作为一行$ paste -s -d &quot;,&quot; p1.txt p2.txt1,2,3zhangsan,lisi,wangwu split split命令用于将一个文件分割成数个。该指令将大文件分割成较小的文件，在默认情况下将按照每1000行切割成一个小文件。默认前缀为“x”。没有输入，或者当输入为-，则读取标准输入。 语法 1split [选项]... [输入 [前缀]] 示例 123456789101112131415161718192021222324# 分割为1000行的小文件，文件名格式xaa,xab...split file#prefix指定分割后的文件前缀，默认为xsplit file prefix# 分割为指定行数的文件，如100行split -l 100 file# 分割为500M大小的文件split -b 500M file# 指定分割后小文件名后缀split --additional-suffix=.log file# 使用数字代替字符文件名，分割后的文件名为x00,x01...的数字形式split -d file# 指定分割后小文件名前缀后跟的文件名长度(不含前缀和后缀)，默认长度为2，这里文件名格式为xaaa.log,xaab.log...# 当分割后文件的数量大于文件名能表达的最大文件数时，会报错split -a 3 --additional-suffix=.log file# 将分割后的文件合并，如文件名格式为xaaa.log,xaab.logcat x*.log &gt; newfile 实战 使用split数字命名时，序号是从0开始的，如果希望从1开始，可以使用如下方法： 1234# 拆分为每100行一个文件，5位数字序号命名，文件名称为: x00000,x00001 ...split -a 5 -d -l 100 content.txt# 将每个文件名称中的数字加1后重新命名为: new00001,new00002 ...ls -1 | grep ^x | awk -F &#x27;x&#x27; &#x27;&#123;d=sprintf(&quot;%05d&quot; ,$2+1);system(&quot;mv &quot;$0&quot; new&quot;d)&#125;&#x27;","summary":"摘要 文本分割合并等相关命令，如tr、cut、paste和split等等 本文基于CentOS8(x86_64)","date_published":"2023-03-06T13:40:05.000Z","tags":["技术","linux","linux常用命令","linux常用命令"]},{"id":"https://blog.hanqunfeng.com/2023/03/06/linux-command03-awk/","url":"https://blog.hanqunfeng.com/2023/03/06/linux-command03-awk/","title":"Linux常用命令--awk","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度 ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>awk命令使用说明</p>\n</li>\n<li class=\"lvl-2\">\n<p>本文基于<code>CentOS8(x86_64)</code></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"awk\">awk</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>awk是一个强大的文本分析工具，在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">格式：awk [-F  field-separator]  <span class=\"string\">&#x27;commands&#x27;</span>  input-file(s)</span><br><span class=\"line\">其中，commands 是真正awk命令，[-F域分隔符]是可选的。 input-file(s) 是待处理的文件。</span><br><span class=\"line\">在awk中，文件的每一行中，由域分隔符分开的每一项称为一个域。通常，在不指名-F域分隔符的情况下，默认的域分隔符是空格。</span><br><span class=\"line\">如果希望指定两个或两个以上字符为分隔符时，则需要使用[ ]将分隔符括起来，如 -F [::]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>commands的格式: <code>匹配规则&#123;执行命令&#125;</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>默认情况下，awk 会将如下变量分配给它在文本行中发现的数据字段：</p>\n<blockquote>\n<p>$0 代表整个文本行；<br>\n$1 代表文本行中的第 1 个数据字段；<br>\n$2 代表文本行中的第 2 个数据字段；<br>\n$n 代表文本行中的第 n 个数据字段。</p>\n</blockquote>\n</li>\n</ul>\n<div class=\"tips\">\n<p><em><strong>小贴士</strong></em><br>\n<code>awk</code>是一种编程语言，它有好几种实现(解释器)，常见的如<code>awk</code>、<code>nawk</code>、<code>mawk</code>、<code>gawk</code>，<br>\nCentOS、Ubuntu等常用的Linux系统下awk的默认实现就是<code>gawk</code>。</p>\n</div>\n<h3 id=\"功能参数\">功能参数</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">功能参数\t解释</span><br><span class=\"line\">-F\t    指定分隔符，默认空格，指定两个或两个以上字符为分隔符时，则需要使用[ ]将分隔符括起来，如 -F [::]</span><br><span class=\"line\">-v\t    变量赋值</span><br><span class=\"line\"></span><br><span class=\"line\">模式\t                    解释</span><br><span class=\"line\">/regexp/\t            匹配满足正则表达式的行</span><br><span class=\"line\">+、-、*、/、%、^\t      加、减、乘、除、取余、指数</span><br><span class=\"line\">=\t                    变量赋值</span><br><span class=\"line\">||、&amp;&amp;\t                或者、并且</span><br><span class=\"line\">~、!~\t                满足某个正则、不满足某个正则</span><br><span class=\"line\">==、&gt;=、&lt;=、!=、&gt;、&lt;\t 等于、大于等于、小于等于、不等于、大于、小于</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 只是显示/etc/passwd的账户</span></span><br><span class=\"line\">awk -F <span class=\"string\">&#x27;:&#x27;</span> <span class=\"string\">&#x27;&#123;print $1&#125;&#x27;</span> /etc/passwd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义一个变量num=3,并参与计算并打印，num也可以设置为一个外部变量，如 num=$a，注意 &#123;&#125;里不能使用外部变量</span></span><br><span class=\"line\">awk -F <span class=\"string\">&#x27;:&#x27;</span> -v num=3 <span class=\"string\">&#x27;&#123;print num*$3&#125;&#x27;</span> /etc/passwd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 只是显示/etc/passwd的账户和账户对应的shell,而账户与shell之间以空格分割</span></span><br><span class=\"line\">awk -F <span class=\"string\">&#x27;:&#x27;</span> <span class=\"string\">&#x27;&#123;print $1,$7&#125;&#x27;</span> /etc/passwd</span><br><span class=\"line\"><span class=\"comment\"># 只是显示/etc/passwd的账户和账户对应的shell,而账户与shell之间以tab分割</span></span><br><span class=\"line\">awk -F <span class=\"string\">&#x27;:&#x27;</span> <span class=\"string\">&#x27;&#123;print $1&quot;\\t&quot;$7&#125;&#x27;</span> /etc/passwd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 只是显示/etc/passwd的账户和账户对应的shell,而账户与shell之间以逗号分割</span></span><br><span class=\"line\"><span class=\"comment\"># a.而且在所有行添加列名name,shell</span></span><br><span class=\"line\">awk -F <span class=\"string\">&#x27;:&#x27;</span> <span class=\"string\">&#x27;BEGIN &#123;print &quot;name,shell&quot;&#125; &#123;print $1&quot;,&quot;$7&#125;&#x27;</span> /etc/passwd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># b.在最后一行添加&quot;blue,/bin/nosh&quot;。</span></span><br><span class=\"line\">awk -F <span class=\"string\">&#x27;:&#x27;</span> <span class=\"string\">&#x27;&#123;print $1&quot;,&quot;$7&#125; END &#123;print &quot;blue,/bin/nosh&quot;&#125;&#x27;</span> /etc/passwd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># c.ab前后都加</span></span><br><span class=\"line\">awk -F <span class=\"string\">&#x27;:&#x27;</span> <span class=\"string\">&#x27;BEGIN &#123;print &quot;name,shell&quot;&#125; &#123;print $1&quot;,&quot;$7&#125; END &#123;print &quot;blue,/bin/nosh&quot;&#125;&#x27;</span> /etc/passwd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 搜索/etc/passwd有root关键字的所有行</span></span><br><span class=\"line\">awk -F <span class=\"string\">&#x27;:&#x27;</span> <span class=\"string\">&#x27;/root/&#x27;</span> /etc/passwd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 搜索/etc/passwd有root关键字的所有行，并显示对应的shell</span></span><br><span class=\"line\">awk -F <span class=\"string\">&#x27;:&#x27;</span> <span class=\"string\">&#x27;/root/&#123;print $1,$7&#125;&#x27;</span> /etc/passwd </span><br><span class=\"line\"><span class=\"comment\"># 多个命令之间加上分号</span></span><br><span class=\"line\">awk -F <span class=\"string\">&#x27;:&#x27;</span> <span class=\"string\">&#x27;/root/&#123;print $7;print $1&#125;&#x27;</span> /etc/passwd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 匹配空白行，如果 test.txt 有 N 个空白行，那么执行此命令会输出 N 个 Blank line</span></span><br><span class=\"line\">awk <span class=\"string\">&#x27;/^$/&#123;print &quot;Blank line&quot;&#125;&#x27;</span> test.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 匹配正则的行</span></span><br><span class=\"line\">awk -F <span class=\"string\">&quot;:&quot;</span> <span class=\"string\">&#x27;$1~/root/&#123;print $1,$3,$7&#125;&#x27;</span> /etc/passwd</span><br><span class=\"line\"><span class=\"comment\"># 不匹配正则的行</span></span><br><span class=\"line\">awk -F <span class=\"string\">&quot;:&quot;</span> <span class=\"string\">&#x27;$1!~/root/&#123;print $1,$3,$7&#125;&#x27;</span> /etc/passwd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 也可以把命令写在文件中，通过 -f 指定</span></span><br><span class=\"line\">awk -F <span class=\"string\">&#x27;:&#x27;</span> -f awk.sh /etc/passwd</span><br><span class=\"line\"><span class=\"built_in\">cat</span> awk.sh</span><br><span class=\"line\">/root/&#123;<span class=\"built_in\">print</span> <span class=\"variable\">$7</span>;<span class=\"built_in\">print</span> <span class=\"variable\">$1</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 并且，第一列字段包含rp并且行数大于10，打印行号和第1、3、7列，NR是内置变量，下面会说明</span></span><br><span class=\"line\">awk -F <span class=\"string\">&quot;:&quot;</span> <span class=\"string\">&#x27;$1~/rp/ &amp;&amp; NR&gt;10 &#123;print NR,$1,$3,$7&#125;&#x27;</span> /etc/passwd</span><br><span class=\"line\"><span class=\"comment\"># 或者</span></span><br><span class=\"line\">awk -F <span class=\"string\">&quot;:&quot;</span> <span class=\"string\">&#x27;$1~/rp/ || $1~/my/ &#123;print NR,$1,$3,$7&#125;&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure>\n<h3 id=\"awk内置变量\">awk内置变量</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>内置变量使用时不需要$前缀</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ARGC               命令行参数个数</span><br><span class=\"line\">ARGV               命令行参数排列</span><br><span class=\"line\">ENVIRON            支持队列中系统环境变量的使用</span><br><span class=\"line\">FILENAME           awk浏览的文件名</span><br><span class=\"line\">FNR                浏览文件的记录数</span><br><span class=\"line\">FS                 设置输入域分隔符，默认空格，等价于 -F选项</span><br><span class=\"line\">NF                 浏览记录的域的个数，分隔后的列数，<span class=\"variable\">$NF</span>表示打印最后一个字段</span><br><span class=\"line\">NR                 已读的记录数,记录所在的行号</span><br><span class=\"line\">OFS                输出域分隔符，默认空格</span><br><span class=\"line\">ORS                输出记录分隔符,默认\\n</span><br><span class=\"line\">RS                 控制记录分隔符,默认\\n</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 匹配包含root的行，并且打印行号，这里$NF 含以为：因为分隔后有7个字段，所有NF为7，$NF表示 $7 ,也就是打印第7个字段，即$NF表示打印最后一个字段</span></span><br><span class=\"line\">awk -F <span class=\"string\">&#x27;:&#x27;</span> <span class=\"string\">&#x27;/root/&#123;print NR,$1,$3,$NF&#125;&#x27;</span> /etc/passwd</span><br><span class=\"line\"><span class=\"comment\"># 设置输出分隔符为逗号</span></span><br><span class=\"line\">awk -F <span class=\"string\">&#x27;:&#x27;</span> <span class=\"string\">&#x27;BEGIN&#123;OFS=&quot;,&quot;&#125;/root/&#123;print NR,$1,$3,$NF&#125;&#x27;</span> /etc/passwd</span><br><span class=\"line\"><span class=\"comment\"># 或者</span></span><br><span class=\"line\">awk -F <span class=\"string\">&#x27;:&#x27;</span> <span class=\"string\">&#x27;/root/&#123;OFS=&quot;,&quot;;print NR,$1,$3,$NF&#125;&#x27;</span> /etc/passwd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 统计/etc/passwd:文件名，每行的行号，每行的列数，对应的完整行内容</span></span><br><span class=\"line\">awk  -F <span class=\"string\">&#x27;:&#x27;</span>  <span class=\"string\">&#x27;&#123;print &quot;filename:&quot; FILENAME &quot;,linenumber:&quot; NR &quot;,columns:&quot; NF &quot;,linecontent:&quot;$0&#125;&#x27;</span> /etc/passwd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用printf替代print,可以让代码更加简洁，易读</span></span><br><span class=\"line\">awk  -F <span class=\"string\">&#x27;:&#x27;</span>  <span class=\"string\">&#x27;&#123;printf(&quot;filename:%10s,linenumber:%s,columns:%s,linecontent:%s\\n&quot;,FILENAME,NR,NF,$0)&#125;&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>print和printf</strong></em></p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">awk中同时提供了print和printf两种打印输出的函数。</li>\n<li class=\"lvl-2\">其中print函数的参数可以是变量、数值或者字符串。字符串必须用双引号引用，参数用逗号分隔。如果没有逗号，参数就串联在一起而无法区分。这里，逗号的作用与输出文件的分隔符的作用是一样的，只是后者是空格而已。</li>\n<li class=\"lvl-2\">printf函数，其用法和c语言中printf基本相似,可以格式化字符串,输出复杂时，printf更加好用，代码更易懂。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%s : 字符串</span><br><span class=\"line\">%ms : 占位m个字节，默认右对齐，比如: %10s</span><br><span class=\"line\">%-ms : 占位m个字节，负号表示左对齐，正号表示右对齐，比如: %-10s</span><br><span class=\"line\">%d : 按十进制整型数据的实际长度输出。</span><br><span class=\"line\">%ld : 长整型</span><br><span class=\"line\">%md : m 为指定的输出字段的宽度。如果数据的位数小于 m，则左端补以空格，若大于 m，则按实际位数输出，默认友对齐。比如: %10d</span><br><span class=\"line\">%-md : 负号表示左对齐。比如: %-10d</span><br><span class=\"line\">%u : 无符号整型</span><br><span class=\"line\">%mu : 无符号整型，默认友对齐。比如: %10u</span><br><span class=\"line\">%-mu : 无符号整型，负号表示左对齐。比如: %-10u</span><br><span class=\"line\">%c : 字符</span><br><span class=\"line\">%f : 用来输出实数，包括单精度和双精度，以小数形式输出。整数部分全部输出，小数部分输出 6 位，超过 6 位的四舍五入。</span><br><span class=\"line\">%mf : m 为指定的输出字段的宽度，默认右对齐，比如: %20f</span><br><span class=\"line\">%-mf : m 为指定的输出字段的宽度，负号表示左对齐，比如: %-20f</span><br><span class=\"line\">%.mf : 输出实数时小数点后保留 m 位，注意 m 前面有个点，比如: %.2f</span><br><span class=\"line\">%m.mf : 负号表示左对齐，比如: %-20.2f</span><br><span class=\"line\">%o : 以八进制整数形式输出，输出格式为：24</span><br><span class=\"line\">%<span class=\"comment\">#o : 以八进制整数形式输出，输出格式为：024</span></span><br><span class=\"line\">%x : 以十六进制形式输出，输出格式为：2f</span><br><span class=\"line\">%X : 以十六进制形式输出，输出格式为：2F</span><br><span class=\"line\">%<span class=\"comment\">#x : 以十六进制形式输出，输出格式为：0x2f</span></span><br><span class=\"line\">%<span class=\"comment\">#X : 以十六进制形式输出，输出格式为：0x2F</span></span><br><span class=\"line\">\\n : 换行符，支持转义字符，如 \\t 等等</span><br><span class=\"line\">\\% : %</span><br><span class=\"line\">\\&quot; : <span class=\"string\">&quot;</span></span><br><span class=\"line\"><span class=\"string\">\\\\ : \\</span></span><br></pre></td></tr></table></figure>\n</div>\n<h3 id=\"awk编程\">awk编程</h3>\n<h4 id=\"基础语句\">基础语句</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>BEGIN &#123;&#125; &#123;&#125; END&#123;&#125;</code></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># count是自定义变量。之前的action&#123;&#125;里都是只有一个print,其实print只是一个语句，而action&#123;&#125;可以有多个语句，以;号隔开。</span></span><br><span class=\"line\">awk <span class=\"string\">&#x27;&#123;count++;print $0;&#125; END&#123;print &quot;user count is &quot;, count&#125;&#x27;</span> /etc/passwd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 上面没有初始化count，虽然默认是0，但是妥当的做法还是初始化为0:</span></span><br><span class=\"line\">awk <span class=\"string\">&#x27;BEGIN &#123;count=0;print &quot;[start]user count is &quot;, count&#125; &#123;count=count+1;print $0;&#125; END&#123;print &quot;[end]user count is &quot;, count&#125;&#x27;</span> /etc/passwd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 统计某个文件夹下的文件占用的字节数，单位M</span></span><br><span class=\"line\"><span class=\"built_in\">ls</span> -l |awk <span class=\"string\">&#x27;BEGIN &#123;size=0;&#125; &#123;size=size+$5;&#125; END&#123;print &quot;[end]size is &quot;, size/1024/1024,&quot;M&quot;&#125;&#x27;</span> </span><br></pre></td></tr></table></figure>\n<h4 id=\"条件语句\">条件语句</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>awk中的条件语句是从C语言中借鉴来的，见如下声明方式：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># a</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (expression) &#123;</span><br><span class=\"line\">    statement;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># b</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (expression) &#123;</span><br><span class=\"line\">    statement;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    statement2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># c</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (expression) &#123;</span><br><span class=\"line\">    statement1;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (expression1) &#123;</span><br><span class=\"line\">    statement2;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    statement3;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.检测系统中UID为0的用户</span></span><br><span class=\"line\">awk -F : <span class=\"string\">&#x27;&#123;if($3==0) &#123;print $1&#125;&#125;&#x27;</span> /etc/passwd</span><br><span class=\"line\">简写：</span><br><span class=\"line\">awk -F : <span class=\"string\">&#x27;$3==0 &#123;print $1&#125;&#x27;</span> /etc/passwd</span><br><span class=\"line\"></span><br><span class=\"line\">-F表示使用什么做为分隔符，这里使用冒号，默认是空格</span><br><span class=\"line\"><span class=\"variable\">$num</span>表示文件的第几列，这里<span class=\"variable\">$1</span>表示第一列</span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;</span>:固定格式，执行命令，这里表示，如果第三列是0,则打印第一列的内容</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.检测系统中密码为空的用户</span></span><br><span class=\"line\"></span><br><span class=\"line\">awk -F : <span class=\"string\">&#x27;&#123;if(length($2)==0) &#123;print $1&#125;&#125;&#x27;</span> /etc/passwd</span><br><span class=\"line\">简写：</span><br><span class=\"line\">awk -F : <span class=\"string\">&#x27;length($2)==0 &#123;print $1&#125;&#x27;</span> /etc/passwd</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3.取出第三行，第一列的值</span></span><br><span class=\"line\"></span><br><span class=\"line\">awk <span class=\"string\">&#x27;&#123;if(NR==3) &#123;print $1&#125;&#125;&#x27;</span> file</span><br><span class=\"line\">简写：</span><br><span class=\"line\">awk <span class=\"string\">&#x27;NR==3 &#123;print $1&#125;&#x27;</span> file</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4.跳过第一行</span></span><br><span class=\"line\">awk <span class=\"string\">&#x27;&#123;if(NR&gt;1) &#123;print $0&#125;&#125;&#x27;</span> file</span><br><span class=\"line\">简写：</span><br><span class=\"line\">awk <span class=\"string\">&#x27;NR&gt;1 &#123;print $0&#125;&#x27;</span> file</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 5.求和</span></span><br><span class=\"line\">awk -F <span class=\"string\">&#x27;;&#x27;</span> <span class=\"string\">&#x27;&#123;if($3&gt;0) &#123;s+=$3&#125;&#125; END &#123;print s&#125;&#x27;</span> file</span><br><span class=\"line\">简写：</span><br><span class=\"line\">awk -F <span class=\"string\">&#x27;;&#x27;</span> <span class=\"string\">&#x27;$3&gt;0 &#123;s+=$3&#125; END &#123;print s&#125;&#x27;</span> file</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 6.if else，~ ，!~\t某个字段满足某个正则或者不满足某个正则</span></span><br><span class=\"line\">awk <span class=\"string\">&#x27;&#123;if ($1 == &quot;foo&quot;) print &quot;Exact match foo&quot;; else if ($1 ~ &quot;bar&quot;) print &quot;Partial match bar&quot;; else print &quot;Baz&quot;&#125;&#x27;</span> path/to/file</span><br></pre></td></tr></table></figure>\n<h4 id=\"aws数组\">aws数组</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>awk中的数组用来从记录中收集信息，可以用于计算总和、统计单词以及跟踪模板被匹配的次数等等</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk -F <span class=\"string\">&#x27;:&#x27;</span> <span class=\"string\">&#x27;BEGIN &#123;count=0;&#125; &#123;name[count] = $1;count++;&#125;; END&#123;for (i = 0; i &lt; NR; i++)&#123;print i, name[i]&#125;&#125;&#x27;</span> /etc/passwd</span><br><span class=\"line\">简写：</span><br><span class=\"line\">awk -F <span class=\"string\">&#x27;:&#x27;</span> <span class=\"string\">&#x27;BEGIN &#123;count=0;&#125; &#123;name[count] = $1;count++;&#125;; END&#123;for (i = 0; i &lt; NR; i++) print i, name[i]&#125;&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure>\n<h4 id=\"aws循环语句\">aws循环语句</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>awk中的循环语句同样借鉴于C语言，支持while、do/while、for、break、continue，这些关键字的语义和C语言中的语义完全相同，感兴趣的自行查阅，这里不再赘述。</p>\n</li>\n</ul>\n","content_text":"摘要 awk命令使用说明 本文基于CentOS8(x86_64) awk awk是一个强大的文本分析工具，在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。 语法 1234格式：awk [-F field-separator] &#x27;commands&#x27; input-file(s)其中，commands 是真正awk命令，[-F域分隔符]是可选的。 input-file(s) 是待处理的文件。在awk中，文件的每一行中，由域分隔符分开的每一项称为一个域。通常，在不指名-F域分隔符的情况下，默认的域分隔符是空格。如果希望指定两个或两个以上字符为分隔符时，则需要使用[ ]将分隔符括起来，如 -F [::] commands的格式: 匹配规则&#123;执行命令&#125; 默认情况下，awk 会将如下变量分配给它在文本行中发现的数据字段： $0 代表整个文本行； $1 代表文本行中的第 1 个数据字段； $2 代表文本行中的第 2 个数据字段； $n 代表文本行中的第 n 个数据字段。 小贴士 awk是一种编程语言，它有好几种实现(解释器)，常见的如awk、nawk、mawk、gawk， CentOS、Ubuntu等常用的Linux系统下awk的默认实现就是gawk。 功能参数 1234567891011功能参数 解释-F 指定分隔符，默认空格，指定两个或两个以上字符为分隔符时，则需要使用[ ]将分隔符括起来，如 -F [::]-v 变量赋值模式 解释/regexp/ 匹配满足正则表达式的行+、-、*、/、%、^ 加、减、乘、除、取余、指数= 变量赋值||、&amp;&amp; 或者、并且~、!~ 满足某个正则、不满足某个正则==、&gt;=、&lt;=、!=、&gt;、&lt; 等于、大于等于、小于等于、不等于、大于、小于 示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 只是显示/etc/passwd的账户awk -F &#x27;:&#x27; &#x27;&#123;print $1&#125;&#x27; /etc/passwd# 定义一个变量num=3,并参与计算并打印，num也可以设置为一个外部变量，如 num=$a，注意 &#123;&#125;里不能使用外部变量awk -F &#x27;:&#x27; -v num=3 &#x27;&#123;print num*$3&#125;&#x27; /etc/passwd# 只是显示/etc/passwd的账户和账户对应的shell,而账户与shell之间以空格分割awk -F &#x27;:&#x27; &#x27;&#123;print $1,$7&#125;&#x27; /etc/passwd# 只是显示/etc/passwd的账户和账户对应的shell,而账户与shell之间以tab分割awk -F &#x27;:&#x27; &#x27;&#123;print $1&quot;\\t&quot;$7&#125;&#x27; /etc/passwd# 只是显示/etc/passwd的账户和账户对应的shell,而账户与shell之间以逗号分割# a.而且在所有行添加列名name,shellawk -F &#x27;:&#x27; &#x27;BEGIN &#123;print &quot;name,shell&quot;&#125; &#123;print $1&quot;,&quot;$7&#125;&#x27; /etc/passwd# b.在最后一行添加&quot;blue,/bin/nosh&quot;。awk -F &#x27;:&#x27; &#x27;&#123;print $1&quot;,&quot;$7&#125; END &#123;print &quot;blue,/bin/nosh&quot;&#125;&#x27; /etc/passwd# c.ab前后都加awk -F &#x27;:&#x27; &#x27;BEGIN &#123;print &quot;name,shell&quot;&#125; &#123;print $1&quot;,&quot;$7&#125; END &#123;print &quot;blue,/bin/nosh&quot;&#125;&#x27; /etc/passwd# 搜索/etc/passwd有root关键字的所有行awk -F &#x27;:&#x27; &#x27;/root/&#x27; /etc/passwd# 搜索/etc/passwd有root关键字的所有行，并显示对应的shellawk -F &#x27;:&#x27; &#x27;/root/&#123;print $1,$7&#125;&#x27; /etc/passwd # 多个命令之间加上分号awk -F &#x27;:&#x27; &#x27;/root/&#123;print $7;print $1&#125;&#x27; /etc/passwd# 匹配空白行，如果 test.txt 有 N 个空白行，那么执行此命令会输出 N 个 Blank lineawk &#x27;/^$/&#123;print &quot;Blank line&quot;&#125;&#x27; test.txt# 匹配正则的行awk -F &quot;:&quot; &#x27;$1~/root/&#123;print $1,$3,$7&#125;&#x27; /etc/passwd# 不匹配正则的行awk -F &quot;:&quot; &#x27;$1!~/root/&#123;print $1,$3,$7&#125;&#x27; /etc/passwd# 也可以把命令写在文件中，通过 -f 指定awk -F &#x27;:&#x27; -f awk.sh /etc/passwdcat awk.sh/root/&#123;print $7;print $1&#125;# 并且，第一列字段包含rp并且行数大于10，打印行号和第1、3、7列，NR是内置变量，下面会说明awk -F &quot;:&quot; &#x27;$1~/rp/ &amp;&amp; NR&gt;10 &#123;print NR,$1,$3,$7&#125;&#x27; /etc/passwd# 或者awk -F &quot;:&quot; &#x27;$1~/rp/ || $1~/my/ &#123;print NR,$1,$3,$7&#125;&#x27; /etc/passwd awk内置变量 内置变量使用时不需要$前缀 1234567891011ARGC 命令行参数个数ARGV 命令行参数排列ENVIRON 支持队列中系统环境变量的使用FILENAME awk浏览的文件名FNR 浏览文件的记录数FS 设置输入域分隔符，默认空格，等价于 -F选项NF 浏览记录的域的个数，分隔后的列数，$NF表示打印最后一个字段NR 已读的记录数,记录所在的行号OFS 输出域分隔符，默认空格ORS 输出记录分隔符,默认\\nRS 控制记录分隔符,默认\\n 123456789101112# 匹配包含root的行，并且打印行号，这里$NF 含以为：因为分隔后有7个字段，所有NF为7，$NF表示 $7 ,也就是打印第7个字段，即$NF表示打印最后一个字段awk -F &#x27;:&#x27; &#x27;/root/&#123;print NR,$1,$3,$NF&#125;&#x27; /etc/passwd# 设置输出分隔符为逗号awk -F &#x27;:&#x27; &#x27;BEGIN&#123;OFS=&quot;,&quot;&#125;/root/&#123;print NR,$1,$3,$NF&#125;&#x27; /etc/passwd# 或者awk -F &#x27;:&#x27; &#x27;/root/&#123;OFS=&quot;,&quot;;print NR,$1,$3,$NF&#125;&#x27; /etc/passwd# 统计/etc/passwd:文件名，每行的行号，每行的列数，对应的完整行内容awk -F &#x27;:&#x27; &#x27;&#123;print &quot;filename:&quot; FILENAME &quot;,linenumber:&quot; NR &quot;,columns:&quot; NF &quot;,linecontent:&quot;$0&#125;&#x27; /etc/passwd# 使用printf替代print,可以让代码更加简洁，易读awk -F &#x27;:&#x27; &#x27;&#123;printf(&quot;filename:%10s,linenumber:%s,columns:%s,linecontent:%s\\n&quot;,FILENAME,NR,NF,$0)&#125;&#x27; /etc/passwd print和printf awk中同时提供了print和printf两种打印输出的函数。 其中print函数的参数可以是变量、数值或者字符串。字符串必须用双引号引用，参数用逗号分隔。如果没有逗号，参数就串联在一起而无法区分。这里，逗号的作用与输出文件的分隔符的作用是一样的，只是后者是空格而已。 printf函数，其用法和c语言中printf基本相似,可以格式化字符串,输出复杂时，printf更加好用，代码更易懂。 1234567891011121314151617181920212223242526%s : 字符串%ms : 占位m个字节，默认右对齐，比如: %10s%-ms : 占位m个字节，负号表示左对齐，正号表示右对齐，比如: %-10s%d : 按十进制整型数据的实际长度输出。%ld : 长整型%md : m 为指定的输出字段的宽度。如果数据的位数小于 m，则左端补以空格，若大于 m，则按实际位数输出，默认友对齐。比如: %10d%-md : 负号表示左对齐。比如: %-10d%u : 无符号整型%mu : 无符号整型，默认友对齐。比如: %10u%-mu : 无符号整型，负号表示左对齐。比如: %-10u%c : 字符%f : 用来输出实数，包括单精度和双精度，以小数形式输出。整数部分全部输出，小数部分输出 6 位，超过 6 位的四舍五入。%mf : m 为指定的输出字段的宽度，默认右对齐，比如: %20f%-mf : m 为指定的输出字段的宽度，负号表示左对齐，比如: %-20f%.mf : 输出实数时小数点后保留 m 位，注意 m 前面有个点，比如: %.2f%m.mf : 负号表示左对齐，比如: %-20.2f%o : 以八进制整数形式输出，输出格式为：24%#o : 以八进制整数形式输出，输出格式为：024%x : 以十六进制形式输出，输出格式为：2f%X : 以十六进制形式输出，输出格式为：2F%#x : 以十六进制形式输出，输出格式为：0x2f%#X : 以十六进制形式输出，输出格式为：0x2F\\n : 换行符，支持转义字符，如 \\t 等等\\% : %\\&quot; : &quot;\\\\ : \\ awk编程 基础语句 BEGIN &#123;&#125; &#123;&#125; END&#123;&#125; 12345678# count是自定义变量。之前的action&#123;&#125;里都是只有一个print,其实print只是一个语句，而action&#123;&#125;可以有多个语句，以;号隔开。awk &#x27;&#123;count++;print $0;&#125; END&#123;print &quot;user count is &quot;, count&#125;&#x27; /etc/passwd# 上面没有初始化count，虽然默认是0，但是妥当的做法还是初始化为0:awk &#x27;BEGIN &#123;count=0;print &quot;[start]user count is &quot;, count&#125; &#123;count=count+1;print $0;&#125; END&#123;print &quot;[end]user count is &quot;, count&#125;&#x27; /etc/passwd# 统计某个文件夹下的文件占用的字节数，单位Mls -l |awk &#x27;BEGIN &#123;size=0;&#125; &#123;size=size+$5;&#125; END&#123;print &quot;[end]size is &quot;, size/1024/1024,&quot;M&quot;&#125;&#x27; 条件语句 awk中的条件语句是从C语言中借鉴来的，见如下声明方式： 12345678910111213141516171819202122# aif (expression) &#123; statement;&#125;# bif (expression) &#123; statement;&#125; else &#123; statement2;&#125;# cif (expression) &#123; statement1;&#125; else if (expression1) &#123; statement2;&#125; else &#123; statement3;&#125; 示例 1234567891011121314151617181920212223242526272829303132333435# 1.检测系统中UID为0的用户awk -F : &#x27;&#123;if($3==0) &#123;print $1&#125;&#125;&#x27; /etc/passwd简写：awk -F : &#x27;$3==0 &#123;print $1&#125;&#x27; /etc/passwd-F表示使用什么做为分隔符，这里使用冒号，默认是空格$num表示文件的第几列，这里$1表示第一列&#x27;&#x27;:固定格式，执行命令，这里表示，如果第三列是0,则打印第一列的内容# 2.检测系统中密码为空的用户awk -F : &#x27;&#123;if(length($2)==0) &#123;print $1&#125;&#125;&#x27; /etc/passwd简写：awk -F : &#x27;length($2)==0 &#123;print $1&#125;&#x27; /etc/passwd# 3.取出第三行，第一列的值awk &#x27;&#123;if(NR==3) &#123;print $1&#125;&#125;&#x27; file简写：awk &#x27;NR==3 &#123;print $1&#125;&#x27; file# 4.跳过第一行awk &#x27;&#123;if(NR&gt;1) &#123;print $0&#125;&#125;&#x27; file简写：awk &#x27;NR&gt;1 &#123;print $0&#125;&#x27; file# 5.求和awk -F &#x27;;&#x27; &#x27;&#123;if($3&gt;0) &#123;s+=$3&#125;&#125; END &#123;print s&#125;&#x27; file简写：awk -F &#x27;;&#x27; &#x27;$3&gt;0 &#123;s+=$3&#125; END &#123;print s&#125;&#x27; file# 6.if else，~ ，!~ 某个字段满足某个正则或者不满足某个正则awk &#x27;&#123;if ($1 == &quot;foo&quot;) print &quot;Exact match foo&quot;; else if ($1 ~ &quot;bar&quot;) print &quot;Partial match bar&quot;; else print &quot;Baz&quot;&#125;&#x27; path/to/file aws数组 awk中的数组用来从记录中收集信息，可以用于计算总和、统计单词以及跟踪模板被匹配的次数等等 123awk -F &#x27;:&#x27; &#x27;BEGIN &#123;count=0;&#125; &#123;name[count] = $1;count++;&#125;; END&#123;for (i = 0; i &lt; NR; i++)&#123;print i, name[i]&#125;&#125;&#x27; /etc/passwd简写：awk -F &#x27;:&#x27; &#x27;BEGIN &#123;count=0;&#125; &#123;name[count] = $1;count++;&#125;; END&#123;for (i = 0; i &lt; NR; i++) print i, name[i]&#125;&#x27; /etc/passwd aws循环语句 awk中的循环语句同样借鉴于C语言，支持while、do/while、for、break、continue，这些关键字的语义和C语言中的语义完全相同，感兴趣的自行查阅，这里不再赘述。","summary":"摘要 awk命令使用说明 本文基于CentOS8(x86_64)","date_published":"2023-03-06T13:35:05.000Z","tags":["技术","linux","linux常用命令","linux常用命令"]},{"id":"https://blog.hanqunfeng.com/2023/03/06/linux-command03-sed/","url":"https://blog.hanqunfeng.com/2023/03/06/linux-command03-sed/","title":"Linux常用命令--sed","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度 ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>sed命令使用说明</p>\n</li>\n<li class=\"lvl-2\">\n<p>本文基于<code>CentOS8(x86_64)</code></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"sed\">sed</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>sed</code> 是一种在线编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出。</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>sed</code> 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">格式：sed [options] <span class=\"string\">&#x27;command&#x27;</span> file(s)</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>参数</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">功能参数\t        解释</span><br><span class=\"line\">-n\t            关闭输出，和p一起使用只输出被sed处理的行</span><br><span class=\"line\">-e\t            多重编辑，且顺序会影响结果</span><br><span class=\"line\">-r\t            使用扩展正则</span><br><span class=\"line\">-i\t            将修改的内容覆盖到文档，使用时要小心</span><br><span class=\"line\">-f\t            指定一个sed脚本文件到命令行执行</span><br><span class=\"line\"></span><br><span class=\"line\">范围表达式\t        解释</span><br><span class=\"line\"><span class=\"string\">&#x27;2,5p&#x27;</span>\t        打印2-5行</span><br><span class=\"line\"><span class=\"string\">&#x27;2p;5p&#x27;</span>         打印2和5行</span><br><span class=\"line\"><span class=\"string\">&#x27;2,+5p&#x27;</span>\t        打印第2行及其以下5行</span><br><span class=\"line\"><span class=\"string\">&#x27;2~2p&#x27;</span>\t        从第二行开始步长为2打印，即打印2，4，6，8……行</span><br><span class=\"line\"><span class=\"string\">&#x27;/regexp/p&#x27;</span>\t    打印正则表达式匹配出的行</span><br><span class=\"line\"><span class=\"string\">&#x27;2,/aaa/p&#x27;</span>\t    打印第2行到下一次出现aaa的行，如果aaa在第二行之前或者不存在则打印到行尾</span><br><span class=\"line\"><span class=\"string\">&#x27;/aaa/,/bbb/p&#x27;</span>\t打印aaa所在的行到bbb所在的行，如果bbb在aaa之前或者不存在则打印到行尾</span><br><span class=\"line\"></span><br><span class=\"line\">动作\t 解释</span><br><span class=\"line\">p\t    打印</span><br><span class=\"line\">d\t    删除</span><br><span class=\"line\">s\t    替换</span><br><span class=\"line\">a\t    当前行后追加</span><br><span class=\"line\">i\t    当前行前插入</span><br><span class=\"line\">c\t    将当前行替换</span><br><span class=\"line\">n\t    匹配行的下一行</span><br><span class=\"line\">y\t    替换，固定用法 y/abcd/ABCD/ 将a替换为A，b替换为B……</span><br><span class=\"line\">q\t    退出sed</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"1-删除：d命令\">1)删除：d命令</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除example文件的第二行</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;2d&#x27;</span> example</span><br><span class=\"line\"><span class=\"comment\"># 删除第二行和第五行</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;2d;5d&#x27;</span> example</span><br><span class=\"line\"><span class=\"comment\"># 删除第二行到第五行</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;2,5d&#x27;</span> example</span><br><span class=\"line\"><span class=\"comment\"># 删除第二行及其之后的五行</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;2,+5d&#x27;</span> example</span><br><span class=\"line\"><span class=\"comment\"># 删除example文件的第二行到末尾所有行</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;2,$d&#x27;</span> example  </span><br><span class=\"line\"><span class=\"comment\"># 删除example文件的最后一行</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;$d&#x27;</span> example</span><br><span class=\"line\"><span class=\"comment\"># 删除example文件所有包含test的行</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;/test/d&#x27;</span> example</span><br><span class=\"line\"><span class=\"comment\"># 所有在模板test和check所确定的范围内的行都被删除</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;/test/,/check/d&#x27;</span> example</span><br><span class=\"line\"><span class=\"comment\"># 从第一行开始，每间隔一行删除一行，这里表示删除1，3，5...行</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;1~2d&#x27;</span> example</span><br><span class=\"line\"><span class=\"comment\"># 删除匹配行的下一行，n表示下一行</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;/test/&#123;n;d&#125;&#x27;</span> example</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除变量指定的行，注意这里要使用双引号</span></span><br><span class=\"line\">sed <span class=\"string\">&quot;1,<span class=\"variable\">$&#123;lineNum&#125;</span>d&quot;</span> example</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-替换：s命令\">2)替换：s命令</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 替换第几处模式匹配的地方，这里2表示替换第二处匹配的地方</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;s/test/mytest/2&#x27;</span> example</span><br><span class=\"line\">    n : 1~512 之间的数字，表示指定要替换的字符串出现第几次时才进行替换</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在整行范围内把test(i不区分大小写)替换为mytest。如果没有g标记，则只有每行第一个匹配的test被替换成mytest</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;s/test/mytest/ig&#x27;</span> example</span><br><span class=\"line\">    i : 不区分大小写</span><br><span class=\"line\">    g : 对数据中所有匹配到的内容进行替换，不加g只匹配第一个</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># (-n)选项和p标志一起使用表示只打印那些发生替换的行。也就是说，如果某一行开头的test被替换成mytest，就打印它</span></span><br><span class=\"line\">sed -n <span class=\"string\">&#x27;s/^test/mytest/p&#x27;</span> example </span><br><span class=\"line\">    -n : 关闭输出，和p标志一起使用表示只打印那些发生替换的行</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># &amp;符号表示替换字符串中被找到的部份。所有以192.168.0.1开头的行都会被替换成它自已加 localhost，变成192.168.0.1localhost</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;s/^192.168.0.1/&amp;localhost/&#x27;</span> example </span><br><span class=\"line\">    &amp; : 表示替换字符串中被找到的部份</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># love被标记为1，所有loveable会被替换成lovers，而且替换的行会被打印出来。</span></span><br><span class=\"line\">sed -n <span class=\"string\">&#x27;s/\\(love\\)able/\\1rs/p&#x27;</span> example </span><br><span class=\"line\">    () : 标记搜索内容，括号顺序按1，2...顺序被标记，注意这里需要被转义</span><br><span class=\"line\"><span class=\"comment\"># love被标记为1，所有loveable会被替换成lovers，打印所有行</span></span><br><span class=\"line\">sed -r <span class=\"string\">&#x27;s/(^love)able/\\1rs/&#x27;</span> example </span><br><span class=\"line\">    -r : 支持扩展正则，这里()不需要被转义</span><br><span class=\"line\"><span class=\"comment\"># 所有loveable会被替换成loversbl，括号顺序按1，2...顺序被标记</span></span><br><span class=\"line\">sed -r <span class=\"string\">&#x27;s/(^love)a(bl)e/\\1rs\\2/&#x27;</span> example </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 不论什么字符，紧跟着s命令的都被认为是新的分隔符，所以，“#”在这里是分隔符，代替了默认的“/”分隔符。表示把所有10替换成100</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;s#10#100#g&#x27;</span> example </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># -i直接替换源文件，慎重使用</span></span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;s/test/mytest/ig&#x27;</span> example </span><br><span class=\"line\">    -i : 直接替换源文件，慎重使用</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># w标记会将匹配后的结果保存到指定文件中，注意这里text.txt中只会保留那些发生替换的行</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;s/test/mytest/w test.txt&#x27;</span> example  ====&gt; sed -n <span class=\"string\">&#x27;s/test/mytest/p&#x27;</span> example &gt; test.txt</span><br><span class=\"line\">    w : 会将匹配后的结果保存到指定文件中</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 替换变量指定的行，注意这里要使用双引号，如果替换内容为双引号，要进行转义</span></span><br><span class=\"line\"><span class=\"comment\"># 这里将第一行到指定的行中的&quot;&#125;替换为&quot;&#125;,</span></span><br><span class=\"line\">sed -r <span class=\"string\">&quot;1,<span class=\"variable\">$&#123;lineNum&#125;</span>s/(\\&quot;&#125;)/\\1,/&quot;</span> example </span><br></pre></td></tr></table></figure>\n<h3 id=\"3-选定行的范围：逗号\">3)选定行的范围：逗号</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 所有在模板test和check所确定的范围内的行都被打印 </span></span><br><span class=\"line\">sed -n <span class=\"string\">&#x27;/test/,/check/p&#x27;</span> example</span><br><span class=\"line\"><span class=\"comment\"># 按连续内容截取，这里还是按关键字搜索匹配，这里假设每行都有序号并且连续</span></span><br><span class=\"line\">sed -n <span class=\"string\">&#x27;/5518/,/5524/p&#x27;</span> example  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># grep也有类似方法：</span></span><br><span class=\"line\">countnum=$[ <span class=\"variable\">$endnum</span> - <span class=\"variable\">$startnum</span> + 1  ]</span><br><span class=\"line\">grep <span class=\"string\">&quot;<span class=\"variable\">$startnum</span>&quot;</span> file -A <span class=\"variable\">$countnum</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 打印文件的第二行</span></span><br><span class=\"line\">sed -n <span class=\"string\">&#x27;2p&#x27;</span> example</span><br><span class=\"line\"><span class=\"comment\"># 打印文件的第二行和第四行</span></span><br><span class=\"line\">sed -n <span class=\"string\">&#x27;2p;4p&#x27;</span> example</span><br><span class=\"line\"><span class=\"comment\"># 打印第1行到第100百行</span></span><br><span class=\"line\">sed -n <span class=\"string\">&#x27;1,100p&#x27;</span> example  </span><br><span class=\"line\"><span class=\"comment\"># 打印从第五行开始到第一个包含以test开始的行之间的所有行</span></span><br><span class=\"line\">sed -n <span class=\"string\">&#x27;5,/^test/p&#x27;</span> example</span><br><span class=\"line\"><span class=\"comment\"># 打印从第一个包含以test开始的行到第五行之间的所有行</span></span><br><span class=\"line\">sed -n <span class=\"string\">&#x27;/^test/,5p&#x27;</span> example</span><br><span class=\"line\"><span class=\"comment\"># 打印从第一个包含以test开始的行到最后一行之间的所有行</span></span><br><span class=\"line\">sed -n <span class=\"string\">&#x27;/^test/,$p&#x27;</span> example</span><br><span class=\"line\"><span class=\"comment\"># 打印包含java或者linux的行</span></span><br><span class=\"line\">sed -r -n <span class=\"string\">&#x27;/java|linux/p&#x27;</span> example</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从第一行开始，间隔2行打印，这里表示打印1，4，7，10...行</span></span><br><span class=\"line\">sed -n <span class=\"string\">&#x27;1~3p&#x27;</span> example</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 打印以java开头的所有行</span></span><br><span class=\"line\">sed -n <span class=\"string\">&#x27;/^java/p&#x27;</span> example</span><br><span class=\"line\"><span class=\"comment\"># 打印以java开头的所有行的下一行</span></span><br><span class=\"line\">sed -n <span class=\"string\">&#x27;/^java/&#123;n;p&#125;&#x27;</span> example</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 对于模板test和check之间的行，每行的末尾用字符串sed test替换</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;/test/,/check/s/$/sed test/&#x27;</span> example</span><br><span class=\"line\"><span class=\"comment\"># 第2到5行，每行的末尾用字符串sed test替换</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;2,5s/$/sed test/&#x27;</span> example</span><br><span class=\"line\"><span class=\"comment\"># 第2到最后一行，每行的末尾用字符串sed test替换</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;2,$s/$/sed test/&#x27;</span> example</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-多点编辑：e命令\">4)多点编辑：e命令</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># (-e)选项允许在同一行里执行多条命令。如例子所示，第一条命令删除1至5行，第二条命令用check替换test。命令的执行顺序对结果有影响。如果两个命令都是替换命令，那么第一个替换命令将影响第二个替换命令的结果</span></span><br><span class=\"line\">sed -e <span class=\"string\">&#x27;1,5d&#x27;</span> -e <span class=\"string\">&#x27;s/test/check/&#x27;</span> example</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 一个比-e更好的命令是--expression。它能给sed表达式赋值。</span></span><br><span class=\"line\">sed --expression=<span class=\"string\">&#x27;s/test/check/&#x27;</span> --expression=<span class=\"string\">&#x27;/love/d&#x27;</span> example</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">totalLine=`<span class=\"built_in\">cat</span> title_list.json | <span class=\"built_in\">wc</span> -l`</span><br><span class=\"line\">lastLineBefore1=$((<span class=\"variable\">$totalLine</span>-<span class=\"number\">1</span>))</span><br><span class=\"line\">sed -i -r -e <span class=\"string\">&quot;1,<span class=\"variable\">$&#123;lastLineBefore1&#125;</span>s/(\\&quot;&#125;)/\\1,/&quot;</span> -e <span class=\"string\">&#x27;1d&#x27;</span> -e <span class=\"string\">&#x27;2i &#123;[&#x27;</span> -e <span class=\"string\">&#x27;$a ]&#125;&#x27;</span> title_list.json</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-追加行或替换行：a、i、c和r\">5)追加行或替换行：a、i、c和r</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>a 命令表示在指定行的后面附加一行，i 命令表示在指定行的前面插入一行</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将hello wordl 插入到第二行上面</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;2i hello world&#x27;</span> example</span><br><span class=\"line\">    i : 表示在指定行的前面插入一行，<span class=\"variable\">$i</span> 表示最后一行前插入</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将hello wordl 插入到第二行下面</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;2a hello world&#x27;</span> example</span><br><span class=\"line\">    a : 表示在指定行的后面插入一行，<span class=\"variable\">$a</span> 表示最后一行后插入</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 也可以同时插入多行内容，使用反斜线即可，这里表示在第二行下面添加两行内容</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;2a\\</span></span><br><span class=\"line\"><span class=\"string\">&gt; hello world\\</span></span><br><span class=\"line\"><span class=\"string\">&gt; i love you&#x27;</span> example</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>c 命令表示将指定行中的所有内容，替换成该选项后面的字符串</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将匹配到的所有含有hello的行替换为hello world</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;/hello/c hello world&#x27;</span> example</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将hello world 替换第二行</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;2c hello world&#x27;</span> example</span><br><span class=\"line\">    c : 替换行内容</span><br><span class=\"line\"><span class=\"comment\"># 同样支持替换为多行</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;2c\\</span></span><br><span class=\"line\"><span class=\"string\">&gt; hello world\\</span></span><br><span class=\"line\"><span class=\"string\">&gt; i love you&#x27;</span> example</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>r 命令用于将一个独立文件的数据插入到当前数据流的指定位置</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将text.txt中的内容插入到example文件的第二行下面</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;2r test.txt&#x27;</span> example</span><br><span class=\"line\"><span class=\"comment\"># 将text.txt中的内容插入到example文件的末尾</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;$r test.txt&#x27;</span> example</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-处理单个字符：y\">6)处理单个字符：y</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将所有以hello开头的行中的 a替换为A，b替换为B，c替换为C，d替换为D</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;/^hello/y/abcd/ABCD/&#x27;</span> example</span><br><span class=\"line\"></span><br><span class=\"line\">$ <span class=\"built_in\">echo</span> <span class=\"string\">&quot;This 1 is a test2 of 1 try3.&quot;</span> | sed <span class=\"string\">&#x27;y/123/456/&#x27;</span></span><br><span class=\"line\">This 4 is a test5 of 4 try6.</span><br><span class=\"line\">    y : 字符全局替换，原字符与替换字符的长度必须相同</span><br></pre></td></tr></table></figure>\n<h3 id=\"7-指定行区间\">7)指定行区间</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>默认情况下，sed 命令会作用于文本数据的所有行，如果只想将命令作用于特定行或某些行，需要明确指定行区间范围。</p>\n</li>\n<li class=\"lvl-2\">\n<p>行区间可以通过如下两种方式进行限定：</p>\n<blockquote>\n<p>1.以数字形式指定行区间<br>\n2.用文本模式指定具体行区间</p>\n</blockquote>\n</li>\n<li class=\"lvl-2\">\n<p>行区间放在命令的前面，具体格式如下：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[行区间]脚本命令</span><br><span class=\"line\"></span><br><span class=\"line\">或者</span><br><span class=\"line\"></span><br><span class=\"line\">行区间 &#123;</span><br><span class=\"line\">    多个脚本命令,分号分隔</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例:以数字形式指定行区间</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 替换第二行中的内容</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;2s/dog/cat/&#x27;</span> test.txt</span><br><span class=\"line\"><span class=\"comment\"># 替换第二行到第四行中的内容</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;2,4s/dog/cat/&#x27;</span> test.txt</span><br><span class=\"line\"><span class=\"comment\"># 替换第二行到文件最后一行中的内容</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;2,$s/dog/cat/&#x27;</span> test.txt</span><br><span class=\"line\"><span class=\"comment\"># 从第一行开始，每间隔一行进行替换，1，3，5，7...</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;1~2s/dog/cat/&#x27;</span> test.txt</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例:用文本模式指定具体行区间</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 替换内容中包含pig的所有行的内容</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;/pig/s/dog/cat/&#x27;</span> test.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 正则匹配限制范围，&#123;&#125;指定多个脚本，这个命令的作用是将 h1Helloh1 转换为 &lt;h1&gt;Hello&lt;/h1&gt;</span></span><br><span class=\"line\">sed <span class=\"string\">&#x27;/h[0-9]/&#123;s//\\&lt;&amp;\\&gt;/1;s//\\&lt;\\/&amp;\\&gt;/2&#125;&#x27;</span> test.txt</span><br><span class=\"line\"><span class=\"comment\"># 也可以将命令写到文件中，通过 -f 参数指定</span></span><br><span class=\"line\">sed -f sed.txt test.txt</span><br><span class=\"line\"><span class=\"built_in\">cat</span> sed.txt</span><br><span class=\"line\">/h[0-9]/&#123;</span><br><span class=\"line\">    s//\\&lt;&amp;\\&gt;/1</span><br><span class=\"line\">    s//\\&lt;\\/&amp;\\&gt;/2</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","content_text":"摘要 sed命令使用说明 本文基于CentOS8(x86_64) sed sed 是一种在线编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出。 sed 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。 语法 1格式：sed [options] &#x27;command&#x27; file(s) 参数 123456789101112131415161718192021222324252627功能参数 解释-n 关闭输出，和p一起使用只输出被sed处理的行-e 多重编辑，且顺序会影响结果-r 使用扩展正则-i 将修改的内容覆盖到文档，使用时要小心-f 指定一个sed脚本文件到命令行执行范围表达式 解释&#x27;2,5p&#x27; 打印2-5行&#x27;2p;5p&#x27; 打印2和5行&#x27;2,+5p&#x27; 打印第2行及其以下5行&#x27;2~2p&#x27; 从第二行开始步长为2打印，即打印2，4，6，8……行&#x27;/regexp/p&#x27; 打印正则表达式匹配出的行&#x27;2,/aaa/p&#x27; 打印第2行到下一次出现aaa的行，如果aaa在第二行之前或者不存在则打印到行尾&#x27;/aaa/,/bbb/p&#x27; 打印aaa所在的行到bbb所在的行，如果bbb在aaa之前或者不存在则打印到行尾动作 解释p 打印d 删除s 替换a 当前行后追加i 当前行前插入c 将当前行替换n 匹配行的下一行y 替换，固定用法 y/abcd/ABCD/ 将a替换为A，b替换为B……q 退出sed 1)删除：d命令 1234567891011121314151617181920212223# 删除example文件的第二行sed &#x27;2d&#x27; example# 删除第二行和第五行sed &#x27;2d;5d&#x27; example# 删除第二行到第五行sed &#x27;2,5d&#x27; example# 删除第二行及其之后的五行sed &#x27;2,+5d&#x27; example# 删除example文件的第二行到末尾所有行sed &#x27;2,$d&#x27; example # 删除example文件的最后一行sed &#x27;$d&#x27; example# 删除example文件所有包含test的行sed &#x27;/test/d&#x27; example# 所有在模板test和check所确定的范围内的行都被删除sed &#x27;/test/,/check/d&#x27; example# 从第一行开始，每间隔一行删除一行，这里表示删除1，3，5...行sed &#x27;1~2d&#x27; example# 删除匹配行的下一行，n表示下一行sed &#x27;/test/&#123;n;d&#125;&#x27; example# 删除变量指定的行，注意这里要使用双引号sed &quot;1,$&#123;lineNum&#125;d&quot; example 2)替换：s命令 12345678910111213141516171819202122232425262728293031323334353637383940# 替换第几处模式匹配的地方，这里2表示替换第二处匹配的地方sed &#x27;s/test/mytest/2&#x27; example n : 1~512 之间的数字，表示指定要替换的字符串出现第几次时才进行替换# 在整行范围内把test(i不区分大小写)替换为mytest。如果没有g标记，则只有每行第一个匹配的test被替换成mytestsed &#x27;s/test/mytest/ig&#x27; example i : 不区分大小写 g : 对数据中所有匹配到的内容进行替换，不加g只匹配第一个# (-n)选项和p标志一起使用表示只打印那些发生替换的行。也就是说，如果某一行开头的test被替换成mytest，就打印它sed -n &#x27;s/^test/mytest/p&#x27; example -n : 关闭输出，和p标志一起使用表示只打印那些发生替换的行# &amp;符号表示替换字符串中被找到的部份。所有以192.168.0.1开头的行都会被替换成它自已加 localhost，变成192.168.0.1localhostsed &#x27;s/^192.168.0.1/&amp;localhost/&#x27; example &amp; : 表示替换字符串中被找到的部份# love被标记为1，所有loveable会被替换成lovers，而且替换的行会被打印出来。sed -n &#x27;s/\\(love\\)able/\\1rs/p&#x27; example () : 标记搜索内容，括号顺序按1，2...顺序被标记，注意这里需要被转义# love被标记为1，所有loveable会被替换成lovers，打印所有行sed -r &#x27;s/(^love)able/\\1rs/&#x27; example -r : 支持扩展正则，这里()不需要被转义# 所有loveable会被替换成loversbl，括号顺序按1，2...顺序被标记sed -r &#x27;s/(^love)a(bl)e/\\1rs\\2/&#x27; example # 不论什么字符，紧跟着s命令的都被认为是新的分隔符，所以，“#”在这里是分隔符，代替了默认的“/”分隔符。表示把所有10替换成100sed &#x27;s#10#100#g&#x27; example # -i直接替换源文件，慎重使用sed -i &#x27;s/test/mytest/ig&#x27; example -i : 直接替换源文件，慎重使用# w标记会将匹配后的结果保存到指定文件中，注意这里text.txt中只会保留那些发生替换的行sed &#x27;s/test/mytest/w test.txt&#x27; example ====&gt; sed -n &#x27;s/test/mytest/p&#x27; example &gt; test.txt w : 会将匹配后的结果保存到指定文件中# 替换变量指定的行，注意这里要使用双引号，如果替换内容为双引号，要进行转义# 这里将第一行到指定的行中的&quot;&#125;替换为&quot;&#125;,sed -r &quot;1,$&#123;lineNum&#125;s/(\\&quot;&#125;)/\\1,/&quot; example 3)选定行的范围：逗号 1234567891011121314151617181920212223242526272829303132333435363738# 所有在模板test和check所确定的范围内的行都被打印 sed -n &#x27;/test/,/check/p&#x27; example# 按连续内容截取，这里还是按关键字搜索匹配，这里假设每行都有序号并且连续sed -n &#x27;/5518/,/5524/p&#x27; example # grep也有类似方法：countnum=$[ $endnum - $startnum + 1 ]grep &quot;$startnum&quot; file -A $countnum # 打印文件的第二行sed -n &#x27;2p&#x27; example# 打印文件的第二行和第四行sed -n &#x27;2p;4p&#x27; example# 打印第1行到第100百行sed -n &#x27;1,100p&#x27; example # 打印从第五行开始到第一个包含以test开始的行之间的所有行sed -n &#x27;5,/^test/p&#x27; example# 打印从第一个包含以test开始的行到第五行之间的所有行sed -n &#x27;/^test/,5p&#x27; example# 打印从第一个包含以test开始的行到最后一行之间的所有行sed -n &#x27;/^test/,$p&#x27; example# 打印包含java或者linux的行sed -r -n &#x27;/java|linux/p&#x27; example# 从第一行开始，间隔2行打印，这里表示打印1，4，7，10...行sed -n &#x27;1~3p&#x27; example# 打印以java开头的所有行sed -n &#x27;/^java/p&#x27; example# 打印以java开头的所有行的下一行sed -n &#x27;/^java/&#123;n;p&#125;&#x27; example# 对于模板test和check之间的行，每行的末尾用字符串sed test替换sed &#x27;/test/,/check/s/$/sed test/&#x27; example# 第2到5行，每行的末尾用字符串sed test替换sed &#x27;2,5s/$/sed test/&#x27; example# 第2到最后一行，每行的末尾用字符串sed test替换sed &#x27;2,$s/$/sed test/&#x27; example 4)多点编辑：e命令 12345678910# (-e)选项允许在同一行里执行多条命令。如例子所示，第一条命令删除1至5行，第二条命令用check替换test。命令的执行顺序对结果有影响。如果两个命令都是替换命令，那么第一个替换命令将影响第二个替换命令的结果sed -e &#x27;1,5d&#x27; -e &#x27;s/test/check/&#x27; example# 一个比-e更好的命令是--expression。它能给sed表达式赋值。sed --expression=&#x27;s/test/check/&#x27; --expression=&#x27;/love/d&#x27; exampletotalLine=`cat title_list.json | wc -l`lastLineBefore1=$(($totalLine-1))sed -i -r -e &quot;1,$&#123;lastLineBefore1&#125;s/(\\&quot;&#125;)/\\1,/&quot; -e &#x27;1d&#x27; -e &#x27;2i &#123;[&#x27; -e &#x27;$a ]&#125;&#x27; title_list.json 5)追加行或替换行：a、i、c和r a 命令表示在指定行的后面附加一行，i 命令表示在指定行的前面插入一行 123456789101112# 将hello wordl 插入到第二行上面sed &#x27;2i hello world&#x27; example i : 表示在指定行的前面插入一行，$i 表示最后一行前插入# 将hello wordl 插入到第二行下面sed &#x27;2a hello world&#x27; example a : 表示在指定行的后面插入一行，$a 表示最后一行后插入# 也可以同时插入多行内容，使用反斜线即可，这里表示在第二行下面添加两行内容sed &#x27;2a\\&gt; hello world\\&gt; i love you&#x27; example c 命令表示将指定行中的所有内容，替换成该选项后面的字符串 12345678910# 将匹配到的所有含有hello的行替换为hello worldsed &#x27;/hello/c hello world&#x27; example# 将hello world 替换第二行sed &#x27;2c hello world&#x27; example c : 替换行内容# 同样支持替换为多行sed &#x27;2c\\&gt; hello world\\&gt; i love you&#x27; example r 命令用于将一个独立文件的数据插入到当前数据流的指定位置 1234# 将text.txt中的内容插入到example文件的第二行下面sed &#x27;2r test.txt&#x27; example# 将text.txt中的内容插入到example文件的末尾sed &#x27;$r test.txt&#x27; example 6)处理单个字符：y 123456# 将所有以hello开头的行中的 a替换为A，b替换为B，c替换为C，d替换为Dsed &#x27;/^hello/y/abcd/ABCD/&#x27; example$ echo &quot;This 1 is a test2 of 1 try3.&quot; | sed &#x27;y/123/456/&#x27;This 4 is a test5 of 4 try6. y : 字符全局替换，原字符与替换字符的长度必须相同 7)指定行区间 默认情况下，sed 命令会作用于文本数据的所有行，如果只想将命令作用于特定行或某些行，需要明确指定行区间范围。 行区间可以通过如下两种方式进行限定： 1.以数字形式指定行区间 2.用文本模式指定具体行区间 行区间放在命令的前面，具体格式如下： 1234567[行区间]脚本命令或者行区间 &#123; 多个脚本命令,分号分隔&#125; 示例:以数字形式指定行区间 12345678# 替换第二行中的内容sed &#x27;2s/dog/cat/&#x27; test.txt# 替换第二行到第四行中的内容sed &#x27;2,4s/dog/cat/&#x27; test.txt# 替换第二行到文件最后一行中的内容sed &#x27;2,$s/dog/cat/&#x27; test.txt# 从第一行开始，每间隔一行进行替换，1，3，5，7...sed &#x27;1~2s/dog/cat/&#x27; test.txt 示例:用文本模式指定具体行区间 123456789101112# 替换内容中包含pig的所有行的内容sed &#x27;/pig/s/dog/cat/&#x27; test.txt# 正则匹配限制范围，&#123;&#125;指定多个脚本，这个命令的作用是将 h1Helloh1 转换为 &lt;h1&gt;Hello&lt;/h1&gt;sed &#x27;/h[0-9]/&#123;s//\\&lt;&amp;\\&gt;/1;s//\\&lt;\\/&amp;\\&gt;/2&#125;&#x27; test.txt# 也可以将命令写到文件中，通过 -f 参数指定sed -f sed.txt test.txtcat sed.txt/h[0-9]/&#123; s//\\&lt;&amp;\\&gt;/1 s//\\&lt;\\/&amp;\\&gt;/2&#125;","summary":"摘要 sed命令使用说明 本文基于CentOS8(x86_64)","date_published":"2023-03-06T13:31:05.000Z","tags":["技术","linux","linux常用命令","linux常用命令"]},{"id":"https://blog.hanqunfeng.com/2023/03/06/linux-command03-grep/","url":"https://blog.hanqunfeng.com/2023/03/06/linux-command03-grep/","title":"Linux常用命令--grep与egerp","content_html":"<!--\n **加粗**\n *斜体*\n ***加粗并斜体***\n ~~删除线~~\n ==突出显示==\n `突出显示(推荐)`\n ++下划线++\n ~下标~\n ^上标^\n 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.\n 图片设置宽度和高度 ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/innodb_buffer_pool.png =900x600)\n\n +++ **点击折叠**\n 这是被隐藏的内容\n +++\n\n::: tips success warning danger\n这里是容器内的内容\n:::\n\n% note info % success warning danger\n这里是容器内的内容\n% endnote %\n\n -->\n<h2 id=\"摘要\">摘要</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>grep与egrep的使用</p>\n</li>\n<li class=\"lvl-2\">\n<p>本文基于<code>CentOS8(x86_64)</code></p>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"grep\">grep</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>grep命令是linux中一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep [option] pattern files</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>常用参数</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">功能参数\t    解释</span><br><span class=\"line\">-c\t        输出匹配到的行数，功能等同于<span class=\"built_in\">wc</span> -l</span><br><span class=\"line\">-i\t        正则表达式忽略大小写</span><br><span class=\"line\">-l\t        查询多文件时只输出包含匹配字符的文件名</span><br><span class=\"line\">-h\t        查询多文件时不显示文件名</span><br><span class=\"line\">-n\t        显示匹配行的行号</span><br><span class=\"line\">-s\t        不显示文件不存在或无匹配文本的错误信息</span><br><span class=\"line\">-v\t        显示不包含匹配文本的行</span><br><span class=\"line\">-w          强制 PATTERN 仅完全匹配字词</span><br><span class=\"line\">-x          强制 PATTERN 仅完全匹配一行</span><br><span class=\"line\">-e          用 PATTERN 来进行匹配操作，通常用来匹配多个条件或者PATTERN中含有参数项的</span><br><span class=\"line\">-o          仅显示匹配的字符串本身，一行中有多个匹配，会分行显示</span><br><span class=\"line\">-r          在指定目录下递归查找所有文件中匹配关键字的行</span><br><span class=\"line\">-A\t        同时显示匹配行的后几行</span><br><span class=\"line\">-B\t        同时显示匹配行的前几行</span><br><span class=\"line\">-C\t        同时显示匹配行的前几行和后几行</span><br><span class=\"line\">-NUM        同时显示匹配行的前几行和后几行，等同于 -C，如：-C 2 === -2</span><br><span class=\"line\">-G          基本正则表达式，此为预设</span><br><span class=\"line\">-E\t        扩展正则表达式，等同于egrep</span><br><span class=\"line\">-P          Perl 正则表达式</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 匹配关键字key，忽略大小写</span></span><br><span class=\"line\">grep -i key file</span><br><span class=\"line\"></span><br><span class=\"line\">grep <span class=\"string\">&quot;^#&quot;</span> file : 显示所有行首是<span class=\"comment\">#的行</span></span><br><span class=\"line\">    ^ : 正则，以什么开头的行</span><br><span class=\"line\">    $ : 正则，以什么结尾的行</span><br><span class=\"line\"></span><br><span class=\"line\">grep -v <span class=\"string\">&quot;^#&quot;</span> file : 显示所有行首不是<span class=\"comment\">#的行</span></span><br><span class=\"line\">    -v : 找出与所给关键字不匹配的行</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 字符匹配</span></span><br><span class=\"line\">grep [A] file : 行中内容包含给定的字符</span><br><span class=\"line\">    [ ] : 匹配单个字符</span><br><span class=\"line\">grep [^A] file : 行中内容不包含给定的字符</span><br><span class=\"line\">    [^] : 不匹配单个字符</span><br><span class=\"line\">grep [A-Z] file : 行中内容包含给定的字符范围中的任何一个</span><br><span class=\"line\">    [-] : 匹配范围字符</span><br><span class=\"line\"></span><br><span class=\"line\">grep [ABC] file : 行中内容包含给定的字符列表中的任何一个</span><br><span class=\"line\">grep [^ABC] file : 匹配除方括号中字符外的所有字符</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 字符类描述: 注意使用时外面要加[]</span></span><br><span class=\"line\">[:alnum:] 字母数字集 “a-z A-Z 0-9”</span><br><span class=\"line\">[:alpha:] 字母集合 “a-z A-Z”</span><br><span class=\"line\">[:blank:] 空格或制表键</span><br><span class=\"line\">[:cntrl:] 任何控制字符</span><br><span class=\"line\">[:digit:] 数字集合 “0-9”</span><br><span class=\"line\">[:graph:] 任何可视字符（无空格）</span><br><span class=\"line\">[:lower:] 小写字母 “a-z”</span><br><span class=\"line\">[:<span class=\"built_in\">print</span>:] 非控制字符</span><br><span class=\"line\">[:punct:] 标点字符</span><br><span class=\"line\">[:space:] 空格</span><br><span class=\"line\">[:upper:] 大写字母 “A-Z”</span><br><span class=\"line\">[:xdigit:] 十六进制数字 “0-9 a-f A-F”</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例</span></span><br><span class=\"line\"><span class=\"comment\">#搜索开头不是英文字母的行</span></span><br><span class=\"line\">grep ^[^[:alpha:]] file === grep ^[^a-zA-Z] file</span><br><span class=\"line\"><span class=\"comment\"># 搜索非空行</span></span><br><span class=\"line\">grep -v <span class=\"string\">&quot;^$&quot;</span> file : 搜索非空行，严格来讲这个不准确，不能去除行内容只有空格或者制表符的行</span><br><span class=\"line\">grep [^[:blank:]] file : 搜索非空行，去除行内容只有空格或者制表符的行</span><br><span class=\"line\"></span><br><span class=\"line\">grep key file -A 10 : 显示关键字行及其后面的10行</span><br><span class=\"line\">    -A : After</span><br><span class=\"line\"></span><br><span class=\"line\">grep key file -B 10 : 显示关键字行及其前面的10行</span><br><span class=\"line\">    -B : Before</span><br><span class=\"line\"></span><br><span class=\"line\">grep key file -2 : 显示关键行及其上两行和下两行</span><br><span class=\"line\">    -num : 显示上下各num行</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># -E 开启扩展正则表达式</span></span><br><span class=\"line\">grep -E <span class=\"string\">&quot;^#&quot;</span> file  <span class=\"comment\">#打印所有注释行</span></span><br><span class=\"line\">    -E : 支持扩展正则表达式</span><br><span class=\"line\"></span><br><span class=\"line\">grep  -E <span class=\"string\">&#x27;key1|key2&#x27;</span>  -n -i file : 查找包含任意关键字的行，并显示行号</span><br><span class=\"line\">    -n : 显示行号</span><br><span class=\"line\">    -i : 不区分大小写</span><br><span class=\"line\"></span><br><span class=\"line\">grep key -c file : 查找关键字匹配的行数</span><br><span class=\"line\">    -c : 只输出匹配行的计数</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 这个命令非常有用，可以快速定位关键字所在的文件位置</span></span><br><span class=\"line\">grep <span class=\"string\">&#x27;key&#x27;</span> -r <span class=\"built_in\">dir</span> : 在目录下递归查找文件内容包含关键字的文件路径及其所含关键字的内容</span><br><span class=\"line\">    -r : 递归查找</span><br><span class=\"line\"></span><br><span class=\"line\">grep <span class=\"string\">&#x27;key&#x27;</span> -l *.<span class=\"built_in\">log</span> : 打印包含关键字的文件名称</span><br><span class=\"line\">    -l : 在多个文件中查找关键字，并打印文件名称</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 把key当做一个完整的单词来进行匹配，忽略那些部分匹配的行，比如 to只能匹配to，不能匹配tom</span></span><br><span class=\"line\">grep -w key file</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果不用 -e 会无法解析命令，即便加上双引号也不行 &quot;-vb-&quot;</span></span><br><span class=\"line\">grep -e -vb- file</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 标准正则，匹配key1 或者 匹配key2，正则中的特殊符号需要转义</span></span><br><span class=\"line\">grep -e key1 -e key2 file</span><br><span class=\"line\"><span class=\"comment\"># 扩展正则</span></span><br><span class=\"line\">grep -Ee key1 -Ee key2 file</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 需要同时匹配key1和key2</span></span><br><span class=\"line\">grep key1 file | grep key2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># -o 可以用来统计找到多少个匹配项</span></span><br><span class=\"line\">grep -E <span class=\"string\">&quot;ro+t&quot;</span> /etc/passwd</span><br><span class=\"line\">root:x:0:0:root:/root:/bin/bash</span><br><span class=\"line\">operator:x:11:0:operator:/root:/sbin/nologin</span><br><span class=\"line\"><span class=\"comment\"># 每个匹配项占一行</span></span><br><span class=\"line\">grep -Eo <span class=\"string\">&quot;ro+t&quot;</span> /etc/passwd</span><br><span class=\"line\">root</span><br><span class=\"line\">root</span><br><span class=\"line\">root</span><br><span class=\"line\">root</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"egrep\">egrep</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>egrep命令用于在文件内查找指定的字符串，egrep执行效果与&quot;grep -E&quot;相似，使用的语法及参数可参照grep指令，与grep的不同点在于解读字符串的方法。</p>\n</li>\n<li class=\"lvl-2\">\n<p>egrep命令为 grep 的扩充版本, 改良了许多传统 grep 不能或不便的操作，比如:</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">grep 使用 <code>?</code> 与 <code>+</code> 时需要转义, 但egrep不需要。</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep <span class=\"string\">&quot;[0-9]\\+&quot;</span> test.txt</span><br><span class=\"line\">grep -E <span class=\"string\">&quot;[0-9]+&quot;</span> test.txt</span><br><span class=\"line\">egrep <span class=\"string\">&quot;[0-9]+&quot;</span> test.txt</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">grep 使用 <code>a|b</code> 或 <code>(abc|xyz)</code> 这类&quot;或一&quot;比对时需要对<code>|</code>进行转义, 但egrep不需要。</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep <span class=\"string\">&quot;a\\|s&quot;</span> test.txt</span><br><span class=\"line\">grep -E <span class=\"string\">&quot;a|s&quot;</span> test.txt</span><br><span class=\"line\">egrep <span class=\"string\">&quot;a|s&quot;</span> test.txt</span><br><span class=\"line\"></span><br><span class=\"line\">grep <span class=\"string\">&quot;\\(a\\|s\\)&quot;</span> test.txt</span><br><span class=\"line\">grep -E <span class=\"string\">&quot;(a|s)&quot;</span> test.txt</span><br><span class=\"line\">egrep <span class=\"string\">&quot;(a|s)&quot;</span> test.txt</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">grep在处理 <code>&#123;n,m&#125;</code> 时, 需用 <code>\\&#123; </code>与 <code>\\&#125;</code> 进行转义, 但egrep不需要。</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep <span class=\"string\">&quot;[0-9]\\&#123;3\\&#125;&quot;</span> test.txt</span><br><span class=\"line\">grep -E <span class=\"string\">&quot;[0-9]&#123;3&#125;&quot;</span> test.txt</span><br><span class=\"line\">egrep <span class=\"string\">&quot;[0-9]&#123;3&#125;&quot;</span> test.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li class=\"lvl-2\">\n<p>语法</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">egrep [范本模式] [文件或目录]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>示例</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">egrep <span class=\"string\">&#x27;key1|key2|key3&#x27;</span> file : 查找包含任意关键字的行</span><br><span class=\"line\">egrep <span class=\"string\">&#x27;a+&#x27;</span> file : 查找包含一个或多个a的行</span><br><span class=\"line\">egrep <span class=\"string\">&#x27;(abc)&#x27;</span> file : 包含abc整体的行</span><br><span class=\"line\">egrep <span class=\"string\">&#x27;(abc)+&#x27;</span> file : 包含一个或多个abc整体的行</span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><em><strong>linux正则表达式</strong></em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">基础正则表达式\t    解释</span><br><span class=\"line\">^\t            ^word表示以word开头的内容</span><br><span class=\"line\">$\t            word$表示以word结尾的内容</span><br><span class=\"line\">^$\t            表示空行</span><br><span class=\"line\">.\t            代表且只能代表任意一个字符</span><br><span class=\"line\">\\\t            转义字符</span><br><span class=\"line\">*\t            重复之前的字符0或多次</span><br><span class=\"line\">.*\t            匹配任意多个字符</span><br><span class=\"line\">[abc]           匹配abc其中的任意一个</span><br><span class=\"line\">[^abc]          匹配未包含在[abc]内的任意一个字符</span><br><span class=\"line\">[a-z]\t        匹配a-z其中的一个字符，[0-9]匹配任意数字</span><br><span class=\"line\"></span><br><span class=\"line\"># grep -E 或者 egrep，grep使用时要转义特殊字符</span><br><span class=\"line\">扩展正则表达式      解释</span><br><span class=\"line\">&#123;m,n&#125;\t        匹配前一个字符m到n次，注意grep使用时，&#123;&#125;要加转义字符\\&#123;\\&#125;</span><br><span class=\"line\">&#123;m&#125;\t            匹配字符m次</span><br><span class=\"line\">&#123;m,&#125;            匹配字符至少m次</span><br><span class=\"line\">+\t            匹配前一个字符1次或者多次，最少一次，如 wo+d，可以匹配 &quot;wood&quot; &quot;woood&quot; &quot;woooooood&quot;等字符串</span><br><span class=\"line\">?\t            重复前一个字符0次或者1次，如 bes?t，可以匹配 &quot;bet&quot; 和 &quot;best&quot; 两个字符串</span><br><span class=\"line\">|\t            同时过滤多个字符，如 of|is|on，匹配包含 &quot;of&quot; 或者 &quot;if&quot; 或者 &quot;on&quot; 的字符串</span><br><span class=\"line\">()              分组，将1个或多个字符捆绑在一起，当做一个整体进行处理，如 t(ad|ef)st，可以匹配 &quot;tadst&quot; 与 &quot;tefst&quot; 两个字符串</span><br><span class=\"line\">                分组括号中的模式匹配到的内容会被正则表达式引擎记录于内部的变量中，这些变量的命名方式为：\\1,\\2,\\3....，如：sed -r &#x27;s/(^love)able/\\1rs/&#x27; example </span><br><span class=\"line\">()+             辨别多个重复的组，如 A(xyz)+C ,可以匹配 开头是&quot;A&quot;结尾是&quot;C&quot;，中间有一个以上的&quot;xyz&quot;的字符串</span><br><span class=\"line\"></span><br><span class=\"line\"># grep -P，不支持egrep</span><br><span class=\"line\">Perl 正则表达式    解释</span><br><span class=\"line\">\\t              匹配制表符</span><br><span class=\"line\">\\n              匹配换行符</span><br><span class=\"line\">\\s              匹配空白字符，空格、制表符\\t、换行符\\r和\\n等</span><br><span class=\"line\">\\S              匹配非空白字符</span><br><span class=\"line\">\\d              匹配数字[0-9]，如：grep -P &quot;\\d&quot; test.txt</span><br><span class=\"line\">\\D              匹配非数字[^0-9]</span><br><span class=\"line\">\\w              匹配字母数字下划线[a-zA-Z0-9_]</span><br><span class=\"line\">\\W              匹配非字母数字下划线[^a-zA-Z0-9_]</span><br><span class=\"line\">(?:xxx)         匹配xxx，但是不会被正则表达式引擎记录于内部的变量中，也就是无法通过\\1,\\2,\\3....获得</span><br></pre></td></tr></table></figure>\n</div>\n","content_text":"摘要 grep与egrep的使用 本文基于CentOS8(x86_64) grep grep命令是linux中一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。 语法 1grep [option] pattern files 常用参数 1234567891011121314151617181920功能参数 解释-c 输出匹配到的行数，功能等同于wc -l-i 正则表达式忽略大小写-l 查询多文件时只输出包含匹配字符的文件名-h 查询多文件时不显示文件名-n 显示匹配行的行号-s 不显示文件不存在或无匹配文本的错误信息-v 显示不包含匹配文本的行-w 强制 PATTERN 仅完全匹配字词-x 强制 PATTERN 仅完全匹配一行-e 用 PATTERN 来进行匹配操作，通常用来匹配多个条件或者PATTERN中含有参数项的-o 仅显示匹配的字符串本身，一行中有多个匹配，会分行显示-r 在指定目录下递归查找所有文件中匹配关键字的行-A 同时显示匹配行的后几行-B 同时显示匹配行的前几行-C 同时显示匹配行的前几行和后几行-NUM 同时显示匹配行的前几行和后几行，等同于 -C，如：-C 2 === -2-G 基本正则表达式，此为预设-E 扩展正则表达式，等同于egrep-P Perl 正则表达式 示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394# 匹配关键字key，忽略大小写grep -i key filegrep &quot;^#&quot; file : 显示所有行首是#的行 ^ : 正则，以什么开头的行 $ : 正则，以什么结尾的行grep -v &quot;^#&quot; file : 显示所有行首不是#的行 -v : 找出与所给关键字不匹配的行# 字符匹配grep [A] file : 行中内容包含给定的字符 [ ] : 匹配单个字符grep [^A] file : 行中内容不包含给定的字符 [^] : 不匹配单个字符grep [A-Z] file : 行中内容包含给定的字符范围中的任何一个 [-] : 匹配范围字符grep [ABC] file : 行中内容包含给定的字符列表中的任何一个grep [^ABC] file : 匹配除方括号中字符外的所有字符# 字符类描述: 注意使用时外面要加[][:alnum:] 字母数字集 “a-z A-Z 0-9”[:alpha:] 字母集合 “a-z A-Z”[:blank:] 空格或制表键[:cntrl:] 任何控制字符[:digit:] 数字集合 “0-9”[:graph:] 任何可视字符（无空格）[:lower:] 小写字母 “a-z”[:print:] 非控制字符[:punct:] 标点字符[:space:] 空格[:upper:] 大写字母 “A-Z”[:xdigit:] 十六进制数字 “0-9 a-f A-F”# 示例#搜索开头不是英文字母的行grep ^[^[:alpha:]] file === grep ^[^a-zA-Z] file# 搜索非空行grep -v &quot;^$&quot; file : 搜索非空行，严格来讲这个不准确，不能去除行内容只有空格或者制表符的行grep [^[:blank:]] file : 搜索非空行，去除行内容只有空格或者制表符的行grep key file -A 10 : 显示关键字行及其后面的10行 -A : Aftergrep key file -B 10 : 显示关键字行及其前面的10行 -B : Beforegrep key file -2 : 显示关键行及其上两行和下两行 -num : 显示上下各num行# -E 开启扩展正则表达式grep -E &quot;^#&quot; file #打印所有注释行 -E : 支持扩展正则表达式grep -E &#x27;key1|key2&#x27; -n -i file : 查找包含任意关键字的行，并显示行号 -n : 显示行号 -i : 不区分大小写grep key -c file : 查找关键字匹配的行数 -c : 只输出匹配行的计数# 这个命令非常有用，可以快速定位关键字所在的文件位置grep &#x27;key&#x27; -r dir : 在目录下递归查找文件内容包含关键字的文件路径及其所含关键字的内容 -r : 递归查找grep &#x27;key&#x27; -l *.log : 打印包含关键字的文件名称 -l : 在多个文件中查找关键字，并打印文件名称# 把key当做一个完整的单词来进行匹配，忽略那些部分匹配的行，比如 to只能匹配to，不能匹配tomgrep -w key file# 如果不用 -e 会无法解析命令，即便加上双引号也不行 &quot;-vb-&quot;grep -e -vb- file# 标准正则，匹配key1 或者 匹配key2，正则中的特殊符号需要转义grep -e key1 -e key2 file# 扩展正则grep -Ee key1 -Ee key2 file# 需要同时匹配key1和key2grep key1 file | grep key2# -o 可以用来统计找到多少个匹配项grep -E &quot;ro+t&quot; /etc/passwdroot:x:0:0:root:/root:/bin/bashoperator:x:11:0:operator:/root:/sbin/nologin# 每个匹配项占一行grep -Eo &quot;ro+t&quot; /etc/passwdrootrootrootroot egrep egrep命令用于在文件内查找指定的字符串，egrep执行效果与&quot;grep -E&quot;相似，使用的语法及参数可参照grep指令，与grep的不同点在于解读字符串的方法。 egrep命令为 grep 的扩充版本, 改良了许多传统 grep 不能或不便的操作，比如: grep 使用 ? 与 + 时需要转义, 但egrep不需要。 123grep &quot;[0-9]\\+&quot; test.txtgrep -E &quot;[0-9]+&quot; test.txtegrep &quot;[0-9]+&quot; test.txt grep 使用 a|b 或 (abc|xyz) 这类&quot;或一&quot;比对时需要对|进行转义, 但egrep不需要。 1234567grep &quot;a\\|s&quot; test.txtgrep -E &quot;a|s&quot; test.txtegrep &quot;a|s&quot; test.txtgrep &quot;\\(a\\|s\\)&quot; test.txtgrep -E &quot;(a|s)&quot; test.txtegrep &quot;(a|s)&quot; test.txt grep在处理 &#123;n,m&#125; 时, 需用 \\&#123; 与 \\&#125; 进行转义, 但egrep不需要。 123grep &quot;[0-9]\\&#123;3\\&#125;&quot; test.txtgrep -E &quot;[0-9]&#123;3&#125;&quot; test.txtegrep &quot;[0-9]&#123;3&#125;&quot; test.txt 语法 1egrep [范本模式] [文件或目录] 示例 1234egrep &#x27;key1|key2|key3&#x27; file : 查找包含任意关键字的行egrep &#x27;a+&#x27; file : 查找包含一个或多个a的行egrep &#x27;(abc)&#x27; file : 包含abc整体的行egrep &#x27;(abc)+&#x27; file : 包含一个或多个abc整体的行 linux正则表达式 1234567891011121314151617181920212223242526272829303132333435基础正则表达式 解释^ ^word表示以word开头的内容$ word$表示以word结尾的内容^$ 表示空行. 代表且只能代表任意一个字符\\ 转义字符* 重复之前的字符0或多次.* 匹配任意多个字符[abc] 匹配abc其中的任意一个[^abc] 匹配未包含在[abc]内的任意一个字符[a-z] 匹配a-z其中的一个字符，[0-9]匹配任意数字# grep -E 或者 egrep，grep使用时要转义特殊字符扩展正则表达式 解释&#123;m,n&#125; 匹配前一个字符m到n次，注意grep使用时，&#123;&#125;要加转义字符\\&#123;\\&#125;&#123;m&#125; 匹配字符m次&#123;m,&#125; 匹配字符至少m次+ 匹配前一个字符1次或者多次，最少一次，如 wo+d，可以匹配 &quot;wood&quot; &quot;woood&quot; &quot;woooooood&quot;等字符串? 重复前一个字符0次或者1次，如 bes?t，可以匹配 &quot;bet&quot; 和 &quot;best&quot; 两个字符串| 同时过滤多个字符，如 of|is|on，匹配包含 &quot;of&quot; 或者 &quot;if&quot; 或者 &quot;on&quot; 的字符串() 分组，将1个或多个字符捆绑在一起，当做一个整体进行处理，如 t(ad|ef)st，可以匹配 &quot;tadst&quot; 与 &quot;tefst&quot; 两个字符串 分组括号中的模式匹配到的内容会被正则表达式引擎记录于内部的变量中，这些变量的命名方式为：\\1,\\2,\\3....，如：sed -r &#x27;s/(^love)able/\\1rs/&#x27; example ()+ 辨别多个重复的组，如 A(xyz)+C ,可以匹配 开头是&quot;A&quot;结尾是&quot;C&quot;，中间有一个以上的&quot;xyz&quot;的字符串# grep -P，不支持egrepPerl 正则表达式 解释\\t 匹配制表符\\n 匹配换行符\\s 匹配空白字符，空格、制表符\\t、换行符\\r和\\n等\\S 匹配非空白字符\\d 匹配数字[0-9]，如：grep -P &quot;\\d&quot; test.txt\\D 匹配非数字[^0-9]\\w 匹配字母数字下划线[a-zA-Z0-9_]\\W 匹配非字母数字下划线[^a-zA-Z0-9_](?:xxx) 匹配xxx，但是不会被正则表达式引擎记录于内部的变量中，也就是无法通过\\1,\\2,\\3....获得","summary":"摘要 grep与egrep的使用 本文基于CentOS8(x86_64)","date_published":"2023-03-06T13:30:05.000Z","tags":["技术","linux","linux常用命令","linux常用命令"]}]}