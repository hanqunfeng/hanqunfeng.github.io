<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico">
  <link rel="mask-icon" href="/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.hanqunfeng.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"default"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="摘要   本文介绍JVM的内存模型与垃圾回收机制   JDK8 The Java® Virtual Machine Specification   JDK8的java指令的官⽅⽂档   JDK⼯具官⽹⽂档   JDK17的java指令的官⽅⽂档">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM 之 内存模型与垃圾回收机制(GC)">
<meta property="og:url" content="https://blog.hanqunfeng.com/2025/05/12/jvm-gc-01/index.html">
<meta property="og:site_name" content="飘逸峰的博客">
<meta property="og:description" content="摘要   本文介绍JVM的内存模型与垃圾回收机制   JDK8 The Java® Virtual Machine Specification   JDK8的java指令的官⽅⽂档   JDK⼯具官⽹⽂档   JDK17的java指令的官⽅⽂档">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/cGMyEe.png">
<meta property="og:image" content="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/TEILZ9.png">
<meta property="og:image" content="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/Apr5aY.png">
<meta property="og:image" content="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/fo2Egs.png">
<meta property="og:image" content="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/AaqBxm.png">
<meta property="og:image" content="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/XbkEoh.png">
<meta property="og:image" content="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/bBUAYt.png">
<meta property="og:image" content="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/LD51Zb.png">
<meta property="og:image" content="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/94yKcU.png">
<meta property="article:published_time" content="2025-05-12T14:30:05.000Z">
<meta property="article:modified_time" content="2025-05-18T06:11:43.854Z">
<meta property="article:author" content="飘逸峰">
<meta property="article:tag" content="jvm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/cGMyEe.png">


<link rel="canonical" href="https://blog.hanqunfeng.com/2025/05/12/jvm-gc-01/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://blog.hanqunfeng.com/2025/05/12/jvm-gc-01/","path":"2025/05/12/jvm-gc-01/","title":"JVM 之 内存模型与垃圾回收机制(GC)"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>JVM 之 内存模型与垃圾回收机制(GC) | 飘逸峰的博客</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-GWTEYMZ5M8"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-GWTEYMZ5M8","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?e5cd6c30fc944bddf6ed6ae96edc722b"></script>






<META http-equiv="Pragma" content="no-cache">
<META http-equiv="Cache-Control" content="no-cache">
<META http-equiv="Expire" content="0">

<script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
<script src="/js-expand/httpToHttps.js"></script>
<meta name="keywords" content="hanqf,hanqunfeng,飘逸峰的博客,Java,Spring,SpringBoot,linux,Mysql">

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start --><script> let HEXO_MMEDIA_DATA = { js: [], css: [], aplayerData: [], metingData: [], artPlayerData: [], dplayerData: []}; </script><!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="飘逸峰的博客" type="application/atom+xml">
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">飘逸峰的博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Spring--Java程序员的春天</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa-solid fa-house fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa-solid fa-table-cells fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa-solid fa-box-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa-solid fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-book"><a href="/book/" rel="section"><i class="fa-solid fa-book fa-fw"></i>资料</a></li><li class="menu-item menu-item-rss"><a href="/atom.xml" rel="section"><i class="fa-solid fa-rss fa-fw"></i>RSS</a></li><li class="menu-item menu-item-hot"><a href="/hot/" rel="section"><i class="fa-solid fa-signal fa-fw"></i>阅读排行榜</a></li><li class="menu-item menu-item-charts"><a href="/charts/" rel="section"><i class="fa-solid fa-chart-bar fa-fw"></i>统计图</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

<link rel="stylesheet" href="/calendar/calendar.css">
<script src="/calendar/calendar.js"></script>


<style>
#img_css {
    cursor:pointer;
    width: 100%;
    text-align:center;
    margin: 0 auto;
    padding: 0px 0px 0px 0px;
}



.calendar-ct ul,.calendar-ct ol,.calendar-ct li {
    list-style: none;
    padding: 0;
    margin: 0;
}

#calendarDiv {
    width: 200px;
    margin: 0px auto;
}

#toast{
    padding: 4px;
    width: 800px;
    background-color: rgb(255, 128, 142);
    
    position: fixed;
    z-index: 25;
    display: block;
    left: 0;
    right: 0;
    top: 400px;
    margin: auto;
    white-space: nowrap;
    overflow: hidden;
    border-top-right-radius: 0px;
    border-bottom-right-radius:40px;
    border-bottom-left-radius:0px;
    border-top-left-radius:40px;
}
.titleContent {
    text-decoration:none;
    border-bottom-color:#fff;
    
    color: #fff;
    font-size: 20px;
    margin-left:4px;
}
.titleIco {
    margin-left:40px;
}

.over {
    position: absolute;
    left: 0;
    right: 0;
    top: 0px;
    margin: auto;
}

.month-items {
    padding-left:4px;
}

.have.have2.have3.have4{
    color: #69dbdc!important;
}

.month-now {
    background: none !important;
    padding: 4px 0px 4px 3px; /* 上（top）、右（right）、下（bottom）、左（left） */
    font:  500 14px sans-serif !important;
}

i.xiu {
    position: absolute;
    left: 0;
    top: 0;
    font-size: 8px;
    color: #F43;
    padding: 0 0;
    margin: 0 0;
}
i.ban {
    position: absolute;
    left: 0;
    top: 0;
    font-size: 8px;
    color: #999;
    padding: 0 0;
    margin: 0 0;
}

.xiu-ban {
    font-size: 12px;
}
</style>

<div id="img_css">





<img src="/images_glob/jiaoshijie.jpeg" id="img_910" style="display: none !important;"/>
<img src="/images_glob/9_18.png" id="img_918" style="display: none !important;"/>
<img src="/images_glob/10_1.png" id="img_101" style="display: none !important;"/>
<img src="/images_glob/zhongqiujie.jpg" id="img_zqj" style="display: none !important;"/>
<img src="/images_glob/duanwujie.jpg" id="img_dwj" style="display: none !important;"/>
<img src="/images_glob/yuanxiaojie.jpeg" id="img_yxj" style="display: none !important;"/>
<img src="/images_glob/yuandan.jpeg" id="img_yd" style="display: none !important;"/>
<img src="/images_glob/qingmingjie.jpeg" id="img_qmj" style="display: none !important;"/>
<img src="/images_glob/5_1.jpeg" id="img_51" style="display: none !important;"/>

<img src="/images_glob/2024.png" id="img_year" style="display: none !important;" />


</div>

<div id="calendarDiv">
    <div id="ca" style="margin-bottom: 10px;">
    </div>
</div>


<script type="text/javascript">
    jQuery(function ($) {
	  $('#img_css').click(function(){
                location.href = "/404";
      });

    let date = new Date();
    const year = date.getFullYear();
    const month = date.getMonth() + 1;
    const day = date.getDate();
    console.log(year,month,day);

     // 显示当前年份图片
    $("#img_year").attr("src", "/images_glob/" + year + ".png");
    $("#img_year").show();

    // 阳历节日、纪念日
    // 显示918图片
    if(month==9 && day==18){
        $("#img_918").show();
    }
    // 显示9月10日教师节图片
    else if(month==9 && day==10){
        $("#img_910").show();
    }
    // 显示10月1日国庆节图片
    else if(month==10 && (day >= 1 && day <= 7)){
        $("#img_101").show();
    }
    // 显示5月1日劳动节图片
    else if(month==5 && (day >= 1 && day <= 5)){
        $("#img_51").show();
    }
    // 显示清明节图片
    else if(month==4 && (day >= 4 && day <= 6)){
        $("#img_qmj").show();
    }
    // 显示元旦图片
    else if(month==1 && day==1){
        $("#img_yd").show();
    }
    // 其它日期不显示任何图片
    else{
        $("#img_918").hide();
        $("#img_910").hide();
        $("#img_101").hide();
        $("#img_qmj").hide();
        $("#img_yd").hide();
        $("#img_51").hide();
    }

    // 农历节日、纪念日
    let monthStr = date.getMonth() + 1 < 10 ? "0" + (date.getMonth() + 1) : date.getMonth() + 1;
    let dayStr = date.getDate() < 10 ? "0" + date.getDate() : date.getDate();
    var fulltime = year + "-" + monthStr + "-" + dayStr;
    $.ajax({
        url: 'https://wannianli.hanqunfeng.com/get_data?date='+fulltime,
        type: 'GET',
        async: false,  // 设置 async 参数为 false
        success: function(data) {
            
            
            // 中秋节
            if(data.wnl_nl_month == "八月" && data.wnl_nl_day == "十五"){
                $("#img_zqj").show();
            }
            // 端午节
            else if(data.wnl_nl_month == "五月" && data.wnl_nl_day == "初五"){
                $("#img_dwj").show();
            }
            // 元宵节
            else if(data.wnl_nl_month == "正月" && data.wnl_nl_day == "十五"){
                $("#img_yxj").show();
            }
            // 其它日期不显示任何图片
            else {
                $("#img_zqj").hide();
                $("#img_dwj").hide();
                $("#img_yxj").hide();
            }
        },
        error: function(xhr, status, error) {
            console.error('请求失败:', status, error);
        }
    });



      function coverLayer(tag) {
        var overContainer = $('<div class=over></div>');//蒙层
        with (overContainer) {
            if (tag == 1) {
                appendTo("body");
                css('height', $(document).height());
                css('display', 'block');
                css('opacity', 1);
                css("background-color", "#FFFFFF");
                css("background-color", "rgba(0,0,0,0.7)");  //蒙层透明度
            } else {
                css('display', 'none');

            }
        }

      overContainer.click(function(){
        coverLayer(0);
        $(".over").remove();
        $(".toast").hide(transtime);
        $("#toast").html("");
      });
    }


      //获取当前网址，如： http://localhost:8083/uimcardprj/share/meun.jsp
      var curWwwPath = window.document.location.href;
      //获取主机地址之后的目录，如： uimcardprj/share/meun.jsp
      var pathName = window.document.location.pathname;
      var pos = curWwwPath.indexOf(pathName);
      //获取主机地址，如： http://localhost:8083
      var localhostPaht = curWwwPath.substring(0, pos);
      head = localhostPaht;
      transtime=300; // dong

      function getCountByDate(date,view){
        var dateObj = new Date(date);
        var keytime = dateObj.getFullYear() + "-" + (dateObj.getMonth() + 1);
        
        
        let mycalendarElement = mycalendar[keytime];
        
        let n = 0;
        if(view=="month"){
            if (mycalendarElement && mycalendarElement.length !== undefined) {
                n = mycalendarElement.length;
            }
        }else{
            if (mycalendarElement && mycalendarElement.length !== undefined) {
                for (var i = 0; i < mycalendarElement.length; i++) {
                    let ordertime = mycalendarElement[i]["date"].substring(0, 10);
                    if (date == ordertime) {
                        n++;
                    }
                }
            }
        }
        
        return n;
      }
       // 初始化班休数据
       ban_xiu_data = null;
       // 获取当前时间戳（毫秒级）
       const timestamp = Date.now();
       if(!ban_xiu_data){
          $.ajax({
            url: '/ban_xiu.json?timestamp='+ timestamp,
            type: 'GET',
            async: false,  // 设置 async 参数为 false
            dataType: "json",
            success: function(data) {
                ban_xiu_data = data;
                //console.log(ban_xiu_data)
                //console.log(ban_xiu_data['2021-01-01'])
            },
            error: function(xhr, status, error) {
                console.error('请求失败:', status, error);
            }
        });
       }


       $('#ca').calendar({
        width: 200,
        height: 200,
        onMouseenter: function (view, date, data) {
          

          let year = date.getFullYear();
          let month = date.getMonth() + 1 < 10 ? "0" + (date.getMonth() + 1) : date.getMonth() + 1;
          let day = date.getDate() < 10 ? "0" + date.getDate() : date.getDate();
          var fulltime = year + "-" + month + "-" + day;
          let n = 0;

          let self = this;

          if (view == "month") {
                n = getCountByDate(fulltime,view);
                if(n>0){
                  $(this).attr('title','创作[' + n + ']篇');
                }else if(n==0){
                  $(this).attr('title','');
                }
            } else {

                let this_title = $(self).attr('title')
                if(this_title){
                    fulltime = this_title.substring(0,10);
                }
                n = getCountByDate(fulltime,view);
                if(n==0){

                    // 发送同步 GET 请求
                    //$.ajax({
                    //    url: 'https://yinli.hanqunfeng.com/lunar?date='+fulltime,
                    //    type: 'GET',
                    //   async: false,  // 设置 async 参数为 false
                    //    success: function(data) {
                    //        
                    //        
                    //        $(self).attr('title',fulltime + "," + '农历[' + data.data.gzYear + '年' + data.data.IMonthCn + data.data.IDayCn + '#' + data.data.Animal + ']');

                    //    },
                    //    error: function(xhr, status, error) {
                    //        console.error('请求失败:', status, error);
                    //    }
                    //});

                    $.ajax({
                        url: 'https://wannianli.hanqunfeng.com/get_data?date='+fulltime,
                        type: 'GET',
                        async: false,  // 设置 async 参数为 false
                        success: function(data) {
                            
                            
                            if(data.wnl_holidays=='None'){
                                $(self).attr('title',fulltime + "," + '农历[' + data.wnl_nl_year  + data.wnl_nl_month + data.wnl_nl_day + '#' + data.wnl_animal_year + ']');
                            }else{
                                $(self).attr('title',fulltime + "[" + data.wnl_holidays + "]" + "," + '农历[' + data.wnl_nl_year  + data.wnl_nl_month + data.wnl_nl_day + '#' + data.wnl_animal_year + ']');
                            }


                        },
                        error: function(xhr, status, error) {
                            console.error('请求失败:', status, error);
                        }
                    });
                }
                else if(n>0){
                  $(this).attr('title',fulltime + "," + '创作[' + n + ']篇->点击查看');
                }


            }
        },
        onSelected: function (view, date, data) {   // 点击事件
            //console.log(view, date, data);
            //if(date == 'Invalid Date'){
              //  date = new Date();
            //}
            //console.log(view, date, data);

            if (view == "month") {
                
                let fullYear = date.getFullYear();
                monthTag(fullYear, date.getMonth() + 1);
            } else {
                let year = date.getFullYear();
                let month = date.getMonth() + 1 < 10 ? "0" + (date.getMonth() + 1) : date.getMonth() + 1;
                let day = date.getDate() < 10 ? "0" + date.getDate() : date.getDate();
                var fulltime = year + "-" + month + "-" + day;
                var keytime = year + "-" + (date.getMonth() + 1);
                let mycalendarElement = mycalendar[keytime];
                $(".toast").hide(transtime);
                $("#toast").html("");

                coverLayer(0);
                $(".over").remove();

                //创建一个空数组，用于存放有文章的日期
                let mycalendar_ordertimes = [];

                let n = 0;
                if (mycalendarElement && mycalendarElement.length !== undefined) {
                    for (var i = 0; i < mycalendarElement.length; i++) {
                        let ordertime = mycalendarElement[i]["date"].substring(0, 10);
                        //将ordertime添加到mycalendar_ordertimes数组中
                        mycalendar_ordertimes.push(ordertime);

                        if (fulltime == ordertime) {
                            n++;
                            if(n==1){
                            coverLayer(1);
                            autoWidth();
                            $(".toast").show(transtime);
                            }
                            

                            var title = mycalendarElement[i]["title"];
                            var link = head + mycalendarElement[i]["link"];
                            $("#toast").append('<i class="fas fa-circle titleIco"></i> <a class="titleContent"' + 'href="' + link + '">' + title + '</a><br/>');
                            
                        }
                    }
                }
                n = 0;

                //判断mycalendar_ordertimes数组中是否包含fulltime，不包含就打开万年历页面
                if(mycalendar_ordertimes.indexOf(fulltime) == -1){
                    window.open("https://www.wnl.cc/"+year+"/"+month+day+".html", "_new");
                }
            }
        }
    });
    });

    function autoWidth(){
      var windowWidth = $(document).width();
      if(windowWidth <= 1000){
        $(".toast").css('width','80%');
      }
    }

    function resolveyear() { // 准备数据
        var currentyear = getCurrentyear();
        var currentmonth = getCurrentmonth();
        
        gblmonth = currentmonth;
        if (currentmonth == 13) { // 首次加载，需要延时
            setCurrentmonth(1); // 首次以后不延时直接执行
            setTimeout(function () {
                $("#ca").append('<div id="toast" class="toast"></div>');
                $(".toast").hide();
                if (mycalendar) {
                    monthTag(currentyear);
                } else {
                    
                }
            }, 2000);
        } else {
            monthTag(currentyear, null);
        }
    }

    // 对月份进行设置，json文件中存在的才显示
    function monthTag(currentyear, date) {
        

        // 此处对当前月份下的日子进行匹配
        if (date) {
            var month = date;
        } else {
            var currentData = new Date();
            var month = currentData.getMonth() + 1;
        }

        removeHaveClass();
        // debugger;
        var flag = true;
        var mycalValue = new Array()
        for (let i = 1; i <= 12; i++) {
            if (mycalendar[currentyear + "-" + i]) {
                
                addHaveClass(i);


                if (flag) { // 只在内部循环一次，当前页的数据后就不再管了
                    flag = false;
                    if (mycalendar[currentyear + "-" + month]) {
                        for (var j = 0; j < mycalendar[currentyear + "-" + month].length; j++) {
                            var pagedata = mycalendar[currentyear + "-" + month][j];
                            var needdate = pagedata["date"].substring(8, 10);
                            if (needdate < 10) {
                                needdate = needdate.replace(0, "");
                            }
                            mycalValue[j] = needdate; // 存到一个数组中备用
                            
                        }
                    }
                }
            }
        }
        
        resolveday(month, mycalValue, currentyear);
    }

    function formatDate(year, month, day) {
        // 检查 month 是否为 1
        if (month < 10) {
            month = "0" + month;
        }
        // 检查 day 是否为 1
        if (day < 10) {
            day = "0" + day;
        }
        // 返回格式化后的日期
        
        return year + "-" + month + "-" + day;
    }


    // 对月份下的日期进行渲染
    function resolveday(month, mycalValue, currentyear) {
        $(".toast").hide("transtime");

        var precurrentyear=currentyear;
        var nextcurrentyear=currentyear;
        
        //当前月份及之后的月份都是 undefined
        if(month === undefined){
            //这里只初始化了当前月份，之后的月份还是不能初始化，就会导致后面获取不到对应的 $("#cal" + month) 对象
            month = new Date().getMonth()+1;
        }
        var preMonth = month - 1 > 0 ? month - 1 : 12;
        var nextMonth = month + 1 > 12 ? 1 : month + 1;
        if (preMonth==12) {
            precurrentyear = currentyear - 1;
        }
        if(nextMonth==1){
            nextcurrentyear = currentyear + 1;
        }
        

        let attr = $("#cal" + month).children("li");

        // if (preMonth != 1 && nextMonth != 1) { // 没有年份的跳跃
            var prevalue =judgeMonth(precurrentyear,preMonth); // 前一个月存在的数据
            var nextvalue =judgeMonth(nextcurrentyear,nextMonth); // 后一个月存在的数据
            jQuery.each(attr, function () {
                let emptclass = jQuery(this).attr("class");
                //console.log("emptclass",emptclass);
                if (emptclass) {
                    if(emptclass=="old"){ // 前一个月的数据
                     var dayVal = jQuery(this).text().replace("休", "").replace("班", "");
                     if (prevalue.indexOf(dayVal) > -1) { // 存在于数组之中,给当天的日期加一个样式
                         jQuery(this).css("color","#FF808E");
                     }
                     dateStr = formatDate(precurrentyear,preMonth,dayVal);
                     jQuery(this).attr('title',dateStr);

                     if(ban_xiu_data){
                        if(ban_xiu_data[dateStr] == '班'){
                            if(jQuery(this).find('i').length == 0){
                                jQuery(this).addClass('xiu-ban');
                                jQuery(this).prepend('<i class="ban">班</i>');
                            }
                        }
                        if(ban_xiu_data[dateStr] == '休'){
                            if(jQuery(this).find('i').length == 0){
                                jQuery(this).addClass('xiu-ban');
                                jQuery(this).prepend('<i class="xiu">休</i>');
                            }
                        }
                    }

                 } else if(emptclass=="new"){
                    var dayVal = jQuery(this).text().replace("休", "").replace("班", "");
                    if (nextvalue.indexOf(dayVal) > -1) { // 存在于数组之中,给当天的日期加一个样式
                        jQuery(this).css("color","#FF808E");
                    }
                    dateStr = formatDate(nextcurrentyear,nextMonth,dayVal);
                    jQuery(this).attr('title',dateStr);

                    if(ban_xiu_data){
                        if(ban_xiu_data[dateStr] == '班'){
                            if(jQuery(this).find('i').length == 0){
                                jQuery(this).addClass('xiu-ban');
                                jQuery(this).prepend('<i class="ban">班</i>');
                            }
                        }
                        if(ban_xiu_data[dateStr] == '休'){
                            if(jQuery(this).find('i').length == 0){
                                jQuery(this).addClass('xiu-ban');
                                jQuery(this).prepend('<i class="xiu">休</i>');
                            }
                        }
                    }

                 }else if(emptclass.includes("now")){
                    var dayVal = jQuery(this).text().replace("休", "").replace("班", "");
                    if (mycalValue.indexOf(dayVal) > -1) { // 存在于数组之中,给当天的日期加一个样式
                        jQuery(this).css("color","#0088FF");
                    }
                    //console.log(currentyear,month,dayVal)
                    dateStr = formatDate(currentyear,month,dayVal);

                    jQuery(this).attr('title',dateStr);

                    if(ban_xiu_data){
                        if(ban_xiu_data[dateStr] == '班'){
                            if(jQuery(this).find('i').length == 0){
                                jQuery(this).addClass('xiu-ban');
                                jQuery(this).prepend('<i class="ban">班</i>');
                            }
                        }
                        if(ban_xiu_data[dateStr] == '休'){
                            if(jQuery(this).find('i').length == 0){
                                jQuery(this).addClass('xiu-ban');
                                jQuery(this).prepend('<i class="xiu">休</i>');
                            }
                        }
                    }

                 }

                }else {
                    var dayVal = jQuery(this).text().replace("休", "").replace("班", "");
                    if (mycalValue.indexOf(dayVal) > -1) { // 存在于数组之中,给当天的日期加一个样式
                        jQuery(this).css("color","#FF808E");
                    }
                    dateStr = formatDate(currentyear,month,dayVal);
                    //console.log(dateStr);
                    jQuery(this).attr('title',dateStr);
                    if(ban_xiu_data){
                        if(ban_xiu_data[dateStr] == '班'){
                            if(jQuery(this).find('i').length == 0){
                                jQuery(this).addClass('xiu-ban');
                                jQuery(this).prepend('<i class="ban">班</i>');
                            }
                        }
                        if(ban_xiu_data[dateStr] == '休'){
                            if(jQuery(this).find('i').length == 0){
                                jQuery(this).addClass('xiu-ban');
                                jQuery(this).prepend('<i class="xiu">休</i>');
                            }
                        }
                    }

                }
            });
        // }
    }

    function judgeMonth(currentyear,month) { // 解析当前年份与月份中存在的文章
        
        var Value = new Array();
        if (mycalendar[currentyear + "-" + month]) {
            for (var j = 0; j < mycalendar[currentyear + "-" + month].length; j++) {
                var pagedata = mycalendar[currentyear + "-" + month][j];
                var needdate = pagedata["date"].substring(8, 10);
                if (needdate < 10) {
                    needdate = needdate.replace(0, "");
                }
                Value[j] = needdate; // 存到一个数组中备用
            }
        }
        
        return Value;
    }

    // 相对当前月份的上一月与下一月判断解析
    function nextMonth() {
        $(".toast").hide("transtime");
        monthTag(getCurrentyear(), getCurrentmonth());
    }

    function preMonth() {
        $(".toast").hide("transtime");
        monthTag(getCurrentyear(), getCurrentmonth());
    }

    function retuenday() {
        if (mycalendar) {
            monthTag(getCurrentyear(), getCurrentmonth());
        }
    }

    // 日历控件自适应窗口大小
      var tid;
      var refreshRem = function () {
        var windowWidth = $(document).width();
        if (windowWidth >= 992) {
            $('#calendarDiv').show();
        } else {
            $('#calendarDiv').hide();
        }
      };
      addEventListener('resize', function () {
               clearTimeout(tid);
               tid = setTimeout(refreshRem, 300);
           }, false);
      addEventListener('pageshow', function (e) {
               if (e.persisted) {
                   clearTimeout(tid);
                   tid = setTimeout(refreshRem, 300);
               }
           }, false);
      refreshRem();

</script>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%91%98%E8%A6%81"><span class="nav-number">1.</span> <span class="nav-text">摘要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BB%93%E6%9E%84-HotSpot"><span class="nav-number">2.</span> <span class="nav-text">JVM虚拟机结构(HotSpot)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E8%A3%85%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%88Class-Loading-Subsystem%EF%BC%89"><span class="nav-number">2.1.</span> <span class="nav-text">类装载子系统（Class Loading Subsystem）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88Execution-Engine%EF%BC%89"><span class="nav-number">2.2.</span> <span class="nav-text">字节码执行引擎（Execution Engine）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88Java-Memory-Model%EF%BC%8CJMM%EF%BC%89"><span class="nav-number">2.3.</span> <span class="nav-text">JVM 内存模型（Java Memory Model，JMM）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">3.</span> <span class="nav-text">垃圾回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE"><span class="nav-number">3.1.</span> <span class="nav-text">什么是垃圾</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%A7%8D%E7%B1%BB%EF%BC%9A"><span class="nav-number">3.2.</span> <span class="nav-text">垃圾回收器种类：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="nav-number">3.3.</span> <span class="nav-text">垃圾回收算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-STW%EF%BC%88Stop-The-World%EF%BC%89"><span class="nav-number">3.3.1.</span> <span class="nav-text">什么是 STW（Stop-The-World）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-number">4.</span> <span class="nav-text">堆内存结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E4%BB%A3%E6%A8%A1%E5%9E%8B"><span class="nav-number">4.1.</span> <span class="nav-text">分代模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Parallel-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">4.1.1.</span> <span class="nav-text">Parallel 垃圾回收器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Parallel-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%88Parallel-GC%EF%BC%89-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="nav-number">4.1.2.</span> <span class="nav-text">Parallel 垃圾回收器（Parallel GC） 的工作方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Parallel-GC-%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E8%A1%A8%EF%BC%88%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88-GC%EF%BC%89"><span class="nav-number">4.1.3.</span> <span class="nav-text">Parallel GC 参数配置表（吞吐量优先 GC）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E6%A8%A1%E5%9E%8B"><span class="nav-number">4.2.</span> <span class="nav-text">分区模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#G1-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">4.2.1.</span> <span class="nav-text">G1 垃圾回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%88%86%E7%B1%BB"><span class="nav-number">4.2.1.1.</span> <span class="nav-text">G1垃圾收集分类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#G1-%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F-MixedGC"><span class="nav-number">4.2.2.</span> <span class="nav-text">G1 收集器的工作方式(MixedGC)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#G1-%E6%94%B6%E9%9B%86%E5%99%A8%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E8%A1%A8"><span class="nav-number">4.2.2.1.</span> <span class="nav-text">G1 收集器参数配置表</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ZGC-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">4.2.3.</span> <span class="nav-text">ZGC 垃圾回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ZGC-%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="nav-number">4.2.3.1.</span> <span class="nav-text">ZGC 收集器的工作方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ZGC%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">4.2.3.2.</span> <span class="nav-text">ZGC存在的问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ZGC-%E6%94%B6%E9%9B%86%E5%99%A8%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E8%A1%A8"><span class="nav-number">4.2.3.3.</span> <span class="nav-text">ZGC 收集器参数配置表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZGC-vs-G1-GC-vs-Parallel-GC-%E5%AF%B9%E6%AF%94%E8%A1%A8"><span class="nav-number">4.3.</span> <span class="nav-text">ZGC vs G1 GC vs Parallel GC 对比表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA-OutOfMemoryError%EF%BC%8C%E7%AE%80%E7%A7%B0-OOM"><span class="nav-number">5.</span> <span class="nav-text">内存溢出(OutOfMemoryError，简称 OOM)</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="飘逸峰"
      src="/uploads/me.png">
  <p class="site-author-name" itemprop="name">飘逸峰</p>
  <div class="site-description" itemprop="description">分享成长与快乐的地方</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">196</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags">
        <span class="site-state-item-count">49</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/13320506/qunfeng-han" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;13320506&#x2F;qunfeng-han" rel="noopener me" target="_blank"><i class="fa-brands fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/hanqunfeng" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hanqunfeng" rel="noopener me" target="_blank"><i class="fa-brands fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://gitee.com/hanqunfeng/" title="Gitee → https:&#x2F;&#x2F;gitee.com&#x2F;hanqunfeng&#x2F;" rel="noopener me" target="_blank"><i class="fa-brands fa-git fa-fw"></i>Gitee</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://hanqunfeng.coding.net/" title="Coding → https:&#x2F;&#x2F;hanqunfeng.coding.net" rel="noopener me" target="_blank"><i class="fa-solid fa-code fa-fw"></i>Coding</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>
<div class="toBottom">
<i class="fa-solid fa-circle-arrow-down" aria-hidden="true"></i>
直达底部
<i class="fa-solid fa-circle-arrow-down" aria-hidden="true"></i>
</div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa-solid fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="http://tongji.baidu.com/web/welcome/login" title="http:&#x2F;&#x2F;tongji.baidu.com&#x2F;web&#x2F;welcome&#x2F;login" rel="noopener" target="_blank">百度统计</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://zhanzhang.baidu.com/" title="http:&#x2F;&#x2F;zhanzhang.baidu.com" rel="noopener" target="_blank">百度站长</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://search.google.com/search-console" title="https:&#x2F;&#x2F;search.google.com&#x2F;search-console" rel="noopener" target="_blank">Google Search Console</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://www.aliyun.com/" title="https:&#x2F;&#x2F;www.aliyun.com" rel="noopener" target="_blank">阿里云</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://leancloud.cn/" title="https:&#x2F;&#x2F;leancloud.cn" rel="noopener" target="_blank">Leancloud</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://www.fontawesome.com.cn/faicons/" title="http:&#x2F;&#x2F;www.fontawesome.com.cn&#x2F;faicons&#x2F;" rel="noopener" target="_blank">FontAwsome</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.hanqunfeng.com/2025/05/12/jvm-gc-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/me.png">
      <meta itemprop="name" content="飘逸峰">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="飘逸峰的博客">
      <meta itemprop="description" content="分享成长与快乐的地方">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="JVM 之 内存模型与垃圾回收机制(GC) | 飘逸峰的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM 之 内存模型与垃圾回收机制(GC)
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-05-12 22:30:05" itemprop="dateCreated datePublished" datetime="2025-05-12T22:30:05+08:00">2025-05-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-18 14:11:43" itemprop="dateModified" datetime="2025-05-18T14:11:43+08:00">2025-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
  
<!-- 置顶，精品 -->
    <span class="post-meta-item">
    <span>
    <span class="post-meta-item-icon">
      <i class="fa-solid fa-thumbtack zhidingtop">置顶</i>
    </span>
    <span class="post-meta-item">
    <span>
    <span class="post-meta-item-icon">
            <i class="fa-regular fa-newspaper jingping">精品</i>
    </span>


    <span class="post-meta-break"></span>

</div>


    <span id="/2025/05/12/jvm-gc-01/" class="leancloud_visitors" data-flag-title="JVM 之 内存模型与垃圾回收机制(GC)" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>14k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>50 分钟</span>
    </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><!--
 **加粗**
 *斜体*
 ***加粗并斜体***
 ~~删除线~~
 ==突出显示==
 `突出显示(推荐)`
 ++下划线++
 ~下标~
 ^上标^
 脚注，参考文献[^1]，然后在文档最下方要添加这个1对应的内容，如：[^1]: My reference.
 图片设置宽度和高度(通过uPic上传后，需要将upic修改过为blog，用于添加水印) ![](https://upic-oss.oss-cn-beijing.aliyuncs.com/blog/innodb_buffer_pool.png =900x600)

 +++ **点击折叠**
 这是被隐藏的内容
 +++

::: tips success warning danger
这里是容器内的内容
:::

% note info % success warning danger
这里是容器内的内容
% endnote %

引用本地其它文章连接{}
 大括号开始% post_link 文件名称(不包含.md) %大括号结束
 -->
<h2 id="摘要">摘要</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>本文介绍JVM的内存模型与垃圾回收机制</p>
</li>
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">JDK8 The Java® Virtual Machine Specification</a></p>
</li>
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">JDK8的java指令的官⽅⽂档</a></p>
</li>
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/17/docs/specs/man/index.html">JDK⼯具官⽹⽂档</a></p>
</li>
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/17/docs/specs/man/java.html">JDK17的java指令的官⽅⽂档</a></p>
</li>
</ul>
<span id="more"></span>
<h2 id="JVM虚拟机结构-HotSpot">JVM虚拟机结构(HotSpot)</h2>
<p><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/cGMyEe.png" alt=""></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>设置内存分配示例</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># jdk1.8+</span></span><br><span class="line">java ‐Xms2048M ‐Xmx2048M ‐Xmn1024M ‐Xss512K ‐XX:MetaspaceSize=128M ‐XX:MaxMetaspaceSize=256M ‐jar server.jar</span><br><span class="line"><span class="comment"># jdk1.6/1.7</span></span><br><span class="line">java ‐Xms2048M ‐Xmx2048M ‐Xmn1024M ‐Xss512K ‐XX:PermSize=128M ‐XX:MaxPermSize=256M ‐jar server.jar</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>各参数含义与默认值（针对 JDK 1.8）</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义说明</th>
<th>默认值（JDK 1.8）</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-Xms2048M</code></td>
<td><strong>初始堆大小</strong>，即 JVM 启动时分配的堆内存大小（这里是 2GB）</td>
<td>物理内存的 1/64（最小 1MB），推荐配置为与 -Xmx 一致</td>
</tr>
<tr>
<td><code>-Xmx2048M</code></td>
<td><strong>最大堆内存大小</strong>，JVM 允许分配的最大堆内存</td>
<td>物理内存的 1/4（受限于 32位/64位）</td>
</tr>
<tr>
<td><code>-Xmn1024M</code></td>
<td><strong>新生代大小</strong>（Eden + Survivor）为 1GB</td>
<td>未显式指定时，通常占堆的 1/3 左右</td>
</tr>
<tr>
<td><code>-Xss512K</code></td>
<td><strong>每个线程的栈大小</strong>（Thread Stack Size），这里设置为 512KB</td>
<td>1MB（64位系统）或 512KB（32位系统）</td>
</tr>
<tr>
<td><code>-XX:MetaspaceSize=256M</code></td>
<td><strong>元空间初始大小</strong>（用于加载类的元数据，不再使用 PermGen），达到该值后，JVM 会触发一次 GC，空间不够时会进行扩容，最大到  <code>MaxMetaspaceSize</code></td>
<td>默认 21MB（客户端）或 16MB（服务器端），为避免频繁扩容导致的GC，可以设置的稍微大一些，比如<code>MaxMetaspaceSize</code>的一半，或干脆与<code>MaxMetaspaceSize</code>一样大</td>
</tr>
<tr>
<td><code>-XX:MaxMetaspaceSize=256M</code></td>
<td><strong>元空间最大大小</strong>，接近设置值时会触发 Full GC</td>
<td>无限制（默认只受物理内存约束） ，推荐配置一个合适的数值，比如8G的内存可以配置为256M</td>
</tr>
</tbody>
</table>
<h3 id="类装载子系统（Class-Loading-Subsystem）">类装载子系统（Class Loading Subsystem）</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>类装载子系统负责将 <code>.class</code> 文件加载到 JVM 中，并进行解析、验证、初始化等过程。</p>
</li>
<li class="lvl-2">
<p>加载过程的几个阶段：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>阶段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>加载（Loading）</strong></td>
<td>将 <code>.class</code> 文件读取为二进制数据，构造 <code>Class</code> 对象</td>
</tr>
<tr>
<td><strong>验证（Verification）</strong></td>
<td>确保字节码文件格式正确、安全合法（防止恶意代码）</td>
</tr>
<tr>
<td><strong>准备（Preparation）</strong></td>
<td>为类的静态变量分配内存，并设置默认初始值</td>
</tr>
<tr>
<td><strong>解析（Resolution）</strong></td>
<td>将常量池中的符号引用替换为直接引用（方法、字段等）</td>
</tr>
<tr>
<td><strong>初始化（Initialization）</strong></td>
<td>执行 <code>&lt;clinit&gt;</code> 静态初始化方法，对静态变量赋初始值</td>
</tr>
</tbody>
</table>
<ul class="lvl-0">
<li class="lvl-2">
<p>类加载器（ClassLoader）体系结构：详细参考 <a href="/2025/05/08/jvm-classloader-01/" title="JVM 之 类加载器">JVM 之 类加载器</a></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>类加载器名称</th>
<th>加载内容</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>引导类加载器（Bootstrap ClassLoader）</strong></td>
<td>Java 核心类库（如 <code>java.lang.*</code>）</td>
<td>由 JVM 自身实现，用本地代码实现，无法直接访问</td>
</tr>
<tr>
<td><strong>扩展类加载器（Extension ClassLoader）</strong></td>
<td><code>JAVA_HOME/jre/lib/ext</code> 目录下的类</td>
<td>加载标准扩展类库</td>
</tr>
<tr>
<td><strong>应用类加载器（Application ClassLoader）</strong></td>
<td>用户应用类路径（CLASSPATH 指定的目录）</td>
<td>最常用，加载大多数应用代码</td>
</tr>
<tr>
<td><strong>自定义类加载器（Custom ClassLoader）</strong></td>
<td>用户手动实现的类加载器</td>
<td>可以打破双亲委派机制，实现热加载、加密类加载等</td>
</tr>
</tbody>
</table>
<blockquote>
<p>类加载采用 双亲委派模型：请求会先向父加载器委托，只有在父加载器加载失败时才尝试自身加载。</p>
</blockquote>
<h3 id="字节码执行引擎（Execution-Engine）">字节码执行引擎（Execution Engine）</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>字节码执行引擎负责将 Java 字节码解释或编译为机器代码，并在底层平台上执行。</p>
</li>
<li class="lvl-2">
<p>执行引擎的核心模块</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>组件名称</th>
<th>作用说明</th>
<th>关键特性</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>解释器（Interpreter）</strong></td>
<td>将字节码逐条解释执行</td>
<td>启动快，适合冷代码（非热点代码），执行效率相对较低</td>
</tr>
<tr>
<td><strong>即时编译器（JIT Compiler）</strong></td>
<td>将热点代码编译为本地机器码，提高执行效率</td>
<td>包含 C1（Client）和 C2（Server）两种，支持优化如：方法内联、逃逸分析、循环展开等</td>
</tr>
<tr>
<td><strong>垃圾收集器（Garbage Collector, GC）</strong></td>
<td>自动内存管理，负责对象生命周期的回收</td>
<td>常见算法包括：Serial、Parallel、CMS、G1、ZGC（低延迟）等，根据不同场景选择</td>
</tr>
<tr>
<td><strong>本地接口（Native Interface）</strong></td>
<td>支持 Java 与本地语言（如 C/C++）的互操作</td>
<td>通过 JNI（Java Native Interface）实现，调用底层操作系统或第三方库功能</td>
</tr>
</tbody>
</table>
<div class="tips">
<p><em><strong>即时编译器（JIT Compiler）</strong></em></p>
<ul class="lvl-1">
<li class="lvl-2">JVM 的 HotSpot 编译器有两个主要组件：<br>
C1 编译器（Client 编译器）：轻量、快速编译，优化少。<br>
C2 编译器（Server 编译器）：优化高级，耗时长，适合长时间运行的热点代码。</li>
<li class="lvl-2">在 64 位 JDK 中，默认就是 -server 模式 <code>(C2 编译器)</code> ，不再支持 -client <code>(C1 编译器)</code>。</li>
<li class="lvl-2">在 32 位 JDK 中，根据平台和启动方式，可能会自动选择 -client 或 -server，也可以手动指定。</li>
<li class="lvl-2">分层编译（Tiered Compilation） 允许 JVM 在一开始用 C1 编译器快速编译字节码，后续热点代码再交给 C2 编译器进行更高级优化。这样结合了 -client（快启动）和 -server（高性能）的优点。<code>TieredCompilation</code>参数控制是否开启分层编译，默认开启。</li>
<li class="lvl-2"><code>-XX:TieredStopAtLeve=&lt;level&gt;</code> 参数控制 编译器最多使用哪一层优化级别。它的取值如下，值越低启动越快，但优化越少。</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>仅解释执行（不开启编译器）</td>
</tr>
<tr>
<td>1</td>
<td>只使用 C1 编译器的第一级（最少优化）</td>
</tr>
<tr>
<td>2</td>
<td>C1 第二级，略多优化</td>
</tr>
<tr>
<td>3</td>
<td>C1 第三级，更优化</td>
</tr>
<tr>
<td>4</td>
<td>启用 C2 编译器（完全优化，默认值）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="JVM-内存模型（Java-Memory-Model，JMM）">JVM 内存模型（Java Memory Model，JMM）</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>JMM 是 Java 虚拟机规范中定义的一种 抽象内存模型，它决定了多线程程序中变量的读写可见性、有序性和原子性。同时，JVM 在物理层也有一个实际的内存结构，称为运行时数据区域（Runtime Data Areas），这两个可以结合理解。</p>
</li>
<li class="lvl-2">
<p>JMM 的主要目标</p>
<ul class="lvl-2">
<li class="lvl-6">保证多线程环境下的数据一致性</li>
<li class="lvl-6">指导 JVM 和 CPU 的内存交互行为（如重排序、缓存）</li>
</ul>
</li>
<li class="lvl-2">
<p>实际运行时内存结构如下：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>内存区域</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>📌 <strong>程序计数器（PC）</strong></td>
<td>每个线程私有，记录当前执行的字节码指令地址</td>
</tr>
<tr>
<td>📌 <strong>Java 线程栈</strong></td>
<td>每个线程私有，方法调用时用于存储局部变量、操作数栈等</td>
</tr>
<tr>
<td>📌 <strong>本地方法栈</strong></td>
<td>与虚拟机栈类似，用于 native 方法</td>
</tr>
<tr>
<td>📌 <strong>堆（Heap）</strong></td>
<td>所有线程共享，存储对象实例、数组等，GC 的主要区域</td>
</tr>
<tr>
<td>📌 <strong>方法区（或元空间）</strong></td>
<td>所有线程共享，存储类信息、静态变量、常量池等（JDK8 后称为 Metaspace）</td>
</tr>
</tbody>
</table>
<h2 id="垃圾回收器">垃圾回收器</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>垃圾回收器负责自动管理内存，回收不再使用的对象，避免内存泄漏和溢出。</p>
</li>
</ul>
<h3 id="什么是垃圾">什么是垃圾</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>内存中没有被（线程栈变量，静态变量，常量池，JNI指针）引用的地址就是垃圾</p>
</li>
<li class="lvl-2">
<p>可达性分析算法：是现代 JVM 判断一个对象是否“还活着”的主要算法。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">基本思想：</span><br><span class="line">从一组称为 “GC Roots” 的对象出发，沿着对象之间的引用链向下搜索。</span><br><span class="line">如果某个对象 可以从 GC Roots 追踪到，就认为它是 “可达” 的（Alive）。</span><br><span class="line">否则就认为是 “不可达” 的（Garbage），可以被回收。</span><br></pre></td></tr></table></figure>
<div class="tips">
<ul class="lvl-1">
<li class="lvl-2">
<p>在 JVM 中，<code>GC Roots</code> 是一些 始终可用的、不会被垃圾回收的引用起点，主要包括：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>GC Roots 来源</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>当前线程栈中的引用（局部变量表）</td>
<td>各个线程正在调用的方法中的局部变量、参数等</td>
</tr>
<tr>
<td>静态字段引用</td>
<td>类的静态字段引用的对象</td>
</tr>
<tr>
<td>JNI 引用（Native 方法引用）</td>
<td>Java 本地方法中引用的对象</td>
</tr>
<tr>
<td>常量引用池中的对象</td>
<td>字符串常量等可能持有对象引用</td>
</tr>
<tr>
<td>活动线程对象</td>
<td>线程自身在 GC 时不会被回收</td>
</tr>
<tr>
<td>JVM 内部结构（如系统类加载器等）</td>
<td>JVM 关键系统对象</td>
</tr>
</tbody>
</table>
</div>
<h3 id="垃圾回收器种类：">垃圾回收器种类：</h3>
<p><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/TEILZ9.png" alt=""></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>左边6种叫分代模型，右边的4种叫分区模型</p>
</li>
</ul>
<div class="tips">
<p><em><strong>分代模型（Generational Model）</strong></em><br>
堆内存划分为：<br>
年轻代（Young Generation）：存放新创建的对象，分为 Eden 和 Survivor 区。<br>
老年代（Old Generation）：存放经过多次 GC 后仍然存活的对象。</p>
<p><em><strong>分区模型（Region-based Model）</strong></em><br>
分区模型（如 G1、ZGC、Shenandoah）不再严格按照代划分内存，而是把堆划分为多个 大小相同的 Region。每个 Region 可以在运行时被动态标记为 Eden、Survivor 或 Old。</p>
</div>
<ul class="lvl-0">
<li class="lvl-2">
<p>分代模型中，上面3个是新生代垃圾回收器，下面3个是老年代垃圾回收器，可以交叉配对（见上图虚线），但最常用是上下两两配对。</p>
</li>
<li class="lvl-2">
<p>CMS即可以作为新生代垃圾回收器，也可以作为老年代垃圾回收器。</p>
</li>
<li class="lvl-2">
<p>EpsilonGC，是一个特殊的垃圾回收器，它不回收任何对象，只负责最终记录，做测试用的。</p>
</li>
<li class="lvl-2">
<p>目前最先进的模型是 <code>ZGC</code>，jkd11开始支持，但直到JDK16才比较完善，目前非默认配置，需要手动配置。其与Redhat出品的 <code>Shenandoah</code> 是竞争关系。</p>
</li>
<li class="lvl-2">
<p>常见垃圾回收器及其分类、JDK版本</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>垃圾回收器</th>
<th>所属模型</th>
<th>说明</th>
<th>首次出现 JDK 版本</th>
<th>启用命令（JVM 参数）</th>
<th>适合的堆内存大小</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Serial</strong></td>
<td>分代模型</td>
<td>单线程，新生代和老年代都使用 Serial，适用于小堆内存, <code>已弃用</code></td>
<td>JDK 1.2</td>
<td><code>-XX:+UseSerialGC</code></td>
<td>💾 小于 1GB</td>
</tr>
<tr>
<td><strong>ParNew</strong></td>
<td>分代模型</td>
<td>Serial 的多线程版本，<strong>仅用于 CMS 新生代</strong>, <code>JDK11已弃用</code></td>
<td>JDK 1.4</td>
<td><code>-XX:+UseParNewGC -XX:+UseConcMarkSweepGC</code></td>
<td>💾 1GB ~ 4GB</td>
</tr>
<tr>
<td><strong>Parallel（吞吐量 GC）</strong></td>
<td>分代模型</td>
<td>多线程 GC，适合吞吐量优先的应用场景</td>
<td>JDK 1.4</td>
<td><code>-XX:+UseParallelGC</code>（新生代）<br><code>-XX:+UseParallelOldGC</code>（老年代）</td>
<td>💾 2GB ~ 8GB</td>
</tr>
<tr>
<td><strong>CMS（Concurrent Mark Sweep）</strong></td>
<td>分代模型</td>
<td>老年代并发标记-清除，低延迟，但存在碎片，<code>JDK14已弃用</code></td>
<td>JDK 1.4</td>
<td><code>-XX:+UseConcMarkSweepGC</code></td>
<td>💾 2GB ~ 8GB</td>
</tr>
<tr>
<td><strong>G1（Garbage First）</strong></td>
<td>分区模型</td>
<td>将堆划分为 Region，逻辑分代，支持并发压缩，平衡延迟与吞吐</td>
<td>JDK 7u4（正式）</td>
<td><code>-XX:+UseG1GC</code></td>
<td>💾 4GB ~ 数十 GB</td>
</tr>
<tr>
<td><strong>ZGC（Z Garbage Collector）</strong></td>
<td>分区模型</td>
<td>Region 弹性大小，支持超大堆，低延迟（&lt;10ms 停顿）</td>
<td>JDK 11（实验），JDK 15（正式）</td>
<td><code>-XX:+UseZGC</code></td>
<td>💾 8GB ~ 数 TB（超大堆）</td>
</tr>
<tr>
<td><strong>Shenandoah</strong></td>
<td>分区模型</td>
<td>红帽主导，低延迟，并发回收与并发压缩</td>
<td>JDK 12（实验），JDK 15（正式）</td>
<td><code>-XX:+UseShenandoahGC</code></td>
<td>💾 2GB ~ 数十 GB</td>
</tr>
</tbody>
</table>
<blockquote>
<p>对于 CMS，启用后会自动使用 ParNew 作为新生代回收器（除非显式禁止）。<br>
对于 Parallel GC 启用 <code>-XX:+UseParallelGC</code>（新生代）会自动启用 <code>-XX:+UseParallelOldGC</code>（老年代）。<br>
对于ZGC，jdk15以前最大支持4T内存，之后最大支持16T内存。</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>各版本默认垃圾回收器及推荐配置（JDK 1.6 起）</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>JDK 版本</th>
<th>默认 GC</th>
<th>建议使用 GC（按场景分类）</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>JDK 1.6</strong></td>
<td>Serial / Parallel</td>
<td>- 小型应用（如桌面程序）：<code>-XX:+UseSerialGC</code>  <br> - 中大型应用（吞吐量优先）：<code>-XX:+UseParallelGC</code></td>
</tr>
<tr>
<td><strong>JDK 1.7</strong></td>
<td>同上</td>
<td>同 JDK 1.6</td>
</tr>
<tr>
<td><strong>JDK 1.8</strong></td>
<td>Parallel</td>
<td>- 吞吐优先：默认 <code>-XX:+UseParallelGC</code> <br> - 响应优先：<code>-XX:+UseConcMarkSweepGC</code>（CMS）<br> - 大堆 + 未来升级考虑：<code>-XX:+UseG1GC</code>（推荐）</td>
</tr>
<tr>
<td><strong>JDK 9-14</strong></td>
<td>G1 GC</td>
<td>- 一般默认即可：<code>-XX:+UseG1GC</code>（延迟与吞吐平衡）<br> - 极端低延迟要求：升级到 JDK 11+ 使用 ZGC/Shenandoah</td>
</tr>
<tr>
<td><strong>JDK 15+</strong></td>
<td>G1 GC（默认），ZGC / Shenandoah 可选</td>
<td>- 延迟敏感（在线服务、RT系统）：<code>-XX:+UseZGC</code> 或 <code>-XX:+UseShenandoahGC</code><br> - 吞吐为主：<code>-XX:+UseParallelGC</code><br> - 综合平衡：<code>-XX:+UseG1GC</code>（默认）</td>
</tr>
</tbody>
</table>
<ul class="lvl-0">
<li class="lvl-2">
<p>判断默认 GC 的方式</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintCommandLineFlags -version</span><br></pre></td></tr></table></figure>
<h3 id="垃圾回收算法">垃圾回收算法</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>JVM 中常见垃圾回收算法汇总</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>算法名称</th>
<th>核心思想</th>
<th>适用阶段/区域</th>
<th>优缺点简述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>标记-清除（Mark-Sweep）</strong></td>
<td>标记出存活对象，清除未标记对象</td>
<td>老年代</td>
<td>简单高效，但会产生大量碎片，不适合连续内存分配</td>
</tr>
<tr>
<td><strong>标记-整理（Mark-Compact）</strong></td>
<td>标记后移动存活对象，整理碎片</td>
<td>老年代</td>
<td>消除碎片，代价是移动对象，适用于老年代压缩</td>
</tr>
<tr>
<td><strong>复制算法（Copying）</strong></td>
<td>将对象复制到另一块内存（如 Eden → Survivor）</td>
<td>新生代</td>
<td>高效率，适合回收大多数对象短命的新生代，但需要额外空间</td>
</tr>
<tr>
<td><strong>分代回收（Generational）</strong></td>
<td>将对象按生命周期划分（新生代/老年代）</td>
<td>整个堆结构</td>
<td>实用性强，结合不同算法应用于不同代，现代 GC 基础</td>
</tr>
<tr>
<td><strong>分区回收（Region-based）</strong></td>
<td>将堆划分为若干等大小的 Region 动态分配</td>
<td>整个堆（如 G1、ZGC）</td>
<td>更灵活，支持并发并行，减少 STW 停顿，适用于大堆、低延迟场景</td>
</tr>
<tr>
<td><strong>增量回收（Incremental）</strong></td>
<td>分阶段小步执行 GC 以减少单次停顿</td>
<td>某些并发/低延迟 GC</td>
<td>减少暂停时间，但整体效率可能降低</td>
</tr>
<tr>
<td><strong>并发回收（Concurrent）</strong></td>
<td>标记、清理等步骤与应用线程并发执行</td>
<td>CMS、G1、ZGC 等</td>
<td>停顿时间短，对响应时间要求高的系统友好</td>
</tr>
<tr>
<td><strong>三色标记（Tri-color Marking）</strong></td>
<td>并发标记算法的一种实现思想</td>
<td>CMS、G1、ZGC 等</td>
<td>白（待回收）、灰（已标记未扫描）、黑（已标记已扫描），避免“漏标”问题</td>
</tr>
<tr>
<td><strong>SATB（Snapshot-At-The-Beginning）</strong></td>
<td>并发标记的快照策略</td>
<td>G1、ZGC</td>
<td>保证在并发标记过程中不遗漏新引用，适合高并发场景</td>
</tr>
<tr>
<td><strong>Lazy Compaction（延迟压缩）</strong></td>
<td>不每次 GC 都压缩，视情况而定</td>
<td>G1 等</td>
<td>降低不必要的移动成本</td>
</tr>
</tbody>
</table>
<ul class="lvl-0">
<li class="lvl-2">
<p>对应关系：GC 回收器和底层算法</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>回收器</th>
<th>使用的算法组合</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Serial</strong></td>
<td>新生代：复制算法<br>老年代：标记-整理</td>
</tr>
<tr>
<td><strong>ParNew</strong></td>
<td>新生代：复制算法（多线程）</td>
</tr>
<tr>
<td><strong>Parallel</strong></td>
<td>新生代：复制算法<br>老年代：标记-整理</td>
</tr>
<tr>
<td><strong>CMS</strong></td>
<td>新生代：ParNew（复制）<br>老年代：标记-清除 + 三色标记 + 并发</td>
</tr>
<tr>
<td><strong>G1</strong></td>
<td>分区回收 + 三色标记 + SATB + Lazy Compaction</td>
</tr>
<tr>
<td><strong>ZGC</strong></td>
<td>分区回收 + 并发标记 + SATB + Region Remapping</td>
</tr>
<tr>
<td><strong>Shenandoah</strong></td>
<td>分区回收 + 并发标记 + 并发压缩 + 三色标记</td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">       ┌────────────────────────┐</span><br><span class="line">       │   常见 GC 算法分类       │</span><br><span class="line">       └────────────────────────┘</span><br><span class="line">                 │</span><br><span class="line">   ┌─────────────┴──────────────┐</span><br><span class="line">   │                            │</span><br><span class="line">分代模型                      分区模型</span><br><span class="line">   │                            │</span><br><span class="line"> ┌─┴─────┐                  ┌───┴─────┐</span><br><span class="line">复制   标记-清除         Region-based 并发</span><br><span class="line">      标记-整理             SATB / 三色标记</span><br></pre></td></tr></table></figure>
<h4 id="什么是-STW（Stop-The-World）">什么是 STW（Stop-The-World）</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>STW（Stop-The-World） 指的是：在某些垃圾回收阶段，JVM 会暂停所有应用线程（也叫用户线程），让垃圾回收线程独占 CPU 执行 GC 逻辑。</p>
</li>
<li class="lvl-2">
<p>你可以这样理解 STW</p>
<ul class="lvl-2">
<li class="lvl-6">JVM 会“按下暂停键”暂停所有正在运行的 Java 程序代码；</li>
<li class="lvl-6">然后 专心进行 GC 的某些阶段（如标记、整理、复制等）；</li>
<li class="lvl-6">GC 完成后，才会“恢复运行”应用线程。</li>
</ul>
</li>
<li class="lvl-2">
<p>各 GC 中 STW 的存在情况</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>回收器</th>
<th>是否存在 STW？</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Serial</td>
<td>✅ 是，全停顿，全阶段单线程</td>
<td>堆越大 STW 越长</td>
</tr>
<tr>
<td>Parallel</td>
<td>✅ 是，全停顿，多线程执行 GC</td>
<td>提高效率但仍会暂停</td>
</tr>
<tr>
<td>CMS</td>
<td>✅ 有，初始标记和最终重新标记是 STW</td>
<td>大部分阶段并发执行</td>
</tr>
<tr>
<td>G1</td>
<td>✅ 有，但设计为尽可能缩短 STW</td>
<td>分阶段并发 + 并行处理</td>
</tr>
<tr>
<td>ZGC</td>
<td>✅ 极短（&lt;10ms）</td>
<td>仅个别阶段是 STW，几乎感知不到</td>
</tr>
<tr>
<td>Shenandoah</td>
<td>✅ 极短</td>
<td>高度并发，STW 时间也极短</td>
</tr>
</tbody>
</table>
<ul class="lvl-0">
<li class="lvl-2">
<p>为什么要关注 STW？</p>
<ul class="lvl-2">
<li class="lvl-6">在响应时间敏感型系统（如在线交易系统、游戏服务器、API 网关）中，长时间的 STW 会造成用户请求卡顿、超时。</li>
<li class="lvl-6">因此，选择 低 STW 的 GC（如 G1、ZGC、Shenandoah） 对这类系统至关重要。</li>
</ul>
</li>
</ul>
<h2 id="堆内存结构">堆内存结构</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>不同的垃圾回收器决定了堆内存的结构不同，但总体上分为两种类型：分代模型和分区模型。</p>
</li>
</ul>
<h3 id="分代模型">分代模型</h3>
<h4 id="Parallel-垃圾回收器">Parallel 垃圾回收器</h4>
<p><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/Apr5aY.png" alt=""></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>堆结构被划分为 <code>Old Generation（老年代）</code> 和 <code>Young Generation（新生代）</code> 两部分。</p>
</li>
<li class="lvl-2">
<p><code>Young Generation</code> 由 <code>Eden</code> 和 两个 <code>Survivor</code> 组成，其中 <code>Eden</code> 是一个连续的内存区域，<code>Survivor</code> 是一个非连续的内存区域。</p>
</li>
<li class="lvl-2">
<p>默认情况下，<code>Young Generation</code>占堆内存的 <code>1/3</code>,  <code>Old Generation</code> 占堆内存的 <code>2/3</code>。</p>
</li>
<li class="lvl-2">
<p>默认情况下，<code>Eden:S0:S1 = 8:1:1</code> ,如果希望为 4:1:1，使用 <code>-XX:SurvivorRatio=4</code>，但实际上这个比例并不是固定的，而是由jvm基于情况自动变化的，因为JVM默认开启了这个参数<code>-XX:+UseAdaptiveSizePolicy</code>，如果希望固定这个比例，可以设置为 <code>-XX:-UseAdaptiveSizePolicy</code>来关闭这个配置。</p>
</li>
<li class="lvl-2">
<p>默认情况下，对象最多经历<code>15次</code>Minor GC后进入老年代，可以通过 <code>-XX:MaxTenuringThreshold=n</code> 设置。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>区域</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Eden</strong></td>
<td>对象首次创建的区域，大部分对象在这里创建并很快被回收</td>
</tr>
<tr>
<td><strong>S0/S1</strong></td>
<td>Survivor 区域：两个交替使用的缓冲区（From 和 To），用于拷贝存活对象</td>
</tr>
<tr>
<td><strong>Old</strong></td>
<td>老年代：存活次数多、生命周期长的对象会从新生代晋升到老年代，回收频率低</td>
</tr>
</tbody>
</table>
<ul class="lvl-0">
<li class="lvl-2">
<p>对象内存分配图解(简化)</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">创建对象</span><br><span class="line">   ↓</span><br><span class="line">进入 Eden 区（新生代）</span><br><span class="line">   ↓ Eden 区满</span><br><span class="line">第一次 Minor GC（存活对象[Eden]复制到 S0）</span><br><span class="line">   ↓ Eden 区满 或 S0 区满</span><br><span class="line">第二次 Minor GC（存活对象[Eden和S0]复制到 S1，年龄 +1）</span><br><span class="line">   ↓ Eden 区满 或 S1 区满</span><br><span class="line">第三次 Minor GC（存活对象[Eden和S1]复制到 S0，年龄 +1）</span><br><span class="line">   ↓</span><br><span class="line">……  S0/S1 交替，年龄达到阈值（如 15）</span><br><span class="line">   ↓ 还没有被回收</span><br><span class="line">晋升到 Old 区（老年代），等待Old区满 触发 Full GC</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>大对象直接进入老年代</p>
<ul class="lvl-2">
<li class="lvl-6">大对象就是需要大量连续内存空间的对象（比如：字符串、数组），如果对象很大（如超过 Eden 区大小，或是超过 Survivor 区大小），可能直接分配到老年代</li>
<li class="lvl-6">也可以通过 <code>-XX:PretenureSizeThreshold=&lt;大小，单位字节&gt;</code> 控制超过一定大小的对象是否直接分配到老年代（Old Generation），跳过新生代（Eden），以避免大对象频繁在年轻代造成 GC 压力。这个参数只在 Serial 和ParNew两个收集器下有效。</li>
</ul>
</li>
<li class="lvl-2">
<p>对象动态年龄判断</p>
<ul class="lvl-2">
<li class="lvl-6">对象在Survivor区来回移动时，如果这批对象的总大小大于这块Survivor区域内存大小的50%(-XX:TargetSurvivorRatio可以指定)，那么此时大于等于这批对象年龄最大值的对象，就可以直接进入老年代了，</li>
<li class="lvl-6">例如Survivor区域里现在有一批对象，年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就会把年龄n(含)以上的对象都放入老年代。这个规则其实是希望那些可能是长期存活的对象，尽早进入老年代。</li>
<li class="lvl-6">对象动态年龄判断机制一般是在minor gc之后触发的。</li>
</ul>
</li>
</ul>
<div class="tips">
<ul class="lvl-1">
<li class="lvl-2">
<p>对象逃逸分析</p>
<ul class="lvl-3">
<li class="lvl-6">如果对象很小，且只在方法内部使用，并没有被外部引用，则其有可能直接分配到栈内存，而不进入堆内存</li>
<li class="lvl-6">JVM对于这种情况可以通过开启逃逸分析参数(-XX:+DoEscapeAnalysis)来优化对象内存分配位置，使其通过<code>标量替换</code>优先分配在栈上(栈上分配)，JDK7之后默认开启逃逸分析，如果要关闭使用参数(-XX:-DoEscapeAnalysis)</li>
</ul>
</li>
<li class="lvl-2">
<p>标量替换</p>
<ul class="lvl-3">
<li class="lvl-6">通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM不会创建该对象，而是将该对象成员变量分解若干个被这个方法使用的成员变量所代替，这些代替的成员变量在栈帧或寄存器上分配空间，这样就不会因为没有一大块连续空间导致对象内存不够分配。</li>
<li class="lvl-6">开启标量替换参数(-XX:+EliminateAllocations)，JDK7之后默认开启。</li>
</ul>
</li>
<li class="lvl-2">
<p>标量与聚合量</p>
<ul class="lvl-3">
<li class="lvl-6">标量即不可被进一步分解的量，而JAVA的基本数据类型就是标量（如：int，long等基本数据类型以及reference类型等），</li>
<li class="lvl-6">标量的对立就是可以被进一步分解的量，而这种量称之为聚合量。而在JAVA中对象就是可以被进一步分解的聚合量。</li>
</ul>
</li>
</ul>
</div>
<h4 id="Parallel-垃圾回收器（Parallel-GC）-的工作方式">Parallel 垃圾回收器（Parallel GC） 的工作方式</h4>
<p><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/fo2Egs.png" alt="" width="1200" height="600"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Parallel GC 是多线程垃圾回收器，可以通过 <code>-XX:ParallelGCThreads</code> 来设置GC线程数量。</p>
</li>
<li class="lvl-2">
<p>当 Parallel GC 被触发（例如 Minor GC 或 Full GC）时，所有用户线程 被完全暂停（Stop-The-World, STW）</p>
</li>
</ul>
<h4 id="Parallel-GC-参数配置表（吞吐量优先-GC）">Parallel GC 参数配置表（吞吐量优先 GC）</h4>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
<th>默认值（如未特别说明）</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-XX:+UseParallelGC</code></td>
<td>开启 Parallel GC，用于新生代收集</td>
<td>-</td>
</tr>
<tr>
<td><code>-XX:+UseParallelOldGC</code></td>
<td>开启老年代并行收集（Parallel Old）</td>
<td>-</td>
</tr>
<tr>
<td><code>-XX:ParallelGCThreads</code></td>
<td>垃圾回收时的并行线程数（与 CPU 数量相关）</td>
<td>根据硬件自动配置</td>
</tr>
<tr>
<td><code>-XX:MaxGCPauseMillis</code></td>
<td>设置 GC 最大暂停时间目标（影响内存分配策略）</td>
<td>一个非常大的值，可以认为无限制（建议按需设置）</td>
</tr>
<tr>
<td><code>-XX:GCTimeRatio</code></td>
<td>设置 GC 时间与应用运行时间的比值（0~100）<br>值越小，GC 越频繁，值越大 GC 越少</td>
<td>99（表示 1% 用于 GC，99% 用于应用）</td>
</tr>
<tr>
<td><code>-XX:+UseAdaptiveSizePolicy</code></td>
<td>启用自适应 GC 策略（根据运行状况自动调整各区域大小）</td>
<td>默认开启</td>
</tr>
<tr>
<td><code>-XX:SurvivorRatio</code></td>
<td>Eden 与 Survivor 的内存比例（如 8 表示 Eden:S0:S1 = 8:1:1）</td>
<td>8</td>
</tr>
<tr>
<td><code>-XX:InitialTenuringThreshold</code></td>
<td>对象晋升到老年代的初始年龄（会随运行动态调整）</td>
<td>7</td>
</tr>
<tr>
<td><code>-XX:MaxTenuringThreshold</code></td>
<td>晋升到老年代的最大年龄（对象在 Survivor 区经历几次 GC）</td>
<td>15</td>
</tr>
<tr>
<td><code>-XX:PretenureSizeThreshold</code></td>
<td>设置大对象阈值，超过该大小的对象直接分配到老年代</td>
<td>0（即禁用）</td>
</tr>
<tr>
<td><code>-XX:+ScavengeBeforeFullGC</code></td>
<td>在 Full GC 之前是否先执行一次 Minor GC</td>
<td>true启</td>
</tr>
<tr>
<td><code>-XX:+UseFastAccessorMethods</code></td>
<td>优化原始类型的 get/set 方法性能</td>
<td>false启</td>
</tr>
<tr>
<td><code>-XX:+AlwaysPreTouch</code></td>
<td>JVM 启动时立即分配并初始化所有内存页，避免运行时首次分配带来的停顿</td>
<td>false</td>
</tr>
</tbody>
</table>
<h3 id="分区模型">分区模型</h3>
<h4 id="G1-垃圾回收器">G1 垃圾回收器</h4>
<p><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/AaqBxm.png" alt="" width="900" height="300"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>G1(Garbage-First) 属于 物理上分区，逻辑上分代，真正的分区模型是 <code>ZGC</code>（jdk21后也支持分代）</p>
</li>
<li class="lvl-2">
<p>G1将Java堆划分为多个大小相等的Region，Region大小是2的幂，范围在1MB到32MB之间。JDK9之前默认最多支持2048个Region，这就导致G1最大支持64G 的堆 (<code>2048 Regions × 32MB = 64GB</code>)，JDK10之后的版本可支持更多Region数量，JDK17进一步优化了Region映射机制，提升了大堆场景下的性能，使其可以支持更大的内存，但对于超大堆（&gt;1T），考虑到GC暂停时间，建议使用ZGC或Shenandoah GC。</p>
</li>
<li class="lvl-2">
<p>Region一旦被回收，重新分配时可以是任意类型，比如原先是<code>Eden</code>，那么重新分配时可以是<code>Old</code>，反之亦然。</p>
</li>
<li class="lvl-2">
<p>一般Region大小由JVM自动计算，当然也可以用参数<code>-XX:G1HeapRegionSize</code>手动指定Region大小，但是推荐默认的计算方式。</p>
</li>
<li class="lvl-2">
<p>G1保留了年轻代和老年代的概念，但不再是物理隔阂了，它们都是（可以不连续）Region的集合。</p>
</li>
<li class="lvl-2">
<p>在 G1 GC 中，不要使用 <code>-Xmn</code>，G1 中推荐使用以下更细粒度的控制方式：</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是实验性参数，需要开启 `-XX:+UnlockExperimentalVMOptions`，但依旧推荐在生产环境中使用</span></span><br><span class="line">-XX:G1NewSizePercent=5</span><br><span class="line">-XX:G1MaxNewSizePercent=60</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>默认年轻代对堆内存的占比是<code>5%</code>，如果堆大小为4096M，那么年轻代占据200MB左右的内存，对应大概是100个Region，可以通过   <code>-XX:G1NewSizePercent</code>设置新生代初始占比，这是实验性参数，需要开启 <code>-XX:+UnlockExperimentalVMOptions</code>，但依旧推荐在生产环境中使用。</p>
</li>
<li class="lvl-2">
<p>在系统运行中，JVM会不停的给年轻代增加更多的Region，但是最多新生代的占比不会超过<code>60%</code>，可以通过<code>-XX:G1MaxNewSizePercent</code>调整，这是实验性参数，需要开启 <code>-XX:+UnlockExperimentalVMOptions</code>，但依旧推荐在生产环境中使用。</p>
</li>
<li class="lvl-2">
<p>年轻代中的Eden和Survivor对应的region也跟之前一样，默认<code>8:1:1</code>，假设年轻代现在有1000个region，eden区对应800个，s0对应100个，s1对应100个。</p>
</li>
<li class="lvl-2">
<p>一个Region可能之前是年轻代，如果Region进行了垃圾回收，之后可能又会变成老年代，也就是说Region的区域功能可能会动态变化。</p>
</li>
<li class="lvl-2">
<p>G1垃圾收集器对于对象什么时候会转移到老年代跟之前讲过的原则一样，唯一不同的是对大对象的处理，G1有专门分配大对象的Region叫<code>Humongous</code>区，而不是让大对象直接进入老年代的Region中。</p>
</li>
<li class="lvl-2">
<p>在G1中，大对象的判定规则就是一个大对象超过了一个Region大小的<code>50%</code>，比如按照上面算的，每个Region是2M，只要一个大对象超过了1M，就会被放入Humongous中，而且一个大对象如果太大，可能会横跨多个Region来存放。</p>
</li>
<li class="lvl-2">
<p>Humongous区专门存放短期巨型对象，不用直接进老年代，可以节约老年代的空间，避免因为老年代空间不够的GC开销。</p>
</li>
<li class="lvl-2">
<p>Full GC的时候除了收集年轻代和老年代之外，也会将Humongous区一并回收。</p>
</li>
</ul>
<h5 id="G1垃圾收集分类">G1垃圾收集分类</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>YoungGC<br>
YoungGC并不是说现有的Eden区放满了就会马上触发，G1会计算下现在Eden区回收大概要多久时间，如果回收时间远远小于参数 <code>-XX:MaxGCPauseMills</code> 设定的值，那么增加年轻代的region，继续给新对象存放，不会马上做YoungGC，直到下一次Eden区放满，G1计算回收时间接近参数 <code>-XX:MaxGCPauseMills</code> 设定的值，那么就会触发Young GC</p>
</li>
<li class="lvl-2">
<p>MixedGC<br>
不是FullGC，老年代的堆占有率达到参数 <code>-XX:InitiatingHeapOccupancyPercent</code> 设定的值则触发，回收所有的Young和部分Old(根据期望的GC停顿时间确定old区垃圾收集的优先顺序)以及大对象区，正常情况G1的垃圾收集是先做MixedGC，主要使用复制算法，需要把各个region中存活的对象拷贝到别的region里去，拷贝过程中如果发现没有足够的空region能够承载拷贝对象就会触发一次Full GC</p>
</li>
<li class="lvl-2">
<p>Full GC<br>
停止系统程序，然后采用单线程进行标记、清理和压缩整理，好空闲出来一批Region来供下一次MixedGC使用，这个过程是非常耗时的。(Shenandoah优化成多线程收集了)</p>
</li>
</ul>
<h4 id="G1-收集器的工作方式-MixedGC">G1 收集器的工作方式(MixedGC)</h4>
<p><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/XbkEoh.png" alt="" width="1200" height="400"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>图中主要展示了一个典型的 G1 GC 的 并发标记周期（Concurrent Mark Cycle） 的过程。</p>
</li>
<li class="lvl-2">
<p>图中的水平箭头表示各线程（用户线程和GC线程）的执行路径。</p>
</li>
<li class="lvl-2">
<p>竖直的<code>Safepoint</code>线表示一次GC过程中会暂停所有用户线程的时刻（Stop-The-World）。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1️⃣ 初始标记（Initial Mark）</span><br><span class="line">    进入 Safepoint： 所有用户线程在此刻暂停（STW）。</span><br><span class="line">    标记 GC Roots 直接可达对象。</span><br><span class="line">    非常短暂，但属于 Stop-The-World 阶段。</span><br><span class="line">    图中是“初始标记”箭头在 Safepoint 之后立刻执行。</span><br><span class="line"></span><br><span class="line">2️⃣ 并发标记（Concurrent Mark）</span><br><span class="line">    用户线程 恢复运行（图中用户线程继续向右延伸）。</span><br><span class="line">    GC 线程 并发进行标记工作（即在用户线程运行期间进行标记）。</span><br><span class="line">    图中蓝色的“并发标记”箭头与用户线程箭头并行显示，表示并发执行。</span><br><span class="line"></span><br><span class="line">3️⃣ 最终标记（Remark / Final Mark）</span><br><span class="line">    再次进入 Safepoint。</span><br><span class="line">    重新暂停所有用户线程。</span><br><span class="line">    处理并发标记阶段中遗漏的引用更新等信息，保证标记的准确性。</span><br><span class="line"></span><br><span class="line">4️⃣ 筛选回收（Cleanup / Filtered Collection）</span><br><span class="line">    对已标记的对象做清理（回收不可达对象）。</span><br><span class="line">    判断是否需要回收某些 Region。</span><br><span class="line">    图中蓝色箭头标注为“筛选回收”。</span><br><span class="line"></span><br><span class="line">5️⃣ 恢复用户线程</span><br><span class="line">    在最后一个 Safepoint 之后，所有用户线程重新开始执行（图中黄色箭头重新向右延伸）。</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>G1的GC 过程会经历多次<code>Safepoint</code>，但只有 <code>并发标记阶段</code> 是整个周期中最耗时但不会暂停用户线程(STW)的部分。</p>
</li>
</ul>
<div class="tips">
<p><em><strong>Safepoint（安全点）</strong></em></p>
<ul class="lvl-1">
<li class="lvl-2">在 JVM（Java 虚拟机）中，Safepoint（安全点） 是一个非常重要的概念，它代表 所有线程必须“安全地”暂停的某个时间点，以便 JVM 能够执行某些全局操作，比如：<br>
垃圾回收（GC）<br>
栈遍历（例如生成堆快照、做逃逸分析等）<br>
类卸载<br>
JIT 编译的一些重写操作等</li>
<li class="lvl-2">如果线程正在运行、改变堆中对象的数据，那么 GC 就无法准确标记和回收对象。因此 JVM 需要 让所有线程在一个“可控、安全的位置”上暂停，这个位置就叫 Safepoint。</li>
<li class="lvl-2">Safepoint 是怎么工作的？<br>
1.JVM 发出“进入 Safepoint”的信号（比如要开始 GC）<br>
2.所有线程收到信号后，必须等到“最近的 Safepoint”再停下来：<br>
Safepoint 不是任意位置都可以停，它只出现在字节码中一些特定的指令点（比如方法调用、循环跳转等）<br>
3.等所有线程都进入 Safepoint 后，JVM 才能开始执行 GC 等全局操作。</li>
</ul>
</div>
<h5 id="G1-收集器参数配置表">G1 收集器参数配置表</h5>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-XX:+UseG1GC</code></td>
<td>使用 G1 垃圾收集器</td>
<td>-</td>
</tr>
<tr>
<td><code>-XX:ParallelGCThreads</code></td>
<td>指定 GC 工作的线程数量</td>
<td>与 CPU 数量相关</td>
</tr>
<tr>
<td><code>-XX:G1HeapRegionSize</code></td>
<td>设置堆分区大小（1MB~32MB，2 的幂），堆默认划分为 2048 个 Region</td>
<td>自动计算</td>
</tr>
<tr>
<td><code>-XX:MaxGCPauseMillis</code></td>
<td>设置 GC 目标最大暂停时间</td>
<td>200ms</td>
</tr>
<tr>
<td><code>-XX:G1NewSizePercent</code></td>
<td>新生代初始占比（占整个堆），实验性参数，-XX:+UnlockExperimentalVMOptions</td>
<td>5%</td>
</tr>
<tr>
<td><code>-XX:G1MaxNewSizePercent</code></td>
<td>新生代最大占比（占整个堆），实验性参数，-XX:+UnlockExperimentalVMOptions</td>
<td>60%</td>
</tr>
<tr>
<td><code>-XX:TargetSurvivorRatio</code></td>
<td>Survivor 区填充目标（超过该比例，晋升老年代）</td>
<td>50%</td>
</tr>
<tr>
<td><code>-XX:MaxTenuringThreshold</code></td>
<td>最大对象年龄阈值（年龄超过将进入老年代）</td>
<td>15</td>
</tr>
<tr>
<td><code>-XX:InitiatingHeapOccupancyPercent</code></td>
<td>老年代的使用率超过该值触发 Mixed GC</td>
<td>45%</td>
</tr>
<tr>
<td><code>-XX:G1MixedGCLiveThresholdPercent</code></td>
<td>Mixed GC 中：Region 存活对象占比低于该值才会被回收，实验性参数，-XX:+UnlockExperimentalVMOptions</td>
<td>85%</td>
</tr>
<tr>
<td><code>-XX:G1HeapWastePercent</code></td>
<td>Mixed GC 回收目标：空闲 Region 达堆总量该百分比就结束混合回收</td>
<td>5%</td>
</tr>
<tr>
<td><code>-XX:G1ReservePercent</code></td>
<td>为满足停顿时间目标保留的堆空间比例，是一种空间换时间的策略，在内存不足时可能造成内存更加紧张</td>
<td>10%</td>
</tr>
<tr>
<td><code>-XX:G1UseAdaptiveIHOP</code></td>
<td>是否启用自适应IHOP，启用后G1会在初始采样后自动调整IHOP值</td>
<td>true</td>
</tr>
<tr>
<td><code>-XX:G1AdaptiveIHOPNumInitialSamples</code></td>
<td>指定前几次GC活动按IHOP参数计算</td>
<td>3</td>
</tr>
<tr>
<td><code>-XX:SoftRefLRUPolicyMSPerMB</code></td>
<td>每MB堆内存中软引用的过期时间(ms)</td>
<td>1000</td>
</tr>
<tr>
<td><code>-XX:G1OldCSetRegionThresholdPercent</code></td>
<td>设置一次混合GC中需要清理的Old区的内存比例，调大可降低G1频率但会增加每次GC时间</td>
<td>10%</td>
</tr>
<tr>
<td><code>-XX:G1MixedGCCountTarget</code></td>
<td>设置G1垃圾回收器的线程上限，HotSpot会根据清理目标自动计算所需线程数，但不会超过此上限</td>
<td>8</td>
</tr>
</tbody>
</table>
<h4 id="ZGC-垃圾回收器">ZGC 垃圾回收器</h4>
<p><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/bBUAYt.png" alt="" width="700" height="500"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>ZGC(Z Garbage Collector)是一款JDK 11中新加入的具有实验性质的低延迟垃圾收集器，ZGC可以说源自于是Azul System公司开发的C4（Concurrent Continuously Compacting Collector） 收集器</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Platform</th>
<th>Supported</th>
<th>Since</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>Linux/x64</td>
<td>✅</td>
<td>JDK 11</td>
<td></td>
</tr>
<tr>
<td>Linux/AArch64</td>
<td>✅</td>
<td>JDK 13</td>
<td></td>
</tr>
<tr>
<td>macOS</td>
<td>✅</td>
<td>JDK 14</td>
<td></td>
</tr>
<tr>
<td>Windows</td>
<td>✅</td>
<td>JDK 14</td>
<td>Requires Windows version 1803 (Windows 10 or Windows Server 2019) or later.</td>
</tr>
</tbody>
</table>
<ul class="lvl-0">
<li class="lvl-2">
<p>ZGC收集器是一款基于Region内存布局的，暂时不设分代的(jdk21后支持分代)，使用了<code>读屏障</code>、<code>颜色指针</code>等技术来实现可并发的标记-整理算法的，以低延迟为首要目标的一款垃圾收集器。</p>
</li>
</ul>
<div class="tips">
<p><em><strong>颜色指针</strong></em></p>
<ul class="lvl-1">
<li class="lvl-2">在 ZGC（Z Garbage Collector）中，颜色指针（Colored Pointer）是一种核心机制，把对象的 GC 状态信息直接嵌入到对象的引用（地址）中，用于在不增加对象额外元数据的前提下，跟踪对象在垃圾回收过程中的状态。</li>
<li class="lvl-2">在传统 GC 中，对象的“颜色”（如白色、灰色、黑色）表示其在 GC 不同阶段的状态，这些信息一般存储在额外的数据结构中（如记忆集合、位图等）。</li>
<li class="lvl-2">而在 ZGC 中，ZGC 将对象的这些状态信息编码进指针的高位中。所以一个对象引用（pointer）不仅仅是内存地址，还携带了对象在 GC 过程中的“颜色”信息。</li>
<li class="lvl-2">ZGC 主要运行在 64 位系统上，但当前的操作系统和 CPU 实际上只使用 48～57 位虚拟地址。ZGC 利用未使用的高位进行编码。<br>
<img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/LD51Zb.png" alt="" width="900" height="300"></li>
<li class="lvl-2">每个对象有一个64位指针，这64位被分为：</li>
</ul>
<table>
<thead>
<tr>
<th>位数</th>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>18 位</td>
<td>预留</td>
<td>保留位，未来可能用于扩展功能</td>
</tr>
<tr>
<td>1 位</td>
<td>Finalizable</td>
<td>表示对象可终结（即实现了 <code>finalize()</code> 方法）</td>
</tr>
<tr>
<td>1 位</td>
<td>Remapped</td>
<td>标识对象是否已被转移(用于标识某个引用是否已经被重定向（更新为新地址）)；为 1 表示该对象未在重定位集（Relocation Set）中，即新地址，为0表示旧地址</td>
</tr>
<tr>
<td>1 位</td>
<td>Marked1</td>
<td>标记位之一，用于 GC 过程中的对象标记阶段 ,由于 ZGC 是并发 GC，需要两位来支持颜色切换机制（Color Flip），确保在不同 GC 周期中可以区分新旧标记，需要触发一次读取屏障（load barrier），找到对象的新位置，并更新这个引用。</td>
</tr>
<tr>
<td>1 位</td>
<td>Marked0</td>
<td>另一个标记位，与 Marked1 配合用于 GC 标记阶段</td>
</tr>
<tr>
<td>42 位</td>
<td>对象地址部分</td>
<td>实际的内存地址部分，最多可表示 2^42 字节（即 4 TB）,jdk15后占用 44位，支持 16TB</td>
</tr>
</tbody>
</table>
<p><em><strong>读屏障</strong></em></p>
<ul class="lvl-1">
<li class="lvl-2">
<p>ZGC（Z Garbage Collector）中的**读屏障（Read Barrier）是其核心机制之一，它保证了并发压缩（对象移动）**时程序的正确性，是实现低延迟、高并发垃圾回收的关键。</p>
</li>
<li class="lvl-2">
<p>在传统 GC 中，如果对象在 GC 过程中被移动，程序访问到的对象地址可能就无效了。因此，需要**“停世界”**将所有引用更新。</p>
</li>
<li class="lvl-2">
<p>而 ZGC 的设计目标是 &lt;10ms 的 GC 停顿时间，所以它采用 <code>并发标记 + 并发移动 + 并发引用更新</code> 的模式。在这种模式下，对象可以在程序运行时被移动，但程序访问时必须“知道”这个对象是否已经被移动，并获取其最新地址，这就是读屏障的职责。</p>
</li>
<li class="lvl-2">
<p>读屏障是一种在读取对象引用时自动插入的逻辑，用于检查引用是否有效，并在必要时进行修正（即地址重定向）。</p>
</li>
<li class="lvl-2">
<p>ZGC 是目前唯一在所有对象访问中都使用读屏障的 GC，它在每次对象指针解引用时都进行如下操作：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>职责</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>检测引用是否是老地址</strong></td>
<td>利用指针中的元信息（颜色指针，如 Remapped 位）判断引用是否已经被更新</td>
</tr>
<tr>
<td><strong>如果未更新则重定向引用</strong></td>
<td>如果引用的是旧地址，屏障会通过 forwarding table 找到新地址并更新</td>
</tr>
<tr>
<td><strong>保证最终访问对象的地址正确</strong></td>
<td>即使在对象移动过程中，程序也总能访问到有效地址，无需停顿所有线程</td>
</tr>
</tbody>
</table>
<pre>
<code class="mermaid">
graph TD
A[程序访问对象引用&lt;br&#x2F;&gt;例如：Person p &#x3D; personField] --&gt; B[JVM 插入读屏障逻辑]
B --&gt; C[读屏障检查颜色指针中的 Remapped 位]
C --&gt; D{Remapped 位为 0 吗？}
D -- 是 --&gt; E[检查对象是否已被移动]
E --&gt; F[更新引用地址为新地址]
F --&gt; G[设置 Remapped 位为 1]
G --&gt; H[使用更新后的引用访问对象]
D -- 否 --&gt; I[直接使用当前引用访问对象]
</code>
</pre>
</div>
<ul class="lvl-0">
<li class="lvl-2">
<p>ZGC的Region可以具有大、中、小三类容量：</p>
<ul class="lvl-2">
<li class="lvl-6">小型Region（Small Region） ： 容量固定为2MB，用于放置小于256KB的小对象。</li>
<li class="lvl-6">中型Region（Medium Region） ： 容量固定为32MB，用于放置大于等于256KB但小于4MB的对象。</li>
<li class="lvl-6">大型Region（Large Region） ： 容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置4MB或以上的大对象。</li>
</ul>
<blockquote>
<p>每个大型Region中只会存放一个大对象，这也预示着虽然名字叫作“大型Region”，但它的实际容量完全有可能小于中型Region，最小容量可低至4MB。</p>
</blockquote>
</li>
<li class="lvl-2">
<p>ZGC 特点：</p>
<ul class="lvl-2">
<li class="lvl-6">支持极大堆（JDK 15 起支持最高 16TB）</li>
<li class="lvl-6">GC 停顿时间通常低于 1ms（与堆大小基本无关）</li>
<li class="lvl-6">适合低延迟、高吞吐、高可用的应用场景，如交易系统、广告推荐等</li>
</ul>
</li>
</ul>
<h5 id="ZGC-收集器的工作方式">ZGC 收集器的工作方式</h5>
<p><img src="https://upic-oss.oss-cn-beijing.aliyuncs.com/uPic/94yKcU.png" alt=""></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1️⃣ 并发标记（Concurrent Mark）：</span><br><span class="line">   与G1一样，并发标记是遍历对象图做可达性分析的阶段，</span><br><span class="line">   它的初始标记(Mark Start)和最终标记(Mark End)也会出现短暂的停顿，</span><br><span class="line">   与G1不同的是，ZGC的标记是在指针上而不是在对象上进行的，</span><br><span class="line">   标记阶段会更新染色指针中的 Marked 0、 Marked 1 标志位。</span><br><span class="line"></span><br><span class="line">2️⃣ 并发预备重分配（Concurrent Prepare <span class="keyword">for</span> Relocate）：</span><br><span class="line">   这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成重分配集（Relocation Set）。</span><br><span class="line">   ZGC每次回收都会扫描所有的Region，用范围更大的扫描成本换取省去G1中记忆集的维护成本。</span><br><span class="line"></span><br><span class="line">3️⃣ 并发重分配（Concurrent Relocate）：</span><br><span class="line">   重分配是ZGC执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的Region上，</span><br><span class="line">   并为重分配集中的每个Region维护一个转发表（Forward Table），记录从旧对象到新对象的转向关系。</span><br><span class="line">   ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，</span><br><span class="line">   这次访问将会被预置的内存屏障(读屏障)所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，</span><br><span class="line">   并同时修正更新该引用的值，使其直接指向新对象，ZGC将这种行为称为指针的“自愈”（Self-Healing）能力。</span><br><span class="line"></span><br><span class="line">4️⃣ 并发重映射（Concurrent Remap）：</span><br><span class="line">   重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用，但是ZGC中对象引用存在“自愈”功能，所以这个重映射操作并不是很迫切。</span><br><span class="line">   ZGC很巧妙地把并发重映射阶段（Concurrent Remap）要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段（Concurrent Mark）里去完成，</span><br><span class="line">   反正它们都是要遍历所有对象的，这样合并就节省了一次遍历对象图的开销。</span><br><span class="line">   一旦所有指针都被修正之后， 原来记录新旧对象关系的转发表就可以释放掉了。</span><br></pre></td></tr></table></figure>
<h5 id="ZGC存在的问题">ZGC存在的问题</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>ZGC最大的问题是<code>浮动垃圾</code>。ZGC的停顿时间是在10ms以下，但是ZGC的执行时间还是远远大于这个时间的。假如ZGC全过程需要执行10分钟，在这个期间由于对象分配速率很高，将创建大量的新对象，这些对象很难进入当次GC，所以只能在下次GC的时候进行回收，这些只能等到下次GC才能回收的对象就是浮动垃圾。</p>
</li>
<li class="lvl-2">
<p>ZGC没有分代概念，每次都需要进行全堆扫描，导致一些“朝生夕死”的对象没能及时的被回收。</p>
</li>
<li class="lvl-2">
<p>目前唯一的办法是增大堆的容量，使得程序得到更多的喘息时间，但是这个也是一个治标不治本的方案。如果需要从根本上解决这个问题，还是需要引入分代收集，让新生对象都在一个专门的区域中创建，然后专门针对这个区域进行更频繁、更快的收集。</p>
</li>
<li class="lvl-2">
<p>JDK21正式引入了分代（jdk17是预览版），可以在生产环境中使用，需要手动开启：<code>-XX:+ZGenerational</code></p>
</li>
</ul>
<h5 id="ZGC-收集器参数配置表">ZGC 收集器参数配置表</h5>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
<th>默认值（如未特殊标注）</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-XX:+UseZGC</code></td>
<td>启用 ZGC 垃圾收集器</td>
<td>-</td>
</tr>
<tr>
<td><code>-XX:+UnlockExperimentalVMOptions</code></td>
<td>解锁实验性参数（JDK 11~14 使用 ZGC 必须）</td>
<td>-</td>
</tr>
<tr>
<td><code>-XX:+UseLargePages</code></td>
<td>启用大页内存（性能优化）</td>
<td>false</td>
</tr>
<tr>
<td><code>-XX:+UseTransparentHugePages</code></td>
<td>启用透明大页（部分 Linux 上可结合使用）</td>
<td>false</td>
</tr>
<tr>
<td><code>-Xmx</code> / <code>-Xms</code></td>
<td>设置最大/初始堆大小</td>
<td>用户配置</td>
</tr>
<tr>
<td><code>-XX:ZUncommitDelay=&lt;秒&gt;</code></td>
<td>未使用内存释放回操作系统的延迟时间（ZGC 会自动释放内存）</td>
<td>300（5分钟）</td>
</tr>
<tr>
<td><code>-XX:SoftMaxHeapSize=&lt;大小&gt;</code></td>
<td>软最大堆（Soft Heap Limit）：ZGC 尝试将使用的堆控制在该值以内</td>
<td>默认等于 -Xmx</td>
</tr>
<tr>
<td><code>-XX:MaxHeapFreeRatio</code></td>
<td>最大堆空闲比例（超过此比例可能触发内存释放）</td>
<td>70</td>
</tr>
<tr>
<td><code>-XX:MinHeapFreeRatio</code></td>
<td>最小堆空闲比例（低于此比例可能触发扩容）</td>
<td>40</td>
</tr>
<tr>
<td><code>-XX:+ZGenerational</code></td>
<td>启用 ZGC 分代收集（从 JDK 21 起支持，默认关闭）</td>
<td>false（JDK 21+）</td>
</tr>
<tr>
<td><code>-XX:+PrintGC</code> / <code>-Xlog:gc*</code></td>
<td>开启 GC 日志输出</td>
<td>-</td>
</tr>
<tr>
<td><code>-XX:+ZProactive</code></td>
<td>主动回收策略（在系统空闲时尝试回收）</td>
<td>true</td>
</tr>
<tr>
<td><code>-XX:ZCollectionInterval=&lt;秒&gt;</code></td>
<td>主动回收之间的最小时间间隔（配合 ZProactive）</td>
<td>默认值因版本而异</td>
</tr>
</tbody>
</table>
<h3 id="ZGC-vs-G1-GC-vs-Parallel-GC-对比表">ZGC vs G1 GC vs Parallel GC 对比表</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th><strong>ZGC</strong></th>
<th><strong>G1 GC</strong></th>
<th><strong>Parallel GC</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>设计目标</strong></td>
<td><strong>极低延迟</strong>，&lt;1ms 停顿</td>
<td>平衡 <strong>低延迟</strong> 与 <strong>高吞吐</strong></td>
<td><strong>高吞吐</strong>，最大化 CPU 使用</td>
</tr>
<tr>
<td><strong>GC 停顿时间</strong></td>
<td>&lt;1ms，堆大小增加不影响停顿时间</td>
<td>几十到几百毫秒，堆越大停顿越明显</td>
<td>停顿时间可能达到秒级，<strong>堆越大越明显</strong></td>
</tr>
<tr>
<td><strong>堆大小支持</strong></td>
<td>支持高达 <strong>16TB</strong>（JDK 15+）</td>
<td>支持 <strong>最多 4TB</strong></td>
<td>支持大堆，但停顿明显</td>
</tr>
<tr>
<td><strong>是否分代</strong></td>
<td>默认不分代（JDK 21+ 可开启 <code>-XX:+ZGenerational</code>）</td>
<td>分代（新生代 + 老年代）</td>
<td>分代（新生代 + 老年代）</td>
</tr>
<tr>
<td><strong>并发回收</strong></td>
<td>是，<strong>包括标记、压缩、引用处理都并发</strong></td>
<td>部分并发，仍包含明显 Stop-The-World 阶段</td>
<td>否，<strong>全部 Stop-The-World</strong></td>
</tr>
<tr>
<td><strong>移动对象时是否停顿</strong></td>
<td>否，使用读屏障并发转移对象</td>
<td>是（通过复制区域）</td>
<td>是</td>
</tr>
<tr>
<td><strong>实现机制</strong></td>
<td>标记-重定位，基于读屏障</td>
<td>Region 分区 + 标记-复制 + Mixed GC</td>
<td>标记-复制（新生代）、标记-整理（老年代）</td>
</tr>
<tr>
<td><strong>吞吐能力</strong></td>
<td>中高</td>
<td>高</td>
<td><strong>最高</strong></td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>低延迟系统，如金融、交易、推荐等实时应用</td>
<td>通用后台系统、Web 服务等</td>
<td>批处理、数据计算、日志分析等不敏感于停顿的系统</td>
</tr>
<tr>
<td><strong>默认启用</strong></td>
<td>否，需指定 <code>-XX:+UseZGC</code></td>
<td>JDK 9+ 默认 GC</td>
<td>JDK 8 及以前默认 GC</td>
</tr>
<tr>
<td><strong>调优复杂度</strong></td>
<td>低，大多数参数可省略</td>
<td>中，需要设置目标停顿时间等</td>
<td>高，需要精细配置 Eden/Survivor 等比例</td>
</tr>
<tr>
<td><strong>GC 日志配置方式</strong></td>
<td>统一日志格式：<code>-Xlog:gc*</code>（JDK 9+）</td>
<td>支持传统的 <code>-XX:+PrintGCDetails</code> 和 <code>-Xlog:gc*</code> 日志输出</td>
<td>主要使用旧参数：<code>-XX:+PrintGCDetails</code> 等</td>
</tr>
</tbody>
</table>
<div class="tips">
<p><em><strong>ZGC 吞吐能力较弱的原因</strong></em></p>
<table>
<thead>
<tr>
<th>原因</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1. 并发阶段代价较高</strong></td>
<td>ZGC 几乎所有的 GC 工作（包括标记、整理、引用处理、转移对象）都在与应用线程并发执行。虽然减少了停顿，但这些 GC 线程与业务线程共享 CPU 资源，<strong>增加了 CPU 上下文切换和缓存竞争</strong>，从而影响业务线程的执行效率。</td>
</tr>
<tr>
<td><strong>2. 读屏障开销</strong></td>
<td>ZGC 依赖<strong>着色指针和读屏障（load barrier）机制</strong>来跟踪对象引用状态，支持并发转移。虽然非常高效，但仍比传统 GC 的普通读写路径慢一些，在高频访问对象场景下会带来一定 CPU 开销。</td>
</tr>
<tr>
<td><strong>3. 对硬件依赖高，调度保守</strong></td>
<td>为了实现“&lt;1ms 停顿”的目标，ZGC 会选择更保守的调度策略（如避免并发线程使用过多 CPU），而不会像 Parallel GC 那样“榨干”所有核心资源。</td>
</tr>
<tr>
<td><strong>4. 内存开销更高</strong></td>
<td>为了支持并发压缩和转移，ZGC 通常需要为每个对象保留元数据和更多的转移空间（即“浮动垃圾”区域），这可能导致<strong>频繁的 GC 周期</strong>，影响吞吐。</td>
</tr>
<tr>
<td><strong>5. 设计目标非吞吐优先</strong></td>
<td>ZGC 的首要目标是<strong>低延迟而非最大吞吐</strong>。与 Parallel GC（以吞吐为核心）设计目标不同，ZGC 更适合场景为“对延迟敏感但吞吐可接受”的系统。</td>
</tr>
</tbody>
</table>
<p>最糟糕的情况下吞吐量会降低15%。这都不是事，停顿时间足够优秀。至于吞吐量，通过扩容分分钟解决。<br>
另外，Oracle官方提到了它最大的优点是：它的停顿时间不会随着堆的增大而增长！<br>
也就是说，几十G堆的停顿时间是10ms以下，几百G甚至上T堆的停顿时间也是10ms以下。</p>
<p>ZGC 吞吐弱，不是因为技术落后，而是因为它主动选择在低延迟和高吞吐之间偏向了低延迟。<br>
在对响应时间要求极高的系统中，它是非常合适的选择。<br>
但如果你的目标是压榨机器性能跑批处理、日志分析这类吞吐导向型任务，Parallel GC 或 G1 会更合适。</p>
</div>
<h2 id="内存溢出-OutOfMemoryError，简称-OOM">内存溢出(OutOfMemoryError，简称 OOM)</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>JVM 常见内存溢出类型汇总表</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>溢出类型</th>
<th>异常信息</th>
<th>触发原因/描述</th>
<th>相关参数和建议配置</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>堆内存溢出</strong></td>
<td><code>java.lang.OutOfMemoryError: Java heap space</code></td>
<td>- 创建大量对象，堆空间不足<br>- 内存泄漏：对象不再使用却有强引用<br>- 老年代对象太多无法晋升</td>
<td><code>-Xms</code> / <code>-Xmx</code> 设置堆大小</td>
</tr>
<tr>
<td><strong>栈溢出（递归）</strong></td>
<td><code>java.lang.StackOverflowError</code></td>
<td>- 方法无限递归或递归层级太深</td>
<td><code>-Xss</code> 设置线程栈大小</td>
</tr>
<tr>
<td><strong>无法创建新线程</strong></td>
<td><code>java.lang.OutOfMemoryError: unable to create new native thread</code></td>
<td>- 创建线程过多（如线程池配置过大）<br>- 系统或 JVM native 线程资源耗尽</td>
<td>控制线程池大小，避免无限新建线程</td>
</tr>
<tr>
<td><strong>元空间溢出</strong></td>
<td><code>java.lang.OutOfMemoryError: Metaspace</code></td>
<td>- 动态加载类过多（如使用 CGLIB、JSP 动态生成类）<br>- 类无法卸载（如 ClassLoader 泄漏）</td>
<td><code>-XX:MetaspaceSize</code> / <code>-XX:MaxMetaspaceSize</code></td>
</tr>
<tr>
<td><strong>直接内存溢出</strong></td>
<td><code>java.lang.OutOfMemoryError: Direct buffer memory</code></td>
<td>- 使用 <code>ByteBuffer.allocateDirect()</code> 分配大量直接内存<br>- Netty 等框架默认使用直接内存</td>
<td><code>-XX:MaxDirectMemorySize</code></td>
</tr>
<tr>
<td><strong>GC 开销过高</strong></td>
<td><code>java.lang.OutOfMemoryError: GC overhead limit exceeded</code></td>
<td>- JVM 花费 &gt;98% 的时间 GC 但回收 &lt;2% 的内存，认为进入“GC 死循环”</td>
<td>分析 GC 日志、优化堆设置</td>
</tr>
<tr>
<td><strong>类卸载失败（内存泄漏）</strong></td>
<td>（不一定报错，但可能导致 Metaspace OOM）</td>
<td>- Web 容器频繁部署热更新 WAR 包时，ClassLoader 无法卸载，导致类永久驻留</td>
<td>优化 ClassLoader 管理，使用内存分析工具</td>
</tr>
</tbody>
</table>
<ul class="lvl-0">
<li class="lvl-2">
<p>堆快照(堆转储)文件分析</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-XX:+HeapDumpOnOutOfMemoryError</code></td>
<td>OOM 时生成堆转储文件 ,建议生产环境开启</td>
</tr>
<tr>
<td><code>-XX:HeapDumpPath=xxx.hprof</code></td>
<td>指定堆转储文件保存路径 <br> 默认保存在当前目录</td>
</tr>
</tbody>
</table>
<ul class="lvl-0">
<li class="lvl-2">
<p>常用分析工具与命令</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>工具/命令</th>
<th>简介与功能</th>
<th>使用说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>MAT（Memory Analyzer Tool）</strong></td>
<td>Eclipse 出品的强大图形工具，支持泄漏分析、对象引用链分析、内存占用统计等</td>
<td>下载地址：<br><a target="_blank" rel="noopener" href="https://www.eclipse.org/mat/">https://www.eclipse.org/mat/</a><br>打开后直接导入 <code>.hprof</code> 文件即可分析</td>
</tr>
<tr>
<td><strong>VisualVM</strong></td>
<td>官方可视化 JVM 监控工具，支持实时分析、GC 查看、线程状态与堆转储查看</td>
<td>附带于 JDK（或单独安装），打开 <code>.hprof</code> 文件进行可视化分析</td>
</tr>
<tr>
<td><strong>JProfiler</strong></td>
<td>商业级 Java 性能分析工具，提供堆分析、CPU 分析、线程分析等全套功能</td>
<td>支持打开 <code>.hprof</code> 文件，也可在运行时配合使用（需付费或试用）</td>
</tr>
<tr>
<td><strong>YourKit</strong></td>
<td>商业性能分析工具，界面友好，支持丰富的分析功能</td>
<td>支持堆分析，适合内存泄漏排查</td>
</tr>
<tr>
<td><strong>jhat</strong>（过时）</td>
<td>JDK 附带的旧工具，用于分析 <code>.hprof</code> 文件，开启 Web 界面查看（已废弃）</td>
<td>命令：<code>jhat heapdump.hprof</code>，浏览器访问 <code>http://localhost:7000</code>（JDK 8 及以下）</td>
</tr>
<tr>
<td><strong>jmap</strong></td>
<td>用于生成堆转储文件或查看堆对象统计信息（<strong>不是分析工具本身</strong>）</td>
<td>命令：<code>jmap -dump:format=b,file=heap.hprof &lt;pid&gt;</code> 生成转储；配合 MAT 使用</td>
</tr>
<tr>
<td><strong>jcmd</strong></td>
<td>更现代的诊断命令工具，可生成 heap dump、执行 GC、打印 VM 状态等</td>
<td>命令：<code>jcmd &lt;pid&gt; GC.heap_dump heap.hprof</code></td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="http://GCEasy.io">GCEasy.io</a></strong></td>
<td>在线分析工具，支持 <code>.hprof</code> 文件和 GC 日志上传分析</td>
<td>网站：<a target="_blank" rel="noopener" href="https://gceasy.io">https://gceasy.io</a></td>
</tr>
</tbody>
</table>
<ul class="lvl-0">
<li class="lvl-2">
<p>GC日志相关参数(JDK1.8及以下)</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-XX:+PrintGC</code></td>
<td>打印基本 GC 信息（建议配合 <code>-XX:+PrintGCDetails</code> 使用）,与<code>-verbose:gc</code>等价</td>
</tr>
<tr>
<td><code>-XX:+PrintGCDetails</code></td>
<td>打印详细的 GC 日志信息（如各区域使用情况、对象分配、晋升等）</td>
</tr>
<tr>
<td><code>-XX:+PrintGCDateStamps</code></td>
<td>在 GC 日志中添加日期时间戳</td>
</tr>
<tr>
<td><code>-XX:+PrintGCTimeStamps</code></td>
<td>在 GC 日志中添加 JVM 启动以来的时间戳</td>
</tr>
<tr>
<td><code>-Xloggc:/var/log/myapp/gc.log</code></td>
<td>将 GC 日志输出到指定文件</td>
</tr>
<tr>
<td><code>-XX:+UseGCLogFileRotation</code></td>
<td>启用 GC 日志文件轮转（适用于大规模系统的 GC 日志管理）</td>
</tr>
<tr>
<td><code>-XX:NumberOfGCLogFiles=5</code></td>
<td>最多保留 5 个 GC 日志历史文件</td>
</tr>
<tr>
<td><code>-XX:GCLogFileSize=10M</code></td>
<td>每个 GC 日志文件最大为 10MB</td>
</tr>
<tr>
<td><code>-XX:+PrintGCCause</code></td>
<td>打印 GC 的触发原因（如 Minor GC、System.gc() 等）</td>
</tr>
</tbody>
</table>
<ul class="lvl-0">
<li class="lvl-2">
<p>GC日志相关参数(JDK9+)</p>
<ul class="lvl-2">
<li class="lvl-6"><code>-Xlog</code> 是用于配置 JVM 日志记录的参数，它是从 JDK 9 开始引入的统一日志框架（Unified Logging）的一部分。</li>
<li class="lvl-6">通过 -Xlog 选项，你可以控制日志的 标签（tags）、输出级别（level）、输出位置（output） 等内容。</li>
<li class="lvl-6">基本格式</li>
</ul>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xlog[:[tag1[,tag2...]][[:level][:[output][:[decorators][:rotation]]]]]</span><br></pre></td></tr></table></figure>
<ul class="lvl-2">
<li class="lvl-6">常见 Tags（标签）</li>
</ul>
<table>
<thead>
<tr>
<th>类别</th>
<th>标签</th>
<th>含义</th>
<th>用途示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类加载</strong></td>
<td><code>classload</code></td>
<td>JVM 类加载活动的总体信息</td>
<td>观察类加载失败或重复加载</td>
</tr>
<tr>
<td></td>
<td><code>class+load</code></td>
<td>显示每个类加载过程细节</td>
<td>定位类加载异常、热加载分析</td>
</tr>
<tr>
<td></td>
<td><code>class+unload</code></td>
<td>记录类卸载事件</td>
<td>分析类卸载时机或内存释放情况</td>
</tr>
<tr>
<td><strong>垃圾回收</strong></td>
<td><code>gc</code></td>
<td>总体 GC 活动信息</td>
<td>GC 调优入门使用</td>
</tr>
<tr>
<td></td>
<td><code>gc+start</code></td>
<td>GC 事件开始时间与类型</td>
<td>查看 GC 频率与触发点</td>
</tr>
<tr>
<td></td>
<td><code>gc+heap</code></td>
<td>GC 前后的堆使用情况</td>
<td>分析堆使用与分区占比</td>
</tr>
<tr>
<td></td>
<td><code>gc+phases</code></td>
<td>GC 内部阶段细节</td>
<td>G1/ZGC 等调试用</td>
</tr>
<tr>
<td></td>
<td><code>gc+age</code></td>
<td>年龄分布情况</td>
<td>判断对象晋升路径、老年代压力</td>
</tr>
<tr>
<td></td>
<td><code>gc+ergo</code></td>
<td>GC 的自适应调整决策</td>
<td>查看线程、堆大小自动调整逻辑</td>
</tr>
<tr>
<td><strong>JIT 编译</strong></td>
<td><code>jit</code></td>
<td>JIT 编译日志入口</td>
<td>性能热点方法分析</td>
</tr>
<tr>
<td></td>
<td><code>compiler</code></td>
<td>显示方法编译、时间等</td>
<td>判断是否有方法未被优化</td>
</tr>
<tr>
<td></td>
<td><code>codecache</code></td>
<td>已编译代码存储区使用情况</td>
<td>判断是否达到缓存上限</td>
</tr>
<tr>
<td></td>
<td><code>nmethod</code></td>
<td>JIT 生成的 native 方法生命周期</td>
<td>观察 native 代码生成与卸载</td>
</tr>
<tr>
<td><strong>内存</strong></td>
<td><code>memory</code></td>
<td>总体内存使用情况</td>
<td>诊断内存泄漏或溢出</td>
</tr>
<tr>
<td></td>
<td><code>gc+heap</code></td>
<td>堆结构与占用情况</td>
<td>与 GC 联合分析使用</td>
</tr>
<tr>
<td></td>
<td><code>os+memory</code></td>
<td>JVM 与操作系统间的内存交互</td>
<td>判断是否系统层内存申请失败</td>
</tr>
<tr>
<td><strong>线程</strong></td>
<td><code>thread</code></td>
<td>线程的创建、终止、状态变化</td>
<td>线程泄漏或频繁创建排查</td>
</tr>
<tr>
<td></td>
<td><code>safepoint</code></td>
<td>JVM 进入/退出 safepoint 的信息</td>
<td>分析 STW 停顿时间与频率</td>
</tr>
<tr>
<td><strong>锁与同步</strong></td>
<td><code>synchronization</code></td>
<td>锁竞争、获取和释放信息</td>
<td>分析性能瓶颈中的锁争用</td>
</tr>
<tr>
<td></td>
<td><code>monitorinflation</code></td>
<td>轻量级锁升级为重量级锁过程</td>
<td>排查锁膨胀导致的延迟问题</td>
</tr>
<tr>
<td><strong>操作系统交互</strong></td>
<td><code>os</code></td>
<td>JVM 与操作系统交互日志</td>
<td>常规系统资源请求信息</td>
</tr>
<tr>
<td></td>
<td><code>os+thread</code></td>
<td>OS 层级线程管理信息</td>
<td>高并发时线程绑定与调度分析</td>
</tr>
<tr>
<td></td>
<td><code>os+cpu</code></td>
<td>CPU 使用与分布情况</td>
<td>排查高 CPU 使用的问题</td>
</tr>
<tr>
<td><strong>类元数据</strong></td>
<td><code>metaspace</code></td>
<td>元空间内存使用与变化</td>
<td>排查 Metaspace OOM</td>
</tr>
<tr>
<td></td>
<td><code>cds</code></td>
<td>类共享数据（CDS）日志</td>
<td>分析类加载加速是否生效</td>
</tr>
<tr>
<td><strong>安全</strong></td>
<td><code>security</code></td>
<td>安全相关操作日志</td>
<td>权限检查失败、密钥加载等调试</td>
</tr>
<tr>
<td></td>
<td><code>module</code></td>
<td>模块系统（JPMS）相关日志</td>
<td>模块访问控制失败分析</td>
</tr>
<tr>
<td><strong>其他</strong></td>
<td><code>start</code></td>
<td>JVM 启动流程日志</td>
<td>启动阶段慢、出错时使用</td>
</tr>
<tr>
<td></td>
<td><code>init</code></td>
<td>各子系统初始化过程</td>
<td>定位子系统启动顺序与异常</td>
</tr>
<tr>
<td></td>
<td><code>jni</code></td>
<td>Java 调用 native 方法日志</td>
<td>JNI 崩溃、性能问题分析</td>
</tr>
<tr>
<td></td>
<td><code>classpath</code></td>
<td>类路径加载详情</td>
<td>类找不到、路径冲突等问题排查</td>
</tr>
<tr>
<td></td>
<td><code>exceptions</code></td>
<td>异常信息及堆栈打印</td>
<td>捕获未处理异常、频繁抛错分析</td>
</tr>
</tbody>
</table>
<ul class="lvl-2">
<li class="lvl-6">
<p>Level（级别）</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>等级</th>
<th>含义说明</th>
<th>用途示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>off</code></td>
<td>关闭日志记录</td>
<td>完全禁用指定标签的日志输出</td>
</tr>
<tr>
<td><code>error</code></td>
<td>严重错误，仅记录影响系统运行的错误信息</td>
<td>捕获崩溃、严重故障</td>
</tr>
<tr>
<td><code>warning</code></td>
<td>潜在问题，可能影响稳定性</td>
<td>记录可能的内存、配置问题</td>
</tr>
<tr>
<td><code>info</code></td>
<td>常规信息（默认级别）</td>
<td>日常运行日志，如 GC 次数</td>
</tr>
<tr>
<td><code>debug</code></td>
<td>更详细的调试信息，适用于问题诊断</td>
<td>跟踪行为变化或代码路径</td>
</tr>
<tr>
<td><code>trace</code></td>
<td>最详细的信息，记录几乎所有细节</td>
<td>深度调试，如方法级别跟踪</td>
</tr>
<tr>
<td><code>all</code></td>
<td>打印所有级别的日志（包括 trace 及以上）</td>
<td>全量日志输出，用于完全监控</td>
</tr>
</tbody>
</table>
<ul class="lvl-2">
<li class="lvl-6">
<p>Output（输出位置）</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>输出位置</th>
<th>含义说明</th>
<th>示例用法</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>stdout</code></td>
<td>标准输出（默认）</td>
<td><code>-Xlog:gc=info:stdout</code></td>
</tr>
<tr>
<td><code>stderr</code></td>
<td>标准错误输出</td>
<td><code>-Xlog:gc=info:stderr</code></td>
</tr>
<tr>
<td><code>file=路径</code></td>
<td>输出到指定文件路径（自动创建文件）</td>
<td><code>-Xlog:gc:file=gc.log</code></td>
</tr>
<tr>
<td>多个输出用逗号分隔</td>
<td>可同时输出到多个位置</td>
<td><code>-Xlog:gc:file=gc.log,stdout</code></td>
</tr>
</tbody>
</table>
<ul class="lvl-2">
<li class="lvl-6">
<p>Decorators（装饰器）</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>装饰器</th>
<th>含义说明</th>
<th>示例输出片段（含该装饰器时）</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>time</code></td>
<td>显示当前系统时间（wall-clock time）</td>
<td><code>2025-05-16T10:45:12.123+0800</code></td>
</tr>
<tr>
<td><code>uptime</code></td>
<td>显示 JVM 启动以来的运行时间（毫秒）</td>
<td><code>5.123s</code>（表示已运行 5.123 秒）</td>
</tr>
<tr>
<td><code>level</code></td>
<td>显示日志级别（如 info, warning 等）</td>
<td><code>[info]</code>, <code>[debug]</code></td>
</tr>
<tr>
<td><code>tags</code></td>
<td>显示日志标签</td>
<td><code>[gc]</code>, <code>[class,load]</code></td>
</tr>
<tr>
<td><code>tid</code></td>
<td>显示线程 ID</td>
<td><code>tid=0x00007fddc4012800</code></td>
</tr>
<tr>
<td><code>hostname</code></td>
<td>显示主机名</td>
<td><code>host=example.local</code></td>
</tr>
<tr>
<td><code>pid</code></td>
<td>显示当前 JVM 进程 ID</td>
<td><code>pid=12345</code></td>
</tr>
</tbody>
</table>
<ul class="lvl-2">
<li class="lvl-6">
<p>Rotation (日志轮转设置)</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>设置参数</th>
<th>含义说明</th>
<th>示例值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>filecount=n</code></td>
<td>保留的日志文件数量（最大文件轮转数）</td>
<td><code>filecount=5</code></td>
</tr>
<tr>
<td><code>filesize=n</code></td>
<td>单个日志文件的最大大小（支持单位：k/m/g）</td>
<td><code>filesize=10m</code></td>
</tr>
</tbody>
</table>
<ul class="lvl-2">
<li class="lvl-6">
<p>示例：</p>
</li>
</ul>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xlog:gc*:file=/var/log/app/gc.log:time,<span class="built_in">uptime</span>,level,tags:filecount=5,filesize=20M</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>项</th>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>tag</code></td>
<td><code>gc*</code></td>
<td>匹配所有以 <code>gc</code> 开头的标签（如 <code>gc+heap</code> 等）</td>
</tr>
<tr>
<td><code>level</code></td>
<td><em>省略</em></td>
<td>默认是 <code>info</code></td>
</tr>
<tr>
<td><code>output</code></td>
<td><code>file=/var/log/app/gc.log</code></td>
<td>日志写入该文件</td>
</tr>
<tr>
<td><code>decorators</code></td>
<td><code>time,uptime,level,tags</code></td>
<td>日志前缀包含时间、启动时间、日志级别、标签</td>
</tr>
<tr>
<td><code>rotation</code></td>
<td><code>filecount=5,filesize=20M</code></td>
<td>最多保留 5 个日志文件，单个文件最大 20MB</td>
</tr>
</tbody>
</table>
<ul class="lvl-2">
<li class="lvl-6">
<p>日志文件中可以使用变量</p>
</li>
</ul>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xlog:gc*:file=gc_%p_%t.log</span><br></pre></td></tr></table></figure>
<p><strong>常用变量表</strong></p>
<table>
<thead>
<tr>
<th>变量</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>%p</td>
<td>进程ID（Process ID）</td>
</tr>
<tr>
<td>%t</td>
<td>时间戳（代表日志文件创建时的时间戳）</td>
</tr>
<tr>
<td>%h</td>
<td>主机名（Hostname）</td>
</tr>
<tr>
<td>%n</td>
<td>序列号，从0开始，每创建新文件加1</td>
</tr>
<tr>
<td>%u</td>
<td>唯一标识符，用于解决文件名冲突</td>
</tr>
<tr>
<td>%i</td>
<td>当多个JVM进程使用相同的文件名模式时的区分计数器</td>
</tr>
</tbody>
</table>
<p><strong>时间相关变量表</strong></p>
<table>
<thead>
<tr>
<th>变量</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>%Y</td>
<td>年（Year）</td>
</tr>
<tr>
<td>%m</td>
<td>月（Month）</td>
</tr>
<tr>
<td>%d</td>
<td>日（Day）</td>
</tr>
<tr>
<td>%H</td>
<td>小时（Hour）</td>
</tr>
<tr>
<td>%M</td>
<td>分钟（Minute）</td>
</tr>
<tr>
<td>%S</td>
<td>秒（Second）</td>
</tr>
</tbody>
</table>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础配置</span></span><br><span class="line">-Xlog:gc*:file=gc_%p_%Y%m%d_%H%M%S.<span class="built_in">log</span>:time,<span class="built_in">uptime</span>,level,tags:filecount=5,filesize=20M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 详细GC日志配置</span></span><br><span class="line">-Xlog:gc*=debug:file=gc_%p_%t.log:time,<span class="built_in">uptime</span>,level,tags:filecount=10,filesize=50M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多目标输出</span></span><br><span class="line">-Xlog:gc*=info:file=gc.log::filecount=5,filesize=20M -Xlog:gc*=debug:file=gc_detailed.log</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>对于GC日志的分析<br>
人工分析还是太复杂了，可以使用<a target="_blank" rel="noopener" href="https://gceasy.io">GCEasy.io</a>，每个月免费5次。</p>
</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
<div style="text-align:center;color: #ccc;font-size:14px;">---------------- The End ----------------</div>

<div>
    <!-- 分享 css & js 此处会被Meting.js干扰，暂时关闭-->
    <link rel="stylesheet" href="/social-share/share.min.css">
    <script src="/social-share/share.min.js"></script>
    <div class="social-share" style="float:right">分享到：</div>
</div>

          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/uploads/wechatpay.jpg" alt="飘逸峰 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/uploads/alipay.jpg" alt="飘逸峰 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>飘逸峰
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://blog.hanqunfeng.com/2025/05/12/jvm-gc-01/" title="JVM 之 内存模型与垃圾回收机制(GC)">https://blog.hanqunfeng.com/2025/05/12/jvm-gc-01/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="followme">
  <span>欢迎关注我的其它发布渠道</span>

  <div class="social-list">

      <div class="social-item">
          <a target="_blank" class="social-link" href="http://www.jianshu.com/users/763c53661578/latest_articles">
            <span class="icon">
              <i class="fa-solid fa-book-open"></i>
            </span>

            <span class="label">简书</span>
          </a>
      </div>

      <div class="social-item">
          <a target="_blank" class="social-link" href="http://blog.csdn.net/hanqunfeng">
            <span class="icon">
              <i class="fa-solid fa-c"></i>
            </span>

            <span class="label">CSDN</span>
          </a>
      </div>

      <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa-solid fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/jvm/" rel="tag"><i class="fa fa-tag"></i> jvm</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/05/08/jvm-classloader-01/" rel="prev" title="JVM 之 类加载器">
                  <i class="fa fa-angle-left"></i> JVM 之 类加载器
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/05/13/jvm-tools-01/" rel="next" title="JVM 之 命令行工具">
                  JVM 之 命令行工具 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">京ICP备2021006748号-1 </a>
  </div>
  <div class="copyright">
    &copy; 2016 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa-solid fa-user"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">飘逸峰</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">566k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">34:19</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa-solid fa-circle-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa-solid fa-chart-area"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
<span id="show_hidden">🇨🇳</span>

<style>

  .toBottomClass {
    color:#333333;
    font-size:38px;
    background: #ffffff;
    width: 3rem;
    height: 3rem;
    position: fixed;
    border-radius: 50%;
    border: none;
    right: 32px;
    bottom: 116px;
    left: unset;
    cursor: pointer;
    transition: all 0.5s ease;
    display: flex;
    justify-content: center;
    align-items: center;
}

 .hover {
            color: #FF9966;
            cursor:pointer;
        }
</style>


<script type="text/javascript">
          jQuery(function ($) {

            // 控制黑暗和白天按钮旋转180度
            var current = 0;
						$('#taiji').click(function(){
                current = (current+180)%360;
                this.style.transform = 'rotate('+current+'deg)';
            });

            $('.darkmode-toggle').before('<div class="toBottom toBottomClass" title="直达底部"><i class="fa fa-arrow-circle-down" aria-hidden="true"/><div>');
          });
</script>

<script type="text/javascript">

    let a = true;

    let gao=0;

    let no_clear = true;
    var timer;

    jQuery(function ($) {

        $(".toBottom").bind("mouseover", function () {
            $(this).addClass("hover");
        });


        $(".toBottom").bind("mouseout", function () {
            $(this).removeClass("hover");
        });

        $(".toBottom").on("click",function () {
            //只有在非最底部时才能触发事件，避免最底部连续点击造成无法向上滚动
            if(a){
                if(gao == 0){
                    //设置定时器
                    timer=setInterval("scrollwindow()",10);
                }else{
                    no_clear = false;
                    $("html,body").animate({ scrollTop: gao }, 1000);//gao为滚动条的位置，1000为滚动的时延
                }

            }

        });
    });

    //滚动函数

    function scrollwindow(){
        gao=gao+100;
        window.scroll(0,gao);
    }

    //清除定时器
    function clear(){
        if(no_clear){
            clearInterval(timer);
        }
    }

    //滚动到底部触发函数
    window.onscroll = function(){
        //变量scrollTop是滚动条滚动时，距离顶部的距离
        var scrollTop = document.documentElement.scrollTop||document.body.scrollTop;
        //变量windowHeight是可视区的高度
        var windowHeight = document.documentElement.clientHeight || document.body.clientHeight;
        //变量scrollHeight是滚动条的总高度
        var scrollHeight = document.documentElement.scrollHeight||document.body.scrollHeight;
               //滚动条到底部的条件
            if(scrollTop+windowHeight==scrollHeight){
                
                
                clear();
                a = false;
             }else{
                a = true;
             }
        }


</script>


    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/hanqunfeng" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"dark","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.4.0/mermaid.min.js","integrity":"sha256-G8ouPAnw4zzMbnAenHnVz6h9XpKbNdOkrqTh7AadyHs="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>


  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"OGMvTuds9s7tzvWNopJHAJ5W-gzGzoHsz","app_key":"A0HB73VDqWDODaRS4yyiW6V8","server_url":null,"security":false}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>


  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" integrity="sha256-UF1fgpAiu3tPJN/uCqEUHNe7pnr+QR0SQDNfgglgtcM=" crossorigin="anonymous">
  <script class="next-config" data-name="katex" type="application/json">{"copy_tex_js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/contrib/copy-tex.min.js","integrity":"sha256-Us54+rSGDSTvIhKKUs4kygE2ipA0RXpWWh0/zLqw3bs="}}</script>
  <script src="/js/third-party/math/katex.js"></script>


<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: '32px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '<img id="taiji" src="/images_glob/yin-yang_262f.png" title="外观切换"/>',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"hanqunfeng/blog_comments","issue_term":"title","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>

<style>
#divcss5{
    margin:0 auto;
    border:0px solid #000;
    width: 100%;
    text-align:center;
    }
</style>

<div id="divcss5">



</div>
<!-- hexo injector body_end start --><script src="/assets/mmedia/mmedia-loader.js"></script><!-- hexo injector body_end end --></body>
</html>
