<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Spring Boot学习笔记06--JPA]]></title>
      <url>%2F2016%2F12%2F21%2Fspring-boot-study-jpa%2F</url>
      <content type="text"><![CDATA[摘要看完本文你将掌握如下知识点： Spring Boot项目中JPA的配置及使用方法 SpringBoot系列：Spring Boot学习笔记 前言JPA即Java Persistence API，是一个基于O/R映射的标准规范，该规范只负责定义规则的标准（注解或接口），而不需要提供具体实现，具体的实现交由软件提供商来实现，目前主要的JPA提供商为Hibernate，EclipseLink和OperJPA。 Spring Data JPA是Spring Data的一个子项目，通过提供基于JPA的Repository来简化代码量。其提供了一个org.springframework.data.jpa.repository.JpaRepository，我们的Repository只要继承该JpaRepository，即可享受到JPA带来的好处。 Spring Boot通过spring-boot-starter-data-jpa来提供对JPA的支持，Spring Boot默认的JPA实现者是Hibernate。 说明在讲解下面的内容前，我们先在数据库中创建一张表 1234567891011121314# 创建库1CREATE SCHEMA `springboot1` DEFAULT CHARACTER SET utf8 ;CREATE TABLE `springboot1`.`person` ( `p_id` INT NOT NULL AUTO_INCREMENT COMMENT '主键', `p_name` VARCHAR(45) NULL COMMENT '姓名', `p_age` INT NULL COMMENT '年龄', PRIMARY KEY (`p_id`))ENGINE = InnoDBCOMMENT = '人员信息表';INSERT INTO `springboot1`.`person` (`p_id`, `p_name`, `p_age`) VALUES ('1', '张三', '20');INSERT INTO `springboot1`.`person` (`p_id`, `p_name`, `p_age`) VALUES ('2', '李四', '25');INSERT INTO `springboot1`.`person` (`p_id`, `p_name`, `p_age`) VALUES ('3', '王五', '18');INSERT INTO `springboot1`.`person` (`p_id`, `p_name`, `p_age`) VALUES ('4', '王五', '18'); Spring Boot项目中使用JPA创建项目时选择JPA依赖，或者手工将spring-boot-starter-data-jpa添加到pom中 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; application.properties中增加jpa相关配置 12345678910111213#datasourcespring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/springboot1?useUnicode=true&amp;characterEncoding=utf-8spring.datasource.username=rootspring.datasource.password=newpwd#spring_jpa#启动时会根据实体类生成数据表，或者更新表结构，不清空数据，开发阶段使用；validate：表结构稳定后使用，可用于正式环境；spring.jpa.hibernate.ddl-auto=update#控制台打印sqlspring.jpa.show-sql=true#让控制器输出的json格式更美观spring.jackson.serialization.indent-output=true 在项目中使用JPA时，只需要创建一个继承于JpaRepository的Repository接口，即可拥有JpaRepository及其父类中提供的全部数据访问方法。如果提供的方法不满足业务需要，可以按如下规则扩展数据方法。 JpaRepository 12345678910111213141516171819202122232425262728293031323334package org.springframework.data.jpa.repository;import java.io.Serializable;import java.util.List;import org.springframework.data.domain.Example;import org.springframework.data.domain.Sort;import org.springframework.data.repository.NoRepositoryBean;import org.springframework.data.repository.PagingAndSortingRepository;import org.springframework.data.repository.query.QueryByExampleExecutor;@NoRepositoryBeanpublic interface JpaRepository&lt;T, ID extends Serializable&gt; extends PagingAndSortingRepository&lt;T, ID&gt;, QueryByExampleExecutor&lt;T&gt; &#123; List&lt;T&gt; findAll(); List&lt;T&gt; findAll(Sort var1); List&lt;T&gt; findAll(Iterable&lt;ID&gt; var1); &lt;S extends T&gt; List&lt;S&gt; save(Iterable&lt;S&gt; var1); void flush(); &lt;S extends T&gt; S saveAndFlush(S var1); void deleteInBatch(Iterable&lt;T&gt; var1); void deleteAllInBatch(); T getOne(ID var1); &lt;S extends T&gt; List&lt;S&gt; findAll(Example&lt;S&gt; var1); &lt;S extends T&gt; List&lt;S&gt; findAll(Example&lt;S&gt; var1, Sort var2);&#125; 自定义Repository：PersonRepository，并扩展数据访问方法，具体扩展方法参看示例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package com.example.dao;import com.example.model.Person;import org.springframework.data.domain.Page;import org.springframework.data.domain.Pageable;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.Modifying;import org.springframework.data.jpa.repository.Query;import org.springframework.data.repository.query.Param;import java.util.List;public interface PersonRepository extends JpaRepository&lt;Person, Integer&gt; &#123; //1.以下方法基于属性名称和查询关键字，所以方法名称必须遵循命名规则，并且参数类型要与实体的参数类型一致。 // 只用于查询方法，以下给出常用的示例 //等于 List&lt;Person&gt; findByPName(String PName); //And --- 等价于 SQL 中的 and 关键字； List&lt;Person&gt; findByPNameAndPAge(String PName, Integer PAge); // Or --- 等价于 SQL 中的 or 关键字； List&lt;Person&gt; findByPNameOrPAge(String PName, Integer PAge); //Between --- 等价于 SQL 中的 between 关键字； List&lt;Person&gt; findByPAgeBetween(Integer min, Integer max); //LessThan --- 等价于 SQL 中的 "&lt;"； 日期类型也可以使用Before关键字 List&lt;Person&gt; findByPAgeLessThan(Integer max); //LessThanEqual --- 等价于 SQL 中的 "&lt;="； List&lt;Person&gt; findByPAgeLessThanEqual(Integer max); //GreaterThan --- 等价于 SQL 中的"&gt;"；日期类型也可以使用After关键字 List&lt;Person&gt; findByPAgeGreaterThan(Integer min); //GreaterThanEqual --- 等价于 SQL 中的"&gt;="； List&lt;Person&gt; findByPAgeGreaterThanEqual(Integer min); //IsNull --- 等价于 SQL 中的 "is null"； List&lt;Person&gt; findByPNameIsNull(); //IsNotNull --- 等价于 SQL 中的 "is not null"； List&lt;Person&gt; findByPNameIsNotNull(); //NotNull --- 与 IsNotNull 等价； List&lt;Person&gt; findByPNameNotNull(); //Like --- 等价于 SQL 中的 "like"; List&lt;Person&gt; findByPNameLike(String PName); //NotLike --- 等价于 SQL 中的 "not like"； List&lt;Person&gt; findByPNameNotLike(String PName); //OrderBy --- 等价于 SQL 中的 "order by"； List&lt;Person&gt; findByPNameNotNullOrderByPAgeAsc(); //Not --- 等价于 SQL 中的 "！ ="； List&lt;Person&gt; findByPNameNot(String PName); //In --- 等价于 SQL 中的 "in"; List&lt;Person&gt; findByPNameIn(String PName); //NotIn --- 等价于 SQL 中的 "not in"; List&lt;Person&gt; findByPNameNotIn(String PName); //Top --- 查询符合条件的前两条记录，等价与First关键字 List&lt;Person&gt; findTop2ByPName(String PName); //2.以下方法基于@Query注解，方法名称可以随意，可用于查询和更新方法，更新方法要设置@Modifying注解 //使用命名参数 @Query("select p from Person p where p.pName = :name and p.pAge = :age") List&lt;Person&gt; withNameAndAgeQuery(@Param("name") String name, @Param("age") Integer age); //使用参数索引 @Query("select p from Person p where p.pName = ?1 and p.pAge = ?2") List&lt;Person&gt; withNameAndAgeQuery2(String name, Integer age); //删除操作，使用hql，如果要使用sql，需要增加nativeQuery = true @Query(value = "delete from Person where pId=?1") @Modifying int deletePersonById(Integer id); //修改操作 @Query(value = "update Person set pName=?1 where pId=?2 ") @Modifying int updatePersonName(String name, Integer id); //插入操作，使用sql操作 @Query(value = "insert into person(p_name,p_age) value(?1,?2)",nativeQuery = true) @Modifying int insertPersonByParam(String name, Integer age); //3.以下方法实现分页查询功能，只需要在方法中增加Pageable pageable参数即可，返回结果为Page集合 Page&lt;Person&gt; findByPNameNot(String name, Pageable pageable); //使用命名参数 @Query("select p from Person p where p.pName = :name ") Page&lt;Person&gt; withNameQueryPage(@Param("name") String name, Pageable pageable);&#125; POJO实体对象：Person 123456789101112131415161718192021222324252627282930313233package com.example.model;import javax.persistence.*;import static javax.persistence.GenerationType.IDENTITY;@Entity@Table(name = "person" , catalog = "springboot1")public class Person implements java.io.Serializable &#123; @Id @GeneratedValue(strategy = IDENTITY) @Column(name = "p_id", unique = true, nullable = false) private Integer pId; @Column(name = "p_name", length = 45) private String pName; @Column(name = "p_age") private Integer pAge; //setter and getter @Override public String toString() &#123; return "Person&#123;" + "pId=" + pId + ", pName='" + pName + '\'' + ", pAge=" + pAge + '&#125;'; &#125;&#125; 测试演示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148package com.example;import com.example.dao.PersonRepository;import com.example.model.Person;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.data.domain.Sort;import org.springframework.test.context.junit4.SpringRunner;import org.springframework.transaction.annotation.Transactional;import java.util.Iterator;import java.util.List;@RunWith(SpringRunner.class)@SpringBootTest@Transactionalpublic class JpaSingleDatasourceApplicationTests &#123; @Autowired private PersonRepository personRepository; @Test public void findByPName() &#123; String name = "王五"; List&lt;Person&gt; list = personRepository.findByPName(name); System.out.println(list.size()); for(Person person : list)&#123; System.out.println(person); &#125; &#125; @Test public void findByPNameAndPAge() &#123; String name = "王五"; int age = 18; List&lt;Person&gt; list = personRepository.findByPNameAndPAge(name,age); System.out.println(list.size()); for(Person person : list)&#123; System.out.println(person); &#125; &#125; @Test public void findByPNameOrPAge() &#123; String name = "王五"; int age = 25; List&lt;Person&gt; list = personRepository.findByPNameOrPAge(name,age); System.out.println(list.size()); for(Person person : list)&#123; System.out.println(person); &#125; &#125; @Test public void findTop2ByPName() &#123; String name = "王五"; List&lt;Person&gt; list = personRepository.findTop2ByPName(name); System.out.println(list.size()); for(Person person : list)&#123; System.out.println(person); &#125; &#125; @Test public void withNameAndAgeQuery() &#123; String name = "王五"; int age = 18; List&lt;Person&gt; list = personRepository.withNameAndAgeQuery(name,age); System.out.println(list.size()); for(Person person : list)&#123; System.out.println(person); &#125; &#125; @Test public void withNameAndAgeQuery2() &#123; String name = "王五"; int age = 18; List&lt;Person&gt; list = personRepository.withNameAndAgeQuery2(name,age); System.out.println(list.size()); for(Person person : list)&#123; System.out.println(person); &#125; &#125; @Test public void deletePersonById()&#123; int id = 1; int result = personRepository.deletePersonById(id); System.out.println("result = " + result); &#125; @Test public void updatePersonName()&#123; int id = 1; String name = "哈哈"; int result = personRepository.updatePersonName(name,id); System.out.println("result = " + result); &#125; @Test public void insertPersonByParam()&#123; int age = 10; String name = "哈哈"; int result = personRepository.insertPersonByParam(name,age); System.out.println("result = " + result); &#125; @Test public void findByPNameNot()&#123; String name = "哈哈"; //排序 Sort sort = new Sort(Sort.Direction.DESC, "pId"); //查询第一页，按一页三行分页 Pageable pageable = new PageRequest(0, 3, sort); Page&lt;Person&gt; pages = personRepository.findByPNameNot(name,pageable); System.out.println("pages.getTotalElements()" + pages.getTotalElements()); System.out.println("pages.getTotalPages()" + pages.getTotalPages()); Iterator&lt;Person&gt; it=pages.iterator(); while(it.hasNext())&#123; System.out.println("value:"+((Person)it.next())); &#125; &#125; @Test public void withNameQueryPage()&#123; String name = "王五"; //排序 Sort sort = new Sort(Sort.Direction.DESC, "pId"); //查询第二页，按一页三行分页 Pageable pageable = new PageRequest(1, 3, sort); Page&lt;Person&gt; pages = personRepository.withNameQueryPage(name,pageable); System.out.println("pages.getTotalElements()" + pages.getTotalElements()); System.out.println("pages.getTotalPages()" + pages.getTotalPages()); Iterator&lt;Person&gt; it=pages.iterator(); while(it.hasNext())&#123; System.out.println("value:"+((Person)it.next())); &#125; &#125;&#125; 本文示例代码下载地址：https://github.com/hanqunfeng/SpringBootStudy]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring Boot学习笔记05--Mybatis+通用Mapper+分页插件]]></title>
      <url>%2F2016%2F12%2F20%2Fspring-boot-study-mybatis%2F</url>
      <content type="text"><![CDATA[摘要看完本文你将掌握如下知识点： Spring Boot项目中，Mybatis+通用Mapper+分页插件的配置方法 SpringBoot系列：Spring Boot学习笔记 前言前文已经对Spring Boot中各种类型的数据访问做了说明，本文是对Spring Boot中使用Mybatis的扩展，重点说明如何在mybatis中集成通用Mapper和分页插件。 本文代码是在上文中讲到的mybatis单数据源配置的基础上进行扩展。 配置说明pom中增加通用Mapper和分页插件的依赖： 123456789101112&lt;!--分页插件--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;4.2.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--通用Mapper--&gt;&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper&lt;/artifactId&gt; &lt;version&gt;3.3.9&lt;/version&gt;&lt;/dependency&gt; MyBatisConfig：在SqlSessionFactory中增加分页插件配置，因为通用Mapper是基于注解的，所以这里去掉xml的加载。 1234567891011121314151617181920212223242526272829@Bean(name = "sqlSessionFactory")public SqlSessionFactory sqlSessionFactoryBean() &#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dataSource()); bean.setTypeAliasesPackage("com.example.pojo"); //分页插件设置 PageHelper pageHelper = new PageHelper(); Properties properties = new Properties(); properties.setProperty("reasonable", "true"); properties.setProperty("supportMethodsArguments", "true"); properties.setProperty("returnPageInfo", "check"); properties.setProperty("params", "count=countSql"); pageHelper.setProperties(properties); //添加分页插件 bean.setPlugins(new Interceptor[]&#123;pageHelper&#125;); ResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(); try &#123; //基于注解扫描Mapper，不需配置xml路径 //bean.setMapperLocations(resolver.getResources("classpath:mapper/*.xml")); return bean.getObject(); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125;&#125; MyBatisMapperScannerConfig注意这里使用的是tk.mybatis.spring.mapper.MapperScannerConfigurer 1234567891011121314151617181920212223242526272829package com.example;import org.springframework.boot.autoconfigure.AutoConfigureAfter;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import tk.mybatis.spring.mapper.MapperScannerConfigurer;import java.util.Properties;@Configuration//必须在MyBatisConfig注册后再加载MapperScannerConfigurer，否则会报错@AutoConfigureAfter(MyBatisConfig.class)public class MyBatisMapperScannerConfig &#123; @Bean public MapperScannerConfigurer mapperScannerConfigurer() &#123; MapperScannerConfigurer mapperScannerConfigurer = new MapperScannerConfigurer(); mapperScannerConfigurer.setSqlSessionFactoryBeanName("sqlSessionFactory"); mapperScannerConfigurer.setBasePackage("com.example.mapper"); //初始化扫描器的相关配置，这里我们要创建一个Mapper的父类 Properties properties = new Properties(); properties.setProperty("mappers", "com.example.MyMapper"); properties.setProperty("notEmpty", "false"); properties.setProperty("IDENTITY", "MYSQL"); mapperScannerConfigurer.setProperties(properties); return mapperScannerConfigurer; &#125;&#125; MyMapper 123456789package com.example;import tk.mybatis.mapper.common.Mapper;import tk.mybatis.mapper.common.MySqlMapper;public interface MyMapper&lt;T&gt; extends Mapper&lt;T&gt;, MySqlMapper&lt;T&gt; &#123; //TODO //FIXME 特别注意，该接口不能被扫描到，否则会出错&#125; PersonMapper：实体mapper继承MyMapper即可，业务方法中我们就可以使用通用Mapper提供的各种方法 12345678910111213141516171819202122232425262728293031package com.example.mapper;import com.example.MyMapper;import com.example.pojo.Person;public interface PersonMapper extends MyMapper&lt;Person&gt; &#123; //以下方法用于演示，当通用Mapper不能买足需求时，可以自己扩展相应的方法 //不允许查询参数为空的情况 @Select(&#123; "select", "p_id, p_name, p_age", "from person", "where p_age between #&#123;startAge&#125; and #&#123;endAge&#125;" &#125;) @Results(&#123; @Result(column="p_id", property="pId", jdbcType= JdbcType.INTEGER, id=true), @Result(column="p_name", property="pName", jdbcType=JdbcType.VARCHAR), @Result(column="p_age", property="pAge", jdbcType=JdbcType.INTEGER) &#125;) List&lt;Person&gt; queryListByParam(Person person); //允许查询参数为空的情况 @SelectProvider(type = PersonSqlProvider.class,method = "selectSelective") @Results(&#123; @Result(column="p_id", property="pId", jdbcType= JdbcType.INTEGER, id=true), @Result(column="p_name", property="pName", jdbcType=JdbcType.VARCHAR), @Result(column="p_age", property="pAge", jdbcType=JdbcType.INTEGER) &#125;) List&lt;Person&gt; queryListByParamSelective(Person person);&#125; 123456789101112131415161718192021222324252627package com.example.mapper;import com.example.pojo.Person;import static org.apache.ibatis.jdbc.SqlBuilder.*;public class PersonSqlProvider &#123; public String selectSelective(Person record)&#123; BEGIN(); SELECT("p_id, p_name, p_age"); FROM("person"); WHERE("1=1"); if(record.getStartAge()!=null)&#123; AND(); WHERE("p_age &gt;= #&#123;startAge&#125;"); &#125; if(record.getEndAge()!=null)&#123; AND(); WHERE("p_age &lt;= #&#123;endAge&#125;"); &#125; return SQL(); &#125;&#125; 这里要注意，使用通用Mapper时，实体类必须有一个叫做id的整型主键，另外，为了方便使用分页插件，要在每个实体对象中定义两个属性–page和rows，我们可以把这些通用的属性放到父类中，比如我们创建一个父类：BaseEntity BaseEntity 123456789101112131415161718package com.example.pojo;import javax.persistence.Transient;public class BaseEntity &#123; @Id //注意，如果是老的项目，表中的主键可能不叫做id，这时可以在父类中去掉这个属性，改在子类中实现 @Column(name = "id") @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; @Transient private Integer page = 1; @Transient private Integer rows = 10;&#125; 1234567891011121314151617package com.example.pojo;import javax.persistence.*;@Table(name = "person")public class Person extends BaseEntity&#123; private String pName; private Integer pAge; //以下属性用于演示范围查询 @Transient private Integer startAge; @Transient private Integer endAge; //setter and getter&#125; 测试演示业务方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.example.service;import com.example.mapper.PersonMapper;import com.example.pojo.Person;import com.github.pagehelper.PageHelper;import org.apache.ibatis.session.RowBounds;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Propagation;import org.springframework.transaction.annotation.Transactional;import java.util.List;@Service@Transactional(propagation = Propagation.REQUIRED, readOnly = false, rollbackFor = &#123;Exception.class&#125;)public class PersonService &#123; @Autowired private PersonMapper personMapper; public int insert(Person person)&#123; return personMapper.insert(person); &#125; @Transactional(readOnly = true) public Person selectByPrimaryKey(Integer pId)&#123; return personMapper.selectByPrimaryKey(pId); &#125; @Transactional(readOnly = true) public List&lt;Person&gt; getAllPersonList()&#123; return personMapper.selectAll(); &#125; @Transactional(readOnly = true) public List&lt;Person&gt; getPagePersonList(Person person, RowBounds rowBounds)&#123; return personMapper.selectByRowBounds(person,rowBounds); &#125; public List&lt;Person&gt; getPagePersonList(Person person)&#123; if (person.getPage() != null &amp;&amp; person.getRows() != null) &#123; PageHelper.startPage(person.getPage(), person.getRows(), "p_id"); &#125; return personMapper.selectAll(); &#125; public List&lt;Person&gt; queryListByParam(Person person)&#123; if (person.getPage() != null &amp;&amp; person.getRows() != null) &#123; PageHelper.startPage(person.getPage(), person.getRows(), "p_id"); &#125; return personMapper.queryListByParam(person); &#125; public List&lt;Person&gt; queryListByParamSelective(Person person)&#123; if (person.getPage() != null &amp;&amp; person.getRows() != null) &#123; PageHelper.startPage(person.getPage(), person.getRows(), "p_id"); &#125; return personMapper.queryListByParamSelective(person); &#125;&#125; 单元测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package com.example;import com.example.pojo.Person;import com.example.service.PersonService;import org.apache.ibatis.session.RowBounds;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import org.springframework.transaction.annotation.Transactional;import java.util.List;@RunWith(SpringRunner.class)@SpringBootTest@Transactionalpublic class MybatisMapperPagehelperApplicationTests &#123; @Autowired PersonService personService; @Test public void selectByPrimaryKey()&#123; Person person = personService.selectByPrimaryKey(1); System.out.println(person); &#125; @Test public void insert()&#123; Person person = new Person(); person.setpName("王五"); person.setpAge(18); System.out.println(personService.insert(person)); &#125; @Test public void getAllPersonList()&#123; List&lt;Person&gt; list = personService.getAllPersonList(); System.out.println(list.size()); for(Person person : list)&#123; System.out.println(person); &#125; &#125; @Test public void getPagePersonList()&#123; Person person = new Person(); person.setpName("王五"); //指定limit和offset List&lt;Person&gt; list = personService.getPagePersonList(person,new RowBounds(2,3)); System.out.println(list.size()); for(Person p : list)&#123; System.out.println(p); &#125; &#125; @Test public void getPagePersonList2()&#123; Person person = new Person(); //每页2行，查询第二页 person.setPage(2); person.setRows(2); List&lt;Person&gt; list = personService.getPagePersonList(person); System.out.println(list.size()); for(Person p : list)&#123; System.out.println(p); &#125; &#125; @Test public void queryListByParam()&#123; Person person = new Person(); //每页2行，查询第二页 person.setPage(2); person.setRows(2); //查询年龄在15到22之间的数据 person.setStartAge(15); person.setEndAge(22); List&lt;Person&gt; list = personService.queryListByParam(person); System.out.println(list.size()); for(Person p : list)&#123; System.out.println(p); &#125; &#125; @Test public void queryListByParamSelective()&#123; Person person = new Person(); //每页2行，查询第一页 person.setPage(1); person.setRows(2); //查询年龄大于等于15的数据 person.setStartAge(15); //person.setEndAge(22); List&lt;Person&gt; list = personService.queryListByParamSelective(person); System.out.println(list.size()); for(Person p : list)&#123; System.out.println(p); &#125; &#125;&#125; 本文示例代码下载地址：https://github.com/hanqunfeng/SpringBootStudy 项目参考：https://github.com/abel533/MyBatis-Spring-Boot]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring Boot学习笔记04--数据访问]]></title>
      <url>%2F2016%2F12%2F17%2Fspring-boot-study-data%2F</url>
      <content type="text"><![CDATA[摘要看完本文你将掌握如下知识点： Spring Boot对JDBC的支持 Spring Boot项目多数据源的配置 Spring Boot的事务管理 Spring Boot项目多数据源的事务管理 Spring Boot项目中使用Hibernate4的方法 Spring Boot项目中使用Mybatis的方法 SpringBoot系列：Spring Boot学习笔记 前言Spring Boot针对企业开发场景提供了各种『开箱即用』的spring-boot-starter-xxx自动配置依赖模块，这就使得我们开发Spring应用更加快速和高效。比如我们前面创建web项目时使用到的spring-boot-starter-web。 这些spring-boot-starter-xxx不但包含了对该功能的全部依赖包，同时也提供了该功能的自动配置类。我们本节要讨论的『数据访问』就是基于这些spring-boot-starter-xxx的自动配置依赖模块。 环境准备jdk版本：java version “1.8.0_31”数据库：10.1.16-MariaDB脚本1234567891011121314151617181920212223242526# 创建库1CREATE SCHEMA `springboot1` DEFAULT CHARACTER SET utf8 ;CREATE TABLE `springboot1`.`person` ( `p_id` INT NOT NULL AUTO_INCREMENT COMMENT '主键', `p_name` VARCHAR(45) NULL COMMENT '姓名', `p_age` INT NULL COMMENT '年龄', PRIMARY KEY (`p_id`))ENGINE = InnoDBCOMMENT = '人员信息表';INSERT INTO `springboot1`.`person` (`p_id`, `p_name`, `p_age`) VALUES ('1', '张三', '20');INSERT INTO `springboot1`.`person` (`p_id`, `p_name`, `p_age`) VALUES ('2', '李四', '25');# 创建库2CREATE SCHEMA `springboot2` DEFAULT CHARACTER SET utf8 ;CREATE TABLE `springboot2`.`person` ( `p_id` INT NOT NULL AUTO_INCREMENT COMMENT '主键', `p_name` VARCHAR(45) NULL COMMENT '姓名', `p_age` INT NULL COMMENT '年龄', PRIMARY KEY (`p_id`))ENGINE = InnoDBCOMMENT = '人员信息表';INSERT INTO `springboot2`.`person` (`p_id`, `p_name`, `p_age`) VALUES ('1', '张三', '20');INSERT INTO `springboot2`.`person` (`p_id`, `p_name`, `p_age`) VALUES ('2', '李四', '25'); Spring Boot对JDBC的支持创建项目新建一个springboot项目，依赖选择web和jdbc 项目创建成功后查看pom，会看到添加了spring-boot-starter-jdbc的依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 配置项目在pom中增加MySQL依赖12345&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.37&lt;/version&gt;&lt;/dependency&gt; 在application.properties中添加数据源配置信息12345#datasourcespring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/springboot1?useUnicode=true&amp;characterEncoding=utf-8spring.datasource.username=rootspring.datasource.password=newpwd 项目代码本例只做简单演示，所以只创建如下3个类，并用一个单元测试类进行测试Model:Person1234567891011121314151617public class Person implements Serializable &#123; private static final long serialVersionUID = -1L; private Long id; private String name; private Integer age; //getter and setter @Override public String toString() &#123; return "Person&#123;" + "id=" + id + ", name='" + name + '\'' + ", age=" + age + '&#125;'; &#125;&#125; Dao:PersonDao1234567891011121314151617181920212223242526272829@Repositorypublic class PersonDao &#123; @Autowired private JdbcTemplate jdbcTemplate; public int savePerson(Person person)&#123; String sql = "INSERT INTO `springboot1`.`person` (`p_name`, `p_age`) VALUES (?, ?)"; int result = jdbcTemplate.update(sql,new Object[]&#123;person.getName(),person.getAge()&#125;); return result; &#125; public List&lt;Person&gt; getAllPersonList()&#123; String sql = "select * from person s"; List&lt;Person&gt; list = jdbcTemplate.query(sql,new PersonMapper()); return list; &#125; class PersonMapper implements RowMapper&lt;Person&gt;&#123; @Override public Person mapRow(ResultSet resultSet, int i) throws SQLException &#123; Person person = new Person(); person.setId(resultSet.getLong("p_id")); person.setName(resultSet.getString("p_name")); person.setAge(resultSet.getInt("p_age")); return person; &#125; &#125;&#125; Service:PersonService1234567891011121314@Servicepublic class PersonService &#123; @Autowired private PersonDao personDao; public int savePserson(Person person)&#123; return personDao.savePerson(person); &#125; public List&lt;Person&gt; getAllPersonList()&#123; return personDao.getAllPersonList(); &#125;&#125; 单元测试:SpringbootjdbcdemoApplicationTests12345678910111213141516171819202122232425@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringbootjdbcdemoApplicationTests &#123; @Autowired private PersonService personService; @Test public void savePerson()&#123; Person person = new Person(); person.setName("王五"); person.setAge(18); int result = personService.savePserson(person); Assert.assertEquals(1,result); &#125; @Test public void getAllPersonList()&#123; List&lt;Person&gt; list = personService.getAllPersonList(); System.out.println(list.size()); for(Person person : list)&#123; System.out.println(person); &#125; &#125;&#125; 说明实际上，项目加入spring-boot-starter-jdbc的依赖后，即可在项目代码中通过@Autowired自动注入JdbcTemplate。而数据源的配置则在application.properties中进行配置。 如果不想使用spring-boot-starter-jdbc带来的默认依赖和自动配置，那么采用如下的方式，效果是一样的。 使用自定义的DataSourceConfig修改pom中的依赖，去掉对spring-boot-starter-jdbc的依赖，并加入对spring-jdbc的依赖，这样我们就失去了对JDBC的自动配置功能了。123456789101112&lt;!--&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.3.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; 启动类中去掉对DataSourceAutoConfiguration的自动配置支持1234567@SpringBootApplication(exclude=&#123;DataSourceAutoConfiguration.class&#125;)public class SpringbootjdbcdemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootjdbcdemoApplication.class, args); &#125;&#125; 创建DataSourceConfig配置类12345678910111213141516171819202122232425262728@Configurationpublic class DataSourceConfig &#123; @Value("$&#123;spring.datasource.driver-class-name&#125;") String driverClass; @Value("$&#123;spring.datasource.url&#125;") String url; @Value("$&#123;spring.datasource.username&#125;") String userName; @Value("$&#123;spring.datasource.password&#125;") String passWord; @Bean(name = "dataSource") public DataSource dataSource() &#123; DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(driverClass); dataSource.setUrl(url); dataSource.setUsername(userName); dataSource.setPassword(passWord); return dataSource; &#125; @Bean(name = "jdbcTemplate") public JdbcTemplate jdbcTemplate()&#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource()); return jdbcTemplate; &#125;&#125; 其它代码不需要任何修改，运行效果一致。 说明为什么SpringBoot为我们提供了spring-boot-starter-jdbc的自动配置解决方案，我们还要自己配置呢，这是因为自动配置并不是那么的强大，spring-boot-starter-jdbc只能支持单一的数据源配置，如果项目中需要关联多个数据源，就需要我们自己处理了。 比如我们在环境准备中创建了两个数据库，接下来我们在项目中增加多数据源的配置。 在application.properties中添加数据源配置信息12345#datasource2spring.datasource.driver-class-name2=com.mysql.jdbc.Driverspring.datasource.url2=jdbc:mysql://localhost:3306/springboot2?useUnicode=true&amp;characterEncoding=utf-8spring.datasource.username2=rootspring.datasource.password2=newpwd 然后在DataSourceConfig配置类中增加如下内容：123456789101112131415161718192021222324@Value("$&#123;spring.datasource.driver-class-name2&#125;")String driverClass2;@Value("$&#123;spring.datasource.url2&#125;")String url2;@Value("$&#123;spring.datasource.username2&#125;")String userName2;@Value("$&#123;spring.datasource.password2&#125;")String passWord2;@Bean(name = "dataSource2")public DataSource dataSource2() &#123; DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(driverClass2); dataSource.setUrl(url2); dataSource.setUsername(userName2); dataSource.setPassword(passWord2); return dataSource;&#125;@Bean(name = "jdbcTemplate2")public JdbcTemplate jdbcTemplate2()&#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource2()); return jdbcTemplate;&#125; 此时需要在Dao中将@Autowired注解替换成@Resource(name = &quot;jdbcTemplate&quot;)，来明确指定要使用哪一个jdbcTemplate对象。 说明关于如何在项目中使用Hibernate4框架，可以参考:SpringMVC4零配置 Spring Boot的事务管理JDBC事务管理如果我们项目中使用的是JDBC的数据访问方案，并且容器中只注册了一个DataSource，那么SpringBoot就会为我们开启DataSourceTransactionManagerAutoConfiguration的自动配置类，其会在容器中注册一个DataSourceTransactionManager事务管理器，同时会开启对注解式事务@Transactional的支持。感兴趣的可以看一下DataSourceTransactionManagerAutoConfiguration的源码。 @Transactional是Spring框架提供的，配置方法参考下面的代码12345678910111213141516//一般我们会在业务实现类上声明事务注解//当前表示需要在事务中运行，可以执行更新和删除操作，遇到异常则回滚@Transactional(propagation = Propagation.REQUIRED, readOnly = false, rollbackFor = &#123; Exception.class &#125;)public class PersonService&#123; //方法上也可以标注事务注解，方法上注解声明会覆盖类上的 //一般查询操作readOnly设置为true，增删该操作设置为false @Transactional(readOnly = true) public List&lt;Person&gt; getAllPersonList()&#123; //do something &#125; //不加@Transactiona注解，则使用类上的设置 public int savePserson(Person person)&#123; //do something &#125;&#125; 如果在测试类上声明@Transactional，则会开启自动回滚，不会产生脏数据1234@RunWith(SpringRunner.class)@SpringBootTest@Transactionalpublic class SpringbootjdbcdemoApplicationTests &#123;…………&#125; 如果希望自己配置事务，可以在配置类中增加事务管理器的配置，比如，我们在DataSourceConfig中增加如下配置：1234567891011121314151617181920212223242526272829303132333435@Configuration//启用注解事务管理，使用CGLib代理@EnableTransactionManagement(proxyTargetClass = true)public class DataSourceConfig &#123; @Value("$&#123;spring.datasource.driver-class-name&#125;") String driverClass; @Value("$&#123;spring.datasource.url&#125;") String url; @Value("$&#123;spring.datasource.username&#125;") String userName; @Value("$&#123;spring.datasource.password&#125;") String passWord; @Bean(name = "dataSource") public DataSource dataSource() &#123; DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(driverClass); dataSource.setUrl(url); dataSource.setUsername(userName); dataSource.setPassword(passWord); return dataSource; &#125; @Bean(name = "jdbcTemplate") public JdbcTemplate jdbcTemplate()&#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource()); return jdbcTemplate; &#125; @Bean public DataSourceTransactionManager transactionManager() &#123; return new DataSourceTransactionManager(dataSource()); &#125;&#125; 说明上面的方法只是针对单一数据源进行事务管理的，但是项目中经常会用到多数据源的情况，那么要如何进行事务管理呢？ 我们上文讲到了可以在项目中通过配置类，自己配置多个数据源，并通过DataSourceConfig进行了演示，接下来我们添加多个事务管理器。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@Configuration//启用注解事务管理，使用CGLib代理@EnableTransactionManagement(proxyTargetClass = true)public class DataSourceConfig &#123; @Value("$&#123;spring.datasource.driver-class-name&#125;") String driverClass; @Value("$&#123;spring.datasource.url&#125;") String url; @Value("$&#123;spring.datasource.username&#125;") String userName; @Value("$&#123;spring.datasource.password&#125;") String passWord; @Value("$&#123;spring.datasource.driver-class-name2&#125;") String driverClass2; @Value("$&#123;spring.datasource.url2&#125;") String url2; @Value("$&#123;spring.datasource.username2&#125;") String userName2; @Value("$&#123;spring.datasource.password2&#125;") String passWord2; @Bean(name = "dataSource") public DataSource dataSource() &#123; DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(driverClass); dataSource.setUrl(url); dataSource.setUsername(userName); dataSource.setPassword(passWord); return dataSource; &#125; @Bean(name = "jdbcTemplate") public JdbcTemplate jdbcTemplate()&#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource()); return jdbcTemplate; &#125; @Bean(name = "transactionManager") public DataSourceTransactionManager transactionManager() &#123; return new DataSourceTransactionManager(dataSource()); &#125; @Bean(name = "dataSource2") public DataSource dataSource2() &#123; DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(driverClass2); dataSource.setUrl(url2); dataSource.setUsername(userName2); dataSource.setPassword(passWord2); System.out.println(url2); return dataSource; &#125; @Bean(name = "jdbcTemplate2") public JdbcTemplate jdbcTemplate2()&#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource2()); return jdbcTemplate; &#125; @Bean(name = "transactionManager2") public DataSourceTransactionManager transactionManager2() &#123; return new DataSourceTransactionManager(dataSource2()); &#125;&#125; 这时，我们必须在@Transactional注解中指定要使用哪一个事务管理器123456789101112131415161718192021222324@Service@Transactional(transactionManager = "transactionManager",propagation = Propagation.REQUIRED, readOnly = false, rollbackFor = &#123; Exception.class &#125;)public class PersonService &#123; @Autowired private PersonDao personDao; public int savePserson(Person person)&#123; return personDao.savePerson(person); &#125; @Transactional(transactionManager = "transactionManager",readOnly = true) public List&lt;Person&gt; getAllPersonList()&#123; return personDao.getAllPersonList(); &#125; @Transactional(transactionManager = "transactionManager2",propagation = Propagation.REQUIRED, readOnly = false, rollbackFor = &#123; Exception.class &#125;) public int savePserson2(Person person)&#123; return personDao.savePerson2(person); &#125; @Transactional(transactionManager = "transactionManager2",readOnly = true) public List&lt;Person&gt; getAllPersonList2()&#123; return personDao.getAllPersonList2(); &#125;&#125; 说明这样做并不美好，不能对多个数据源同时进行事务管理，比如，我们在一个业务方法里同时对两个数据源进行操作，我们希望只要有一个发生异常，则两个数据源的数据都进行回滚。 那要怎么做呢，我们接着往下看。 多数据源事务管理这里推荐使用Atomikos，Atomikos支持Mysql、Oracle等多种数据库，可与多种ORM框架集成，如MyBatis、JPA、Hibernate等等，同时支持各种容器下JNDI的多数据源管理。Atomikos官网提供了各种情况下使用Atomikos的Example，本文只对使用JDBC时的情况进行说明。 目前maven中央仓库的最新版本是4.0.4，使用Atomikos，需要在项目中加入如下依赖：12345678910111213141516171819202122232425&lt;dependency&gt; &lt;groupId&gt;com.atomikos&lt;/groupId&gt; &lt;artifactId&gt;transactions-jdbc&lt;/artifactId&gt; &lt;version&gt;4.0.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.atomikos&lt;/groupId&gt; &lt;artifactId&gt;transactions-jta&lt;/artifactId&gt; &lt;version&gt;4.0.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.atomikos&lt;/groupId&gt; &lt;artifactId&gt;transactions&lt;/artifactId&gt; &lt;version&gt;4.0.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.atomikos&lt;/groupId&gt; &lt;artifactId&gt;atomikos-util&lt;/artifactId&gt; &lt;version&gt;4.0.4&lt;/version&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.transaction&lt;/groupId&gt; &lt;artifactId&gt;jta&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt;&lt;/dependency&gt; 对DataSourceConfig进行改造：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127package com.example;import com.atomikos.icatch.jta.UserTransactionImp;import com.atomikos.icatch.jta.UserTransactionManager;import com.atomikos.jdbc.AtomikosDataSourceBean;import com.mysql.jdbc.jdbc2.optional.MysqlXADataSource;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.DependsOn;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.transaction.PlatformTransactionManager;import org.springframework.transaction.annotation.EnableTransactionManagement;import org.springframework.transaction.jta.JtaTransactionManager;import javax.sql.DataSource;import javax.transaction.TransactionManager;import javax.transaction.UserTransaction;@Configuration//启用注解事务管理，使用CGLib代理@EnableTransactionManagement(proxyTargetClass = true)public class DataSourceConfig &#123; @Value("$&#123;spring.datasource.driver-class-name&#125;") String driverClass; @Value("$&#123;spring.datasource.url&#125;") String url; @Value("$&#123;spring.datasource.username&#125;") String userName; @Value("$&#123;spring.datasource.password&#125;") String passWord; @Value("$&#123;spring.datasource.driver-class-name2&#125;") String driverClass2; @Value("$&#123;spring.datasource.url2&#125;") String url2; @Value("$&#123;spring.datasource.username2&#125;") String userName2; @Value("$&#123;spring.datasource.password2&#125;") String passWord2; @Bean(name = "userTransaction") public UserTransaction userTransaction() throws Throwable &#123; UserTransactionImp userTransactionImp = new UserTransactionImp(); userTransactionImp.setTransactionTimeout(300); return userTransactionImp; &#125; @Bean(name = "atomikosTransactionManager", initMethod = "init", destroyMethod = "close") public TransactionManager atomikosTransactionManager() throws Throwable &#123; UserTransactionManager userTransactionManager = new UserTransactionManager(); userTransactionManager.setForceShutdown(true); return userTransactionManager; &#125; @Bean(name = "transactionManager") @DependsOn(&#123; "userTransaction", "atomikosTransactionManager" &#125;) public PlatformTransactionManager transactionManager() throws Throwable &#123; UserTransaction userTransaction = userTransaction(); TransactionManager atomikosTransactionManager = atomikosTransactionManager(); JtaTransactionManager jtaTransactionManager = new JtaTransactionManager(userTransaction, atomikosTransactionManager); jtaTransactionManager.setAllowCustomIsolationLevels(true); return jtaTransactionManager; &#125; @Bean(name = "dataSource", initMethod = "init", destroyMethod = "close") public DataSource dataSource() &#123; System.out.println("dataSource init"); //Oracle:oracle.jdbc.xa.client.OracleXADataSource //Druid:com.alibaba.druid.pool.xa.DruidXADataSource //Postgresql:org.postgresql.xa.PGXADataSource MysqlXADataSource mysqlXaDataSource = new MysqlXADataSource(); mysqlXaDataSource.setUrl(url); mysqlXaDataSource.setPassword(passWord); mysqlXaDataSource.setUser(userName); mysqlXaDataSource.setPinGlobalTxToPhysicalConnection(true); AtomikosDataSourceBean xaDataSource = new AtomikosDataSourceBean(); xaDataSource.setXaDataSource(mysqlXaDataSource); xaDataSource.setUniqueResourceName("dataSource"); xaDataSource.setMinPoolSize(10); xaDataSource.setPoolSize(10); xaDataSource.setMaxPoolSize(30); xaDataSource.setBorrowConnectionTimeout(60); xaDataSource.setReapTimeout(20); xaDataSource.setMaxIdleTime(60); xaDataSource.setMaintenanceInterval(60); return xaDataSource; &#125; @Bean(name = "dataSource2", initMethod = "init", destroyMethod = "close") public DataSource dataSource2() &#123; System.out.println("dataSource2 init"); MysqlXADataSource mysqlXaDataSource = new MysqlXADataSource(); mysqlXaDataSource.setUrl(url2); mysqlXaDataSource.setPassword(passWord2); mysqlXaDataSource.setUser(userName2); mysqlXaDataSource.setPinGlobalTxToPhysicalConnection(true); AtomikosDataSourceBean xaDataSource = new AtomikosDataSourceBean(); xaDataSource.setXaDataSource(mysqlXaDataSource); xaDataSource.setUniqueResourceName("dataSource2"); xaDataSource.setMinPoolSize(10); xaDataSource.setPoolSize(10); xaDataSource.setMaxPoolSize(30); xaDataSource.setBorrowConnectionTimeout(60); xaDataSource.setReapTimeout(20); xaDataSource.setMaxIdleTime(60); xaDataSource.setMaintenanceInterval(60); return xaDataSource; &#125; @Bean(name = "jdbcTemplate") public JdbcTemplate jdbcTemplate()&#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource()); return jdbcTemplate; &#125; @Bean(name = "jdbcTemplate2") public JdbcTemplate jdbcTemplate2()&#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource2()); return jdbcTemplate; &#125;&#125; 项目编译路径下可以创建一个jta.properties文件，用于对Atomikos的相关属性进行配置，不过也可以不加这个文件，因为所有的属性都有默认值。123456789101112131415161718192021com.atomikos.icatch.enable_logging=truecom.atomikos.icatch.force_shutdown_on_vm_exit=falsecom.atomikos.icatch.automatic_resource_registration=truecom.atomikos.icatch.checkpoint_interval=500com.atomikos.icatch.serial_jta_transactions=truecom.atomikos.icatch.default_jta_timeout=10000com.atomikos.icatch.max_timeout=300000com.atomikos.icatch.log_base_dir=./com.atomikos.icatch.threaded_2pc=falsecom.atomikos.icatch.max_actives=50com.atomikos.icatch.log_base_name=tmlogjava.naming.factory.initial=com.sun.jndi.rmi.registry.RegistryContextFactorycom.atomikos.icatch.client_demarcation=falsejava.naming.provider.url=rmi://localhost:1099com.atomikos.icatch.rmi_export_class=nonecom.atomikos.icatch.trust_client_tm=falsecom.atomikos.icatch.forget_orphaned_log_entries_delay=86400000com.atomikos.icatch.recovery_delay=$&#123;com.atomikos.icatch.default_jta_timeout&#125;com.atomikos.icatch.oltp_max_retries=5com.atomikos.icatch.oltp_retry_interval=10000com.atomikos.icatch.allow_subtransactions=true Spring Boot中Atomikos与Hibernate4多数据源集成方法Atomikos与Hibernate4集成方法与JDBC类似，我们在pom中加入hibernate的依赖，并对DataSourceConfig进行改造pom12345&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;4.3.5.Final&lt;/version&gt;&lt;/dependency&gt; DataSourceConfig123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183package com.example;import com.atomikos.icatch.jta.UserTransactionImp;import com.atomikos.icatch.jta.UserTransactionManager;import com.atomikos.jdbc.AtomikosDataSourceBean;import com.example.hibernate.CP_HibernateDAO;import com.example.hibernate.impl.CP_Hibernate4DAOImpl;import com.mysql.jdbc.jdbc2.optional.MysqlXADataSource;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.DependsOn;import org.springframework.orm.hibernate4.LocalSessionFactoryBean;import org.springframework.transaction.PlatformTransactionManager;import org.springframework.transaction.annotation.EnableTransactionManagement;import org.springframework.transaction.jta.JtaTransactionManager;import javax.sql.DataSource;import javax.transaction.TransactionManager;import javax.transaction.UserTransaction;import java.util.Properties;@Configuration@EnableTransactionManagement(proxyTargetClass = true)public class DataSourceConfig &#123; @Value("$&#123;spring.datasource.driver-class-name&#125;") String driverClass; @Value("$&#123;spring.datasource.url&#125;") String url; @Value("$&#123;spring.datasource.username&#125;") String userName; @Value("$&#123;spring.datasource.password&#125;") String passWord; @Value("$&#123;spring.datasource.driver-class-name2&#125;") String driverClass2; @Value("$&#123;spring.datasource.url2&#125;") String url2; @Value("$&#123;spring.datasource.username2&#125;") String userName2; @Value("$&#123;spring.datasource.password2&#125;") String passWord2; @Bean(name = "userTransaction") public UserTransaction userTransaction() throws Throwable &#123; UserTransactionImp userTransactionImp = new UserTransactionImp(); userTransactionImp.setTransactionTimeout(10000); return userTransactionImp; &#125; @Bean(name = "atomikosTransactionManager", initMethod = "init", destroyMethod = "close") public TransactionManager atomikosTransactionManager() throws Throwable &#123; UserTransactionManager userTransactionManager = new UserTransactionManager(); userTransactionManager.setForceShutdown(true); return userTransactionManager; &#125; @Bean(name = "transactionManager") @DependsOn(&#123; "userTransaction", "atomikosTransactionManager" &#125;) public PlatformTransactionManager transactionManager() throws Throwable &#123; System.out.println(); UserTransaction userTransaction = userTransaction(); TransactionManager atomikosTransactionManager = atomikosTransactionManager(); JtaTransactionManager jtaTransactionManager = new JtaTransactionManager(userTransaction, atomikosTransactionManager); jtaTransactionManager.setAllowCustomIsolationLevels(true); return jtaTransactionManager; &#125; @Bean(name = "dataSource", initMethod = "init", destroyMethod = "close") public DataSource dataSource() &#123; System.out.println(); MysqlXADataSource mysqlXaDataSource = new MysqlXADataSource(); mysqlXaDataSource.setUrl(url); mysqlXaDataSource.setPassword(passWord); mysqlXaDataSource.setUser(userName); mysqlXaDataSource.setPinGlobalTxToPhysicalConnection(true); AtomikosDataSourceBean xaDataSource = new AtomikosDataSourceBean(); xaDataSource.setXaDataSource(mysqlXaDataSource); xaDataSource.setUniqueResourceName("dataSource"); xaDataSource.setMinPoolSize(10); xaDataSource.setPoolSize(10); xaDataSource.setMaxPoolSize(30); xaDataSource.setBorrowConnectionTimeout(60); xaDataSource.setReapTimeout(20); xaDataSource.setMaxIdleTime(60); xaDataSource.setMaintenanceInterval(60); return xaDataSource; &#125; @Bean(name = "dataSource2", initMethod = "init", destroyMethod = "close") public DataSource dataSource2() &#123; System.out.println(); MysqlXADataSource mysqlXaDataSource = new MysqlXADataSource(); mysqlXaDataSource.setUrl(url2); mysqlXaDataSource.setPassword(passWord2); mysqlXaDataSource.setUser(userName2); mysqlXaDataSource.setPinGlobalTxToPhysicalConnection(true); AtomikosDataSourceBean xaDataSource = new AtomikosDataSourceBean(); xaDataSource.setXaDataSource(mysqlXaDataSource); xaDataSource.setUniqueResourceName("dataSource2"); xaDataSource.setMinPoolSize(10); xaDataSource.setPoolSize(10); xaDataSource.setMaxPoolSize(30); xaDataSource.setBorrowConnectionTimeout(60); xaDataSource.setReapTimeout(20); xaDataSource.setMaxIdleTime(60); xaDataSource.setMaintenanceInterval(60); return xaDataSource; &#125; @Bean(name = "sessionFactory") public LocalSessionFactoryBean localSessionFactoryBean() &#123; System.out.println("sessionFactory"); LocalSessionFactoryBean sessionFactory = new LocalSessionFactoryBean(); sessionFactory.setDataSource(dataSource()); //扫描实体对象的目录，不同的数据源，实体要存放不同的目录 String[] packagesToScan = new String[] &#123; "com.example.model.ds1" &#125;; sessionFactory.setPackagesToScan(packagesToScan); Properties hibernateProperties = new Properties(); hibernateProperties.setProperty("hibernate.dialect", "org.hibernate.dialect.MySQLDialect"); hibernateProperties.setProperty("hibernate.show_sql", "true"); //开启Hibernate对JTA的支持 hibernateProperties.setProperty("hibernate.current_session_context_class", "jta"); hibernateProperties.setProperty("hibernate.transaction.factory_class", "org.hibernate.transaction.JTATransactionFactory"); sessionFactory.setHibernateProperties(hibernateProperties); return sessionFactory; &#125; @Bean(name = "sessionFactory2") public LocalSessionFactoryBean localSessionFactoryBean2() &#123; System.out.println("sessionFactory2"); LocalSessionFactoryBean sessionFactory = new LocalSessionFactoryBean(); sessionFactory.setDataSource(dataSource2()); //扫描实体对象的目录，不同的数据源，实体要存放不同的目录 String[] packagesToScan = new String[] &#123; "com.example.model.ds2" &#125;; sessionFactory.setPackagesToScan(packagesToScan); Properties hibernateProperties = new Properties(); hibernateProperties.setProperty("hibernate.dialect", "org.hibernate.dialect.MySQLDialect"); hibernateProperties.setProperty("hibernate.show_sql", "true"); //开启Hibernate对JTA的支持 hibernateProperties.setProperty("hibernate.current_session_context_class", "jta"); hibernateProperties.setProperty("hibernate.transaction.factory_class", "org.hibernate.transaction.JTATransactionFactory"); sessionFactory.setHibernateProperties(hibernateProperties); return sessionFactory; &#125; @Bean(name = "hibernateDAO") public CP_HibernateDAO hibernate4Dao() &#123; System.out.println("hibernateDAO"); CP_Hibernate4DAOImpl dao = new CP_Hibernate4DAOImpl(); //绑定SessionFactory dao.setSessionFactory(localSessionFactoryBean().getObject()); return dao; &#125; @Bean(name = "hibernateDAO2") public CP_HibernateDAO hibernate4Dao2() &#123; System.out.println("hibernateDAO2"); CP_Hibernate4DAOImpl dao = new CP_Hibernate4DAOImpl(); //绑定SessionFactory2 dao.setSessionFactory(localSessionFactoryBean2().getObject()); return dao; &#125;&#125; 123456789101112131415@Entity@Table(name = "person")public class Person implements Serializable &#123; private static final long serialVersionUID = -1L; @Id @GeneratedValue(strategy = GenerationType.AUTO) @Column(name = "p_id") private Long id; @Column(name = "p_name") private String name; @Column(name = "p_age") private Integer age; //setter and getter&#125; CP_HibernateDAO是我们自定义的Hibernate的通用Dao接口，其定义的方法和和实现类CP_Hibernate4DAOImpl代码如下：1234567891011package com.example.hibernate;import java.util.List;public interface CP_HibernateDAO &#123; public List&lt;?&gt; findAll(Class&lt;?&gt; entityClazz, String... str); public void save(Object entity);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.example.hibernate.impl;import com.example.hibernate.CP_HibernateDAO;import org.hibernate.Criteria;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.criterion.DetachedCriteria;import java.util.List;public class CP_Hibernate4DAOImpl implements CP_HibernateDAO &#123; private SessionFactory sessionFactory; public SessionFactory getSessionFactory() &#123; return sessionFactory; &#125; //绑定SessionFactory public void setSessionFactory(SessionFactory sessionFactory) &#123; this.sessionFactory = sessionFactory; &#125; private Session getHibernateSession() &#123; Session session = sessionFactory.openSession(); return session; &#125; /* * @see com.example.hibernate.CP_HibernateDAO#findAll() */ @Override public List&lt;?&gt; findAll(Class&lt;?&gt; entityClazz, String... str) &#123; DetachedCriteria dc = DetachedCriteria.forClass(entityClazz); List&lt;?&gt; list = findAllByCriteria(dc); return list; &#125; /* * @see com.example.hibernate.CP_HibernateDAO#save(java.lang.Object) */ @Override public void save(Object entity) &#123; getHibernateSession().save(entity); //注意这里一定要执行flush方法 getHibernateSession().flush(); &#125; public List&lt;?&gt; findAllByCriteria(DetachedCriteria detachedCriteria) &#123; // TODO Auto-generated method stub Criteria criteria = detachedCriteria .getExecutableCriteria(getHibernateSession()); return criteria.list(); &#125;&#125; 说明需要注意两点： session必须使用sessionFactory.openSession()的方式获得，不能使用sessionFactory.getCurrentSession()。 更新操作必须调用session.flush()方法。 Spring配置文件的方式，可以参考：Spring4+Hibernate4+Atomikos3.3多数据源事务管理 Spring Boot中Mybitas的使用创建项目时，我们可以选择mybatis-spring-boot-starter依赖，这样可以激活SpringBoot对Mybatis的自动配置类。 pom中添加依赖12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt; application.properties中添加mybaits的自动配置属性，可以查看MybatisProperties了解可以配置哪些属性12#mapper配置文件路径，如果是基于注解的形式可以不需要配置该属性mybatis.mapper-locations=classpath:mapper/*.xml Mapper接口上要配置@Mapper注解，因为mybatis-spring-boot-starter的自动配置会扫描@Mapper注解来注册Mapper接口。1234@Mapperpublic interface PersonMapper &#123; //………………&#125; 此时同样可以使用@Transactional注解 说明可以使用maven的mybatis-generator插件自动生成代码，参考maven插件–MyBatis自动生成代码 mybatis-spring-boot-starter不利于扩展，所以还是我们自己实现个mybitas的配置类吧。 pom中去掉mybatis-spring-boot-starter的依赖，增加mybatis的依赖1234567891011121314151617181920212223&lt;!--&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt;--&gt;&lt;!--Mybatis--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.3.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; 创建MyBatisConfig12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Configuration@EnableTransactionManagement(proxyTargetClass = true)public class MyBatisConfig &#123; @Value("$&#123;spring.datasource.driver-class-name&#125;") String driverClass; @Value("$&#123;spring.datasource.url&#125;") String url; @Value("$&#123;spring.datasource.username&#125;") String userName; @Value("$&#123;spring.datasource.password&#125;") String passWord; @Bean(name = "dataSource") public DataSource dataSource() &#123; DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(driverClass); dataSource.setUrl(url); dataSource.setUsername(userName); dataSource.setPassword(passWord); return dataSource; &#125; @Bean(name = "sqlSessionFactory") public SqlSessionFactory sqlSessionFactoryBean() &#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dataSource()); //添加XML目录 ResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(); try &#123; bean.setMapperLocations(resolver.getResources("classpath:mapper/*.xml")); return bean.getObject(); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; &#125; @Bean public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) &#123; return new SqlSessionTemplate(sqlSessionFactory); &#125; @Bean public PlatformTransactionManager annotationDrivenTransactionManager() &#123; return new DataSourceTransactionManager(dataSource()); &#125;&#125; MyBatisMapperScannerConfig，基于包扫描Mapper，此时不需要配置@Mapper注解123456789101112@Configuration//必须在MyBatisConfig注册后再加载MapperScannerConfigurer，否则会报错@AutoConfigureAfter(MyBatisConfig.class)public class MyBatisMapperScannerConfig &#123; @Bean public MapperScannerConfigurer mapperScannerConfigurer() &#123; MapperScannerConfigurer mapperScannerConfigurer = new MapperScannerConfigurer(); mapperScannerConfigurer.setSqlSessionFactoryBeanName("sqlSessionFactory"); mapperScannerConfigurer.setBasePackage("com.example.mapper"); return mapperScannerConfigurer; &#125;&#125; 关闭DataSourceAutoConfiguration，因为这里我们配置了数据源，所以需要关闭该自动配置，另外，MybatisAutoConfiguration也是基于DataSourceAutoConfiguration的，所以关闭了DataSourceAutoConfiguration也就同时关闭了MybatisAutoConfiguration。 Spring Boot中Atomikos与Mybatis多数据源集成方法pom1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.3.4.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--Mybatis--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.atomikos&lt;/groupId&gt; &lt;artifactId&gt;transactions-jdbc&lt;/artifactId&gt; &lt;version&gt;4.0.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.atomikos&lt;/groupId&gt; &lt;artifactId&gt;transactions-jta&lt;/artifactId&gt; &lt;version&gt;4.0.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.atomikos&lt;/groupId&gt; &lt;artifactId&gt;transactions&lt;/artifactId&gt; &lt;version&gt;4.0.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.atomikos&lt;/groupId&gt; &lt;artifactId&gt;atomikos-util&lt;/artifactId&gt; &lt;version&gt;4.0.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.transaction&lt;/groupId&gt; &lt;artifactId&gt;jta&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.37&lt;/version&gt;&lt;/dependency&gt; MyBatisConfig123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134@Configuration@EnableTransactionManagement(proxyTargetClass = true)public class MyBatisConfig &#123; @Value("$&#123;spring.datasource.driver-class-name&#125;") String driverClass; @Value("$&#123;spring.datasource.url&#125;") String url; @Value("$&#123;spring.datasource.username&#125;") String userName; @Value("$&#123;spring.datasource.password&#125;") String passWord; @Value("$&#123;spring.datasource.driver-class-name2&#125;") String driverClass2; @Value("$&#123;spring.datasource.url2&#125;") String url2; @Value("$&#123;spring.datasource.username2&#125;") String userName2; @Value("$&#123;spring.datasource.password2&#125;") String passWord2; @Bean(name = "userTransaction") public UserTransaction userTransaction() throws Throwable &#123; UserTransactionImp userTransactionImp = new UserTransactionImp(); userTransactionImp.setTransactionTimeout(10000); return userTransactionImp; &#125; @Bean(name = "atomikosTransactionManager", initMethod = "init", destroyMethod = "close") public TransactionManager atomikosTransactionManager() throws Throwable &#123; UserTransactionManager userTransactionManager = new UserTransactionManager(); userTransactionManager.setForceShutdown(true); return userTransactionManager; &#125; @Bean(name = "transactionManager") @DependsOn(&#123; "userTransaction", "atomikosTransactionManager" &#125;) public PlatformTransactionManager transactionManager() throws Throwable &#123; UserTransaction userTransaction = userTransaction(); TransactionManager atomikosTransactionManager = atomikosTransactionManager(); JtaTransactionManager jtaTransactionManager = new JtaTransactionManager(userTransaction, atomikosTransactionManager); jtaTransactionManager.setAllowCustomIsolationLevels(true); return jtaTransactionManager; &#125; @Bean(name = "dataSource", initMethod = "init", destroyMethod = "close") public DataSource dataSource() &#123; System.out.println("dataSource init"); MysqlXADataSource mysqlXaDataSource = new MysqlXADataSource(); mysqlXaDataSource.setUrl(url); mysqlXaDataSource.setPassword(passWord); mysqlXaDataSource.setUser(userName); mysqlXaDataSource.setPinGlobalTxToPhysicalConnection(true); AtomikosDataSourceBean xaDataSource = new AtomikosDataSourceBean(); xaDataSource.setXaDataSource(mysqlXaDataSource); xaDataSource.setUniqueResourceName("dataSource"); xaDataSource.setMinPoolSize(10); xaDataSource.setPoolSize(10); xaDataSource.setMaxPoolSize(30); xaDataSource.setBorrowConnectionTimeout(60); xaDataSource.setReapTimeout(20); xaDataSource.setMaxIdleTime(60); xaDataSource.setMaintenanceInterval(60); return xaDataSource; &#125; @Bean(name = "dataSource2", initMethod = "init", destroyMethod = "close") public DataSource dataSource2() &#123; System.out.println("dataSource2 init"); MysqlXADataSource mysqlXaDataSource = new MysqlXADataSource(); mysqlXaDataSource.setUrl(url2); mysqlXaDataSource.setPassword(passWord2); mysqlXaDataSource.setUser(userName2); mysqlXaDataSource.setPinGlobalTxToPhysicalConnection(true); AtomikosDataSourceBean xaDataSource = new AtomikosDataSourceBean(); xaDataSource.setXaDataSource(mysqlXaDataSource); xaDataSource.setUniqueResourceName("dataSource2"); xaDataSource.setMinPoolSize(10); xaDataSource.setPoolSize(10); xaDataSource.setMaxPoolSize(30); xaDataSource.setBorrowConnectionTimeout(60); xaDataSource.setReapTimeout(20); xaDataSource.setMaxIdleTime(60); xaDataSource.setMaintenanceInterval(60); return xaDataSource; &#125; //基于xml式Mapper @Bean(name = "sqlSessionFactory") public SqlSessionFactory sqlSessionFactoryBean() &#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dataSource()); //添加Mapper配置文件的目录 ResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(); try &#123; bean.setMapperLocations(resolver.getResources("classpath:mapper/ds1/*.xml")); return bean.getObject(); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; &#125; @Bean(name = "sqlSessionTemplate") public SqlSessionTemplate sqlSessionTemplate() &#123; return new SqlSessionTemplate(sqlSessionFactoryBean()); &#125; //基于注解式Mapper @Bean(name = "sqlSessionFactory2") public SqlSessionFactory sqlSessionFactoryBean2() &#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dataSource2()); try &#123; return bean.getObject(); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; &#125; @Bean(name = "sqlSessionTemplate2") public SqlSessionTemplate sqlSessionTemplate2() &#123; return new SqlSessionTemplate(sqlSessionFactoryBean2()); &#125;&#125; MyBatisMapperScannerConfig123456789101112131415161718192021222324@Configuration//必须在MyBatisConfig注册后再加载MapperScannerConfigurer，否则会报错@AutoConfigureAfter(MyBatisConfig.class)public class MyBatisMapperScannerConfig &#123; @Bean public MapperScannerConfigurer mapperScannerConfigurer() &#123; MapperScannerConfigurer mapperScannerConfigurer = new MapperScannerConfigurer(); //绑定datasorce的sqlSessionFactory mapperScannerConfigurer.setSqlSessionFactoryBeanName("sqlSessionFactory"); //扫描ds1目录来注册Mapper接口 mapperScannerConfigurer.setBasePackage("com.example.mapper.ds1"); return mapperScannerConfigurer; &#125; @Bean public MapperScannerConfigurer mapperScannerConfigurer2() &#123; MapperScannerConfigurer mapperScannerConfigurer = new MapperScannerConfigurer(); //绑定datasorce2的sqlSessionFactory mapperScannerConfigurer.setSqlSessionFactoryBeanName("sqlSessionFactory2"); //扫描ds2目录来注册Mapper接口 mapperScannerConfigurer.setBasePackage("com.example.mapper.ds2"); return mapperScannerConfigurer; &#125;&#125; 这里要说明的是，如果两个数据源下的Mapper起了相同的类名，虽然他们在不同的包路径下，启动也会报错了，因为默认注册Mapper时使用的是类名称（不含包名），此时可以在Mapper上加上@Component(“personMapper”)注解 写在后面的话Spring Boot为我们提供了大量的spring-boot-starter-xxx来加快我们的开发流程，创建项目时就可以看到可供选择的各种spring-boot-starter-xxx，那么这么多的spring-boot-starter-xxx，我们是否都需要了解呢，如果项目中需要用到某一个功能，是否就应该加入这个spring-boot-starter-xxx呢？ 笔者人为，spring-boot-starter-xxx提供的完整jar包依赖和自动配置固然很好，但是当我们要在项目中加入某一个功能时，作为开发人员，是应该清楚的知道该功能的依赖关系和配置逻辑的，所以并不一定需要引入SpringBoot的spring-boot-starter-xxx，而且SpringBoot对这些spring-boot-starter-xxx做的自动配置，如果我们并不熟悉和十分清楚，往往会给我们开发人员造成不明所以的困扰，所以，笔者建议，在对SpringBoot提供的某一个spring-boot-starter-xxx所提供的功能并不十分清楚时，还是使用配置类的方式吧。 还有，由于某些自动配置类的激活是根据项目中是否包含某个class或容器中是否注册了某个bean，所以笔者建议，如果项目中引入了新的jar包，或者手工注册了某个bean，都要通过debug的方式查看是否开启了某个自动配置。 另外，本文代码只是为了辅助说明，比如DriverManagerDataSource正式环境不建议使用，请更换为其它数据源，比如BasicDataSource。 本文示例代码下载地址：https://github.com/hanqunfeng/SpringBootStudy]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring Boot学习笔记03--深入了解SpringBoot的启动过程]]></title>
      <url>%2F2016%2F12%2F13%2Fspring-boot-study-springapplication%2F</url>
      <content type="text"><![CDATA[摘要看完本文你将掌握如下知识点： SpringApplication的作用及运行过程 SpringBootServletInitializer的作用及运行过程 PS:本节内容略显枯燥，如果对SpringBoot的启动过程不感兴趣，可以略过。 SpringBoot系列：Spring Boot学习笔记 深入了解SpringApplication123456@SpringBootApplicationpublic class SpringBootWebDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootWebDemoApplication.class, args); &#125;&#125; 这就是SpringBoot的启动入口，通过前面的学习我们大体上了解了@SpringBootApplication的作用，接下来我们来认识一下SpringApplication。SpringApplication (Spring Boot Docs 1.4.2.RELEASE API)。 SpringApplication.run(SpringBootWebDemoApplication.class, args);通过源码我们来看一下SpringApplication.run()方法的执行过程1.调用static方法1234//1public static ConfigurableApplicationContext run(Object source, String... args) &#123;return run(new Object[]&#123;source&#125;, args);&#125;public static ConfigurableApplicationContext run(Object[] sources, String[] args) &#123;return (new SpringApplication(sources)).run(args);&#125; 2.创建SpringApplication对象12345678910//2public SpringApplication(Object... sources) &#123; this.bannerMode = Mode.CONSOLE; //banner的打印模式，此时是控制台模式 this.logStartupInfo = true; //开启日志 this.addCommandLineProperties = true;//启用CommandLineProperties this.headless = true;//开启headless模式支持 this.registerShutdownHook = true;//启用注册ShutdownHook，用于在非Web应用中关闭IoC容器和资源 this.additionalProfiles = new HashSet(); this.initialize(sources);//初始化 &#125; PS：Headless参考资料：在 Java SE 平台上使用 Headless 模式 3.初始化相关对象和属性1234567891011121314//3private void initialize(Object[] sources) &#123; if(sources != null &amp;&amp; sources.length &gt; 0) &#123; this.sources.addAll(Arrays.asList(sources)); &#125; //3.1判断是否是web运行环境，如果classpath中是否含有**WEB_ENVIRONMENT_CLASSES**指定的全部类，则返回true this.webEnvironment = this.deduceWebEnvironment(); //3.2找到*META-INF/spring.factories*中声明的所有ApplicationContextInitializer的实现类并将其实例化 this.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class)); //3.3找到*META-INF/spring.factories*中声明的所有ApplicationListener的实现类并将其实例化 this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class)); //3.4获得当前执行main方法的类对象，这里就是SpringBootWebDemoApplication的实例 this.mainApplicationClass = this.deduceMainApplicationClass(); &#125; 3.1 判断是否是web运行环境如果classpath中是否含有WEB_ENVIRONMENT_CLASSES指定的全部类，则返回true，用于创建指定类型的ApplicationContext对象。12//3.1private static final String[] WEB_ENVIRONMENT_CLASSES = new String[]&#123;"javax.servlet.Servlet", "org.springframework.web.context.ConfigurableWebApplicationContext"&#125;; 3.2 大体的过程就是通过SpringFactoriesLoader检索META-INF/spring.factories，找到声明的所有ApplicationContextInitializer的实现类并将其实例化。ApplicationContextInitializer是Spring框架中的接口，其作用可以理解为在ApplicationContext执行refresh之前，调用ApplicationContextInitializer的initialize()方法，对ApplicationContext做进一步的设置和处理。123public interface ApplicationContextInitializer&lt;C extends ConfigurableApplicationContext&gt; &#123; void initialize(C var1);&#125; spring-boot-1.4.2.RELEASE.jar中的META-INF/spring.factories包含的ApplicationContextInitializer123456# Application Context Initializersorg.springframework.context.ApplicationContextInitializer=\org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\org.springframework.boot.context.ContextIdApplicationContextInitializer,\org.springframework.boot.context.config.DelegatingApplicationContextInitializer,\org.springframework.boot.context.web.ServerPortInfoApplicationContextInitializer spring-boot-autoconfigure-1.4.2.RELEASE.jar中的META-INF/spring.factories包含的ApplicationContextInitializer1234# Initializersorg.springframework.context.ApplicationContextInitializer=\org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\org.springframework.boot.autoconfigure.logging.AutoConfigurationReportLoggingInitializer 3.3 大体的过程就是通过SpringFactoriesLoader检索META-INF/spring.factories，找到声明的所有ApplicationListener的实现类并将其实例化。ApplicationListener是Spring框架中的接口，就是事件监听器，其作用可以理解为在SpringApplicationRunListener发布通知事件时，由ApplicationListener负责接收。123public interface ApplicationListener&lt;E extends ApplicationEvent&gt; extends EventListener &#123; void onApplicationEvent(E var1);&#125; SpringBoot只提供了一个SpringApplicationRunListener的实现类，就是EventPublishingRunListener，起作用就是在SpringBoot启动过程中，负责注册ApplicationListener监听器，在不同的时点发布不同的事件类型，如果有哪些ApplicationListener的实现类监听了这些事件，则可以接收并处理。123456789101112public interface SpringApplicationRunListener &#123; //通知监听器，SpringBoot开始执行 void started(); //通知监听器，Environment准备完成 void environmentPrepared(ConfigurableEnvironment var1); //通知监听器，ApplicationContext已经创建并初始化完成 void contextPrepared(ConfigurableApplicationContext var1); //通知监听器，ApplicationContext已经完成IoC配置加载 void contextLoaded(ConfigurableApplicationContext var1); //通知监听器，SpringBoot启动完成 void finished(ConfigurableApplicationContext var1, Throwable var2);&#125; spring-boot-1.4.2.RELEASE.jar中的META-INF/spring.factories包含的ApplicationListener1234567891011# Application Listenersorg.springframework.context.ApplicationListener=\org.springframework.boot.ClearCachesApplicationListener,\org.springframework.boot.builder.ParentContextCloserApplicationListener,\org.springframework.boot.context.FileEncodingApplicationListener,\org.springframework.boot.context.config.AnsiOutputApplicationListener,\org.springframework.boot.context.config.ConfigFileApplicationListener,\org.springframework.boot.context.config.DelegatingApplicationListener,\org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener,\org.springframework.boot.logging.ClasspathLoggingApplicationListener,\org.springframework.boot.logging.LoggingApplicationListener spring-boot-autoconfigure-1.4.2.RELEASE.jar中的META-INF/spring.factories包含的ApplicationListener123# Application Listenersorg.springframework.context.ApplicationListener=\org.springframework.boot.autoconfigure.BackgroundPreinitializer spring-boot-1.4.2.RELEASE.jar中的META-INF/spring.factories包含的SpringApplicationRunListener123# Run Listenersorg.springframework.boot.SpringApplicationRunListener=\org.springframework.boot.context.event.EventPublishingRunListener 3.4 获得当前执行main方法的类对象，这里就是SpringBootWebDemoApplication的实例。 4.核心方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//4public ConfigurableApplicationContext run(String... args) &#123; //开启任务执行时间监听器 StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; Object analyzers = null; //设置系统属性『java.awt.headless』，为true则启用headless模式支持 this.configureHeadlessProperty(); //通过*SpringFactoriesLoader*检索*META-INF/spring.factories*， //找到声明的所有SpringApplicationRunListener的实现类并将其实例化， //之后逐个调用其started()方法，广播SpringBoot要开始执行了。 SpringApplicationRunListeners listeners = this.getRunListeners(args); listeners.started(); try &#123; DefaultApplicationArguments ex = new DefaultApplicationArguments(args); //创建并配置当前SpringBoot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）, //并遍历调用所有的SpringApplicationRunListener的environmentPrepared()方法，广播Environment准备完毕。 ConfigurableEnvironment environment = this.prepareEnvironment(listeners, ex); //决定是否打印Banner Banner printedBanner = this.printBanner(environment); //根据webEnvironment的值来决定创建何种类型的ApplicationContext对象 //如果是web环境，则创建org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext //否则创建org.springframework.context.annotation.AnnotationConfigApplicationContext context = this.createApplicationContext(); //注册异常分析器 new FailureAnalyzers(context); //为ApplicationContext加载environment，之后逐个执行ApplicationContextInitializer的initialize()方法来进一步封装ApplicationContext， //并调用所有的SpringApplicationRunListener的contextPrepared()方法，【EventPublishingRunListener只提供了一个空的contextPrepared()方法】， //之后初始化IoC容器，并调用SpringApplicationRunListener的contextLoaded()方法，广播ApplicationContext的IoC加载完成， //这里就包括通过**@EnableAutoConfiguration**导入的各种自动配置类。 this.prepareContext(context, environment, listeners, ex, printedBanner); //初始化所有自动配置类，调用ApplicationContext的refresh()方法 this.refreshContext(context); //遍历所有注册的ApplicationRunner和CommandLineRunner，并执行其run()方法。 //该过程可以理解为是SpringBoot完成ApplicationContext初始化前的最后一步工作， //我们可以实现自己的ApplicationRunner或者CommandLineRunner，来对SpringBoot的启动过程进行扩展。 this.afterRefresh(context, ex); //调用所有的SpringApplicationRunListener的finished()方法，广播SpringBoot已经完成了ApplicationContext初始化的全部过程。 listeners.finished(context, (Throwable)null); //关闭任务执行时间监听器 stopWatch.stop(); //如果开启日志，则答应执行是时间 if(this.logStartupInfo) &#123; (new StartupInfoLogger(this.mainApplicationClass)).logStarted(this.getApplicationLog(), stopWatch); &#125; return context; &#125; catch (Throwable var9) &#123; //调用异常分析器打印报告，调用所有的SpringApplicationRunListener的finished()方法将异常信息发布出去 this.handleRunFailure(context, listeners, (FailureAnalyzers)analyzers, var9); throw new IllegalStateException(var9); &#125; &#125; spring-boot-1.4.2.RELEASE.jar中的META-INF/spring.factories包含的FailureAnalyzer和FailureAnalysisReporters12345678910111213# Failure Analyzersorg.springframework.boot.diagnostics.FailureAnalyzer=\org.springframework.boot.diagnostics.analyzer.BeanCurrentlyInCreationFailureAnalyzer,\org.springframework.boot.diagnostics.analyzer.BeanNotOfRequiredTypeFailureAnalyzer,\org.springframework.boot.diagnostics.analyzer.BindFailureAnalyzer,\org.springframework.boot.diagnostics.analyzer.ConnectorStartFailureAnalyzer,\org.springframework.boot.diagnostics.analyzer.NoUniqueBeanDefinitionFailureAnalyzer,\org.springframework.boot.diagnostics.analyzer.PortInUseFailureAnalyzer,\org.springframework.boot.diagnostics.analyzer.ValidationExceptionFailureAnalyzer# FailureAnalysisReportersorg.springframework.boot.diagnostics.FailureAnalysisReporter=\org.springframework.boot.diagnostics.LoggingFailureAnalysisReporter 说明 SpringBoot的启动过程，实际上就是对ApplicationContext的初始化过程。 ApplicationContext创建后立刻为其设置Environmen，并由ApplicationContextInitializer对其进一步封装。 通过SpringApplicationRunListener在ApplicationContext初始化过程中各个时点发布各种广播事件，并由ApplicationListener负责接收广播事件。 初始化过程中完成IoC的注入，包括通过@EnableAutoConfiguration导入的各种自动配置类。 初始化完成前调用ApplicationRunner和CommandLineRunner的实现类。 扩展SpringApplication通过上面的学习，我们基本上了解了，如果要对SpringApplication进行扩展，我们可以选择如下三种方案： 创建ApplicationContextInitializer的实现类 创建ApplicationListener的实现类 创建ApplicationRunner和CommandLineRunner的实现类 1.可以通过如下方式加载自定义的ApplicationContextInitializer和ApplicationListener12345678910111213@SpringBootApplicationpublic class SpringBootWebDemoApplication &#123; public static void main(String[] args) &#123; //SpringApplication.run(SpringBootWebDemoApplication.class, args); SpringApplication springApplication = new SpringApplication(SpringBootWebDemoApplication.class); springApplication.addInitializers(MyApplicationContextInitializer1,MyApplicationContextInitializer2); springApplication.addListeners(MyApplicationListener1,MyApplicationListener2); springApplication.run(args); &#125;&#125; 2.也可以在当前项目的类路径下创建META-INF/spring.factories文件，并声明相应的ApplicationContextInitializer和ApplicationListener12345678org.springframework.context.ApplicationContextInitializer=\xxx.xxx.MyApplicationContextInitializer1,\xxx.xxx.MyApplicationContextInitializer2# Application Listenersorg.springframework.context.ApplicationListener=\xxx.xxx.MyApplicationListener1,\xxx.xxx.MyApplicationListener2 3.至于ApplicationRunner和CommandLineRunner，只需要在其实现类上加上@Component注解或者在@Configuration配置类中通过@Bean注解注入。 深入了解SpringBootServletInitializer熟悉了SpringApplication的原理之后，我们再来了解SpringBootServletInitializer的原理就比较容易了。1234567public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; return application.sources(DemoWarApplication.class); &#125;&#125; SpringBootServletInitializer就是一个org.springframework.web.context.WebApplicationContext，容器启动时会调用其onStartup(ServletContext servletContext)方法，接下来我么就来看一下这个方法:12345678910111213public void onStartup(ServletContext servletContext) throws ServletException &#123; this.logger = LogFactory.getLog(this.getClass()); final WebApplicationContext rootAppContext = this.createRootApplicationContext(servletContext); if(rootAppContext != null) &#123; servletContext.addListener(new ContextLoaderListener(rootAppContext) &#123; public void contextInitialized(ServletContextEvent event) &#123; &#125; &#125;); &#125; else &#123; this.logger.debug("No ContextLoaderListener registered, as createRootApplicationContext() did not return an application context"); &#125; &#125; 这里的核心方法就是createRootApplicationContext(servletContext)：123456789101112131415161718192021222324252627282930313233343536protected WebApplicationContext createRootApplicationContext(ServletContext servletContext) &#123; //创建SpringApplicationBuilder，并用其生产出SpringApplication对象 SpringApplicationBuilder builder = this.createSpringApplicationBuilder(); builder.main(this.getClass()); ApplicationContext parent = this.getExistingRootWebApplicationContext(servletContext); if(parent != null) &#123; this.logger.info("Root context already created (using as parent)."); servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, (Object)null); builder.initializers(new ApplicationContextInitializer[]&#123;new ParentContextApplicationContextInitializer(parent)&#125;); &#125; //初始化并封装SpringApplicationBuilder对象，为SpringApplication对象增加ApplicationContextInitializer和ApplicationListener做准备 builder.initializers(new ApplicationContextInitializer[]&#123;new ServletContextApplicationContextInitializer(servletContext)&#125;); builder.listeners(new ApplicationListener[]&#123;new ServletContextApplicationListener(servletContext)&#125;); //指定创建的ApplicationContext类型 builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class); //传递入口类，并构建SpringApplication对象 //可以通过configure()方法对SpringBootServletInitializer进行扩展 builder = this.configure(builder); SpringApplication application = builder.build(); if(application.getSources().isEmpty() &amp;&amp; AnnotationUtils.findAnnotation(this.getClass(), Configuration.class) != null) &#123; application.getSources().add(this.getClass()); &#125; Assert.state(!application.getSources().isEmpty(), "No SpringApplication sources have been defined. Either override the configure method or add an @Configuration annotation"); if(this.registerErrorPageFilter) &#123; application.getSources().add(ErrorPageFilter.class); &#125; //最后调用SpringApplication的run方法 return this.run(application); &#125; 说明SpringBootServletInitializer的执行过程，简单来说就是通过SpringApplicationBuilder构建并封装SpringApplication对象，并最终调用SpringApplication的run方法的过程。 扩展SpringBootServletInitializer与扩展SpringApplication类似，ApplicationContextInitializer和ApplicationListener可以基于SpringApplicationBuilder提供的public方法进行扩展12345678910public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; application.initializers(MyApplicationContextInitializer1,MyApplicationContextInitializer2); application.listeners(MyApplicationListener1,MyApplicationListener2) return application.sources(DemoWarApplication.class); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring Boot学习笔记02--深入了解自动配置]]></title>
      <url>%2F2016%2F12%2F10%2Fspring-boot-study-web%2F</url>
      <content type="text"><![CDATA[摘要看完本文你将掌握如下知识点： SpringBoot都帮我们做了哪些自动配置 我们如何接管SpringBoot的自动配置 注册Servlet、Filter、Listener的方法 SpringBoot系列：Spring Boot学习笔记 SpringBoot的自动配置1.自动配置类都存放在spring-boot-autoconfigure-1.4.2.RELEASE.jar下的org.springframework.boot.autoconfigure路径下；2.application.properties中配置debug=true后启动容器，可以看到服务器初始化的自动配置如下: DispatcherServletAutoConfiguration注册org.springframework.web.servlet.DispatcherServlet EmbeddedServletContainerAutoConfiguration注册容器类型，如类路径下存在org.apache.catalina.startup.Tomcat，就会注册Tomcat容器 ErrorMvcAutoConfiguration注册异常处理器 HttpEncodingAutoConfiguration注册http编码过滤器 HttpMessageConvertersAutoConfiguration注册json或者xml处理器 JacksonAutoConfiguration注册json对象解析器 JmxAutoConfiguration注册JMX管理器 JMX与Spring集成spring通过annotation注解注册MBean到JMX实现监控java运行状态 MultipartAutoConfiguration注册文件传输处理器 ServerPropertiesAutoConfiguration用于初始化容器相关的配置属性，如服务地址、端口、contextPath，并根据当前容器类型初始化各个容器的特有属性，如tomcat的maxThreads、uriEncoding等等，其对应的属性类为ServerProperties； WebClientAutoConfiguration注册RestTemplate WebMvcAutoConfiguration注册SpringMvc相关处理器，如ResourceResolver、RequestMappingHandlerAdapter、ExceptionHandlerExceptionResolver、ViewResolver、LocaleResolver，等等 WebSocketAutoConfiguration注册webSocket相关处理器，根据容器类型注册不同的处理器 3.如果依赖中加入了其它功能的依赖，SpringBoot还会实现这些功能的自动适配，比如我们增加数据库的JPA的功能，就会启用对JpaRepositoriesAutoConfiguration的自动配置功能。关于数据库方面的内容将在后文介绍。1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; 说明从各个AutoConfiguration配置类中可以看到如下注解，基于这些注解可以确定这些AutoConfiguration的初始化顺序： @AutoConfigureOrder(-2147483648)：数越小越先初始化 @AutoConfigureAfter({EmbeddedServletContainerAutoConfiguration.class})：在指定的配置类初始化后再加载 @AutoConfigureBefore({WebMvcAutoConfiguration.class})：在指定的配置类初始化前加载 接管SpringBoot的自动配置我们介绍过@SpringBootApplication这个注解，因其包含@EnableAutoConfiguration和@ComponentScan注解，可以自动扫描相关的自动配置类，从而实现自动配置功能的。上面介绍默认情况下SpringBoot默认会初始化很多的自动配置，这些配置有些我们在项目中可能用不到，那要如何去掉呢？ 去掉不需要的自动配置类比如我们不需要开启webSocket和JMX的自动配置，我们需要在@SpringBootApplication这个注解中指定exclude属性123456@SpringBootApplication(exclude = &#123;WebSocketAutoConfiguration.class,JmxAutoConfiguration.class&#125;)public class SpringBootWebDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootWebDemoApplication.class, args); &#125;&#125; 明确指定需要启用哪些自动配置我们可以去掉@SpringBootApplication注解，改用@Configuration、@Import、@ComponentScan注解，在@Import注解中明确指定需要启用哪些自动配置1234567891011121314151617181920//@SpringBootApplication(exclude = &#123;WebSocketAutoConfiguration.class,JmxAutoConfiguration.class&#125;)@Configuration@Import(&#123; DispatcherServletAutoConfiguration.class, EmbeddedServletContainerAutoConfiguration.class, ErrorMvcAutoConfiguration.class, HttpEncodingAutoConfiguration.class, HttpMessageConvertersAutoConfiguration.class, JacksonAutoConfiguration.class, MultipartAutoConfiguration.class, ServerPropertiesAutoConfiguration.class, WebMvcAutoConfiguration.class&#125;)@ComponentScanpublic class SpringBootWebDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootWebDemoApplication.class, args); &#125;&#125; 说明： 这里推荐使用第一种方式：@SpringBootApplication(exclude={})； 实际上，开启默认的自动配置功能，只是会影响项目启动时间，所以没有特殊需要，可以不需要关闭某个自动配置功能； 在某些情况，比如项目需要多数据源时，在项目中就会包含多个DataSource的Bean，因为DataSourceAutoConfiguration自动配置只能绑定一个数据源，此时发现多个DataSource的Bean被Spring注册就会抛出异常。 1.这时就可以采用去掉DataSourceAutoConfiguration的方式;2.或者也可以在某一个DataSource的Bean上声明@Primary注解，指定其为主数据源，这时DataSourceAutoConfiguration只会加载被指定@Primary注解的主数据源，这样就可以享受到SpringBoot自动配置带来的好处。 接管WebMvc自动配置对于一个web项目，最重要的就是Mvc相关的控制，SpringBoot通过WebMvcAutoConfiguration来完成与Mvc有关的自动配置。如果希望完全接管WebMvc自动配置，可以在项目中创建一个注解了@EnableWebMvc的配置类，比如：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169package com.example;import org.apache.log4j.Logger;import org.springframework.context.MessageSource;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.FilterType;import org.springframework.context.support.ResourceBundleMessageSource;import org.springframework.stereotype.Controller;import org.springframework.web.multipart.commons.CommonsMultipartResolver;import org.springframework.web.servlet.HandlerAdapter;import org.springframework.web.servlet.HandlerMapping;import org.springframework.web.servlet.ViewResolver;import org.springframework.web.servlet.config.annotation.EnableWebMvc;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;import org.springframework.web.servlet.handler.SimpleMappingExceptionResolver;import org.springframework.web.servlet.handler.SimpleServletHandlerAdapter;import org.springframework.web.servlet.i18n.CookieLocaleResolver;import org.springframework.web.servlet.i18n.LocaleChangeInterceptor;import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter;import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;import org.springframework.web.servlet.view.InternalResourceViewResolver;import java.util.Properties;@Configuration@EnableWebMvc@ComponentScan(basePackages = "com.example", useDefaultFilters = false, includeFilters = &#123; @ComponentScan.Filter(type = FilterType.ANNOTATION, value = &#123;Controller.class&#125;)&#125;)public class MvcConfig extends WebMvcConfigurationSupport &#123; private static final Logger logger = Logger .getLogger(MvcConfig.class); /** * 描述 : &lt;注册视图处理器&gt;. &lt;br&gt; *&lt;p&gt; &lt;使用方法说明&gt; &lt;/p&gt; * @return */ @Bean public ViewResolver viewResolver() &#123; logger.info("ViewResolver"); InternalResourceViewResolver viewResolver = new InternalResourceViewResolver(); viewResolver.setPrefix("/WEB-INF/views/jsp/function/"); viewResolver.setSuffix(".jsp"); return viewResolver; &#125; /** * 描述 : &lt;注册消息资源处理器&gt;. &lt;br&gt; *&lt;p&gt; &lt;使用方法说明&gt; &lt;/p&gt; * @return */ @Bean public MessageSource messageSource() &#123; logger.info("MessageSource"); ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); messageSource.setBasename("config.messages.messages"); return messageSource; &#125; /** * 描述 : &lt;注册servlet适配器&gt;. &lt;br&gt; *&lt;p&gt; &lt;只需要在自定义的servlet上用@Controller("映射路径")标注即可&gt; &lt;/p&gt; * @return */ @Bean public HandlerAdapter servletHandlerAdapter()&#123; logger.info("HandlerAdapter"); return new SimpleServletHandlerAdapter(); &#125; /** * 描述 : &lt;本地化拦截器&gt;. &lt;br&gt; *&lt;p&gt; &lt;使用方法说明&gt; &lt;/p&gt; * @return */ @Bean public LocaleChangeInterceptor localeChangeInterceptor()&#123; logger.info("LocaleChangeInterceptor"); return new LocaleChangeInterceptor(); &#125; /** * 描述 : &lt;基于cookie的本地化资源处理器&gt;. &lt;br&gt; *&lt;p&gt; &lt;使用方法说明&gt; &lt;/p&gt; * @return */ @Bean(name="localeResolver") public CookieLocaleResolver cookieLocaleResolver()&#123; logger.info("CookieLocaleResolver"); return new CookieLocaleResolver(); &#125; /** * 描述 : &lt;添加拦截器&gt;. &lt;br&gt; *&lt;p&gt; &lt;使用方法说明&gt; &lt;/p&gt; * @param registry */ @Override protected void addInterceptors(InterceptorRegistry registry) &#123; // TODO Auto-generated method stub logger.info("addInterceptors start"); registry.addInterceptor(localeChangeInterceptor()); logger.info("addInterceptors end"); &#125; /** * 描述 : &lt;资源访问处理器&gt;. &lt;br&gt; *&lt;p&gt; &lt;可以在jsp中使用/static/**的方式访问/WEB-INF/static/下的内容&gt; &lt;/p&gt; * @param registry */ @Override protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123; logger.info("addResourceHandlers"); registry.addResourceHandler("/static/**").addResourceLocations("/WEB-INF/static/"); &#125; /** * 描述 : &lt;文件上传处理器&gt;. &lt;br&gt; *&lt;p&gt; &lt;使用方法说明&gt; &lt;/p&gt; * @return */ @Bean(name="multipartResolver") public CommonsMultipartResolver commonsMultipartResolver()&#123; logger.info("CommonsMultipartResolver"); return new CommonsMultipartResolver(); &#125; /** * 描述 : &lt;异常处理器&gt;. &lt;br&gt; *&lt;p&gt; &lt;系统运行时遇到指定的异常将会跳转到指定的页面&gt; &lt;/p&gt; * @return */ @Bean(name="exceptionResolver") public SimpleMappingExceptionResolver simpleMappingExceptionResolver()&#123; logger.info("CP_SimpleMappingExceptionResolver"); SimpleMappingExceptionResolver simpleMappingExceptionResolver= new SimpleMappingExceptionResolver(); simpleMappingExceptionResolver.setDefaultErrorView("common_error"); simpleMappingExceptionResolver.setExceptionAttribute("exception"); Properties properties = new Properties(); properties.setProperty("java.lang.RuntimeException", "common_error"); simpleMappingExceptionResolver.setExceptionMappings(properties); return simpleMappingExceptionResolver; &#125;&#125; 此时debug模式运行项目，会看到WebMvcAutoConfiguration没有被自动配置，说明我们自己定义的MvcConfig已经完全接管了默认的自动配置，这是因为WebMvcAutoConfiguration有一个条件注解:1@ConditionalOnMissingBean(&#123;WebMvcConfigurationSupport.class&#125;) 而我们本例中MvcConfig就是WebMvcConfigurationSupport的实现类，同时加入@EnableWebMvc注解也会导入一个WebMvcConfigurationSupport的实现类：DelegatingWebMvcConfiguration，所以MvcConfig继承WebMvcConfigurationSupport不是必须的，但是可以方便我们编码。 参考：SpringMVC4零配置–Web上下文配置【MvcConfig】 如果希望可以继续使用WebMvcAutoConfiguration的自动配置，而只是需要修改或者增加MVC中的某些配置时，我们可以创建一个配置类，并继承于抽象类WebMvcConfigurerAdapter，我们可以通过实现抽象类的方法来注册自己的控制器。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public abstract class WebMvcConfigurerAdapter implements WebMvcConfigurer &#123; public WebMvcConfigurerAdapter() &#123; &#125; public void configurePathMatch(PathMatchConfigurer configurer) &#123; &#125; public void configureContentNegotiation(ContentNegotiationConfigurer configurer) &#123; &#125; public void configureAsyncSupport(AsyncSupportConfigurer configurer) &#123; &#125; public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; &#125; public void addFormatters(FormatterRegistry registry) &#123; &#125; public void addInterceptors(InterceptorRegistry registry) &#123; &#125; public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; &#125; public void addCorsMappings(CorsRegistry registry) &#123; &#125; public void addViewControllers(ViewControllerRegistry registry) &#123; &#125; public void configureViewResolvers(ViewResolverRegistry registry) &#123; &#125; public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) &#123; &#125; public void addReturnValueHandlers(List&lt;HandlerMethodReturnValueHandler&gt; returnValueHandlers) &#123; &#125; public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; &#125; public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; &#125; public void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; exceptionResolvers) &#123; &#125; public void extendHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; exceptionResolvers) &#123; &#125; public Validator getValidator() &#123; return null; &#125; public MessageCodesResolver getMessageCodesResolver() &#123; return null; &#125;&#125; 比如我们可以增加一个视图跳转控制器，如下：1234567@Configurationpublic class WebMvcConfig extends WebMvcConfigurerAdapter&#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController("/demo/123").setViewName("/demo"); &#125;&#125; 注册Servlet、Filter、Listener的方法1.如果是war包项目，我们可以将Servlet、Filter、Listener注册到WebApplicationInitializer的实现类中123456789101112131415161718192021222324252627282930@Order(1)public class CommonInitializer implements WebApplicationInitializer &#123; @Override public void onStartup(ServletContext servletContext) throws ServletException &#123; //Log4jConfigListener servletContext.setInitParameter("log4jConfigLocation", "classpath:log4j.properties"); servletContext.addListener(Log4jConfigListener.class); //OpenSessionInViewFilter OpenSessionInViewFilter hibernateSessionInViewFilter = new OpenSessionInViewFilter(); FilterRegistration.Dynamic filterRegistration = servletContext.addFilter( "hibernateFilter", hibernateSessionInViewFilter); filterRegistration.addMappingForUrlPatterns( EnumSet.of(DispatcherType.REQUEST, DispatcherType.FORWARD, DispatcherType.INCLUDE), false, "/"); //DemoServlet DemoServlet demoServlet = new DemoServlet(); ServletRegistration.Dynamic dynamic = servletContext.addServlet( "demoServlet", demoServlet); dynamic.setLoadOnStartup(2); dynamic.addMapping("/demo_servlet"); &#125;&#125; 2.如果是jar包部署方式，则可以将其注册到任意一个@Configuration配置类中1234567891011121314151617181920212223242526272829303132333435@Configurationpublic class WebConfig &#123; @Bean public ServletRegistrationBean servletRegistrationBean_demo1()&#123; return new ServletRegistrationBean(new DemoServlet(),"/demo-servlet1"); &#125; @Bean public ServletRegistrationBean servletRegistrationBean_demo2()&#123; ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean(); servletRegistrationBean.addUrlMappings("/demo-servlet2"); servletRegistrationBean.setServlet(new DemoServlet2()); return servletRegistrationBean; &#125; @Bean public FilterRegistrationBean filterRegistrationBean()&#123; FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(); filterRegistrationBean.setFilter(new OpenSessionInViewFilter()); Set&lt;String&gt; set = new HashSet&lt;String&gt;(); set.add("/"); filterRegistrationBean.setUrlPatterns(set); return filterRegistrationBean; &#125; @Bean public ServletListenerRegistrationBean servletListenerRegistrationBean()&#123; ServletListenerRegistrationBean servletListenerRegistrationBean = new ServletListenerRegistrationBean(); servletListenerRegistrationBean.setListener(new Log4jConfigListener()); servletListenerRegistrationBean.addInitParameter("log4jConfigLocation","classpath:log4j.properties"); return servletListenerRegistrationBean; &#125;&#125; 总结一句话概括SpringBoot的自动配置–就是一组基于条件注解实现Bean注册的Spring配置类。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring Boot学习笔记01--基本介绍]]></title>
      <url>%2F2016%2F12%2F09%2Fspring-boot-study%2F</url>
      <content type="text"><![CDATA[摘要看完本文你将掌握如下知识点： 如何搭建一个SpringBoot项目 SpringBoot自动配置原理 SpringBoot属性配置方法 修改默认的Logback日志为log4j和log4j2的方法 修改默认的内置tomcat容器为Jetty容器和Undertow容器的方法 SpringBoot单元测试方法 使用war包运行项目 SpringBoot系列：Spring Boot学习笔记 Spring Boot简介 要我给Spring Boot做个定义，简单来说就是一个基于强大的Spring框架的、推崇JavaConfig的极简配置的web开发框架； Spring Boot通过内嵌Servlet容器（Tomcat、Jetty，等等）的方式，可以以jar包的形式独立运行一个web项目； Spring Boot提倡JavaConfig和注解的零配置方式，并且默认配置满足绝大多数场景的需要，意味着少量修改默认配置即可快速搭建一个web项目，极大的提高开发效率； 项目中加入某一个spring-boot-starter-*依赖，就可以引入该功能的完整jar包，降低pom的复杂度 本文基于Spring Boot的版本为1.4.2.RELEASE Spring Boot项目创建方法 http://start.spring.io：可以通过网页创建项目结构并下载； Spring Boot CLI：通过命令行的方式创建Spring Boot项目； Spring Tool Suite：习惯Eclipse的用户可以使用STS创建『Spring Starter Project』项目; IntelliJ IDEA：强大的生产力工具，推荐使用，创建『Spring Initializr』项目; 使用IntelliJ IDEA创建一个web项目 新建Spring Initializr项目 说明：Spring Boot要求JDK1.6+ 填写项目信息，构建工具使用maven 选择项目使用的依赖，这里我们只需要勾选web Spring Boot当前最新的稳定版是1.4.2； 所有依赖可以在创建时勾选，也可以在创建后手工将依赖添加到pom中，如果对依赖比较熟悉，推荐手工添加，这样可以加快创建项目的时间； 填写项目名称，点击Finish 新建的项目结构如下 SpringBoot项目只会在项目根目录下生成一个类–SpringBootWebDemoApplication(artifactId+Application)，它就是一个带有main函数的启动类； 123456789101112package com.example;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class SpringBootWebDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootWebDemoApplication.class, args); &#125;&#125; pom.xml说明12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;springbootwebdemo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;SpringBootWebDemo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;!-- 创建的Springboot项目需要继承于spring-boot-starter-parent --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- 创建项目是勾选的web依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 每个项目都会自动添加一个test依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- Springboot的编译插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 这就是一个web项目的pom文件，可以看到只关联了很少的依赖，这是因为我们继承的spring-boot-starter-parent和关联的spring-boot-starter-web本身已经为我们关联了全部的依赖，如下是该项目所有的依赖包 运行Spring Boot项目 maven运行：mvn spring-boot:run； main函数运行：右键单击SpringBootWebDemoApplication，选择『Run 或者 Debug』； 推荐安装JRebel插件，支持热部署； 当然，也可以maven先打成jar，然后通过命令行执行java -jar xx.jar； 运行成功会看到控制台打印了如下信息 可以看到打印信息中有tomcat的启动信息，说明springboot默认使用tomcat作为web运行容器，这点从上面的依赖包中也可以看到。因为当前项目并没有开放任何服务，所以此时访问8080端口会提示无服务 添加服务 我们可以在项目中创建一个Controller控制器，比如DemoController 12345678910111213package com.example.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class DemoController &#123; @RequestMapping("/") String index()&#123; return "Hello Spring Boot!"; &#125;&#125; 运行SpringBootWebDemoApplication，再次访问http://localhost:8080 一切似乎就是那么美好，我们什么都没配置，一个web项目就这样运行起来了，SpringBoot自动帮我们默认了一些常用的配置 自动配置原理说明SpringBootWebDemoApplication类上的注解：@SpringBootApplication123456789101112131415161718192021222324252627282930313233343536373839404142434445package org.springframework.boot.autoconfigure;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import org.springframework.boot.SpringBootConfiguration;import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.boot.context.TypeExcludeFilter;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.FilterType;import org.springframework.context.annotation.ComponentScan.Filter;import org.springframework.core.annotation.AliasFor;@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;)&#125;)public @interface SpringBootApplication &#123; Class&lt;?&gt;[] exclude() default &#123;&#125;; String[] excludeName() default &#123;&#125;; @AliasFor( annotation = ComponentScan.class, attribute = "basePackages" ) String[] scanBasePackages() default &#123;&#125;; @AliasFor( annotation = ComponentScan.class, attribute = "basePackageClasses" ) Class&lt;?&gt;[] scanBasePackageClasses() default &#123;&#125;;&#125; @SpringBootConfiguration实际上就是@Configuration，说明这是一个JavaConfig @ComponentScan，启用注解自动扫描 @EnableAutoConfiguration的作用是根据类路径中jar包是否存在来决定是否开启某一个功能的自动配置，比如，我们项目中添加了spring-boot-starter-web依赖，因其关联Tomcat和Srping MVC，所以类路径下就会存在Tomcat和Spring MVC的jar包，SpringBoot项目扫描到这些jar包后会自动开启两者的配置，当然，这个配置是默认配置，我们可以根据需要进行修改（下文介绍）。 exclude和excludeName用于关闭指定的自动配置，比如关闭数据源相关的自动配置 1@SpringBootApplication(exclude=&#123;DataSourceAutoConfiguration.class&#125;) scanBasePackages和scanBasePackageClasses用于指定扫描的路径，默认情况下会自动扫描被@SpringBootApplication注解的类（这里是SpringBootWebDemoApplication）的同级包以及子包中的Bean。比如我们创建的DemoController，因为开启了SpringMVC自动配置，同时又在对应的路径下，所以该Controller会被自动加载。比如我们这里指定扫描的包路径如下： 1@SpringBootApplication(scanBasePackages = &#123;"com.temp.Controller"&#125;) 再次运行程序，发现原来的DemoController不能被访问了，而『com.temp.Controller』下的controller却可以被访问。 那么问题来了，SpringBoot到底为我们自动配置了哪些功能呢？ 开启Debug模式，方式有多种: java -jar xx.jar –debug 在IDE中执行Run时添加VM arguments:-Ddebug 在项目resources下的application.properties文件中增加debug=true Debug模式运行程序，打印信息中会显示如下内容 启动的自动配置未启用的自动配置 从打印结果中看到，每一个*AutoConfiguration*都对应着一类功能的自动配置类，比如HttpEncodingAutoConfiguration: 1234HttpEncodingAutoConfiguration matched: - @ConditionalOnClass found required class &apos;org.springframework.web.filter.CharacterEncodingFilter&apos; (OnClassCondition) - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition) - @ConditionalOnProperty (spring.http.encoding.enabled) matched (OnPropertyCondition) 开启的自动配置中都会有@ConditionalOnClass、@ConditionalOnWebApplication等标识，这是什么意思呢？为了弄清楚这个，我们需要先来认识一下@EnableAutoConfiguration； @EnableAutoConfiguration12345678910111213141516171819202122232425package org.springframework.boot.autoconfigure;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import org.springframework.boot.autoconfigure.AutoConfigurationPackage;import org.springframework.boot.autoconfigure.EnableAutoConfigurationImportSelector;import org.springframework.context.annotation.Import;@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(&#123;EnableAutoConfigurationImportSelector.class&#125;)public @interface EnableAutoConfiguration &#123; String ENABLED_OVERRIDE_PROPERTY = "spring.boot.enableautoconfiguration"; Class&lt;?&gt;[] exclude() default &#123;&#125;; String[] excludeName() default &#123;&#125;;&#125; 这里我们需要了解一下@Import注解中的EnableAutoConfigurationImportSelector 感兴趣的可以看一下源码，大体的功能就是扫描jar包里是否含有META-INF/spring.factories文件;并在spring.factories中找到@EnableAutoConfiguration的全路径名称org.springframework.boot.autoconfigure.EnableAutoConfiguration这个key，该key对应的value就是用于声明都需要启用哪些自动配置类;比如spring-boot-autoconfigure-1.4.2.RELEASE.jar中就有一个spring.factories，可以看到org.springframework.boot.autoconfigure.EnableAutoConfiguration参数中列出了自动配置类列表，而HttpEncodingAutoConfiguration这个自动配置类就是其声明的; HttpEncodingAutoConfiguration 先看下源码 12345678910111213141516171819202122232425262728@Configuration@EnableConfigurationProperties(&#123;HttpEncodingProperties.class&#125;)@ConditionalOnWebApplication@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;)@ConditionalOnProperty( prefix = "spring.http.encoding", value = &#123;"enabled"&#125;, matchIfMissing = true)public class HttpEncodingAutoConfiguration &#123; private final HttpEncodingProperties properties; public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) &#123; this.properties = properties; &#125; @Bean @ConditionalOnMissingBean(&#123;CharacterEncodingFilter.class&#125;) public CharacterEncodingFilter characterEncodingFilter() &#123; OrderedCharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE)); return filter; &#125; //.......省略以下........&#125; 熟悉JavaConfig的都会明白，这就是一个配置类@Configuration，并且通过@Bean注册了一个CharacterEncodingFilter; 但是还有一些注解，是什么意思呢，我们分别说明： @EnableConfigurationProperties：开启属性注入 本例中表示HttpEncodingProperties是属性类，并使用@Autowired自动注入；属性类实际上是一个是注解了@ConfigurationProperties的JavaBean，SpringBoot将属性文件（application.properties）中的键值对与JavaBean的属性建立起一一对应关系: 1234567891011121314@ConfigurationProperties( prefix = "spring.http.encoding" //属性值的前缀)/*举例：application.properties中设置如下属性spring.http.encoding.charset=UTF-8spring.http.encoding.force=true*/public class HttpEncodingProperties &#123; private Charset charset; private Boolean force; //....属性声明及set、get方法........ &#125; 所有@ConditionalOn开头的注解都是用于进行条件判断的 @ConditionalOnWebApplication：当前项目是web项目的条件下才加载当前配置类 @ConditionalOnClass：当类路径下有指定的类的条件下才加载当前配置类 12//本例表示，当前类路径（含jar）下必须存在CharacterEncodingFilter@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;) @ConditionalOnProperty：当指定的属性等于指定的值的情况下加载当前配置类 1234567// spring.http.encoding=enabled// matchIfMissing = true表示如果没有在application.properties设置该属性，则默认为条件符合@ConditionalOnProperty( prefix = "spring.http.encoding", value = &#123;"enabled"&#125;, matchIfMissing = true) @ConditionalOnMissingBean：当前容器里没有指定的Bean的情况下 12// 如果当前容器中找不到CharacterEncodingFilter实例，则创建当前的Bean@ConditionalOnMissingBean(&#123;CharacterEncodingFilter.class&#125;) 通过上面的分析，应该可以明白SpringBoot是如何做到自动配置的，简单总结如下： @SpringBootConfiguration实际上就是@Configuration，说明这是一个JavaConfig @EnableAutoConfiguration负责扫描jar包中的META-INF/spring.factories来找到要初始化的各种AutoConfiguration类 各种@Conditional注解决定哪些Bean可以被容器初始化 如果希望进一步了解SpringBoot的自动配置，建议查看每一个AutoConfiguration类的源码 除了上面介绍的，@Conditional注解还有如下形式 @ConditionalOnExpression：基于SpEL表达式作为条件判断 @ConditionalOnJava：基于JAVA版本作为判断条件 @ConditionalOnJndi：在JNDI存在的条件下查找指定的位置 @ConditionalOnMissingClass：当前类路径下没有指定的类的条件下 @ConditionalOnNotWebApplication：当前项目不是web项目的条件下 @ConditionalOnResource：类路径下是否有指定的值 @ConditionalOnSingleCandidate：当指定的Bean在容器中只有一个的情况下 如果我们希望自己创建一个自动配置类(AutoConfiguration)，则只需要在我们自己创建的JavaConfig中加上@ConditionalOn注解，并且在类路径下创建META-INF/spring.factories，加入参数org.springframework.boot.autoconfigure.EnableAutoConfiguration=xxxxAutoConfiguration SpringBoot的配置文件 SpringBoot支持常规的properties配置文件(application.properties)，还支持yaml语言的配置文件(application.yml) SpringBoot会从classpath下的/config目录或者classpath的根目录查找application.properties或application.yml 如果要修改SpringBoot自动配置中默认配置，可以通过在配置文件中配置相应的参数即可 比如，项目启动时，tomcat默认的端口号是『8080』，访问路径是『/』，修改如下： application.properties 12server.port=8081server.context-path=/demo application.yml 123server: port: 8081 context-path: /demo IntelliJ IDEA支持对properties和yml的代码提示功能，编辑起来还是很方便的，不需要特别记住这些属性名称 SpringBoot默认使用priperites进行配置 SpringBoot的属性可以通过多种方式指定，配置文件只是其中一种方式，常用的方式还有如下几种，按加载的优先级列出： 命令行参数：java -jar xx.jar --server.port=8081 --server.context-path=/demo操作系统环境变量：有些OS不支持使用.这种名字，如server.port，可以使用SERVER_PORT来配置。项目中的配置文件：application.properties或者application.yml项目依赖jar包中的配置文件：application.properties或者application.yml 关于SpringBoot支持的配置属性可以查看官网地址1.4.2.RELEASE Profile配置 不同的环境可以使用不同的配置文件，application-{profile}.properties，比如 开发：application-rnd.properties测试：application-release.properties验证：application-verify.properties生产：application-prod.properties 通过在application.properties(项目中必须包含该文件)中设置spring.profiles.active=prod来指定启用哪一个Profile。 关于属性配置还想多说的一些内容 application.properties也可以配置自定义属性：my.name=hanqf 通过@Value将属性注入Bean属性 12@Value("$&#123;my.name&#125;")private String myName; 通过@ConfigurationProperties将属性注入Bean对象 使用prefix123my.name=hanqfmy.servers[0]=rnd.hanqf.commy.servers[1]=release.hanqf.com 1234567@ConfigurationProperties(prefix="my")public class Config &#123; private String name; private List&lt;String&gt; servers = new ArrayList&lt;String&gt;();//list需要初始化 //....set and get method&#125; 不使用prefix123name=hanqfjdbc.username=rootjdbc.password=root 123456789101112@ConfigurationPropertiespublic class Config &#123; private String name; private Jdbc jdbc; class Jdbc &#123; private String username; private String password; //....set and get method &#125; //....set and get method&#125; 属性占位符 1234app.name=MyAppapp.description=$&#123;app.name&#125; is a Spring Boot application server.port=$&#123;port:8080&#125; # 如果没有设置port，则使用默认值8080 属性名匹配规则 123456@ConfigurationProperties(prefix="person")public class Config &#123; private String firstName; //....set and get method&#125; firstName可以使用的属性名如下：123person.firstName，标准的驼峰式命名person.first-name，虚线（-）分割方式，推荐在.properties和.yml配置文件中使用PERSON_FIRST_NAME，大写下划线形式，建议在系统环境变量中使用 日志配置 Spring Boot默认使用Logback作为日志框架，这是推荐的方式，如果希望修改为熟悉的log4j可以看下文 创建项目时我们引入了spring-boot-starter-web，其依赖spring-boot-starter，spring-boot-starter又依赖于spring-boot-starter-logging，该依赖内容就是Spring Boot默认的日志框架LogbackLogback相关设置，可以在application.properties中进行如下配置： 12345# 日志文件路径logging.file=D:/my_log.log # 配置日志打印级别logging.level.org.springframework=INFO 当然，也可以直接将自己的logback.xml放到项目根路径下 修改为log4j框架pom中排除对spring-boot-starter-logging的依赖，并加入对spring-boot-starter-log4j的依赖目前maven中央仓库的最新版本是1.3.8.RELEASE12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j&lt;/artifactId&gt; &lt;version&gt;1.3.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; 项目根路径下添加log4j.properties 修改为log4j2框架与log4j类似，修改pom，增加spring-boot-starter-log4j2依赖目前maven中央仓库的最新版本是1.4.2.RELEASE12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt; &lt;version&gt;1.4.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; 项目根路径下添加log4j2.xml 说明这里需要说明一个问题，如果切换为其它log框架，debug=true将会失效，需要在各自的log配置文件中声明，比如log4j需要添加log4j.logger.org.springframework.boot=debug 修改内置Tomcat为Jetty 修改pom，去除spring-boot-starter-tomcat的依赖，增加spring-boot-starter-jetty依赖目前maven中央仓库的最新版本是1.4.2.RELEASE 12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;version&gt;1.4.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; application.properties中的属性配置与tomcat一致 修改内置Tomcat为Undertow容器 修改pom，去除spring-boot-starter-tomcat的依赖，增加spring-boot-starter-undertow依赖目前maven中央仓库的最新版本是1.4.2.RELEASE 12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt; &lt;version&gt;1.4.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; application.properties中的属性配置与tomcat一致 单元测试 创建一个单元测试的抽象父类，用于初始化必要的对象 123456789101112131415161718192021222324252627package com.common;import org.junit.Before;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.setup.MockMvcBuilders;import org.springframework.web.context.WebApplicationContext;@RunWith(SpringRunner.class)//1.4.2.RELEASE中不再需要@SpringApplicationConfiguration和@WebAppConfiguration@SpringBootTest public abstract class SpringBootTestParent &#123; public MockMvc mockMvc; @Autowired WebApplicationContext webApplicationContext; @Before public void setUp() throws Exception &#123; mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build(); &#125;&#125; 继承抽象父类，并实现测试逻辑 123456789101112131415161718192021222324public class SpringBootWebDemoApplicationTests extends SpringBootTestParent&#123; @Autowired DemoService demoService; @Test public void content()&#123; String content = "456"; System.out.println(demoService.printContent(content)); Assert.assertEquals(content,demoService.printContent(content)); &#125; @Test public void DemoControllerContent()&#123; String uri = "/content/123"; MvcResult mvcResult; try &#123; mvcResult = mockMvc.perform(MockMvcRequestBuilders.get(uri)).andReturn(); System.out.println(mvcResult.getResponse().getStatus() + "##" + mvcResult.getResponse().getContentAsString()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 使用war包的形式运行项目上面我们介绍了SpringBoot通过jar的形式运行项目的方法，这也是SpringBoot推荐的方式，因其内置Servlet容器，所以发布和部署都非常方便，但是某些情况下（比如使用JSP作为VIEW层，内置容器的形式并不能支持），我们希望将web项目部署到自己的容器中，这时候就需要将SpringBoot项目打成war包部署，有两种方式：1.创建项目时打包方式选择：war war项目目录结构 2.将原打包方式为jar的项目修改为war形式与war项目对比发现，通过修改如下内容，可以将jar项目修改为war项目2.1 pom中将&lt;packaging&gt;jar&lt;/packaging&gt;==&gt;&lt;packaging&gt;war&lt;/packaging&gt;2.2 pom中添加tomcat依赖，显示声明scope为provided，这样打包时就不会将tomcat的jar包打到war中12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 2.3 创建ServletInitializer类123456public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; return application.sources(DemoWarApplication.class); &#125;&#125; 说明 Servlet3.0规范，支持将web.xml相关配置也硬编码到代码中，并由javax.servlet.ServletContainerInitializer的实现类负责在容器启动时进行加载 spring提供了一个实现类org.springframework.web.SpringServletContainerInitializer,该类会调用所有org.springframework.web.WebApplicationInitializer的实现类的onStartup(ServletContext servletContext)方法，从而将相关的容器组件注册到容器； SpringBootServletInitializer就是WebApplicationInitializer的实现类； 我之前写过一篇SpringMVC4零配置的文章，对零配置感兴趣的同学可以参考。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown编辑器--Sublime Text和Atom]]></title>
      <url>%2F2016%2F12%2F06%2Fmd-subl-atom%2F</url>
      <content type="text"><![CDATA[摘要 Markdown 是一种轻量级的「标记语言」，相对于更为复杂的 HTML 标记语言来说Markdown的语法十分简单。Markdown百度百科； Markdown语法说明『中文』，『英文』，Hexo就是基于Markdown语法； 支持Markdown的编辑器很多，这里推荐使用Sublime Text和Atom，因为这两种编辑器对于喜欢编程的人来说都非常熟悉，支持多种语法并且跨平台，所以如果你已经在使用其中之一，就没必要为了使用markdown再安装其它的编辑器了； Sublime Text 官方网站 Sublime默认不支持Markdown语法，需要安装插件，而要为Sublime Text安装插件，需要先安装package control； Package Control安装方法，简单说就是按『ctrl+`』调出控制台，并根据Sublime Text的版本粘贴相应的脚本并回车执行； 安装完成后按ctrl+shift+p (Win, Linux) or cmd+shift+p (OS X)，调出『Command Palette』，输入package control install回车，等待左下角的缓冲结束会弹出一个输入框，我们在里面输入插件的名称，即可快速筛选出可用的插件； 安装markdown编辑插件：MarkdownEditing 在弹出的输入框中输入MarkdownEditing，回车安装，安装后需要重新启动Sublime Text； 新建文件后缀为md，则会自动开启markdown语法支持； 非md后缀文件，可以按ctrl+shift+p (Win, Linux) or cmd+shift+p (OS X)，调出『Command Palette』，输入markdown回车来开启markdown语法支持； 安装markdown查看插件：OmniMarkupPreviwer 在弹出的输入框中输入OmniMarkupPreviwer，回车安装，安装后需要重新启动Sublime Text； 打开markdown的文档，按ctrl+alt+o (Win, Linux) or cmd+alt+o (OS X)，会打开浏览器对当前文档查看效果； 可以通过下面的方式查看所有安装的插件，并对其进行个性化配置； Atom 官方网站 Atom是github开发的开源跨平台的编辑器，Atom的强大可以与大名鼎鼎的Sublime Text相媲美。其使用方式与Sublime Text类似，所以如果会使用Sublime Text，上手Atom会很快。而且与Sublime Text相比，Atom是免费的，但是由于其安装包大小接近百兆，所以对于轻量级编辑器来说略显笨重； Atom内置了对markdown的支持，编辑markdown文档时，按ctrl+shift+M即可打开实时预览窗口，这点比Sublime Text方便很多； 对于非md结尾的文档，可以通过点击右下角的语法格式条，在弹出筛选框输入markdown进行语法切换； 可以按ctrl+, (Win, Linux) or cmd+,(OS X)，调出Atom的Settings，对其进行设置以及插件的管理; 总结 Atom相比Sublime Text来说一个新的产物，目前还不是很普及，不过Atom从一开始就整合了Sublime Text优点，同时提供了更友好的配置和管理方式，安装与卸载插件更加的方便； 编程时我们经常喜欢使用snippets+tab补全的方式来快速生成代码块，Atom和Sublime Text都支持snippets Atom 按ctrl+shift+p (Win, Linux) or cmd+shift+p (OS X)，调出『Command Palette』，输入Snippet: Available，可以调出snippets筛选框； Sublime Text 按ctrl+shift+p (Win, Linux) or cmd+shift+p (OS X)，调出『Command Palette』，输入Snippet:，可以调出snippets筛选框； 在Atom的Settings中，我们可以搜索相应的插件，并点击『settings』，可以在其中查看到其所支持的snippets，语法与Sublime Text一致；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo--解决百度不能索引git page的问题]]></title>
      <url>%2F2016%2F12%2F05%2Fhexo-baidu-coding%2F</url>
      <content type="text"><![CDATA[摘要 由于git page网站对百度spider进行了屏蔽，所以导致了百度是无法对我们发布在git page上的网站进行索引； 解决方式是将我们的代码发布到国内的coding站点，其同样可以提供代码托管和Pages服务； Coding配置 Coding站点地址，注册个帐号 新建一个项目，比如： 设置SSH公钥，实现免密提交代码，如下图，将我们设置github page时生成的公钥填入其中，这里注意，要去掉最后面的邮箱地址。参考 新建coding-pages分支，并设置为默认 开启Pages服务 注意，此时提交代码后，可以通过http://hanqunfeng.coding.me访问 Hexo配置 hexo支持多仓库发布 1234567deploy:- type: git repo: https://github.com/hanqunfeng/hanqunfeng.github.io.git branch: master- type: git repo: https://git.coding.net/hanqunfeng/hanqunfeng.git branch: coding-pages 执行hexo d，会将代码同时发布到github和coding 域名解析–Dnspod 因为代码同时发布到github和coding，所以我希望国内用户访问coding，国外用户访问github，这样可以提高访问效率； 使用Dnspod实现域名解析，其支持让来源为指定线路的用户访问特定的地址； 注册一个Dnspod帐号，注册成功后在【域名解析】中添加一个域名，我这里添加的就是hanqunfeng.com； 添加成功后会自动解析出两个记录类型为A的记录，选择导入； 之后手工添加两条记录，一个CNAME到hanqunfeng.github.io.【国外】，一个CNAME到hanqunfeng.coding.me.【国内】，如下： 注意记录值最后都要加个点 修改万网的域名DNS 因为我的域名是在万网购买的，所以要想Dnspod起作用，需要修改万网中的DNS为Dnspod提供的地址； 万网域名修改 DNS 方法12f1g1ns1.dnspod.netf1g1ns2.dnspod.net Coding Pages服务中配置映射域名]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo--百度和谷歌搜索引擎索引方法]]></title>
      <url>%2F2016%2F12%2F05%2Fhexo-baidu-google%2F</url>
      <content type="text"><![CDATA[摘要 让百度和谷歌搜索引擎对当前站点进行索引的方法。 由于国内对谷歌的访问限制，所以可以使用chrome浏览器安装『谷歌访问助手』插件，安装方法 百度搜索 需要拥有百度帐号，并进行网站验证，因为我已经验证过blog.hanqunfneg.com，所以这里为了演示，使用www.hanqunfeng.com进行验证。 推荐『HTML 文件上传』的方式进行验证 将百度的验证文件，如我的是baidu_verify_5T5OVCioxp.html下载到本地，并拷贝到source目录下，并在文件上方增加如下内容,这样可以保证该文件不会被编译： 123layout: false---5T5OVCioxp 编译并发布，之后在刚才的下载页面进行验证 谷歌搜索 需要拥有谷歌帐号，并进行网站验证 推荐『HTML 文件上传』的方式进行验证 将谷歌的验证文件，如我的是googleea53a22ff4210278.html下载到本地，并拷贝到source目录下，并在文件上方增加如下内容,这样可以保证该文件不会被编译： 123layout: false---google-site-verification: googleea53a22ff4210278.html 编译并发布，之后在刚才的下载页面进行验证 插件站点地图安装 分别使用以下命令来安装针对百度和Google的地图插件，在站点的根目录下执行以下命令： 12$ npm install hexo-generator-sitemap --save$ npm install hexo-generator-baidu-sitemap --save 配置hexo的站点配置文件_config.yml 1234567891011#启用相应插件Plugins:- hexo-generator-sitemap- hexo-generator-baidu-sitemap#配置站点地图文件#sitemapsitemap: path: sitemap.xml baidusitemap:path: baidusitemap.xml 执行hexo g，当你成功编译并在Public目录下生成对应的baidusitemap.xml(针对百度)，sitemap.xml(针对Google)表明你已经成功建立的站点地图。 收录站点地图 百度推送 入口：百度站长–网页抓取–链接提交 谷歌推送 入口：Google Search Console–抓取–站点地图 百度推送方式–自动推送 索引效率：主动推送&gt;自动推送&gt;sitemap 百度的网站上有说明，地址 将自动推送的js脚本拷贝到themes\next\layout\_partials\footer.swig文件的最下方即可]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[学习笔记]]></title>
      <url>%2F2016%2F12%2F02%2Fbook%2F</url>
      <content type="text"><![CDATA[资料列表 CentOS7下zabbix3.2的安装及使用 Rancher–Docker的管理控制台 git学习笔记]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Dubbo初体验]]></title>
      <url>%2F2016%2F12%2F01%2Fdubbo_dubbox%2F</url>
      <content type="text"><![CDATA[摘要 官网地址，官网有完整的资料以帮助使用者快速熟悉dubbo，不过目前相关下载地址已经失效，代码已经迁移到github，请参看下面的代码地址，自行编译打包 dubbo代码地址 2.5.4(官方版本)，基于spring3.2.16.RELEASE 2.8.4(第三方基于2.5.3修改)，基于spring3.2.9.RELEASE,项目名称为dubbox，但生成的包名依然是dubbo git、maven、jdk、tomcat、nexus请自行安装，我安装的版本如下 git version 2.9.3Apache Maven 3.3.9java version “1.8.0_31”tomcat version 8.5.4nexus version 2.5.0-04 编译打包以dubbo2.8.4为例 git clone https://github.com/dangdangdotcom/dubbox.git cd dubbox mvn clean package install -Dmaven.test.skip=true 发布dubbo2.8.4到nexus的3rd party仓库 登录nexus，设置3rd party的Deployment Policy=Allow Redeploy(在Configuration中配置) vi ~/.m2/settings.xml，在servers中增加如下配置 12345&lt;server&gt; &lt;id&gt;thirdparty&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt; 修改dubbox的pom.xml，增加如下配置 123456&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;thirdparty&lt;/id&gt; &lt;url&gt;http://192.168.36.49:8080/nexus/content/repositories/thirdparty/&lt;/url&gt; &lt;/repository&gt;&lt;/distributionManagement&gt; mvn clean package deploy -Dmaven.test.skip=true 发布dubbo2.5.4到nexus的3rd party仓库 因为目前2.5.4是Snapshots版本，所以不能直接发布到3rd party中，如果要发布到3rd party，需要修改pom.xml，去掉版本号中的Snapshots，比如在intellij IDEA中，使用快捷键Command+Shift+R； dubbo包含四个组件 Provider: 暴露服务的服务提供方。这里我们自己提供(基于2.8.4)； Consumer: 调用远程服务的服务消费方。这里我们自己提供(基于2.8.4)； Registry: 服务注册与发现的注册中心。这里使用zookeeper； Monitor: 统计服务的调用次调和调用时间的监控中心。这里介绍两个，一个是dubbo提供的dubbo-monitor-simple，另一个是第三方对dubbo-monitor-simple的改进版本：改版的monitor(基于2.8.4) 下面分别介绍：顺序为Registry，Provider，Consumer，Monitor。 ZooKeeper Registry注册中心官网地址 下载安装1234$ wget http://apache.fayea.com/zookeeper/zookeeper-3.4.9/zookeeper-3.4.9.tar.gz$ tar zxvf zookeeper-3.4.9.tar.gz$ cd zookeeper-3.4.9$ cp conf/zoo_sample.cfg conf/zoo.cfg 配置$ vi conf/zoo.cfg123456tickTime=2000initLimit=10syncLimit=5#实际上只需要配置dataDir，这里修改为自己的存储目录dataDir=/usr/local/zookeeper-3.4.9/dataclientPort=2181 集群配置 分别在两台主机上按上述方法安装zookeeper，比如两台主机的IP分别为192.168.37.144、192.168.37.143； 分别在两台主机的zoo.cfg中增加如下配置 12server.1=192.168.37.144:2555:3555server.2=192.168.37.143:2555:3555 在144主机的dataDir指定的目录(/usr/local/zookeeper-3.4.9/data)下创建文件myid vi myid设置内容为1 #就是zoo.cfg中server.后面对应的数字 同理将143的myid文件中内容设置为2 开放端口 两台主机分别开放2181，2555，3555端口vi /etc/sysconfig/iptablse，加入如下内容 1234#zookeeper-A INPUT -p tcp -m state --state NEW -m tcp --dport 2181 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 2555 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 3555 -j ACCEPT 重启iptables 启动与关闭zookeeper./bin/zkServer.sh start./bin/zkServer.sh stop 查看在zookeeper中注册的信息echo dump | nc 192.168.37.144 2181ORtelnet 192.168.37.144 2188dump 关于Provider&amp;Consumer，阿里官方的实例很详细了，网上也有很多资料，这里只做简单的说明，示例项目依赖于dubbo2.8.4,spring替换为4.3.3，使用中并未见异常，示例源码地址:https://github.com/hanqunfeng/DubboStudy Provider 服务提供者123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt; &lt;!-- 一个项目中只能有一个dubbo:application配置项 --&gt; &lt;dubbo:application name="demo-provider" owner="hanqf" organization="dubbox"/&gt; &lt;!-- 使用zookeeper注册中心暴露服务地址--&gt; &lt;dubbo:registry address="zookeeper://192.168.37.144:2181?backup=192.168.37.143:2181" timeout="50000"/&gt; &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt; &lt;dubbo:protocol name="dubbo" port="20880"/&gt; &lt;!-- 声明需要暴露的服务接口 服务实现类是通过注解注册的，所以此处不需要声明实现类 --&gt; &lt;dubbo:service interface="web.function.demo.service.DemoService" ref="demoService"/&gt; &lt;dubbo:service interface="web.function.demo.service.Demo2Service" ref="demo2Service"/&gt; &lt;!-- 启用monitor服务，只有配置这个，才会主动向monitor推送信息 --&gt; &lt;dubbo:monitor protocol="registry" /&gt;&lt;/beans&gt; 不同的Provider之间可以使用相同的应用名称（比如这里是name=”demo-provider”），因为注册的服务只基于服务所在服务器的ip地址和dubbo协议开放的端口号，两者有一个不相同即可，但是不建议这样做。 对于提供相同服务的Provider，也就是副本（同一个war包，部署到不同主机），则可以不去修改name，但是对于提供不同服务的Provider，不要使用相同的name，这样不便于在monitor中查看。 对于同一个Provider，要在同一台主机中部署（同一个war包，部署到同一台主机），则需要修改duboo协议端口，比如示例代码中的dubbo-provider和dubbo-provider02，因为两者提供相同的服务，所以应用名称相同，但是因为都在本机部署，所以一个用20880，一个使用20881 Consumer 服务消费者12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt; &lt;dubbo:application name="demo-consumer" owner="hanqf" organization="dubbox"/&gt; &lt;!-- 设置check的缺省值，如果配置中有显式的声明，如：&lt;dubbo:reference check="true"/&gt;，不会受影响 --&gt; &lt;!-- 关闭所有服务的启动时检查,注意：如果关闭某个服务的启动时检查，需要在指定的服务单独配置check="false" --&gt; &lt;dubbo:consumer check="false" /&gt; &lt;dubbo:registry protocol="zookeeper" address="192.168.37.144:2181,192.168.37.143:2181" timeout="50000"/&gt; &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt; &lt;dubbo:protocol name="dubbo" port="20880"/&gt; &lt;!-- 声明需要暴露的服务接口 --&gt; &lt;dubbo:reference interface="web.function.demo.service.DemoService" id="demoService" timeout="50000"/&gt; &lt;dubbo:reference interface="web.function.demo.service.Demo2Service" id="demo2Service" timeout="50000"/&gt; &lt;dubbo:monitor protocol="registry" /&gt;&lt;/beans&gt; Consumer和Provider如果部署在同一台主机，可以使用相同的dubbo协议端口，两者不受影响 关于相关配置属性的说明，还是参考官方资料吧，在dubbo源码中已经包含了Consumer和Provider的示例，可以作为参考。 Monitordubbo-monitor-simple 简易监控中心 dubbo项目源码中已经自带了一个Monitor，就是dubbo-monitor-simple，使用maven编译后，会在dubbox/dubbo-simple/dubbo-monitor-simple/target下生成dubbo-monitor-simple-2.8.4-assembly.tar.gz 将dubbo-monitor-simple-2.8.4-assembly.tar.gz拷贝的合适的地方并解压 123$ tar -zxvf dubbo-monitor-simple-2.8.4-assembly.tar.gz$ cd dubbo-monitor-simple-2.8.4$ vi conf/dubbo.properties 主要修改zookeeper地址、端口、绘图目录（该目录必须手工创建，比如这里是/Users/hanqunfeng/monitor）： 1234567891011121314dubbo.container=log4j,spring,registry,jettydubbo.application.name=simple-monitordubbo.application.owner=#dubbo.registry.address=multicast://224.5.6.7:1234dubbo.registry.address=zookeeper://192.168.37.144:2181?backup=192.168.37.143:2181#dubbo.registry.address=redis://127.0.0.1:6379#dubbo.registry.address=dubbo://127.0.0.1:9090dubbo.protocol.port=7070dubbo.jetty.port=8085dubbo.jetty.directory=/Users/hanqunfeng/monitordubbo.charts.directory=$&#123;dubbo.jetty.directory&#125;/chartsdubbo.statistics.directory=/Users/hanqunfeng/monitor/statisticsdubbo.log4j.file=logs/dubbo-monitor-simple.logdubbo.log4j.level=WARN 启动与关闭 ./bin/start.sh./bin/stop.sh 浏览器访问http://localhost:8085，图表中的效果是注册了Provider，Consumer的效果 改版的monitor(基于2.8.4) 特点：使用mysql作为数据存储，界面使用bootstrap进行优化 下载 12$ git clone http://git.oschina.net/handu/dubbo-monitor$ cd dubbo-monitor 配置vi src/main/resources/application.properties，修改zookeeper地址，端口，数据库信息 1234567891011121314dubbo.application.name=dubbo-monitordubbo.application.owner=hanqunfengdubbo.registry.address=zookeeper://192.168.37.144:2181?backup=192.168.37.143:2181dubbo.protocol.port=6060# Database Settingsdb.url=jdbc:mysql://127.0.0.1:3306/monitor?prepStmtCacheSize=517&amp;cachePrepStmts=true&amp;autoReconnect=true&amp;characterEncoding=utf-8db.username=rootdb.password=passworddb.maxActive=500# System Managermanager.username=adminmanager.password=admin 数据库初始化 创建monitor数据库 执行sql目录下的create.sql 打包mvn clean package -Dmaven.test.skip=true 基于本地nexus编译打包时，提示找不到jetbrick-template-2.0.10.jar，去maven中央仓库下载再上传到nexus中吧。 部署将生成的dubbo-monitor.war包部署到tomcat中，启动tomcat（端口8084）访问地址http://localhost:8084/dubbo-monitor 最后说一下dubbo-admin，这个是dubbo官方提供的dubbo管理控制台官方说明：管理控制台为内部裁剪版本，开源部分主要包含：路由规则，动态配置，服务降级，访问控制，权重调整，负载均衡，等管理功能。 dubbo-admin 管理控制台dubbo项目源码中有一个模块叫做dubbo-admin cd dubbox/dubbo-admin/src/main/webapp/WEB-INFvi dubbo.properties配置dubbo.registry.address=zookeeper://192.168.37.144:2181?backup=192.168.37.143:2181编译打包，将生成的dubbo-admin-2.8.4.war部署到tomcat]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo--NexT主题]]></title>
      <url>%2F2016%2F11%2F17%2Fhexo-theme-next%2F</url>
      <content type="text"><![CDATA[NexT主题简介 NexT有着完善的使用文档，NexT官方资料； NexT整合了常用的插件，如评论、分享、统计； 下载安装 12cd ~/bloggit clone https://github.com/iissnan/hexo-theme-next themes/next 第三方参考资料 我的配置多说评论和百度统计 NexT主题的_config.yml，配置方式参考Hexo–添加多说评论插件和百度统计插件 12345678910111213141516171819# 多说配置：# Duoshuo ShortNameduoshuo_shortname: 注册前缀# 开启热评文章duoshuo_hotartical: true# 可以看到评论用户的UA信息# Make duoshuo show UA# user_id must NOT be null when admin_enable is true!# you can visit http://dev.duoshuo.com get duoshuo user id.duoshuo_info: ua_enable: true admin_enable: false user_id: 0# 百度统计配置：# Baidu Analytics ID# 这里只需要填写js代码中hm.js链接的参数(如下：xxxxxxx)部分，而不再需要将整个js配置到模板中baidu_analytics: xxxxxxx 百度统计代码 1234567var _hmt = _hmt || [];(function() &#123; var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?xxxxxxx"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);&#125;)(); 百度分享 NexT主题的_config.yml，其它主题配置方式参考地址123456# Baidu Share# Available value:# button | slide# Warning: Baidu Share does not support https.baidushare: type: button 阅读次数 注册LeanCloud帐号，在LeanCloud中创建应用，具体配置方式查看参考资料。 复制AppID以及AppKey并在NexT主题的_config.yml文件中我们相应的位置填入即可，正确配置之后文件内容像这个样子: 1234leancloud_visitors: enable: true app_id: joaeuuc4hsqudUUwx4gIvGF6-gzGzoHsz app_key: E9UJsJpw1omCHuS22PdSpKoh 这里要注意，一定要在LeanCloud中的安全中心配置Web安全域名，否则不能正常统计 字数统计和阅读时常 参考资料 安装hexo-wordcount插件，在站点的根目录下执行以下命令：npm install hexo-wordcount --save 修改模板位置：themes\next\layout\_macro\post.swig，插入代码如下：1234567891011121314151617181920212223242526272829303132333435# 查找如下代码段： &#123;# LeanCould PageView #&#125; &#123;% if theme.leancloud_visitors.enable %&#125; &lt;span id="&#123;&#123; url_for(post.path) &#125;&#125;" class="leancloud_visitors" data-flag-title="&#123;&#123; post.title &#125;&#125;"&gt; &amp;nbsp; | &amp;nbsp; &lt;span class="post-meta-item-icon"&gt; &lt;i class="fa fa-eye"&gt;&lt;/i&gt; &lt;/span&gt; &lt;span class="post-meta-item-text"&gt;&#123;&#123;__('post.visitors')&#125;&#125; &lt;/span&gt; &lt;span class="leancloud-visitors-count"&gt;&lt;/span&gt; &lt;/span&gt; &#123;% endif %&#125;# 添加如下代码段： # 以下部分为：字数统计、阅读时长插入代码 &lt;span class="post-time"&gt; &amp;nbsp; | &amp;nbsp; &lt;span class="post-meta-item-icon"&gt; &lt;i class="fa fa-calendar-o"&gt;&lt;/i&gt; &lt;/span&gt; &lt;span class="post-meta-item-text"&gt;字数统计:&lt;/span&gt; &lt;span class="post-count"&gt;&#123;&#123; wordcount(post.content) &#125;&#125;(字)&lt;/span&gt; &lt;/span&gt; &lt;span class="post-time"&gt; &amp;nbsp; | &amp;nbsp; &lt;span class="post-meta-item-icon"&gt; &lt;i class="fa fa-calendar-o"&gt;&lt;/i&gt; &lt;/span&gt; &lt;span class="post-meta-item-text"&gt;阅读时长:&lt;/span&gt; &lt;span class="post-count"&gt;&#123;&#123; min2read(post.content) &#125;&#125;(分)&lt;/span&gt; &lt;/span&gt;# 以上部分为：字数统计、阅读时长插入代码 Local Search 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令：$ npm install hexo-generator-searchdb --save NexT主题的_config.yml 12345search: path: search.xml field: post format: html limit: 10000 重新编译之后会发现左侧导航栏最下方多出一个搜索菜单 标签页和分类页 默认情况下，NexT没有开启标签页和分类页功能 新增标签页 使用命令hexp new page “tags” 并将页面类型设置为tags12345---title: 标签date: 2016-11-17 23:03:47type: &quot;tags&quot;--- 通常情况下你的标签页并不需要评论框，取消评论代码123456---title: 标签date: 2016-11-17 23:03:47type: &quot;tags&quot;comments: false--- 在主题配置文件下的菜单设置项memu下设置，设置完成在主页导航可以看到标签导航栏12menu: tags: /tags 新增分类页 使用命令hexp new page categories 并将页面类型设置为categories12345---title: 分类date: 2016-11-17 23:08:35type: &quot;categories&quot;--- 通常情况下你的标签页并不需要评论框，取消评论代码123456---title: 分类date: 2016-11-17 23:08:35type: &quot;categories&quot;comments: false--- 在主题配置文件下的菜单设置项memu下设置，设置完成在主页导航可以看到分类导航栏12menu: categories: /categories 设定首页/归档/标签页面文章的篇数 安装如下插件，在站点的根目录下执行以下命令： 123$ npm install hexo-generator-index --save$ npm install hexo-generator-archive --save$ npm install hexo-generator-tag --save NexT主题的_config.yml 12345678910index_generator: per_page: 5archive_generator: per_page: 20 yearly: true monthly: truetag_generator: per_page: 10 RSS设置 安装 hexo-generator-feed，在站点的根目录下执行以下命令：$ npm install hexo-generator-feed --save NexT主题的_config.yml 1234# Set rss to false to disable feed link.# Leave rss as empty to use site's feed link.# Set rss to specific value if you have burned your feed already.rss: /atom.xml 编译后，会看到左侧头像下方会显示RSS入口 跳过指定文件的渲染 如果某些资源希望放到source下，但是又不希望被编译，可以在hexo的_config.yml中增加如下配置： 1234skip_render: - zabbix/** #跳过zabbix文件夹下的全部子目录和文件 - abc.html #跳过某一个具体的文件 - *.html #跳过以html结尾的文件 比如我的导航菜单中的『资料』，其下面配置的资源就是我从为知笔记中导出的html。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo--绑定域名到githubpage]]></title>
      <url>%2F2016%2F11%2F17%2Fhexo-domain-name%2F</url>
      <content type="text"><![CDATA[申请域名 可以通过万网购买域名; 比如博主的域名为hanqunfeng.com; 添加解析规则 登录阿里云的控制台，进入【域名】，找到自己的域名，点击【解析】 点击【添加解析】 『记录类型』：CNAME 『主机记录』：blog #说明：设置为二级域名，也可以设置为www的一级域名 『记录值』：hanqunfeng.github.io. #注意最后面有个点 上面的配置表示将blog.hanqunfeng.com的请求定向到hanqunfeng.github.io blog目录下创建CNAME文件 在自己的blog目录下的/source目录下新建一个文件，命名为CNAME，内容为：blog.hanqunfeng.com hexo cl，hexo g，hexo d，发布到github page 说明 购买域名需要进行实名认证； 官方说域名解析最长等待48小时就可以全球生效； 博主配置时，只是提交了实名认证申请，域名解析不到5分钟就可以访问了；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo--添加多说评论插件和百度统计插件]]></title>
      <url>%2F2016%2F11%2F16%2Fhexo_duoshuo_baidutongji%2F</url>
      <content type="text"><![CDATA[添加多说评论插件 登录多说官网，多说不支持注册，仅支持绑定社交帐号登录，比如QQ，新浪微博，等等。 登录后会要求进行站点设置，这里需要设置域名、站点名称、首页网址等信息，域名的后缀已经默认为.duoshuo.com,所以我们只需要设置前缀，记住这个前缀。站点名称随便起个名字，首页网站填写https://hanqunfeng.github.io； 编辑yilia主题的_config.yml文件，设置如下： duoshuo: 域名前缀 重新发布即可，效果见页面下方的评论区； 在多说管理后台中可以对评论进行管理。 添加百度统计插件 注册百度统计帐号; 新注册用户会要求创建一个网站，设置如下： 登录后在代码管理--》代码获取中复制代码，将其粘贴到yilia主题下的layout/_partial/after-footer.gjs的最下面； 重新发布到github page； 在百度统计管理平台中的代码管理--》代码安装检查查看是否配置正确； 配置无误后，可以通过百度统计平台查看统计数据。 参考资料 http://m.blog.csdn.net/article/details?id=51049695]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo+GitHub Page搭建自己的Blog]]></title>
      <url>%2F2016%2F11%2F14%2Fhexo_gitpage%2F</url>
      <content type="text"><![CDATA[什么是Hexo Hexo 是一个简单地、轻量地、基于Node的一个静态博客框架，可以方便的生成静态网页托管在github和Heroku上，引用Hexo作者 @tommy351 的话： 快速、简单且功能强大的 Node.js 博客框架。A fast, simple &amp; powerful blog framework, powered by Node.js. GitHub Pages是什么？ GitHub Pages 可以被认为是用户编写的、托管在github上的静态网页。由于它的空间免费稳定， 可以用于介绍托管在github上的Project或者搭建网站。 以下环境为mac下安装。 Hexo安装需要安装git和Node.js运行环境 git安装 mac自带git，如果需要重新安装，可去官网下载12$ git --versiongit version 2.9.3 (Apple Git-75) 安装npm 基于brew方式安装npm1$ brew install npm 安装Hexo1$ npm install hexo-cli -g npm安装Hexo：参考资料 查看Hexo版本12345678910111213$ hexo versionhexo: 3.2.2hexo-cli: 1.0.2os: Darwin 16.1.0 darwin x64http_parser: 2.7.0node: 6.6.0v8: 5.1.281.83uv: 1.9.1zlib: 1.2.8ares: 1.10.1-DEVicu: 57.1modules: 48openssl: 1.0.2h Quick StartSetup your blog123$ cd ~$ hexo init blog$ cd blog 此命令会在当前用户的家目录下创建一个blog目录，并初始化相关文件，如下为初始化的目录结构： blog目录结构说明 scaffolds ：模板文件夹，新建文章时，Hexo 会根据 scaffold 来建立文件。Hexo 有三种默认布局： post 、 page 和 draft ，它们分别对应不同的路径。新建文件的默认布局是 post ，可以在配置文件中更改布局。用 draft 布局生成的文件会被保存到 source/_drafts 文件夹。 source ：资源文件夹是存放用户资源的地方。 source/_post ：文件箱。除 posts 文件夹之外，开头命名为 (下划线)的文件或者文件夹和隐藏的文件将会被忽略。Markdown文件会被解析并放到 public 文件夹。 themes ：主题 文件夹。Hexo 会根据主题来生成静态页面。我们可以将自己的主题放到该目录下，然后在_config.yml中修改默认的主题即可。 themes/landscape ：默认的皮肤文件夹 _config.yml ：全局的配置文件，每次更改要重启服务。 _config.yml简介1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site 站点配置title: Study Zone #网站标题subtitle: Spring--java程序员的春天 #网站副标题description: 分享成长与快乐的地方 #网站描述author: hanqunfeng #作者，网站所有者language: zh-CN #网站使用的语言timezone: Asia/Shanghai #网站时区# URL 可以不配置## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://hanqunfeng.github.io #网址，搜索时会在搜索引擎中显示root: / #网站根目录 permalink: :year/:month/:day/:title/ #永久链接格式permalink_defaults: #永久链接中各部分的默认值# Directory 目录配置source_dir: source #资源文件夹，这个文件夹用来存放内容public_dir: public #公共文件夹，这个文件夹用于存放生成的站点文件tag_dir: tags #标签文件夹archive_dir: archives #归档文件夹category_dir: categories #分类文件夹code_dir: downloads/code #Include code 文件夹i18n_dir: :lang #国际化文件夹skip_render: #跳过指定文件的渲染，您可使用 glob 来配置路径# Writing 写作配置new_post_name: :title.md # File name of new posts # 新文章的文件名称default_layout: post #默认布局titlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0 #把文件名称转换为 (1) 小写或 (2) 大写render_drafts: false #显示草稿post_asset_folder: false #是否启动资源文件夹relative_link: false #把链接改为与根目录的相对位址future: truehighlight: #代码块的设置 enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tag 分类 &amp; 标签default_category: uncategorized #默认分类category_map: #分类别名tag_map: #标签别名# Date / Time format 时间和日期## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination 分页## Set per_page to 0 to disable paginationper_page: 10 #每页显示的文章量 (0 = 关闭分页功能)pagination_dir: page #分页目录# Extensions 扩展## Plugins: https://hexo.io/plugins/ 插件## Themes: https://hexo.io/themes/ 主题# theme: landscape #当前主题名称theme: yilia #当前主题名称# Deployment #部署到github## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/hanqunfeng/hanqunfeng.github.io.git branch: master 注意：以下所有命令，都必须在blog目录下执行。 Start the server123$ hexo serverINFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 我们可以通过浏览器访问http://localhost:4000/，就可以看到blog的页面了。 创建文件、生成静态文件以及发布到github，都不需要启动服务，启动服务的目的仅是为了能在本地看到效果。 hexo server == hexo s Create a new post12$ hexo new "Hello Hexo"INFO Created: ~/blog/source/_posts/Hello-Hexo.md 创建好的文件基于makedown语法，可以使用sublime或者atom编辑器，进行编辑与管理。 编辑完成后不需要执行hexo generate命令即可在浏览器中查看效果，但是修改了主题内容，有时会不生效，需要先生成静态文件才能看到最终效果。 hexo new == hexo n Generate static files1$ hexo generate 该命令用于将makedown文件转换为静态html文件，并放到public文件夹下。 可以使用hexo clean命令来删除public文件夹，之后再使用hexo generate来重新生成静态文件。 hexo generate == hexo g Clean static files123$ hexo cleanINFO Deleted database.INFO Deleted public folder. hexo clean == hexo cl 主题更换主题 github上有许多技术达人为Hexo制作的主题，可以clone到本地，并拷贝到themes文件夹下，然后修改_config.yml中的theme属性，修改主题需要重启Hexo才能生效。 比如博主使用主题为yilia下载地址: 12$ cd ~/blog$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 更新主题时，在themes/yilia目录下执行git pull。 添加资源 可以在当前主题的source目录下放入自己的资源，执行hexo generate命令时，会将主题中的source目录下的内容拷贝到public目录下。 但是这样做如果更换主题，则资源就失效了，所以一般是在source目录下创建资源文件，执行hexo generate命令时，会将source目录下的内容拷贝到public目录下。 发布到Github安装hexo的git发布包1$ npm install hexo-deployer-git -S 创建SSH密钥 创建密钥可以在执行发布时不需要每次都输入用户名和密码，具体创建方法查看如下资料: github官网 图文教程 Deploy to remote sites 因为使用GitPage，所以需要申请一个Github帐号，并创建一个仓库，仓库名称为”your_name.github.io”。 创建好仓库后，在_config.yml中按上文中的内容配置好deploy属性。 执行如下命令，会将public下的文件发布到该仓库中，一般执行deploy前先执行clean和generate保证文件最新。 访问https://hanqunfeng.github.io，查看blog页面。 123$ hexo clean$ hexo generate$ hexo deploy hexo deploy == hexo d 参考资料 http://www.tuicool.com/articles/ueI7naV http://www.jianshu.com/p/465830080ea9]]></content>
    </entry>

    
  
  
</search>
