<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Redis集群]]></title>
    <url>%2F2018%2F12%2F27%2Fredis-cluster%2F</url>
    <content type="text"><![CDATA[一、摘要看完本文你将掌握如下知识点： redis集群的构建方法【redis-5.0.2】 redis早期的版本中使用基于ruby的redis-trib.rb命令进行集群创建，新版本推荐使用 redis-cli --cluster，本文就是通过redis-cli --cluster命令实现集群构建。 二、快速创建集群redis为我们提供了快速创建集群的工具，安装好redis后，在其/redis-5.0.2/utils/create-cluster/目录下存在一个create-cluster命令，通过该命令可以快速创建一个基于本机端口30001~30006的三主三从的redis集群，可以通过修改端口号及服务数量来改变集群的配置。1.启动6个redis服务，./create-cluster start2.创建集群，./create-cluster create3.关闭集群服务，./create-cluster stop4.清除数据及日志文件，./create-cluster stop 三、源码分析通过看源码可以很清楚其创建过程1.启动6个reids服务，通过参数的方式进行启动，在生产环境中建议通过配置文件启动12345678910if [ &quot;$1&quot; == &quot;start&quot; ]then while [ $((PORT &lt; ENDPORT)) != &quot;0&quot; ]; do PORT=$((PORT+1)) echo &quot;Starting $PORT&quot; ../../src/redis-server --port $PORT --cluster-enabled yes --cluster-config-file nodes-$&#123;PORT&#125;.conf --cluster-node-timeout $TIMEOUT --appendonly yes --appendfilename appendonly-$&#123;PORT&#125;.aof --dbfilename dump-$&#123;PORT&#125;.rdb --logfile $&#123;PORT&#125;.log --daemonize yes done exit 0fi 参数说明：123456789101112131415161718#端口：port $PORT#是否启用集群：cluster-enabled yes#集群关联文件路径，创建redis集群时自动创建cluster-config-file nodes-$&#123;PORT&#125;.conf#集群节点间通信的超时时间，毫秒，建议2000，默认15000cluster-node-timeout $TIMEOUT#开启aofappendonly yes#aof文件名称，注意这里只能是文件名称，若要修改路径需要设置dir属性 ，如dir /home/hanqf/redis-dir/redis-5.0.2/cluster-conf/files/appendfilename appendonly-$&#123;PORT&#125;.aof#rdb文件名称，同样只能是文件名称，同上路径共用dir属性dbfilename dump-$&#123;PORT&#125;.rdb#日志文件路径logfile $&#123;PORT&#125;.log#后台运行模式启动daemonize yes 2.构建集群，这里使用的就是redis-cli --cluster命令，可以看出与redis-trib.rb命令类似12345678910if [ &quot;$1&quot; == &quot;create&quot; ]then HOSTS=&quot;&quot; while [ $((PORT &lt; ENDPORT)) != &quot;0&quot; ]; do PORT=$((PORT+1)) HOSTS=&quot;$HOSTS 127.0.0.1:$PORT&quot; done ../../src/redis-cli --cluster create $HOSTS --cluster-replicas $REPLICAS exit 0fi create后根的$HOSTS就是redis服务列表1127.0.0.1:30001 127.0.0.1:30002 127.0.0.1:30003 127.0.0.1:30004 127.0.0.1:30005 127.0.0.1:30006 --cluster-replicas $REPLICAS，这里$REPLICAS值为1，表示为每一个master节点分配一个slave节点 四、实际应用这里我们使用2台服务器，分别启动3个redis服务，来构建一个三主三从的redis集群。 1.服务器IP 10.211.55.15 10.211.55.16 2.端口设置分别开启俩台服务器的如下端口，前面是redis服务端口，后面是集群通信端口（默认服务端口+10000）1236379，163796380，163806381，16381 3.redis-{port}.conf这里需要按照上面的参数说明进行配置，如我们配置号redis-6379.conf后，可以通过如下命令进行复制12more redis-6379.conf | sed &apos;s/6379/6380/g&apos; &gt; redis-6380.confmore redis-6379.conf | sed &apos;s/6379/6381/g&apos; &gt; redis-6381.conf 4.启动服务12345678910#10.211.55.15./redis-server redis-6379.conf./redis-server redis-6380.conf./redis-server redis-6381.conf#10.211.55.16./redis-server redis-6379.conf./redis-server redis-6380.conf./redis-server redis-6381.conf 5.构建集群1./redis-cli --cluster create 10.211.55.15:6379 10.211.55.15:6380 10.211.55.15:6381 10.211.55.16:6379 10.211.55.16:6380 10.211.55.16:6381 --cluster-replicas 1 五、集群相关命令1.健康检查12# 后面可以是集群中任意节点./redis-cli --cluster check 10.211.55.15:6380 输出如下，可以看到集群中的主从关系，以及每个master中含有key的数量：1234567891011121314151617181920212223242526272810.211.55.15:6380 (c39c1e8a...) -&gt; 2 keys | 5461 slots | 1 slaves.10.211.55.16:6380 (3edc1dae...) -&gt; 5 keys | 5461 slots | 1 slaves.10.211.55.16:6379 (4dd31f17...) -&gt; 2 keys | 5462 slots | 1 slaves.[OK] 9 keys in 3 masters.0.00 keys per slot on average.&gt;&gt;&gt; Performing Cluster Check (using node 10.211.55.15:6380)M: c39c1e8aa6e07e337aaab03eab3727f739201cd2 10.211.55.15:6380 slots:[10923-16383] (5461 slots) master 1 additional replica(s)S: a83903f50621d7627f3ce59f1210af4938b8acc4 10.211.55.15:6381 slots: (0 slots) slave replicates 4dd31f17e83ef7aa6c7a36474f7f54d842e0ed64M: 3edc1daeaf3a848156ad8cc601b1374dd0459d9c 10.211.55.16:6380 slots:[0-5460] (5461 slots) master 1 additional replica(s)M: 4dd31f17e83ef7aa6c7a36474f7f54d842e0ed64 10.211.55.16:6379 slots:[5461-10922] (5462 slots) master 1 additional replica(s)S: cb6a94201d6f5a4e016b1549afc8c976a1a3dda4 10.211.55.15:6379 slots: (0 slots) slave replicates 3edc1daeaf3a848156ad8cc601b1374dd0459d9cS: 3f41a95296cb2681ea599f47aaff9c662b3338ad 10.211.55.16:6381 slots: (0 slots) slave replicates c39c1e8aa6e07e337aaab03eab3727f739201cd2[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered. 说明：此时如果关闭其中一个master节点，那么其对应的从节点就会升级为主节点，当重新启动原master节点后，则该节点会自动加入集群，并作为从节点。 2.集群扩容，即为集群添加新的主机和从机2.1通过如下命令添加新的node说明：10.211.55.15:6382 是新的服务地址，10.211.55.16:6380 是集群中任意一个的服务地址,添加后的服务类型为master。 此时我们通过健康检查可以看到新加入的服务没有分配槽点：123456789101112131415161718192021222324252627282930./redis-cli --cluster check 10.211.55.15:6380Warning: Using a password with &apos;-a&apos; or &apos;-u&apos; option on the command line interface may not be safe.Could not connect to Redis at 10.211.55.15:6379: Connection refused10.211.55.15:6380 (a5f63b8e...) -&gt; 2 keys | 5461 slots | 1 slaves.10.211.55.16:6379 (15506850...) -&gt; 2 keys | 5462 slots | 1 slaves.10.211.55.15:6382 (316e068f...) -&gt; 0 keys | 0 slots | 0 slaves. #注意，这里新添加的主机没有分配槽（slot），需要先进行分配才能使用10.211.55.16:6380 (d944c0b1...) -&gt; 5 keys | 5461 slots | 0 slaves.[OK] 9 keys in 4 masters.0.00 keys per slot on average.&gt;&gt;&gt; Performing Cluster Check (using node 10.211.55.15:6380)M: a5f63b8e4f24a73d36da9e0bbf84988d7c5558d3 10.211.55.15:6380 slots:[10923-16383] (5461 slots) master 1 additional replica(s)M: 15506850b235f4277306368533cacf4a5ec1bbd1 10.211.55.16:6379 slots:[5461-10922] (5462 slots) master 1 additional replica(s)M: 316e068fd71ee228299198a271efd839d3493835 10.211.55.15:6382 slots: (0 slots) masterS: b3c0e06da5b5d694c3a68408fb4c8f7607d7e9e0 10.211.55.16:6381 slots: (0 slots) slave replicates a5f63b8e4f24a73d36da9e0bbf84988d7c5558d3M: d944c0b19e92af325b882e3a86ff09c2b6b53f47 10.211.55.16:6380 slots:[0-5460] (5461 slots) masterS: 4bce4c24959bda55d087296e86f58ec03186d3ae 10.211.55.15:6381 slots: (0 slots) slave replicates 15506850b235f4277306368533cacf4a5ec1bbd1[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered. 2.2分配槽1./redis-cli --cluster reshard 10.211.55.15:6382 执行命令后会有如下设置： 1.问你是否从原有的1-16384个槽中分配多少到新的主节点，我们这里分配4000为例，回车 2：然后紧接着会询问你给id为谁的主节点分配，这里就是新加的节点10.211.55.15:6382，其对应的Id为:316e068fd71ee228299198a271efd839d3493835 3：询问你是从所有的空间去给这个节点分配空间还是从某一个节点分配，我这里输入all 回车继续 4：然后会给你分配出一个分配计划，输入yes开始分配。完成ok 此时再次运行健康检查可以看到槽点已经分配成功123456789./redis-cli --cluster check localhost:6380Warning: Using a password with &apos;-a&apos; or &apos;-u&apos; option on the command line interface may not be safe.localhost:6380 (a5f63b8e...) -&gt; 1 keys | 4128 slots | 1 slaves.10.211.55.16:6379 (15506850...) -&gt; 2 keys | 4128 slots | 1 slaves.10.211.55.15:6382 (316e068f...) -&gt; 2 keys | 4000 slots | 0 slaves.10.211.55.16:6380 (d944c0b1...) -&gt; 4 keys | 4128 slots | 1 slaves.[OK] 9 keys in 4 masters.0.00 keys per slot on average.……………………………… 2.3平衡槽，就是均匀分配集群中的所有槽到所有的节点，该步非必须，只是看着好看点1./redis-cli --cluster rebalance --cluster-threshold 1 10.211.55.15:6382 12345678./redis-cli --cluster info localhost:6380Warning: Using a password with &apos;-a&apos; or &apos;-u&apos; option on the command line interface may not be safe.localhost:6380 (a5f63b8e...) -&gt; 1 keys | 4096 slots | 1 slaves.10.211.55.16:6379 (15506850...) -&gt; 2 keys | 4096 slots | 1 slaves.10.211.55.15:6382 (316e068f...) -&gt; 2 keys | 4096 slots | 0 slaves.10.211.55.16:6380 (d944c0b1...) -&gt; 4 keys | 4096 slots | 1 slaves.[OK] 9 keys in 4 masters.0.00 keys per slot on average. 2.4为新加入的master添加slave同样需要先加入集群1./redis-cli --cluster add-node 10.211.55.16:6382 10.211.55.16:6380 之后不需要做分配和平衡槽的操作登录这个redis， ./redis-cli -h 10.211.55.16 -p 638212127.0.0.1:6382&gt; cluster replicate 316e068fd71ee228299198a271efd839d3493835 #主节点的idOK 3.删除节点3.1删除主节点删除节点前，节点上的槽要被清空1./redis-cli --cluster reshard 10.211.55.15:6382 #集群中任意ip即可 1.问你是否从原有的1-16384个槽中分配多少到新的主节点我们这里分配4096，即该节点上的槽数 2：然后紧接着会询问你给id为谁的主节点分配，这里我们分配给10.211.55.16:6379，即15506850b235f4277306368533cacf4a5ec1bbd1 3：询问你是从所有的空间去给这个节点分配空间还是从某一个节点分配 我这里输入要移出的节点ID ,即316e068fd71ee228299198a271efd839d3493835 回车继续 输入 done 4：然后会给你分配出一个分配计划，输入yes开始分配。完成ok 执行删除节点命令12345./redis-cli --cluster del-node 10.211.55.16:6379 316e068fd71ee228299198a271efd839d3493835Warning: Using a password with &apos;-a&apos; or &apos;-u&apos; option on the command line interface may not be safe.&gt;&gt;&gt; Removing node 316e068fd71ee228299198a271efd839d3493835 from cluster 10.211.55.16:6379&gt;&gt;&gt; Sending CLUSTER FORGET messages to the cluster...&gt;&gt;&gt; SHUTDOWN the node. 说明：删除节点会自动关闭被移出的redis服务，此时，该主节点的从节点会自动转为其它主节点的从节点，而不会升级为主节点 3.2删除从节点直接执行节点删除命令1./redis-cli --cluster del-node 10.211.55.16:6379 从节点ID]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot2学习笔记--activemq]]></title>
    <url>%2F2018%2F12%2F12%2Factivemq-springboot%2F</url>
    <content type="text"><![CDATA[摘要看完本文你将掌握如下知识点： Spring Boot(2.1.1.RELEASE)中使用activemq(5.15.8)的方法 引入依赖12345678910111213141516171819202122232425&lt;!-- activemq自动配置依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt; &lt;/dependency&gt;&lt;!-- 连接池依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-pool&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 如果springboot是2.x.x的版本如果启用连接池（spring.activemq.pool.enabled=true），就必须引入这个依赖，否则启动时会报错，提示找不到JmsMessagingTemplate springboot是1.5.x的版本就不需要引入， 这是因为springboot1.5.x使用的是org.apache.activemq.pool.PooledConnectionFactory， 而springboot2.x.x时候用的org.messaginghub.pooled.jms.JmsPoolConnectionFactory， 可以通过源码查看： org.springframework.boot.autoconfigure.jms.activemq.ActiveMQConnectionFactoryConfiguration : 负责初始化ConnectionFactory org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration : 负责初始化JmsMessagingTemplate --&gt; &lt;dependency&gt; &lt;groupId&gt;org.messaginghub&lt;/groupId&gt; &lt;artifactId&gt;pooled-jms&lt;/artifactId&gt; &lt;version&gt;1.0.3&lt;/version&gt; &lt;/dependency&gt; 配置文件1234567spring.activemq.broker-url=tcp://localhost:61616spring.activemq.user=adminspring.activemq.password=admin#启用连接池spring.activemq.pool.enabled=true#最大连接数spring.activemq.pool.max-connections=100 配置类12345678910111213141516171819202122232425262728293031323334@Configuration@EnableJms //启用jms功能public class ActiveMqConfig &#123; //如果要使用topic类型的消息，则需要配置该bean @Bean("jmsTopicListenerContainerFactory") public JmsListenerContainerFactory jmsTopicListenerContainerFactory( ConnectionFactory connectionFactory )&#123; DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory(); factory.setConnectionFactory(connectionFactory); factory.setPubSubDomain(true); //这里必须设置为true，false则表示是queue类型 return factory; &#125; @Bean("springboot.queue") public Queue queue() &#123; return new ActiveMQQueue("springboot.queue") ; &#125; @Bean("springboot.topic") public Topic topic() &#123; return new ActiveMQTopic("springboot.topic") ; &#125; @Bean("springboot.queuereply") public Queue queuereply() &#123; return new ActiveMQQueue("springboot.queuereply") ; &#125;&#125; 消费者1234567891011121314151617181920212223242526272829303132333435@Componentpublic class Consumer &#123; //监听队列，queue类型 @JmsListener(destination="springboot.queue.a") public void receiveQueueA(String text)&#123; System.out.println(this.getClass().getName()+ "收到的报文为:"+text); &#125; @JmsListener(destination="springboot.*.b") public void receiveQueueB(String text)&#123; System.out.println(this.getClass().getName()+ "收到的报文为:"+text); &#125; @JmsListener(destination="springboot.&gt;") public void receiveQueueAll(String text)&#123; System.out.println(this.getClass().getName()+ "收到的报文为:"+text); &#125; //监听队列，topic类型，这里containerFactory要配置为jmsTopicListenerContainerFactory @JmsListener(destination = "springboot.topic", containerFactory = "jmsTopicListenerContainerFactory" ) public void receiveTopic(String text) &#123; System.out.println(this.getClass().getName()+" 收到的报文为:"+text); &#125; @JmsListener(destination="springboot.queuereply") @SendTo("out.replyTo.queue") //消费者应答后通知生产者 public String receiveQueueReply(String text)&#123; System.out.println(this.getClass().getName()+ "收到的报文为:"+text); return "out.replyTo.queue receiveQueueReply"; &#125;&#125; 生产者123456789101112131415161718192021222324252627282930313233343536373839404142434445@Componentpublic class Producer &#123; @Resource("springboot.queue.a") private Queue queuea; @Resource("springboot.queue.b") private Queue queueb; @Resource("springboot.topic") private Topic topic; @Resource("springboot.queuereply") private Queue queuereply; @Autowired private JmsMessagingTemplate jmsTemplate; // 发送消息，destination是发送到的队列，message是待发送的消息 public void sendMessage(Destination destination, final String message)&#123; jmsTemplate.convertAndSend(destination, message); &#125; public void sendQueueAMessage(final String message)&#123; sendMessage(queuea, message); &#125; public void sendQueueBMessage(final String message)&#123; sendMessage(queueb, message); &#125; public void sendTopicMessage(final String message)&#123; sendMessage(topic, message); &#125; public void sendQueueMessageReply(final String message)&#123; sendMessage(queuereply, message); &#125; //生产者监听消费者的应答 @JmsListener(destination = "out.replyTo.queue") public void consumerMessage(String text)&#123; System.out.println("从out.replyTo.queue收到报文"+text); &#125;&#125;]]></content>
      <categories>
        <category>技术 activemq</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot2学习笔记--thymeleaf]]></title>
    <url>%2F2018%2F10%2F10%2Fthymeleaf_study%2F</url>
    <content type="text"><![CDATA[摘要看完本文你将掌握如下知识点： Spring Boot(2.0.4)中使用thymeleaf(3.0.9)的常用语法 项目准备依赖12345&lt;!--spring对thymeleaf的支持--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 开启spring boot对thymeleaf的支持123456789##thymeleafspring.thymeleaf.enabled=truespring.thymeleaf.prefix=classpath:/templates/spring.thymeleaf.suffix=.htmlspring.thymeleaf.encoding=UTF-8spring.thymeleaf.mode=HTML#关闭页面缓存spring.thymeleaf.cache=falsespring.thymeleaf.servlet.content-type=text/html 也可以通过@Bean的方式开启支持123456789101112131415161718192021222324252627282930@Beanpublic ThymeleafViewResolver thymeleafViewResolver()&#123; log.info("thymeleafViewResolver"); ThymeleafViewResolver viewResolver = new ThymeleafViewResolver(); viewResolver.setTemplateEngine(templateEngine()); viewResolver.setOrder(1); viewResolver.setCharacterEncoding("UTF-8"); viewResolver.setContentType("text/html"); viewResolver.setCache(false); return viewResolver;&#125;@Beanpublic SpringResourceTemplateResolver templateResolver()&#123; SpringResourceTemplateResolver templateResolver = new SpringResourceTemplateResolver(); templateResolver.setApplicationContext(this.applicationContext); templateResolver.setPrefix("classpath:/templates/"); templateResolver.setSuffix(".html"); templateResolver.setTemplateMode(TemplateMode.HTML); templateResolver.setCacheable(false); return templateResolver;&#125;@Beanpublic SpringTemplateEngine templateEngine()&#123; SpringTemplateEngine templateEngine = new SpringTemplateEngine(); templateEngine.setTemplateResolver(templateResolver()); templateEngine.setEnableSpringELCompiler(true); return templateEngine;&#125; 开启html页面对thymeleaf语法的支持123&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;/html&gt; 语法各种表达式语法 ${…} 变量表达式，用于展示后台传递过来的变量（request和session中的值） 123456789101112131415&lt;input type="text" name="modify" th:value="$&#123;modify&#125;"/&gt;&lt;input type="text" name="id" th:value="$&#123;dataObj.id&#125;"/&gt;&lt;textarea name="logParamData" id="logParamData" th:text="$&#123;dataObj.logParamData&#125;"&gt;&lt;/textarea&gt;以下两种方式效果一致&lt;span th:text="$&#123;dataObj.name&#125;"&gt;&lt;/span&gt;&lt;span&gt;[[$&#123;dataObj.name&#125;]]&lt;/span&gt;字符串拼接，可以使用加号，也可以使用竖线，以下两种方式效果一致&lt;input type="checkbox" name="accessTypes" th:value="$&#123;item.id&#125;+'_'+$&#123;type.id&#125;" checked="checked"&gt; [[$&#123;type.name&#125;]&lt;input type="checkbox" name="accessTypes" th:value="$&#123;|$&#123;item.id&#125;_$&#123;type.id&#125;|&#125;" checked="checked"&gt; [[$&#123;type.name&#125;]#dates与java.util.Date对象的方法对应，格式化、日期组件抽取等等&lt;td th:text="$&#123;#dates.format(item.logTime, 'yyyy-MM-dd')&#125;"&gt;&lt;/td&gt;&lt;td&gt;[[$&#123;#dates.format(item.logTime, 'yyyy-MM-dd')&#125;]]&lt;/td&gt; #{…} 国际化消息表达式，用于展示message.properties等国际化资源文件中的内容 12345678&lt;input type="checkbox" name="selectAll" id="selectAll" th:text="#&#123;common.choose&#125;"/&gt;消息中需要传递变量的情况，多个变量逗号分割&lt;strong th:text="#&#123;common.page.summary($&#123;_pageBean.pageCount&#125;,$&#123;_pageBean.total&#125;)&#125;"&gt;以下两种方式效果一致&lt;td th:text="#&#123;common.operate&#125;"&gt;&lt;/td&gt;&lt;td&gt;[[#&#123;common.operate&#125;]]&lt;/td&gt; @{…} 链接url表达式，用于封装url，如contextPath补全 12345&lt;link th:href="@&#123;/resource/css/netqin.css&#125;" rel="stylesheet"/&gt;用两个竖线来拼接带表达式的字符串&lt;script type="text/javascript" th:src="@&#123;|/resource/js/i18n/list.#&#123;locale&#125;.js|&#125;"&gt;&lt;/script&gt;带请求参数的url，多个用逗号分割&lt;a th:href="@&#123;/auth/systemLogger/edit.do(id=$&#123;item.id&#125;,flag=$&#123;flag&#125;)&#125;" th:text="#&#123;common.edit&#125;"&gt;&lt;/a&gt; js和css中用到表达式时使用双中括号的方式 1234var modify = "[[$&#123;modify&#125;]]";if(modify != "add")&#123; $("#password").attr("placeholder","[[#&#123;user.detail.changeNotice&#125;]]");&#125; *{…} 选择变量表达式，用于简写变量名称，需要配合th:object一起使用 123456789&lt;div th:object="$&#123;user&#125;"&gt; &lt;p&gt;firstName: &lt;span th:text="*&#123;firstName&#125;"&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;lastName: &lt;span th:text="*&#123;lastName&#125;"&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;相当于&lt;div&gt; &lt;p&gt;firstName: &lt;span th:text="$&#123;user.firstName&#125;"&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;lastName: &lt;span th:text="$&#123;user.lastName&#125;"&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt; ~{…} 代码块表达式，用于在html中复用相同的结构语法：~{templatename::fragmentname}示例：common/model.html，th:fragment=”header”指定代码块名称 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head th:fragment="header"&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;&lt;META http-equiv="Pragma" content="no-cache"&gt;&lt;META http-equiv="Cache-Control" content="no-cache"&gt;&lt;META http-equiv="Expire" content="0"&gt;&lt;link th:href="@&#123;/resource/css/bootstrap.min.css&#125;" rel="stylesheet" /&gt;&lt;link th:href="@&#123;/resource/css/ace.min.css&#125;" rel="stylesheet" /&gt;&lt;link rel="stylesheet" th:href="@&#123;/resource/css/font-awesome.min.css&#125;" /&gt;&lt;script th:src="@&#123;/resource/js/jquery-1.11.0.min.js&#125;"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; demo.html，th:replace=”common/model::header”，模板名称::代码块名称123456&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;header th:replace="common/model::header"&gt;&lt;/header&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 说明：代码块表达式需要配合th属性（th:insert，th:replace，th:include）一起使用。123th:insert：将代码块片段整个插入到使用了th:insert的HTML标签中，th:replace：将代码块片段整个替换使用了th:replace的HTML标签中，th:include：将代码块片段包含的内容插入到使用了th:include的HTML标签中， 遍历简单示例1234567891011&lt;tr th:each="item:$&#123;results&#125;"&gt;&lt;td&gt; &lt;input type="checkbox" name="ids" th:value="$&#123;item.id&#125;" class="noborder"/&gt;&lt;/td&gt;&lt;td th:text="$&#123;item.id&#125;"&gt;&lt;/td&gt;&lt;td&gt; [[$&#123;#dates.format(item.logTime, 'yyyy-MM-dd')&#125;]]&lt;/td&gt;&lt;td th:text="$&#123;item.logDesc&#125;"&gt;&lt;/td&gt;&lt;td th:text="$&#123;item.logUser&#125;"&gt;&lt;/td&gt;&lt;/tr&gt; 带遍历状态的示例1234567891011&lt;tr th:each="item,status:$&#123;results&#125;" th:class="$&#123;status.odd&#125;? 'odd':'even'"&gt;&lt;td&gt; &lt;input type="checkbox" name="ids" th:value="$&#123;item.id&#125;" class="noborder"/&gt;&lt;/td&gt;&lt;td th:text="$&#123;item.id&#125;"&gt;&lt;/td&gt;&lt;td&gt; [[$&#123;#dates.format(item.logTime, 'yyyy-MM-dd')&#125;]]&lt;/td&gt;&lt;td th:text="$&#123;item.logDesc&#125;"&gt;&lt;/td&gt;&lt;td th:text="$&#123;item.logUser&#125;"&gt;&lt;/td&gt;&lt;/tr&gt; 状态说明1234567index：当前遍历索引，从0开始count：当前遍历索引，从1开始size：总元素数量current：每一次遍历的iter变量even/odd：当前遍历是even还是odd，布尔属性first：当前遍历是第一个，布尔属性last：当前遍历是最后一个，布尔属性 遍历时可以自定义变量12345th:with：用于定义变量，多个使用逗号分割&lt;span th:each="type,status:$&#123;accessTypes&#125;" th:with="shwoName=$&#123;item.id&#125;+'_'+$&#123;item.name&#125;"&gt;[[$&#123;shwoName&#125;]]&lt;span th:if="$&#123;not status.last&#125;"&gt;,&lt;/span&gt; &lt;/span&gt; 条件判断th:if1234567891011121314151617181920212223判断为true时才会显示div，authorities为Set类型，所以判断是否包含时可以使用#sets.contains()方法，测试时发现使用#arrays.contains()方法时也可以&lt;div th:if="$&#123;dataObj.reserved&#125;"&gt; &lt;li th:each="item:$&#123;dataObj.authorities&#125;"&gt; &lt;input type="checkbox" name="authorities" th:value="$&#123;item.id&#125;" th:if="$&#123;dataObj.authorities ==null or not #sets.contains(dataObj.authorities,item)&#125;"&gt; &lt;input type="checkbox" name="authorities" th:value="$&#123;item.id&#125;" checked="checked" th:if="$&#123;dataObj.authorities !=null and #sets.contains(dataObj.authorities,item)&#125;"&gt; &lt;span th:text="$&#123;item.showNameRole&#125;"&gt;&lt;/span&gt; &lt;/li&gt;&lt;/div&gt;如果要判断为false时才会显示div，可以判断值是否等于false，或者使用th:unless&lt;div th:if="$&#123;dataObj.reserved==false&#125;"&gt; &lt;li th:each="item:$&#123;dataObj.authorities&#125;"&gt; &lt;input type="checkbox" name="authorities" th:value="$&#123;item.id&#125;"&gt;&lt;span th:text="$&#123;item.showNameRole&#125;"&gt;&lt;/span&gt; &lt;/li&gt;&lt;/div&gt;&lt;div th:unless="$&#123;dataObj.reserved&#125;"&gt; &lt;li th:each="item:$&#123;dataObj.authorities&#125;"&gt; &lt;input type="checkbox" name="authorities" th:value="$&#123;item.id&#125;"&gt;&lt;span th:text="$&#123;item.showNameRole&#125;"&gt;&lt;/span&gt; &lt;/li&gt;&lt;/div&gt; th:if 以下情况运算为true123456值不为null值为boolean且为true值为数字且非0值为字符且非0值是字符串且不是：“false”，“off”，“no”值是object,但不为null th:switch 和 th:case1234567891011121314151617bool匹配&lt;div th:switch="$&#123;dataObj.reserved&#125;"&gt; &lt;p th:case="true"&gt;true&lt;/p&gt; &lt;p th:case="false"&gt;false&lt;/p&gt;&lt;/div&gt;字符串匹配，要加单引号&lt;div th:switch="$&#123;item.showNameRole&#125;"&gt; &lt;p th:case="'admin'"&gt;administrator&lt;/p&gt; &lt;p th:case="'manager'"&gt;manager&lt;/p&gt;&lt;/div&gt;&lt;div th:switch="$&#123;item.showNameRole&#125;"&gt; &lt;p th:case="'admin'"&gt;administrator&lt;/p&gt; &lt;p th:case="'manager'"&gt;manager&lt;/p&gt; &lt;p th:case="*"&gt;unknow&lt;/p&gt;&lt;/div&gt; 说明：th:case=”*” 表示没有匹配成功时显示的内容 运算符 字符串连接 12 + : $&#123;item.id&#125;+&apos;_&apos;+$&#123;type.id&#125; |xxxx| : |The name is $&#123;name&#125;| 算术运算 12 + , - , * , / , % (二元运算符) - :负号（一元运算符） 布尔操作 12 and :且,or :或 (二元运算符) !,not :非（一元操作符） 关系操作符 12 &gt; , &lt; , &gt;= , &lt;= (gt , lt , ge , le) == , != (eq, ne) 表达式工具对象12345678910111213#dates 与java.util.Date对象的方法对应，格式化、日期组件抽取等等#calendars 类似#dates，与java.util.Calendar对象对应#numbers 格式化数字对象的工具方法#strings 与java.lang.String对应的工具方法：contains、startsWith、prepending/appending等等#objects 用于对象的工具方法#bools 用于布尔运算的工具方法#arrays 用于数组的工具方法#lists 用于列表的工具方法#sets 用于set的工具方法#maps 用于map的工具方法#aggregates 用于创建数组或集合的聚合的工具方法#messages 用于在变量表达式内部获取外化消息的工具方法，与#&#123;…&#125;语法获取的方式相同#ids 用于处理可能重复出现（例如，作为遍历的结果）的id属性的工具方法 使用springsecurity权限标签的方法添加依赖123456&lt;!--如果项目中使用到了springsecurity4， 则要加入下面的依赖来使用权限标签--&gt;&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity4&lt;/artifactId&gt; &lt;version&gt;3.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; 开启命名空间支持123456&lt;html xmlns:th="http://www.thymeleaf.org" xmlns:sec="http://www.thymeleaf.org/thymeleaf-extras-springsecurity4"&gt;&lt;/html&gt;使用方式与jsp标签类似：&lt;a th:href="@&#123;/auth/systemLogger/edit.do&#125;" class="btn btn-success btn-xs no-hover" th:text="#&#123;common.create&#125;" sec:authorize="hasRole('LOGGER_ADD')"&gt;&lt;/a&gt;&lt;button class="btn btn-danger btn-xs" id="delete" th:text="#&#123;common.delete&#125;" sec:authorize="hasRole('LOGGER_DELETE')"&gt;&lt;/button&gt; 调用spring管理的bean的方法语法：${@beanName.methodName(param,…)}说明：beanName就是注册时的名称示例：123#httpSession就是javax.servlet.http.HttpSession对象#httpServletRequest就是javax.servlet.http.HttpServletRequest对象&lt;span th:text="$&#123;@commonService.clearSessionMessage(#httpServletRequest)&#125;" style="display: none"&gt;&lt;/span&gt; 参考资料 https://www.cnblogs.com/itdragon/archive/2018/04/13/8724291.html https://blog.csdn.net/abap_brave/article/details/53009149]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django2学习笔记]]></title>
    <url>%2F2018%2F04%2F28%2Fdjango2_study%2F</url>
    <content type="text"><![CDATA[摘要 版本：python3.6.4+django2.0.3Demo：https://github.com/hanqunfeng/DjangoHelloWorld 参考资料：官方资料Django 1.8.2 文档Django 1.11.6 文档Django 2.0.2文档Django中文教程 1.安装pip install Djangopython -m django --version 2.创建新项目django-admin startproject mysite # mysite就是项目名称 3.创建新的应用python manage.py startapp polls # polls是应用名称settings.py中加入新应用配置123456789INSTALLED_APPS = [ 'polls.apps.PollsConfig', 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles',] 4.创建和更新数据库：python manage.py makemigrations # 全部应用都会创建迁移文件 python manage.py makemigrations polls # 只创建指定的应用 python manage.py migrate # 执行迁移文件到数据库 查看迁移文件生成的sql: sqlmigrate命令接收迁移文件的名字并返回它们的SQL语句：#只是打印出要执行的sql语句 python manage.py sqlmigrate polls 0001 # 这里迁移文件的后缀_initial.py不需要。 5.启动服务器Django的管理后台站点是默认启用的。 让我们启动开发服务器，然后探索它。如果服务器没有运行，像下面这样启动它： python manage.py runserver 现在，打开一个浏览器访问你本地域名中的 “/admin/” — 例如http://127.0.0.1:8000/admin/。 启动： python manage.py runserver 9000 #指定启动端口 python manage.py runserver 0.0.0.0:9000 #指定启动ip+端口 6.测试：python manage.py test #运行整个项目的全部tests.py python manage.py test django2 #运行指定模块的tests.py python manage.py test django2.tests.Django2Test #测试指定模块的指定测试类 python manage.py test django2.tests.Django2Test.test_sql #测试指定模块的指定测试类指定方法 7.检查代码覆盖率：pip install coverage coverage run my_program.py arg1 arg2 django检查方法： coverage run --source=&#39;.&#39; manage.py test myapp 之后可以运行 coverage report ：显示结果 coverage html：生成html 测试会在当前项目下生成htmlcov目录，运行index.html即可查看 8.mysql:brew install mysql-connector-c pip install mysqlclient 需要提前创建好数据库settings.py:12345678910DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'django', 'USER': 'django', 'PASSWORD': 'django', 'HOST': '127.0.0.1', 'PORT': '3306', &#125;&#125; 数据库更新：一般情况下，我们使用如下两个命令更新数据库 python manage.py makemigrations #生成数据库模型文件 python manage.py migrate #执行模型文件 或者：python manage.py migrate --database=users #指定数据库，默认为default 如果由于默写原因删除了数据库中对应的表，则再次执行上面的命令是不能重新创建成功的，原因是每次django执行模型文件时都会在django_migrations表中新增对应的log记录，删掉对应的log记录即可重新执行成功。 9.多数据源配置django配置连接多个数据库，自定义表名称：https://www.cnblogs.com/dreamer-fish/p/5469141.html 使用models文件夹维护model时，一定要在其下的init.py中添加对model的引用，否则python manage.py makemigrations 命令不会创建出对应的迁移文件比如：1234from .person import Personfrom .user import Userfrom .identity_card import IdentityCardfrom .car import Car 数据库路由:settings.py:1DATABASE_ROUTERS = ['django2.router.django2_router.Django2Router', ] 可以将对应的迁移文件的sql导入到指定的db，所以路由器的设置很重要12345def allow_migrate(self, db, app_label, model_name=None, **hints): if db == 'django2_db': #如果指定了数据库 return app_label == 'django2' #并且model被设置了正确的app_label，则可以执行迁移文件 elif app_label == 'django2': return False 设置好数据库路由器后，执行python manage.py migrate –database=django2_db 10.缓存说明：不推荐使用站点级缓存和页面级缓存，除非是展示信息类的网站，如果是频繁修改的站点，最好手工在代码中维护缓存。 1).memcached brew install memcached 启动：memcached -d -p 11211 -c 1024 -m 64 -d:后台运行-p:端口-c:最大连接数-m:最多分配内存 1.使用memcached：pip install python-memcached 2.settings 123456789# 缓存设置CACHES = &#123; 'default': &#123; 'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache', 'LOCATION': '127.0.0.1:11211', 'TIMEOUT': 600, # 单位秒，默认300s, 60s * 10 = 10min 'KEY_PREFIX': 'myapp', # 缓存键的字符串前缀 &#125;&#125; 3.代码中12from django.core.cache import cachescache = caches['default'] 123456#如果希望使用默认的default，也可以from django.core.cache import cachecache.set('user_list', user_list)user_list = cache.get('user_list')user_list = cache.delete('user_list') 2).redis 参考资料：http://django-redis-chs.readthedocs.io/zh_CN/latest/ 1.brew install redis 启动：redis-server /usr/local/etc/redis.conf 2.pip install django-redis 3.settings123456789101112131415161718192021222324# 缓存设置CACHES = &#123; 'default': &#123; 'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache', 'LOCATION': '127.0.0.1:11211', 'TIMEOUT': 600, # 单位秒，默认300s, 60s * 10 = 10min 'KEY_PREFIX': 'myapp', # 缓存键的字符串前缀 &#125;, "redis": &#123; "BACKEND": "django_redis.cache.RedisCache", "LOCATION": "redis://127.0.0.1:6379/1", 'TIMEOUT': 600, "OPTIONS": &#123; "CLIENT_CLASS": "django_redis.client.DefaultClient", "SOCKET_CONNECT_TIMEOUT": 5, # in seconds socket 建立连接超时设置 "SOCKET_TIMEOUT": 5, # in seconds 连接建立后的读写操作超时设置 "COMPRESSOR": "django_redis.compressors.zlib.ZlibCompressor", # 压缩支持 "IGNORE_EXCEPTIONS": True, # 如果redis服务关闭，不会引起异常，memcached默认支持 "CONNECTION_POOL_KWARGS": &#123;"max_connections": 100&#125; # 连接池 &#125; &#125;&#125;# redis记录异常日志DJANGO_REDIS_LOG_IGNORED_EXCEPTIONS = True 4.代码中123456from django.core.cache import cachesredis_cache = caches['redis']redis_cache.set('user_list', user_list)user_list = redis_cache.get('user_list')user_list = redis_cache.delete('user_list') 11.注册模板自定义方法:1.创建myapp.libraries.utils.py123456789101112131415161718from django import templateregister = template.Library()color = ((1, 'red'), (2, 'black'), (3, 'blue'))# @register.filter使用方法，最多两个参数# &#123;&#123; car.carColor|getcolorstr &#125;&#125;# &#123;&#123; car.carColor|getcolorstr:param2 &#125;&#125; 前面的表示第一个参数@register.filterdef getcolorstr(colorNum): return color[colorNum - 1][1]# @register.simple_tag使用方法，不限制参数个数# &#123;% getcolorstr2 car.carColor %&#125;# &#123;% getcolorstr2 param1 param2 param3 %&#125;@register.simple_tagdef getcolorstr2(colorNum): return color[colorNum - 1][1] 2.settings:在模板配置中加入libraries配置12345678910111213141516171819TEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR, 'templates')] , 'APP_DIRS': True, 'OPTIONS': &#123; 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], 'libraries': &#123; # Adding this section should work around the issue. 'utils': 'myapp.libraries.utils', &#125;, &#125;, &#125;,] 3.模板页面中使用123&#123;% load utils %&#125;&#123;&#123; car.carColor|getcolorstr &#125;&#125;&#123;% getcolorstr2 car.carColor %&#125; 12.模板1.转义:由于模板系统没有“转义”的概念，为了显示模板标签中使用的一个位，必须使用{％ templatetag ％}标记。123456789论据 输出openblock &#123;％closeblock ％&#125;openvariable &#123;&#123;closevariable &#125;&#125;openbrace &#123;closebrace &#125;opencomment &#123;＃closecomment ＃&#125; 例如：1&#123;% templatetag openblock %&#125; url &apos;entry_list&apos; &#123;% templatetag closeblock %&#125; 或者使用如下方式：被包含的内容不会被模板引擎转意，将直接输出123&#123;% verbatim myblock %&#125; Avoid template rendering via the &#123;% verbatim %&#125;&#123;% endverbatim %&#125; block.&#123;% endverbatim myblock %&#125; 2.for:12345678变量 描述forloop.counter 循环的当前迭代（1索引）forloop.counter0 循环的当前迭代（0索引）forloop.revcounter 循环结束的迭代次数（1索引）forloop.revcounter0 循环结束的迭代次数（0索引）forloop.first 如果这是第一次通过循环，则为真forloop.last 如果这是最后一次循环，则为真forloop.parentloop 对于嵌套循环，这是围绕当前循环的循环 13.自定义400、403、404、500页面1.settings.py中DEBUG = False，否则自定义页面不起作用 2.在任意模块下的views.py中增加如下方法，也可以在主模块中创建一个views.py方法处理逻辑可以参考：~venv/lib/python3.6/site-packages/django/views/defaults.py中对各个方法的定义1234567891011121314151617from django.shortcuts import renderdef bad_request(request, exception, template_name='400.html'): return render(request, template_name)def permission_denied(request, exception, template_name='403.html'): return render(request, template_name)def page_not_found(request, exception, template_name='404.html'): context = &#123;'exception': exception&#125; return render(request, template_name, context=context)def server_error(request, template_name='500.html'): return render(request, template_name) 3.在项目根目录下的templates下创建对应的400.html、403.html、404.html、500.html，内容更加需要自定义，也可以参考~venv/lib/python3.6/site-packages/django/views/templates下的对应文件 4.在主模块下urls.py中增加如下配置:1234handler400 = 'DjangoHelloWorld.views.bad_request' #模块名称.views.方法名称handler403 = 'DjangoHelloWorld.views.permission_denied'handler404 = 'DjangoHelloWorld.views.page_not_found'handler500 = 'DjangoHelloWorld.views.server_error' 14.Django配置session超时#配置失效时间为半个小时SESSION_COOKIE_AGE = 60*30 #关闭浏览器清除cookieSESSION_EXPIRE_AT_BROWSER_CLOSE = True 15.json与xml1.json创建一个JSONUtil工具类，用于返回json数据1234567891011121314151617181920212223242526272829303132333435363738import jsonfrom django.core.serializers import serialize, deserializefrom django.db import modelsfrom django.db.models.query import QuerySetfrom django.http import JsonResponse# 反序列化def json_to_list(json): if json[0] == '[': deserializedObjectList = deserialize('json', json) else: deserializedObjectList = deserialize('json', '[' + json + ']') list = [] for deserializedObject in deserializedObjectList: list.append(deserializedObject.object) return list# 序列化def to_json(obj): if isinstance(obj, models.Model): obj = [obj] # 因为serialize只支持可迭代对象，比如querySet对象 data = serialize("json", obj) return data# 该方法没有做严格的验证，只支持dict,models.Model,models.QuerySet，可以根据需要自行扩展def render_json(data, dict_key='data', **response_kwargs): if isinstance(data, dict): return JsonResponse(data) data = to_json(data) if 'safe' in response_kwargs and response_kwargs['safe'] is False: pass else: data = &#123;dict_key: data&#125; # 默认必须传递字典数据 if isinstance(data, str): # 由于非字典类型的数据会被当做字符串处理，即返回结果两边都有引号，所以此处将其转换为对象，否则ajax调用时不方便处理 data = json.loads(data) return JsonResponse(data, **response_kwargs) view.py中：123def user_query_json(request): user_list = User.objects.all() return JSONUtil.render_json(user_list, safe=False) # safe=False可以传递对象，否则必须传递一个dict，ajax请求时这样要设置safe=False，这样页面可以直接获取到对象 返回结果，可以看到两边没有引号：[{“model”: “myapp.user”, “pk”: 4, “fields”: {“name”: “\u54c8\u54c8”, “birth_day”: “2018-04-09”, “phone”: “None”, “email”: “None”}}, {“model”: “myapp.user”, “pk”: 9, “fields”: {“name”: “\u5929\u738b\u5c71”, “birth_day”: “2018-09-10”, “phone”: “123”, “email”: “123@123.com“}}] 1234def user_query_json_get(request, user_id): user = User.objects.get(pk=user_id) # user = User.objects.filter(pk=user_id) return JSONUtil.render_json(user, dict_key='user', safe=True) 返回结果：[{“model”: “myapp.user”, “pk”: 1, “fields”: {“name”: “\u97e9\u7fa4\u5cf0”, “birth_day”: “2018-04-07”, “phone”: “None”, “email”: “qunfeng_han@126.com“}}] 模板中：123456789101112131415161718192021222324&lt;script src="&#123;% static 'polls/js/jquery-1.11.0.min.js' %&#125;"&gt;&lt;/script&gt; #注意这里必须有闭合标签&lt;/script&gt;，否则显示会有问题&lt;div id="userdiv"&gt;&lt;/div&gt;&lt;div id="userlistdiv"&gt;&lt;/div&gt;&lt;script&gt; $.getJSON("&#123;% url 'myapp:user_query_json_get' 1 %&#125;", function(ret) &#123; $.each(ret, function (key, value) &#123; // key 为字典的 key，value 为对应的值 $("#userdiv").append(value.pk+"#"+value.fields.name+"#"+value.fields.birth_day+"#"+value.fields.phone+"#"+value.fields.email+"&lt;br&gt;") &#125;); &#125;); $.getJSON("&#123;% url 'myapp:user_query_json' %&#125;", function(ret) &#123; $.each(ret, function (key, value) &#123; // key 为字典的 key，value 为对应的值 $("#userlistdiv").append(value.pk+"#"+value.fields.name+"#"+value.fields.birth_day+"#"+value.fields.phone+"#"+value.fields.email+"&lt;br&gt;") &#125;); &#125;)&lt;/script&gt; 2.xml XMLUtil.py 12345678910111213141516171819202122232425262728293031# -*- coding=utf-8 -*-from django.core import serializersfrom django.db import modelsfrom django.db.models.query import QuerySetfrom django.http import HttpResponsedef render_xml(data): data = to_xml(data) response = HttpResponse(data) response['Content-Type'] = 'application/xml' return response# 序列化def to_xml(data): if isinstance(data, models.Model): data = [data] # 因为serialize只支持可迭代对象，比如querySet对象 elif isinstance(data, QuerySet): data = data else: pass data = serializers.serialize("xml", data) return data# 反序列化def xml_to_list(xml): deserializedObjectList = serializers.deserialize("xml", xml) list = [] for deserializedObject in deserializedObjectList: list.append(deserializedObject.object) return list views.py123456789from utils import XMLUtildef user_query_xml(request): user_list = User.objects.all() return XMLUtil.render_xml(user_list)def user_query_xml_get(request, user_id): user = User.objects.get(pk=user_id) return XMLUtil.render_xml(user) 输出结果12345678910111213141516171819&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;django-objects version="1.0"&gt; &lt;object model="myapp.user" pk="4"&gt; &lt;field name="name" type="CharField"&gt;哈哈&lt;/field&gt; &lt;field name="birth_day" type="DateField"&gt;2018-04-09&lt;/field&gt; &lt;field name="phone" type="CharField"&gt;13800138000&lt;/field&gt; &lt;field name="email" type="CharField"&gt;138@qq.com&lt;/field&gt; &lt;/object&gt; &lt;object model="myapp.user" pk="2"&gt; &lt;field name="name" type="CharField"&gt;张三&lt;/field&gt; &lt;field name="birth_day" type="DateField"&gt; &lt;None&gt;&lt;/None&gt; &lt;/field&gt; &lt;field name="phone" type="CharField"&gt; &lt;None&gt;&lt;/None&gt; &lt;/field&gt; &lt;field name="email" type="CharField"&gt;zhansan@163.com&lt;/field&gt; &lt;/object&gt;&lt;/django-objects&gt; js:123456789101112131415161718$.ajax(&#123; url:"&#123;% url 'myapp:user_query_xml' %&#125;", type:"GET", dataType:'xml', success:function(xml)&#123; $(xml).find("object").each(function(i) &#123; //获取id var id=$(this).attr("pk"); var content = ""; $(this).find("field").each(function(j)&#123; content += $(this).attr('name') + "==" + $(this).text() + "#" &#125;) $("#userdivxml").append(id+ "#" + content +"&lt;br&gt;") &#125;); &#125;, error:function()&#123; alert("加载失败"); &#125;&#125;) 16.response添加相应头一般我们返回视图时都是调用from django.shortcuts import render的render(request, ‘myapp/user/index.html’, context)实际上它返回的是一个HttpResponse对象，我们可以这样为其添加返回头123response = render(request, 'myapp/user/index.html', context)response['Last-Modified'] = date.strftime('%a, %d %b %Y %H:%M:%S GMT')return response 17.多语言参考：https://code.ziqiangxuetang.com/django/django-internationalization.html 1.brew install gettext 2.pip的bug，需要手工处理/venv/lib/python3.6/site-packages/pip-9.0.1-py3.6.egg/pip/_vendor/webencodings/修改3个文件：init.py，tests.py，x_user_defined.py，将：utf8 修改为 utf-8.3.settings.py123456LANGUAGE_CODE = 'zh-hans' # 英文是en，这里是中文，注意这里必须配置为zh-hans，而下面创建和编译语言文件是要使用zh_hansUSE_I18N = TrueLOCALE_PATHS = ( os.path.join(BASE_DIR, 'myapp/locale'), # 应用下的路径 os.path.join(BASE_DIR, 'locale'),) 注意：这里『locale』文件夹需要手工创建，默认就是项目根路径下的locale目录。这里需要注意一点，如果应用下面创建了locale并且配置到LOCALE_PATHS中，则后面执行创建命令时，无论是在项目根路径下执行还是在应用下执行，都只会将语言文件创建到应用下的locale中。如果应用下没用locale目录则需要在项目根路径下执行命令，并且创建到项目根路径下的locale目录中。 4.在代码中加入一些多语言对应的内容代码中12from django.utils.translation import ugettext as _ output = _('Today is %(month)s %(day)s.') % &#123;'month': m, 'day': d&#125; 模板页面中可以直接使用下划线的别名形式12&#123;&#123; _('Django site admin') &#125;&#125;&lt;br&gt;&#123;&#123; _('my test local') &#125;&#125;&lt;br&gt; 1234567891011121314151617这里注意，如果要使用『trans』标签，必须在页面中加载 i18n&#123;% load i18n %&#125;&#123;% trans "my test local" %&#125;&lt;br&gt;&#123;#将翻译结果保存到变量中#&#125;&#123;% trans "my test local" as mylocal %&#125;&#123;&#123; mylocal &#125;&#125;&lt;br&gt;&#123;#设置局部显示的语言，下面的内容将显示对应的英文内容，但只在区块内有效#&#125;&#123;% language 'en' %&#125; &#123;% get_current_language as LANGUAGE_CODE %&#125; Current language: &#123;&#123; LANGUAGE_CODE &#125;&#125; &lt;br&gt; #区块内显示en &#123;&#123; _('Django site admin') &#125;&#125;&lt;br&gt;&#123;% endlanguage %&#125;&#123;% get_current_language as LANGUAGE_CODE %&#125; Current language: &#123;&#123; LANGUAGE_CODE &#125;&#125; &lt;br&gt; #区块外显示zh-hans 如果没有找到对应的key值，则会直接显示待翻译的key值字符串；如果对应的语言包下没有找到key值，而默认语言包下有对应的key值，则会显示默认的语言，如LANGUAGE_CODE = ‘zh-hans’ PS:如果需要翻译的内容包含变量，比如_(‘Today is %(month)s %(day)s.’) ，最好在后台处理好后做为变量传递到模板页面上，目前暂不知道如何在模板中直接处理。 5.创建或更新语言文件 django-admin makemessages -l en # 英文 django-admin makemessages -l zh_hans #指定中文语言，注意这里不要写成zh-hans 会在locale目录下生成对应的语言包django.po django-admin makemessages -a #全部语言 说明：如果在项目根路径下执行，会将项目中所有应用都扫描一遍并汇总合并到一起，如果在某个应用下执行命令，则只会扫描当前应用，并在其下的locale目录下创建文件，优先级根据settings中配置的LOCALE_PATHS的顺序而定。 6.编译 django-admin compilemessages --locale zh_hans #指定语言 django-admin compilemessages # 全部语言 django.po—-&gt;diango.mo 7.语言切换 1）在settings中的中间件配置中加入如下配置：12345678910MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.locale.LocaleMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware',] 2）url中加入配置：1path('i18n/', include('django.conf.urls.i18n')), #对应下面的&#123;% url 'set_language' %&#125; 变更后的语言会保存在session中，可以通过request.session[&#39;_language&#39;]获得 3）在模板页面中需要切换语言的地方加入如下代码：1234567891011121314&lt;form action="&#123;% url 'set_language' %&#125;" method="post"&gt;&#123;% csrf_token %&#125; &lt;input name="next" type="hidden" value="&#123;&#123; redirect_to &#125;&#125;" /&gt; &lt;select name="language"&gt; &#123;% get_current_language as LANGUAGE_CODE %&#125; &#123;% get_available_languages as LANGUAGES %&#125; &#123;% get_language_info_list for LANGUAGES as languages %&#125; &#123;% for language in languages %&#125; &lt;option value="&#123;&#123; language.code &#125;&#125;"&#123;% if language.code == LANGUAGE_CODE %&#125; selected&#123;% endif %&#125;&gt; &#123;&#123; language.name_local &#125;&#125; (&#123;&#123; language.code &#125;&#125;) &lt;/option&gt; &#123;% endfor %&#125; &lt;/select&gt; &lt;input type="submit" value="Go" /&gt;&lt;/form&gt; 说明：redirect_to：如果不设置就会返回当前页面，设置的话就会跳转到设置的页面这里get_available_languages会显示所有支持的语言，不过一般项目不会支持这么多的语言，所以可以在settings中增加配置来明确语言范围：12345LANGUAGES = ( ('en', ('English')), ('zh-hans', ('中文简体')), ('zh-hant', ('中文繁體')),) 4）js中使用多语言js需要单独处理，比如我们写了一个js文件，路径为project/myapp/static/myapp/js/test.js12a = gettext('wwww hhhh')alert(a) 模板中引入： #下面这个是动态js，必须引入，否则gettext方法不起作用12&lt;script type="text/javascript" src="&#123;% url 'javascript-catalog' %&#125;"&gt;&lt;/script&gt;&lt;script src="&#123;% static 'myapp/js/test.js' %&#125;"&gt;&lt;/script&gt; urls加入对javascript-catalog的支持：path(&#39;jsi18n/&#39;, JavaScriptCatalog.as_view(), name=&#39;javascript-catalog&#39;),` 执行如下命令： django-admin makemessages -d djangojs -l zh_hans此时会在应用下的locale中生成djangojs.po文件（如果配置了应用locale，否则会在项目下的locale中创建） django-admin compilemessages --locale zh_hans此时会将djangojs.po编译为djangojs.mo 如果直接将带翻译的js代码写在模板页面中，暂时不清楚要通过什么命令实现，不过可以有个折中的办法，就是创建一个js文件，然后将所有需要翻译的内容都加上，然后运行上面两个命令，这样django在运行模板中的js时同样可以完成翻译模板中：1234&lt;script&gt; alert(gettext('hello js')) alert(gettext('o my god'))&lt;/script&gt; js中：只要js代码中出现翻译方法的地方都会被加入翻译，这个js不需要被任何模板引入，也不需要被同步到静态文件夹中，仅仅是为生成翻译文件而存在12gettext('hello js')gettext('o my god') 18.日志1.settings1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071LOGGING = &#123; 'version': 1, 'disable_existing_loggers': False, # 是否禁用logger，建议设置为False 'formatters': &#123; # 日志格式，提供给handler使用，非必须，如果不设置格式，默认只会打印消息体 'verbose': &#123; # 格式名称 # INFO 2018-04-25 15:43:27,586 views 8756 123145350217728 这是一个日志 'format': '%(levelname)s %(asctime)s %(module)s %(process)d %(thread)d %(message)s' &#125;, 'simple': &#123; # INFO 这是一个日志 'format': '%(levelname)s %(message)s' &#125;, 'standard': &#123; # 2018-04-25 16:40:00,195 [Thread-7:123145575223296] [myapp.log:282] [views:user_query_json_get] [INFO]- 这是一个日志 'format': '%(asctime)s [%(threadName)s:%(thread)d] [%(name)s:%(lineno)d] [%(module)s:%(funcName)s] [%(levelname)s]- %(message)s' &#125;, &#125;, 'filters': &#123; # 过滤器，提供给handler使用，非必须 'require_debug_true': &#123; # 要求DEBUG=True时才打印日志 '()': 'django.utils.log.RequireDebugTrue', &#125;, &#125;, 'handlers': &#123; # 处理器，设置日志记录方式，必须 'console': &#123; # 处理器名称 'level': 'DEBUG', # 设置级别 'filters': ['require_debug_true'], # 设置过滤器，多个用逗号分割 'class': 'logging.StreamHandler', # 处理器，这里是控制台打印 'formatter': 'verbose' # 设置日志格式 &#125;, 'file': &#123; 'level': 'DEBUG', 'class': 'logging.FileHandler', # 记录到文件 'filename': '/Users/hanqunfeng/python_workspace/log/file.log', 'formatter': 'verbose' &#125;, 'rotatingFile': &#123; 'level': 'DEBUG', 'class': 'logging.handlers.RotatingFileHandler', # 按文件大小切割日志 # 'filename': 'log/all.log', # 日志输出文件 默认在当前项目根路径下 'filename': '/Users/hanqunfeng/python_workspace/log/rotatingFile.log', # 日志输出文件 'maxBytes': 1024 * 1024 * 5, # 每个文件大小 'backupCount': 5, # 保留日志份数，只保留最后5份，如果都保留，设置为0，默认就是0 'formatter': 'standard', # 使用哪种formatters日志格式 &#125;, 'timedRotatingFile': &#123; 'level': 'DEBUG', 'class': 'logging.handlers.TimedRotatingFileHandler', # 按时间切割日志 'filename': '/Users/hanqunfeng/python_workspace/log/timedRotatingFile.log', # 日志输出文件 'when': 'D', # 按天分割 'backupCount': 5, # 保留日志份数，只保留最后5份，如果都保留，设置为0，默认就是0 'formatter': 'standard', # 使用哪种formatters日志格式 &#125;, &#125;, 'loggers': &#123;#日志记录器 'django': &#123;#日志名称路径前缀，即logging.getLogger(__name__)获取logger对象时，_name__得到的前缀与之匹配即可，比如__name__得到的是django.server 'handlers': ['console'], 'propagate': True, 'level': os.getenv('DJANGO_LOG_LEVEL', 'DEBUG'), # 只有设置DEBUG = True时，该配置才会打印sql信息 &#125;, 'django.request': &#123; 'handlers': ['rotatingFile'], 'level': 'ERROR', 'propagate': False, # 设置为False，表示不像其父级别传递日志内容 &#125;, 'myapp.log': &#123; # 也可以这样创建logger对象，logging.getLogger('myapp.log') 'handlers': ['file', 'timedRotatingFile'], 'level': 'INFO', # 这里的日志级别不能低于处理器中设置的日志级别 &#125;, &#125;,&#125; 代码中使用方式：12345678# 导入logging库import logging# 获取logger的一个实例# logger = logging.getLogger(__name__)logger = logging.getLogger('myapp.log')# 方法中：logger.info('这是一个日志') 19.发送邮件1.settings1234567EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'EMAIL_USE_SSL = TrueEMAIL_HOST = 'smtp.163.com'EMAIL_PORT = 465EMAIL_HOST_USER = 'xxx@163.com' # 帐号EMAIL_HOST_PASSWORD = 'xxxxxxx' # 密码DEFAULT_FROM_EMAIL = 'hanqf &lt;xxx@163.com&gt;' 2.代码里12345678910111213141516171819202122232425from django.conf import settings# 发送邮件from django.core.mail import send_mailsend_mail('Subject here主题', 'Here is the message.消息', settings.DEFAULT_FROM_EMAIL, ['aaaaa@126.com'], fail_silently=False)# 一次可以发送多组邮件from django.core.mail import send_mass_mailmessage1 = ('Subject here', 'Here is the message', settings.DEFAULT_FROM_EMAIL, ['aaaaa@126.com', 'aaaaa@163.com'])message2 = ('Another Subject', 'Here is another message', settings.DEFAULT_FROM_EMAIL, ['aaaaa@126.com'])send_mass_mail((message1, message2), fail_silently=False)# 可以这是抄送附件等from django.core.mail import EmailMultiAlternativesmsg = EmailMultiAlternatives('主题', '内容', settings.DEFAULT_FROM_EMAIL, ['aaaaa@126.com'], cc=['aaaaa@163.com'])# msg.content_subtype = "html" # 设置邮件格式，html可以发送内容为html，不推荐这么使用，可以使用下面的方式html_content = '&lt;p&gt;这是一封&lt;strong&gt;重要的&lt;/strong&gt;邮件.&lt;/p&gt;'msg.attach_alternative(html_content, "text/html") # 如果接收方的邮件支持html，则显示该信息，否则显示原「内容」# 添加附件（可选）msg.attach_file('/Users/hanqunfeng/python_workspace/STATIC_ROOT/polls/images/background.jpg')# 发送msg.send() 20.main方法测试mian方法测试一定要在如下情况下使用，这样可以保证当前模块被别处引用时不会触发如下测试代码，只有独立运行该模块时才会执行。12345678910if __name__ == '__main__': # 加载环境配置 import django, os os.environ.setdefault("DJANGO_SETTINGS_MODULE", "DjangoHelloWorld.settings") django.setup() # 以下是测试内容 from myapp.models.user import User user_list = User.objects.all() xml = to_xml(user_list) print(xml) 21.Signal，信号，有点类似MQ1.定义信号和接收器123456789101112from django.dispatch import Signal, receiver# my_singal = Signal()my_singal = Signal(providing_args=["key1", "key2"]) # 定义信号接收的参数，不指定参数也可以@receiver(my_singal)def my_callback(sender, **kwargs): # 接收器回调函数 print(sender) print(kwargs) for key in kwargs: print(key) print(kwargs[key]) print("Request finished!") 2.发送信号，发送信号时接收器就会被执行12from signals.signals import my_singalmy_singal.send(sender=__name__, key1='qqq', key2=10, key3=100) # 实际上可以多发送一些参数 22.Django管理后台简介首先，我们需要创建一个能够登录管理后台站点的用户。运行如下命令：1python manage.py createsuperuser 键入你想要使用的用户名，然后按下回车键：1Username: admin 然后提示你输入想要使用的邮件地址：1Email address: admin@example.com 你需要输入两次密码，第二次输入是确认密码123Password: **********Password (again): *********Superuser created successfully. PS：管理员密码忘记了可以通过如下方法修改：123456$ python manage.py shell&gt;&gt;&gt; from django.contrib.auth.models import User&gt;&gt;&gt; user = User.objects.get(pk=1) # 可以通过查询获得用户对象&gt;&gt;&gt; user.set_password('xxxxxxxx')&gt;&gt;&gt; user.save()&gt;&gt;&gt; quit() 23.部署正式环境settings.py:123456789101112DEBUG = False # 此时很多问题就会出现，需要增加很多额外的配置才能正常工作，这也是为了包含生产环境吧ALLOWED_HOSTS = ['127.0.0.1']# ALLOWED_HOSTS = ['*', ] # 允许所有机器访问STATIC_URL = 'http://localhost/static/' # apache部署的静态文件服务器访问地址STATIC_ROOT = "/Users/hanqunfeng/python_workspace/STATIC_ROOT/" #apache 服务目录# 上传文件路径MEDIA_URL = 'http://localhost/media/'MEDIA_ROOT = '/Users/hanqunfeng/python_workspace/MEDIA/' apache配置：12345678910Alias /media/ /Users/hanqunfeng/python_workspace/MEDIA/Alias /static/ /Users/hanqunfeng/python_workspace/STATIC_ROOT/&lt;Directory /Users/hanqunfeng/python_workspace/STATIC_ROOT&gt;Require all granted&lt;/Directory&gt;&lt;Directory /Users/hanqunfeng/python_workspace/MEDIA/&gt;Require all granted&lt;/Directory&gt; 使用如下命令可以将本地的静态资源部署到apache服务目录：1python manage.py collectstatic 模板页面：123&#123;% load static %&#125;&lt;link rel="stylesheet" type="text/css" href="&#123;% static 'polls/style.css' %&#125;" /&gt; 上传文件：model中：1photo = models.ImageField(upload_to="photo", default="default/django.jpeg") # 路径相对于MEDIA_ROOT的配置 之后要注意更新数据库。 需要安装Pillow，否则会报错123ERRORS:polls.Question.photo: (fields.E210) Cannot use ImageField because Pillow is not installed. HINT: Get Pillow at https://pypi.python.org/pypi/Pillow or run command &quot;pip install Pillow&quot;. 1pip install Pillow 如果要在页面中使用settings中的变量，需要在当前应用中创建一个context_processors.py 文件12345from django.conf import settings # import the settings filedef settings_constant(request): # return the value you want as a dictionnary. you may add multiple values in there. return &#123;'MEDIA_URL': settings.MEDIA_URL, 'DEBUG': settings.DEBUG&#125; 并在settings文件配置如下 1234567891011121314151617TEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR, 'templates')] , 'APP_DIRS': True, 'OPTIONS': &#123; 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', 'polls.context_processors.settings_constant', #应用名称.文件名称.方法名称 ], &#125;, &#125;,] 模板页面中：123456789&lt;form enctype="multipart/form-data"&gt;&lt;img src="&#123;&#123;MEDIA_URL&#125;&#125;abc/a.png"&gt;&lt;input type="file" name="photo" id="id_photo" /&gt;&lt;/form&gt;也可以使用下面的形式获得上传文件的url，即使用上传文件字段的url属性：&#123;&#123; question.photo.url &#125;&#125;&lt;a href="&#123;&#123;MEDIA_URL&#125;&#125;&#123;&#123; question.photo &#125;&#125;"&gt;&#123;&#123; question.photo &#125;&#125;&lt;/a&gt; ##&lt;a href="&#123;&#123; question.photo.url &#125;&#125;"&gt;&#123;&#123; question.photo &#125;&#125;&lt;/a&gt; views处理代码中：123input_img = request.FILES['photo']question.photo = input_imgquestion.save() 部署到apache： 下载mod_wsgi：https://github.com/GrahamDumpleton/mod_wsgi/releases12345tar xvfz mod_wsgi-X.Y.tar.gz./configure --with-apxs=/Applications/XAMPP/bin/apxs --with-python=/Library/Frameworks/Python.framework/Versions/3.6/bin/python3makemake install 然后在apache配置文件中加入如下配置1LoadModule wsgi_module modules/mod_wsgi.so 普通模式：12WSGIPythonHome /Users/hanqunfeng/python_workspace/DjangoHelloWorld/venvWSGIPythonPath /Users/hanqunfeng/python_workspace/DjangoHelloWorld 或者采用守护进程模式：123WSGIDaemonProcess example.com python-home=/Users/hanqunfeng/python_workspace/DjangoHelloWorld/venv python-path=/Users/hanqunfeng/python_workspace/DjangoHelloWorldWSGIProcessGroup example.com 配置项目访问路径1234567WSGIScriptAlias /mysite /Users/hanqunfeng/python_workspace/DjangoHelloWorld/DjangoHelloWorld/wsgi.py&lt;Directory /Users/hanqunfeng/python_workspace/DjangoHelloWorld/DjangoHelloWorld&gt;&lt;Files wsgi.py&gt;Require all granted&lt;/Files&gt;&lt;/Directory&gt; 访问地址：http://127.0.0.1/mysite/polls]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python--virtualenv]]></title>
    <url>%2F2018%2F04%2F28%2Fpython_virtualenv%2F</url>
    <content type="text"><![CDATA[摘要官方网站：https://virtualenv.pypa.io/en/stable/installation/ 执行python项目时都需要为其安装运行环境需要的依赖，比如有些项目需要在python2下运行，有些项目需要在python3下运行，有些项目需要安装mysqlclient依赖，有些项目需要django依赖，如果这些依赖都被安装在统一的系统环境中，势必彼此之间会造成干扰，特别是需要同一个依赖的不同版本时更是难以维护； virtualenv可以为python项目创建独立的虚拟运行环境，这样不同的项目可以运行在各自独立的执行环境中而彼此之间不受干扰； 在使用pycharm创建项目时，需要指定python执行器，此时就是创建的虚拟环境。 安装pip3 install virtualenv 本文使用python3的pip命令安装virtualenv，所以默认情况下创建虚拟环境时都是python3的执行环境，可以通过--python参数指定python的执行环境，详见下文『创建新的虚拟环境』 创建新的虚拟环境virtualenv venv1 # 当前目录下创建venv1文件夹，并在其下创建python环境 默认情况下，除了python本身的命令外不包含系统环境下的第三方依赖，比如系统环境已经安装好django、mysqlclient等，都不会带过来，需要重新在当前虚拟环境下安装。 如果希望访问系统环境中的某些第三方依赖，可以在创建虚拟环境时执行如下命令：virtualenv venv1 --system-site-packages #此时当前虚拟环境就可以访问系统环境了 python本身支持python2和python3同时共存，可以指定python命令路径，比如使用python2的环境 --python1234567## 激活虚拟环境`source activate````shellcd venv1/binhanqunfengdeMacBook-Pro:bin hanqunfeng$ source activate(venv1) hanqunfengdeMacBook-Pro:bin hanqunfeng$ 激活后所有python相关命令都变为venv1下的命令了 退出虚拟环境deactivate12(venv1) hanqunfengdeMacBook-Pro:bin hanqunfeng$ deactivatehanqunfengdeMacBook-Pro:bin hanqunfeng$ 删除虚拟环境rm -rf venv1 删除venv1目录即可]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Protocol Buffer学习笔记(Python)]]></title>
    <url>%2F2018%2F03%2F27%2Fprotocol-buffer-study-python%2F</url>
    <content type="text"><![CDATA[摘要 本文内容基于python3.6.4，protobuf3.5.1，但实际上python2和protobuf2.x.x同样适用 Protocol Buffer学习笔记(Java&amp;NodeJS) Protocol Buffer学习笔记(PHP) 项目中引入proto的依赖【两种方法】：方法1、 官网下载对应的语言包，这里下载protobuf-python-3.5.1.tar.gz，解压后进入python-protobuf-3.5.1/python目录，执行python3 setup.py install方法2 、【推荐】命令行执行pip3 install protobuf，此时会下载最新的protobuf版本，如果下载的版本与本地安装的proto命令版本不一致，有可能导致异常，所以此时最好指定要下载的版本号：pip3 install protobuf==3.5.1 【注意】 上面的安装方式是全局安装，安装成功后对应的依赖包都会被安装到对应的site-packages目录下，比如/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages使用IDE开发时，如PyCharm，绑定interpreter时要注意勾选inherit global site-packages，这样项目才能使用全局依赖中的所有包 如果只是为当前项目安装依赖包可以不勾选inherit global site-packages，然后进入当前项目依赖的pip目录，即Location指定的路径下，执行./bin/pip install protobuf==3.5.1来安装需要的依赖包 准备proto文件 proto示例文件参考[Protocol Buffer学习笔记(Java&amp;NodeJS)](https://www.jianshu.com/p/55f4b4b22dd2) python同时支持proto2和proto3，所以如果基于proto3，这里注意去掉其中的required、optional，因为这里要求语法严格遵循proto3，不能在属性前出现required、optional，同时文件顶端要明确syntax = &quot;proto3&quot;; 生成proto对应的python文件 命令行执行protoc --python_out=. OTIpcDef.proto 此时会在当前目录下生成OTIpcDef_pb2.py，将该文件拷贝到项目中，比如放到项目根目录的proto目录下 python中使用protobuf12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from proto import OTIpcDef_pb2otIpcList = OTIpcDef_pb2.OTIpcList()# list类型数据创建方式otIpc = otIpcList.otpic.add()otIpc.CompanyId = "companyId"otIpc.Source = "Source"otIpc.IPCType = OTIpcDef_pb2.baseInfoCompany# list类型数据创建方式baseInfoCompany = otIpc.baseInfoCompany.add()# print(type(baseInfoCompany))baseInfoCompany.Address = 110011baseInfoCompany.CompanyId = "companyId"baseInfoCompany.CompanyName = "companyName中文"baseInfoCompany.Identifier = "identifier"baseInfoCompany.BusinessScope = "BusinessScope"baseInfoCompany.ContactAddress = "ContactAddress"baseInfoCompany.EconomicType = "EconomicType"baseInfoCompany.RegCapital = "RegCapital"baseInfoCompany.LegalName = "LegalName"baseInfoCompany.LegalID = "LegalID"baseInfoCompany.LegalPhone = "LegalPhone"baseInfoCompany.State = 0baseInfoCompany.Flag = 1baseInfoCompany.UpdateTime = 20180226121212otIpc2 = otIpcList.otpic.add()otIpc2.CompanyId = "companyId"otIpc2.Source = "Source"otIpc2.IPCType = OTIpcDef_pb2.baseInfoCompanyStatbaseInfoCompanyStat = otIpc2.baseInfoCompanyStat.add()baseInfoCompanyStat.CompanyId = "companyId"baseInfoCompanyStat.DriverNum = 10baseInfoCompanyStat.Flag = 0baseInfoCompanyStat.UpdateTime = 20180226121212baseInfoCompanyStat.VehicleNum = 5print("============================================")# print(otIpc)print(otIpcList)print("============================================")# 序列化b = otIpcList.SerializeToString()# 打印二进制数据print(b)print("============================================")otIpcList2 = OTIpcDef_pb2.OTIpcList()# 反序列化otIpcList2.ParseFromString(b)print(otIpcList2)]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>protocbuf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Protocol Buffer学习笔记(PHP)]]></title>
    <url>%2F2018%2F03%2F19%2Fprotocol-buffer-study-php%2F</url>
    <content type="text"><![CDATA[摘要 本文内容基于laravel5.4.*框架 Protocol Buffer学习笔记(Java&amp;NodeJS) 项目中引入proto的依赖在项目根目录下执行如下命令，composer会自动下载最新版本，目前是”google/protobuf”: “^3.5”composer require &quot;google/protobuf&quot; 准备proto文件 注意事项参考：PHP Generated Code proto示例文件参考Protocol Buffer学习笔记(Java&amp;NodeJS)，这里注意去掉其中的required、optional，因为这里要求语法严格遵循proto3，不能在属性前出现required、optional，所以文件顶端要明确syntax = &quot;proto3&quot;;，另外增加package配置为package app.proto; 生成proto对应的php文件 将准备好的proto文件放到laravel根目录下，并在根目录下执行如下命令protoc --php_out=. OTIpcDef.proto 此时会在app目录下自动创建Proto目录，并在其目录下生成对应的php类文件 同时在根目录下会生成GPBMetadata\OTIpcDef.php 由于laravel要求所有的class都必须在app目录下，所以需要移动GPBMetadata目录到app目录下，同时修改对应的namespace 为namespace App\GPBMetadata;; 同时需要修改app\Proto下的各个class的构造方法 1234public function __construct() &#123; \App\GPBMetadata\OTIpcDef::initOnce(); parent::__construct();&#125; php中使用protobuf创建ProtoController12345678910111213namespace App\Http\Controllers;use App\Proto\BaseInfoCompany;use App\Helper\HttpUtils;class ProtoController extends Controller&#123; /** * ProtoController constructor. */ public function __construct() &#123; &#125;&#125; 1.主动获取protobuf数据123456789101112131415161718192021222324252627282930313233343536public function build_proto_data() &#123; $baseInfoCompany = new BaseInfoCompany(); $baseInfoCompany-&gt;setAddress(110011); $baseInfoCompany-&gt;setCompanyId("companyId"); $baseInfoCompany-&gt;setCompanyName("companyName中文"); $baseInfoCompany-&gt;setIdentifier("identifier"); $baseInfoCompany-&gt;setBusinessScope("BusinessScope"); $baseInfoCompany-&gt;setContactAddress("ContactAddress"); $baseInfoCompany-&gt;setEconomicType("EconomicType"); $baseInfoCompany-&gt;setRegCapital("RegCapital"); $baseInfoCompany-&gt;setLegalName("LegalName"); $baseInfoCompany-&gt;setLegalID("LegalID"); $baseInfoCompany-&gt;setLegalPhone("LegalPhone"); $baseInfoCompany-&gt;setState(0); $baseInfoCompany-&gt;setFlag(1); $baseInfoCompany-&gt;setUpdateTime(20180226121212); // $protostr = $baseInfoCompany-&gt;serializeToString(); //生成json $protostr = $baseInfoCompany-&gt;serializeToJsonString(); return $protostr; &#125;public function receive_proto_data()&#123; $protoData = file_get_contents("http://localhost:83/proto/build"); try &#123; $baseInfoCompany = new BaseInfoCompany();// $baseInfoCompany-&gt;mergeFromString($protoData); $baseInfoCompany-&gt;mergeFromJsonString($protoData); echo $baseInfoCompany-&gt;getCompanyName(); return $baseInfoCompany-&gt;serializeToJsonString(); &#125; catch (Exception $ex) &#123; die('something is wrong'); &#125; &#125; 2.被动接收protobuf数据12345678910111213141516171819public function send_proto_data()&#123; $data = $this-&gt;build_proto_data(); $receive = HttpUtils::request_by_curl("http://localhost:83/proto/receive",$data); echo $receive; &#125;public function receive_proto_data()&#123; // $protoData = file_get_contents("http://localhost:83/proto/build"); $protoData = $_POST["data"]; try &#123; $baseInfoCompany = new BaseInfoCompany();// $baseInfoCompany-&gt;mergeFromString($protoData); $baseInfoCompany-&gt;mergeFromJsonString($protoData); echo $baseInfoCompany-&gt;getCompanyName(); return $baseInfoCompany-&gt;serializeToJsonString(); &#125; catch (Exception $ex) &#123; die('something is wrong'); &#125; &#125; 这里用到一个工具类App\Helper\HttpUtils123456789101112131415161718namespace App\Helper;class HttpUtils&#123; public static function request_by_curl($remote_server, $post_string) &#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $remote_server); curl_setopt($ch, CURLOPT_POSTFIELDS, 'data=' . $post_string); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (compatible; MSIE 5.01; Windows NT 5.0)'); curl_setopt($ch, CURLOPT_TIMEOUT, 1);//异步处理 $data = curl_exec($ch); if (curl_errno($ch)) &#123; //响应错误的处理 &#125; curl_close($ch); return $data; &#125;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>protocbuf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA与NodeJS实现AES加密]]></title>
    <url>%2F2018%2F03%2F09%2Fjava_nodejs_aes%2F</url>
    <content type="text"><![CDATA[内容要点本文实现java与nodejs的AES加密方式如下，并可实现java加密，nodejs解密或者nodejs加密，java解密 aes-128-ecb aes-256-ecb aes-128-cbc aes-256-cbc java实现AES注意Java本身限制密钥的长度最多128位，而AES256需要的密钥长度是256位，因此需要到Java官网上下载一个Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files。在Java SE的下载页面下面的Additional Resources那里会有下载链接。下载后打开压缩包，里面有两个jar文件:local_policy.jar和US_export_policy.jar把这两个jar文件解压到JRE目录下的lib/security文件夹，覆盖原来的文件。这样Java就不再限制密钥的长度了，否则编译会报错： java.security.InvalidKeyException: Illegal key size 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245import org.apache.commons.lang.StringUtils;import sun.misc.BASE64Decoder;import sun.misc.BASE64Encoder;import javax.crypto.Cipher;import javax.crypto.spec.IvParameterSpec;import javax.crypto.spec.SecretKeySpec;import java.security.spec.AlgorithmParameterSpec;public class EncodeUtil &#123; public static void main(String[] args) throws Exception &#123; //key是16进制，需要转换为bytes，转换后bytes长度为16，即aes128，如果bytes长度是32则是aes256 //也就是说keybytes.length须满足16的整数倍 String key128 = "c4b84456c1379bec99c4d1b7e9f13173"; String key256 = "c4b84456c1379bec99c4d1b7e9f13173c4b84456c1379bec99c4d1b7e9f13173"; //iv.length须满足16的整数倍 byte[] iv = "abcdefgh12345678".getBytes("UTF-8"); String content_str = "helloworld 你好"; byte[] contentbytes = content_str.getBytes("utf-8"); //ecb128 bytes byte[] encryptbytes = EncodeUtil.aesEncryptToECB(contentbytes,key128); byte[] decryptbytes = EncodeUtil.aesDecryptToECB(encryptbytes,key128); System.out.println(new String(decryptbytes,"utf-8")); //ecb256 bytes encryptbytes = EncodeUtil.aesEncryptToECB(contentbytes,key256); decryptbytes = EncodeUtil.aesDecryptToECB(encryptbytes,key256); System.out.println(new String(decryptbytes,"utf-8")); //ecb128 String String encryptString = EncodeUtil.aesEncryptToECB(content_str,key128); String decryptString = EncodeUtil.aesDecryptToECB(encryptString,key128); System.out.println(decryptString); //ecb256 String encryptString = EncodeUtil.aesEncryptToECB(content_str,key256); decryptString = EncodeUtil.aesDecryptToECB(encryptString,key256); System.out.println(decryptString); //cbc128 bytes encryptbytes = EncodeUtil.aesEncryptToCBC(contentbytes,key128,iv); decryptbytes = EncodeUtil.aesDecryptToCBC(encryptbytes,key128,iv); System.out.println(new String(decryptbytes,"utf-8")); //cbc256 bytes encryptbytes = EncodeUtil.aesEncryptToCBC(contentbytes,key256,iv); decryptbytes = EncodeUtil.aesDecryptToCBC(encryptbytes,key256,iv); System.out.println(new String(decryptbytes,"utf-8")); //cbc128 String encryptString = EncodeUtil.aesEncryptToCBC(content_str,key128,iv); decryptString = EncodeUtil.aesDecryptToCBC(encryptString,key128,iv); System.out.println(decryptString); //cbc256 String encryptString = EncodeUtil.aesEncryptToCBC(content_str,key256,iv); decryptString = EncodeUtil.aesDecryptToCBC(encryptString,key256,iv); System.out.println(decryptString); &#125; /** * base 64 encode * * @param bytes 待编码的byte[] * @return 编码后的base 64 code */ public static String base64Encode(byte[] bytes) &#123; return new BASE64Encoder().encode(bytes); &#125; /** * base 64 decode * * @param base64Code 待解码的base 64 code * @return 解码后的byte[] * @throws Exception */ public static byte[] base64Decode(String base64Code) throws Exception &#123; return StringUtils.isEmpty(base64Code) ? null : new BASE64Decoder().decodeBuffer(base64Code); &#125; /** * 验证密钥长度是否有效 * * @param key 密钥bytes * @throws Exception */ public static void checkkey(byte[] key) throws Exception &#123; if(key.length != 16 &amp;&amp; key.length != 32) &#123; throw new Exception("密钥长度错误，必须是16后者32位"); &#125; &#125; /** * AES加密 aes-128/256-ecb * * @param content 待加密的内容 * @param encryptKey 加密密钥 * @return 加密后的byte[] * @throws Exception */ public static byte[] aesEncryptToECB(byte[] content, String encryptKey) throws Exception &#123; byte[] key = org.apache.commons.codec.binary.Hex.decodeHex(encryptKey.toCharArray()); checkkey(key); Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding"); cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, "AES")); return cipher.doFinal(content); &#125; /** * AES加密 aes-128/256-ecb * * @param content 待加密的内容 * @param encryptKey 加密密钥 * @return 加密后的base64字符串 * @throws Exception */ public static String aesEncryptToECB(String content, String encryptKey) throws Exception &#123; byte[] key = org.apache.commons.codec.binary.Hex.decodeHex(encryptKey.toCharArray()); checkkey(key); Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding"); cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, "AES")); return base64Encode(cipher.doFinal(content.getBytes("utf-8"))); &#125; /** * AES解密 aes-128/256-ecb * * @param content 待解密的byte[] * @param decryptKey 解密密钥 * @return 解密后的byte[] * @throws Exception */ public static byte[] aesDecryptToECB(byte[] content, String decryptKey) throws Exception &#123; byte[] key = org.apache.commons.codec.binary.Hex.decodeHex(decryptKey.toCharArray()); checkkey(key); Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding"); cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key, "AES")); byte[] decryptBytes = cipher.doFinal(content); return decryptBytes; &#125; /** * AES解密 aes-128/256-ecb * * @param content 待解密的byte[] * @param decryptKey 解密密钥 * @return 解密后的String * @throws Exception */ public static String aesDecryptToECB(String content, String decryptKey) throws Exception &#123; byte[] key = org.apache.commons.codec.binary.Hex.decodeHex(decryptKey.toCharArray()); checkkey(key); Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding"); cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key, "AES")); byte[] decryptBytes = cipher.doFinal(base64Decode(content)); return new String(decryptBytes,"utf-8"); &#125; /** * AES加密 aes-128/256-cbc * * @param content 待解密的byte[] * @param encryptKey 加密密钥 * @param iv 偏移 * @return 解密后的byte[] * @throws Exception */ public static byte[] aesEncryptToCBC(byte[] content, String encryptKey,byte[] iv) throws Exception &#123; byte[] key = org.apache.commons.codec.binary.Hex.decodeHex(encryptKey.toCharArray()); checkkey(key); Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding"); //算法参数 AlgorithmParameterSpec paramSpec = new IvParameterSpec(iv); cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, "AES"),paramSpec); return cipher.doFinal(content); &#125; /** * AES解密 aes-128/256-cbc * * @param content 待解密的byte[] * @param decryptKey 解密密钥 * @param iv 偏移 * @return 解密后的byte[] * @throws Exception */ public static byte[] aesDecryptToCBC(byte[] content, String decryptKey,byte[] iv) throws Exception &#123; byte[] key = org.apache.commons.codec.binary.Hex.decodeHex(decryptKey.toCharArray()); checkkey(key); Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding"); //算法参数 AlgorithmParameterSpec paramSpec = new IvParameterSpec(iv); cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key, "AES"),paramSpec); return cipher.doFinal(content); &#125; /** * AES加密 aes-128/256-cbc * * @param content 待解密的byte[] * @param encryptKey 加密密钥 * @param iv 偏移 * @return 解密后的byte[] * @throws Exception */ public static String aesEncryptToCBC(String content, String encryptKey,byte[] iv) throws Exception &#123; byte[] key = org.apache.commons.codec.binary.Hex.decodeHex(encryptKey.toCharArray()); checkkey(key); Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding"); //算法参数 AlgorithmParameterSpec paramSpec = new IvParameterSpec(iv); cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, "AES"),paramSpec); return base64Encode(cipher.doFinal(content.getBytes("utf-8"))); &#125; /** * AES解密 aes-128/256-cbc * * @param content 待解密的byte[] * @param decryptKey 解密密钥 * @param iv 偏移 * @return 解密后的byte[] * @throws Exception */ public static String aesDecryptToCBC(String content, String decryptKey,byte[] iv) throws Exception &#123; byte[] key = org.apache.commons.codec.binary.Hex.decodeHex(decryptKey.toCharArray()); checkkey(key); Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding"); //算法参数 AlgorithmParameterSpec paramSpec = new IvParameterSpec(iv); cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key, "AES"),paramSpec); byte[] decryptBytes = cipher.doFinal(base64Decode(content)); return new String(decryptBytes,"utf-8"); &#125;&#125; nodejs说明以下nodejs代码来源于 aes-cross项目123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186/** * "AES/cbc/pkcs5Padding" encription and decription. * setAutoPadding(true) is actually pkcs5Padding,. */'use strict';var crypto = require('crypto');var CBC = 'cbc';var ECB = 'ecb';var NULL_IV = new Buffer([]);var IV = new Buffer([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);var cipherMode = ECB;var keySize = 128;var algorithm;setAlgorithm();var outputEncoding = 'base64';var inputEncoding = 'utf8';function setAlgorithm() &#123; algorithm = 'aes-' + keySize + '-' + cipherMode;&#125;function setCipherMode(mode) &#123; if (mode !== CBC &amp;&amp; mode !== ECB) &#123; throw ('AES.setCipherMode error: ' + mode); &#125; cipherMode = mode; setAlgorithm();&#125;function setKeySize(size) &#123; if (size !== 128 &amp;&amp; size !== 256) &#123; throw ('AES.setKeySize error: ' + size); &#125; keySize = size; setAlgorithm(); // console.log('setKeySize:%j',keySize);&#125;/** * the key must match the keySize/8 , like:16 ,32 * @param &#123;Buffer&#125; key * @return &#123;&#125; */function checkKey(key) &#123; if (!key) &#123; throw 'AES.checkKey error: key is null '; &#125; if (key.length !== (keySize / 8)) &#123; throw 'AES.checkKey error: key length is not ' + (keySize / 8) + ': ' + key.length; &#125;&#125;/** * buffer/bytes encription * @param &#123;Buffer&#125; buff * @param &#123;Buffer&#125; key the length must be 16 or 32 * @param &#123;Buffer&#125; [newIv] default is [0,0...0] * @return &#123;encripted Buffer&#125; */function encBytes(buff, key, newIv) &#123; checkKey(key); var iv = newIv || IV; if (cipherMode === ECB) iv = NULL_IV; var cipher = crypto.createCipheriv(algorithm, key, iv); cipher.setAutoPadding(true); var re = Buffer.concat([cipher.update(buff), cipher.final()]); // console.log('enc re:%s,len:%d', printBuf(re), re.length); return re;&#125;/** * text encription * @param &#123;string&#125; text * @param &#123;Buffer&#125; key the length must be 16 or 32 * @param &#123;Buffer&#125; [newIv] default is [0,0...0] * @param &#123;string&#125; [input_encoding] ["utf8" -default,"ascii","base64","binary"...](https://nodejs.org/api/buffer.html#buffer_buffer) * @param &#123;string&#125; [output_encoding] ["base64" -default,"hex"] * @return &#123;string&#125; encription result */function encText(text, key, newIv, input_encoding, output_encoding) &#123; checkKey(key); var iv = newIv || IV; if (cipherMode === ECB) iv = NULL_IV; var inEncoding = input_encoding || inputEncoding; var outEncoding = output_encoding || outputEncoding; var buff = new Buffer(text, inEncoding); var out = encBytes(buff, key, iv); var re = new Buffer(out).toString(outEncoding); return re;&#125;/** * buffer/bytes decription * @param &#123;Buffer&#125; buff * @param &#123;Buffer&#125; key the length must be 16 or 32 * @param &#123;Buffer&#125; [newIv] default is [0,0...0] * @return &#123;encripted Buffer&#125; */function decBytes(buff, key, newIv) &#123; checkKey(key); var iv = newIv || IV; if (cipherMode === ECB) iv = NULL_IV; var decipher = crypto.createDecipheriv(algorithm, key, iv); decipher.setAutoPadding(true); var out = Buffer.concat([decipher.update(buff), decipher.final()]); return out;&#125;/** * text decription * @param &#123;string&#125; text * @param &#123;Buffer&#125; key the length must be 16 or 32 * @param &#123;Buffer&#125; [newIv] default is [0,0...0] * @param &#123;string&#125; [input_encoding] ["utf8" - default,"ascii","base64","binary"...](https://nodejs.org/api/buffer.html#buffer_buffer) * @param &#123;string&#125; [output_encoding] ["base64"- default ,"hex"] * @return &#123;string&#125; decription result */function decText(text, key, newIv, input_encoding, output_encoding) &#123; checkKey(key); var iv = newIv || IV; if (cipherMode === ECB) iv = NULL_IV; var inEncoding = input_encoding || inputEncoding; var outEncoding = output_encoding || outputEncoding; var buff = new Buffer(text, outEncoding); var re = new Buffer(decBytes(buff, key, iv)).toString(inEncoding); return re;&#125;exports.setCipherMode = setCipherMode;exports.setKeySize = setKeySize;exports.encText = encText;exports.encBytes = encBytes;exports.decText = decText;exports.decBytes = decBytes;// 以下为测试部分// //key是16进制，需要转换为buffer，转换后buffer长度为16，即aes128，如果buffer长度是32则是aes256// var key = new Buffer("c4b84456c1379bec99c4d1b7e9f13173", 'hex');// var key256 = new Buffer("c4b84456c1379bec99c4d1b7e9f13173c4b84456c1379bec99c4d1b7e9f13173", 'hex');// var str = "helloworld 你好";// var buffer = new Buffer(str,"utf8");//// //aes-ecb-128 buffer// var buffer_encrypt = encBytes(buffer,key);// var crypto_buffer =decBytes(buffer_encrypt,key);// var str = crypto_buffer.toString();// console.log(str);//// //aes-ecb-128 string// var text_encrypt = encText(str,key);// var text_decrypt =decText(text_encrypt,key);// console.log(text_decrypt);//// text_encrypt = encText(str,key,null,'utf8','base64');// text_decrypt =decText(text_encrypt,key,null,'utf8','base64');// console.log(text_decrypt);//// //aes-cbc-128 buffer// setCipherMode(CBC);// var iv = new Buffer("abcdefgh12345678","utf8");//字符串一定是16位// buffer_encrypt = encBytes(buffer,key,iv);// crypto_buffer =decBytes(buffer_encrypt,key,iv);// str = crypto_buffer.toString();// console.log(str);//// //aes-cbc-128 string// text_encrypt = encText(str,key,iv);// text_decrypt =decText(text_encrypt,key,iv);// console.log(text_decrypt);//// text_encrypt = encText(str,key,iv,'utf8','base64');// text_decrypt =decText(text_encrypt,key,iv,'utf8','base64');// console.log(text_decrypt);////// //aes-ecb-256 buffer// setKeySize(256);// setCipherMode(ECB);// buffer_encrypt = encBytes(buffer,key256);// crypto_buffer =decBytes(buffer_encrypt,key256);// str = crypto_buffer.toString();// console.log("256=="+str); 参考资料 用Java进行AES256-ECB-PKCS7Padding加密 aes-cross]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Protocol Buffer学习笔记(Java&NodeJS)]]></title>
    <url>%2F2018%2F02%2F26%2Fprotocol-buffer-study%2F</url>
    <content type="text"><![CDATA[什么是Protocol BufferProtocol Buffers(也称protobuf)是Google公司出品的一种独立于开发语言，独立于平台的可扩展的结构化数据序列机制。通俗点来讲它跟xml和json是一类。是一种数据交互格式协议。主要优点是它是基于二进制的，所以比起结构化的xml协议来说，它的体积很少，数据在传输过程中会更快。另外它也支持c++、java、python、php、javascript等主流开发语言。 官网地址：https://developers.google.com/protocol-buffers/ Proto3安装下载地址：3.x.x的版本基本都按照操作系统和语言进行了区分，系统包里只包含了protoc命令，语言包则是用于编译后使用，比如java需要生成对应的jar包。这里可以根据需要下载对应的操作系统和语言包，比如这里我下载的是protoc-3.5.1-osx-x86_64.zip（苹果系统）和protobuf-java-3.5.1.tar.gz（java语言）。 unzip protoc-3.5.1-osx-x86_64.zip 在/etc/profile中添加环境变量PROTOCTL_BUFFER_HOME（protoc-3.5.1-osx-x86_64.zip解压后目录），并在PATH中添加$PROTOCTL_BUFFER_HOME/bin 查看版本：protoc --version ：输出 libprotoc 3.5.1 以下部分只为自行编译生成对应的jar包，实际上maven中央仓库中已经存在了 tar -zxcf protobuf-java-3.5.1.tar.gz，解压后目录名称为protobuf-3.5.1 cd protobuf-3.5.1/src，创建软连接 ln -s $PROTOCTL_BUFFER_HOME/bin/protoc protoc cd protobuf-3.5.1/java，mvn package（maven请自行安装），成功后会在protobuf-3.5.1/java/code/target下生成protobuf-java-3.5.1.jar 然后将protobuf-java-3.5.1.jar上传到maven私服或者安装到本地仓库就可以使用了 1mvn install:install-file -Dfile=protobuf-java-3.5.1.jar -DgroupId=com.google.protobuf -DartifactId=protobuf-java -Dversion=3.5.1 -Dpackaging=jar pom中添加依赖 123456&lt;!-- protocol buffer --&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.protobuf&lt;/groupId&gt; &lt;artifactId&gt;protobuf-java&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt; Proto2安装下载地址：这里只是操作系统包，比如这里我下载的是protoc-2.6.1-osx-x86_64.exe，语言包protobuf-2.6.1.tar.gz。 mv protoc-2.6.1-osx-x86_64.exe protoc 将上面重命名后的protoc文件所在目录加到系统环境变量PATH中 查看版本：protoc --version ：输出 libprotoc 2.6.1 以下部分只为自行编译生成对应的jar包，实际上maven中央仓库中已经存在了 tar -zxcf protobuf-2.6.1.tar.gz，解压后目录名称为protobuf-2.6.1 cd protobuf-2.6.1/src，创建软连接 ln -s $PROTOCTL_BUFFER_HOME/bin/protoc protoc cd protobuf-2.6.1/java，mvn package（maven请自行安装），成功后会在protobuf-2.6.1/java/target下生成protobuf-java-2.6.1.jar 然后将protobuf-java-2.6.1.jar上传到maven私服或者安装到本地仓库就可以使用了 1mvn install:install-file -Dfile=protobuf-java-2.6.1.jar -DgroupId=com.google.protobuf -DartifactId=protobuf-java -Dversion=2.6.1 -Dpackaging=jar pom中添加依赖 123456&lt;!-- protocol buffer --&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.protobuf&lt;/groupId&gt; &lt;artifactId&gt;protobuf-java&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt;&lt;/dependency&gt; Proto使用 先编写proto文件，具体语法请参考通信协议之Protocol buffer(Java篇) 生成java文件：protoc --java_out=. XXXX.proto 生成js文件：protoc --js_out=import_style=commonjs,binary:. XXXX.proto 『只有proto3支持该命令』 proto2与proto3语法上有一些不同，但是在使用时却没有特别的不同之处，此外proto3向下兼容proto2，所以可以只安装proto3，然后通过在proto文件中声明『syntax = “proto2”;或者syntax = “proto3”;』来指定类型 proto例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//syntax = "proto2";package com.data.upload.proto;// 4.1 网约车平台公司基本信息接口message BaseInfoCompany&#123; // 公司标识 required string CompanyId = 1; // 公司名称 required string CompanyName = 2; // 统一社会信用代码 required string Identifier = 3; // 注册地行政区划代码 required uint32 Address = 4; // 经营范围 required string BusinessScope = 5; // 通讯地址 required string ContactAddress = 6; // 经营业户经济类型 required string EconomicType = 7; // 注册资本 required string RegCapital = 8; // 法人代表姓名 required string LegalName = 9; // 法人代表身份证号 required string LegalID = 10; // 法人代表电话 required string LegalPhone = 11; // 法人代表身份证扫描件文件编号 optional string LegalPhoto = 12; // 状态 required uint32 State = 13; // 操作标识 required uint32 Flag = 14; // 更新时间 required uint64 UpdateTime = 15; // 保留字段 optional string Reserved = 16;&#125;// 4.2 网约车平台公司营运规模信息信息接口message BaseInfoCompanyStat&#123; // 公司标识 required string CompanyId = 1; // 平台注册网约车辆数 required uint32 VehicleNum = 2; // 平台注册驾驶员数 required uint32 DriverNum = 3; // 操作标识 required uint32 Flag = 4; // 更新时间 required uint64 UpdateTime = 5; // 保留字段 optional string Reserved = 6;&#125;enum IpcType&#123; // 4.1 网约车平台公司基本信息接口 baseInfoCompany = 0x1001; // 4.2 网约车平台公司营运规模信息信息接口 baseInfoCompanyStat = 0x1002;&#125;message OTIpc&#123; // 公司标识 required string CompanyId = 1; // 消息来源标识 required string Source = 2; // 业务接口代码 required IpcType IPCType = 3; // 4.1 网约车平台公司基本信息接口 repeated BaseInfoCompany baseInfoCompany = 0x1001; // 4.2 网约车平台公司营运规模信息信息接口 repeated BaseInfoCompanyStat baseInfoCompanyStat = 0x1002;&#125;message OTIpcList&#123; repeated OTIpc otpic = 1;&#125; java中使用Protocol Buffer 添加依赖 123456&lt;!-- protocol buffer --&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.protobuf&lt;/groupId&gt; &lt;artifactId&gt;protobuf-java&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt;&lt;/dependency&gt; Client端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//创建对象OTIpcDef.BaseInfoCompany.Builder baseInfoCompanyBuilder = OTIpcDef.BaseInfoCompany.newBuilder();baseInfoCompanyBuilder.setAddress(110011);baseInfoCompanyBuilder.setCompanyId("companyId");baseInfoCompanyBuilder.setCompanyName("companyName");baseInfoCompanyBuilder.setIdentifier("identifier");baseInfoCompanyBuilder.setBusinessScope("BusinessScope");baseInfoCompanyBuilder.setContactAddress("ContactAddress");baseInfoCompanyBuilder.setEconomicType("EconomicType");baseInfoCompanyBuilder.setRegCapital("RegCapital");baseInfoCompanyBuilder.setLegalName("LegalName");baseInfoCompanyBuilder.setLegalID("LegalID");baseInfoCompanyBuilder.setLegalPhone("LegalPhone");baseInfoCompanyBuilder.setState(0);baseInfoCompanyBuilder.setFlag(1);baseInfoCompanyBuilder.setUpdateTime(20180226121212l);OTIpcDef.BaseInfoCompany baseInfoCompany = baseInfoCompanyBuilder.build();OTIpcDef.OTIpc.Builder otIpcBuilder = OTIpcDef.OTIpc.newBuilder();otIpcBuilder.setCompanyId("companyId");otIpcBuilder.setSource("Source");otIpcBuilder.setIPCType(OTIpcDef.IpcType.baseInfoCompany);//如果一次传递多条记录可以使用list//List&lt;OTIpcDef.BaseInfoCompany&gt; list = new ArrayList&lt;OTIpcDef.BaseInfoCompany&gt;();//list.add(baseInfoCompany);//otIpcBuilder.addAllBaseInfoCompany(list);//也可以用add方法一个一个的添加otIpcBuilder.addBaseInfoCompany(baseInfoCompany);otIpcBuilder.addBaseInfoCompany(baseInfoCompany);OTIpcDef.OTIpc otIpc = otIpcBuilder.build();OTIpcDef.BaseInfoCompanyStat.Builder baseInfoCompanyStatBuilder = OTIpcDef.BaseInfoCompanyStat.newBuilder();baseInfoCompanyStatBuilder.setCompanyId("companyId");baseInfoCompanyStatBuilder.setDriverNum(10);baseInfoCompanyStatBuilder.setFlag(0);baseInfoCompanyStatBuilder.setUpdateTime(20180226121212l);baseInfoCompanyStatBuilder.setVehicleNum(5);OTIpcDef.BaseInfoCompanyStat baseInfoCompanyStat = baseInfoCompanyStatBuilder.build();OTIpcDef.OTIpc.Builder otIpcBuilder2 = OTIpcDef.OTIpc.newBuilder();otIpcBuilder2.setCompanyId("companyId");otIpcBuilder2.setSource("Source");otIpcBuilder2.setIPCType(OTIpcDef.IpcType.baseInfoCompanyStat);otIpcBuilder2.addBaseInfoCompanyStat(baseInfoCompanyStat);OTIpcDef.OTIpc otIpc2 = otIpcBuilder2.build();OTIpcDef.OTIpcList.Builder oTIpcListBuilder = OTIpcDef.OTIpcList.newBuilder();oTIpcListBuilder.addOtpic(otIpc);oTIpcListBuilder.addOtpic(otIpc2);OTIpcDef.OTIpcList otIpcList = oTIpcListBuilder.build();//序列话数据byte[] array = otIpcList.toByteArray();HttpClientUtils httpClientUtils = new HttpClientUtils();httpClientUtils.doPost4ProtocleBuffer("http://localhost:3000/demo/protoc",array); HttpClientUtils.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import com.yipin.entity.HttpResult;import org.apache.http.client.config.RequestConfig;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpPost;import org.apache.http.entity.ByteArrayEntity;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.impl.client.LaxRedirectStrategy;import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;import org.apache.http.util.EntityUtils;public class HttpClientUtils &#123; private CloseableHttpClient httpClient; private RequestConfig requestConfig; public HttpClientUtils()&#123; init(); &#125; public void init()&#123; PoolingHttpClientConnectionManager httpClientConnectionManager = new PoolingHttpClientConnectionManager(); // 创建全局的requestConfig this.requestConfig = RequestConfig.custom().build(); // 声明重定向策略对象 LaxRedirectStrategy redirectStrategy = new LaxRedirectStrategy(); this.httpClient = HttpClients.custom().setConnectionManager(httpClientConnectionManager) .setDefaultRequestConfig(requestConfig) .setRedirectStrategy(redirectStrategy) .build(); &#125; public HttpResult doPost4ProtocleBuffer(String url, byte[] bytes) throws Exception &#123; // 创建http POST请求 HttpPost httpPost = new HttpPost(url); httpPost.setConfig(this.requestConfig); httpPost.setHeader("Connection", "keep-alive"); httpPost.setHeader("Content-type", "application/x-protobuf"); httpPost.setHeader("Accept-Encoding", "gzip"); httpPost.setHeader("Accept-Charset", "utf-8"); if (bytes != null) &#123; // 构造一个请求实体 ByteArrayEntity byteArrayEntity = new ByteArrayEntity(bytes); byteArrayEntity.setContentType("application/x-protobuf"); // 将请求实体设置到httpPost对象中 httpPost.setEntity(byteArrayEntity); &#125; CloseableHttpResponse response = null; try &#123; // 执行请求 response = this.httpClient.execute(httpPost); return new HttpResult(response.getStatusLine().getStatusCode(), EntityUtils.toString(response.getEntity(), "UTF-8")); &#125; finally &#123; if (response != null) &#123; response.close(); &#125; &#125; &#125;&#125; server端12345678910111213141516171819InputStream in = request.getInputStream();OTIpcDef.OTIpcList otIpcList = OTIpcDef.OTIpcList.parseFrom(in);List&lt;OTIpcDef.OTIpc&gt; list= otIpcList.getOtpicList();for(OTIpcDef.OTIpc otIpc : list)&#123; String companyid = otIpc.getCompanyId(); String source = otIpc.getSource(); OTIpcDef.IpcType ipcType = otIpc.getIPCType(); if(ipcType == OTIpcDef.IpcType.baseInfoCompany)&#123; List&lt;OTIpcDef.BaseInfoCompany&gt; baseInfoCompanyList = otIpc.getBaseInfoCompanyList(); for(OTIpcDef.BaseInfoCompany baseInfoCompany : baseInfoCompanyList)&#123; String companyName = baseInfoCompany.getCompanyName(); &#125; &#125;else if(ipcType == OTIpcDef.IpcType.baseInfoCompanyStat)&#123; List&lt;OTIpcDef.BaseInfoCompanyStat&gt; baseInfoCompanyStatList = otIpc.getBaseInfoCompanyStatList(); for(OTIpcDef.BaseInfoCompanyStat baseInfoCompanyStat : baseInfoCompanyStatList)&#123; int driverNum = baseInfoCompanyStat.getDriverNum(); &#125; &#125;&#125; nodejs中使用Protocol Buffer 安装依赖npm install google-protobuf --savenpm install bufferhelper --save Client端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960var OTIpcDefProto = require('../protocbuf/OTIpcDef_pb');var http = require('http');//业务对象封装var baseInfoCompany = new OTIpcDefProto.BaseInfoCompany();baseInfoCompany.setAddress(110011);baseInfoCompany.setCompanyid("companyId");baseInfoCompany.setIdentifier("identifier");baseInfoCompany.setCompanyname("companyName公司名称");baseInfoCompany.setBusinessscope("BusinessScope");baseInfoCompany.setContactaddress("ContactAddress");baseInfoCompany.setEconomictype("EconomicType");baseInfoCompany.setRegcapital("RegCapital");baseInfoCompany.setLegalname("LegalName");baseInfoCompany.setLegalid("LegalID");baseInfoCompany.setLegalphone("LegalPhone");baseInfoCompany.setState(0);baseInfoCompany.setFlag(1);baseInfoCompany.setUpdatetime(20180226121212);//业务类型封装var otIpc = new OTIpcDefProto.OTIpc();otIpc.setCompanyid("companyId");otIpc.setSource("Source");otIpc.setIpctype(OTIpcDefProto.IpcType.BASEINFOCOMPANY);//可以多次调用add方法添加多条业务对象数据otIpc.addBaseinfocompany(baseInfoCompany);//统一封装为list传输var otIpcList = new OTIpcDefProto.OTIpcList();//可以通过add方法条件多条业务类型数据otIpcList.addOtpic(otIpc);//序列化对象var contents = otIpcList.serializeBinary();var options = &#123; host: 'localhost', port: 3000, path: '/demo2/protoc', method: 'POST', headers: &#123; 'Content-Type': 'application/x-protobuf' &#125;&#125;;//发送请求var req = http.request(options, function(res)&#123; // res.setEncoding('uft8'); res.on('data', function(data)&#123; console.log(data); &#125;);&#125;);//转成buffervar buffer = new Buffer(contents);//只支持string和buffer类型req.write(buffer);req.end(); Server端（express） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758var express = require('express');var router = express.Router();var OTIpcDefProto = require('../protocbuf/OTIpcDef_pb');var BufferHelper = require('bufferhelper');// http://localhost:3000/demo/router.post('/protoc', function(req, res, next) &#123; //数据接收，可以使用bufferHelper接收protocolbuffer数据 var bufferHelper = new BufferHelper(); req.on("data", function (chunk) &#123; bufferHelper.concat(chunk); &#125;); req.on('end', function () &#123; var buffer = bufferHelper.toBuffer(); //buffer转换为proto对象 var otIpcList = OTIpcDefProto.OTIpcList.deserializeBinary(new Uint8Array(buffer)); for(var i=0;i&lt;otIpcList.getOtpicList().length;i++) &#123; console.log(i+"========================================"); var otIpc = otIpcList.getOtpicList()[i]; var companyid = otIpc.getCompanyid(); var source = otIpc.getSource(); var iPCType = otIpc.getIpctype(); console.log(companyid); console.log(source); console.log(iPCType); if(iPCType == OTIpcDefProto.IpcType.BASEINFOCOMPANY)&#123; var baseInfoCompanyList = otIpc.getBaseinfocompanyList(); for(var j=0;j&lt;baseInfoCompanyList.length;j++)&#123; console.log(j+"===============baseInfoCompanyList================="); var baseInfoCompany = baseInfoCompanyList[j]; console.log(baseInfoCompany.toObject()); console.log(baseInfoCompany.getCompanyid()); console.log(baseInfoCompany.getCompanyname()); &#125; &#125;else if(iPCType == OTIpcDefProto.IpcType.BASEINFOCOMPANYSTAT)&#123; var baseInfoCompanyStatList = otIpc.getBaseinfocompanystatList(); for(var j=0;j&lt;baseInfoCompanyStatList.length;j++)&#123; console.log(j+"===============baseInfoCompanyStatList================="); var baseInfoCompanyStat = baseInfoCompanyStatList[j]; console.log(baseInfoCompanyStat.toObject()); console.log(baseInfoCompanyStat.getCompanyid()); console.log(baseInfoCompanyStat.getDrivernum()); &#125; &#125; &#125; console.log(otIpcList.toObject()); res.send(otIpcList.toObject()); &#125;);&#125;);module.exports = router; 这里可以将protocolbuffer数据的接收过程封装到app.js中123456789101112131415161718192021//以下代码要在路由映射的最上方声明，以保证其先被执行app.use('/*',function(req, res, next) &#123; var contentType = req.get('Content-Type'); //判断contentType，如果是protobuf类型则将数据封装到req.body中 if(contentType=='application/x-protobuf') &#123; var bufferHelper = new BufferHelper(); req.on("data", function (chunk) &#123; bufferHelper.concat(chunk); &#125;); req.on('end', function () &#123; var buffer = bufferHelper.toBuffer(); req.body = buffer; console.log(req.body); next(); &#125;); &#125;else&#123; next(); &#125;&#125;); 然后在路由js中只需要按照如下方式接收数据即可1var otIpcList = OTIpcDefProto.OTIpcList.deserializeBinary(new Uint8Array(req.body)); Server端（restify）restify中接收proto数据比较简单，因为proto数据已经被封装到req.body中了，所以使用方式类似于上面express的第二种方法1var otIpcList = OTIpcDefProto.OTIpcList.deserializeBinary(new Uint8Array(req.body)); JSON与Protobuf相互转换JAVA123456&lt;!-- protocol buffer format --&gt;&lt;dependency&gt; &lt;groupId&gt;com.googlecode.protobuf-java-format&lt;/groupId&gt; &lt;artifactId&gt;protobuf-java-format&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt; json to proto 123456com.googlecode.protobuf.format.JsonFormat jsonFormat = new JsonFormat();com.google.protobuf.Message.Builder builder = OTIpcDef.BaseInfoCompany.newBuilder();//这里实际上需要提供一个json字符串，这里假设这个json是从某个对象转换而来的String json = com.alibaba.fastjson.JSON.toJSONString(myObject);//该方法会将json中与builder所代表的对象中的属性做merge，也就是说只要字段名称和类型一致即可进行封装，对于字段名称和类型匹配不上的属性不予处理，方法成功后builder对象会完成属性值的封装。jsonFormat.merge(new ByteArrayInputStream(json.getBytes()), builder); proto to json 1234OTIpcDef.OTIpcList otIpcList = oTIpcListBuilder.build();//proto对象转jsoncom.googlecode.protobuf.format.JsonFormat jsonFormat = new JsonFormat();String json =jsonFormat.printToString(otIpcList); nodejs json to proto编写json2Proto.js，里面就一个方法，用于将json字符串转换为封装好的proto对象123456789101112131415161718192021222324252627282930313233var json2proto = function (json_str,protoObject) &#123; Array.prototype.contains = function ( needle ) &#123; for (i in this) &#123; if (this[i] == needle) return true; &#125; return false; &#125; var p_json_str = json_str; var p_json = eval("(" + p_json_str + ")"); var p_json_key_array = []; var i = 0; for(var p in p_json)&#123;//遍历json对象的每个key/value对,p为key p_json_key_array[i] = p; i++; &#125; var s_json = protoObject.toObject(); for(var p in s_json)&#123;//遍历json对象的每个key/value对,p为key if (p_json_key_array.contains(p)) &#123; var setMethod = "set"+p.charAt(0).toUpperCase() + p.slice(1); protoObject[setMethod](p_json[p]); &#125; &#125; return protoObject;&#125;module.exports = json2proto; 调用方法123456789101112131415161718192021var OTIpcDefProto = require('../protocbuf/OTIpcDef_pb');var json2proto = require('../json2Proto');//json字符串var p_json_str = "&#123; companyid: '公司ID'," + "companyname: 'companyId'," + "identifier : 'identifier'," + "address : 111111," + "businessscope : 'businessscope'," + "contactaddress : 'contactaddress'," + "economictype : 'economictype'," + "regcapital : 'regcapital'," + "legalname : 'legalname'," + "legalid : 'legalid'," + "legalphone : 'legalphone'," + "legalphoto : 'legalphoto'," + "state : 0," + "flag : 1," + "updatetime: 20180226121212&#125;";var baseInfoCompany = json2proto(p_json_str,new OTIpcDefProto.BaseInfoCompany());console.log(baseInfoCompany.toObject()); 参考资料 springMVC项目中实现Protocol Buffers对象自动转换 protobuf实现js与java间的http通信]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>protocbuf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[钉钉与企业微信之OA产品分析]]></title>
    <url>%2F2017%2F08%2F08%2Fdingtalk-weixin-oa%2F</url>
    <content type="text"><![CDATA[网站 钉钉 企业微信 结论 钉钉自身就实现了OA中的绝大部分功能，且流程配置更加灵活，目前我们用到的只有CRM需要依赖于第三方的销帮帮。 销帮帮不支持区间设置，但只有合同审批会受此影响（目前正在和对方沟通希望其能进行升级）。 微信自身提供的功能和第三方应用都不如钉钉的多。 从功能、使用方式、价格和技术支持等多个维度对比，钉钉更有优势。 平台对比 功能 钉钉 企业微信 说明 web端 支持 支持 手机客户端 支持 支持 PC客户端 支持 支持 钉钉：除第三方功能（销帮帮CRM）外，都可以在客户端上完成，第三方功能会跳转到web端。企业微信：部分内置审批功能都需要跳转到web端，第三方（企微云）支持客户端直接发起申请很审批。 微信插件 无 有 使用微信插件可以不安装企业微信客户端，只使用微信就可以。 自定义表单 支持 支持 自定义流程 支持 支持 企业微信：分支流程不支持区间设置，所以不能实现超过2个分支的情况，比如按请假天数走不同的审批流：小于3天，大于等于3天且小于10天，大于等于10天。企微云mac系统支持不好。销帮帮不支持区间设置。 自定义工作台布局 支持 不支持 使用方式 多公司 单公司 钉钉：登录后可同时接收多家公司的消息，在工作台中对某个公司进行切换。企业微信：登录时选择公司，只接收登录公司的信息 OA功能对比 功能 钉钉 企业微信 说明 出勤休假–考勤打卡（签到） 有 有 企微云平台 - 移动办公 出勤休假–请假 有 有 适用于请假申请，精确扣减出勤时间，并同步考勤报表 出勤休假–出差 有 有 适用于出差申请，精确汇总至考勤报表 出勤休假–外出 有 有 适用于外出申请，精确汇总至考勤报表 出勤休假–加班 有 有 适用于加班申请，精确汇总至考勤报表 出勤休假–补卡 有 有（企微云） 当员工考勤出现缺卡时，可发起补卡审批，审批通过后考勤报表中的缺卡记录改为正常 人事–转正 有 无（可以创建） 用于试用期内员工的员工转正申请 人事–招聘 有 无（可以创建） 用于用人部门需求申请 人事–调岗申请单 有 无（可以创建） 适用于调岗审批 人事–离职申请单 有 无（可以创建） 适用于离职审批 行政–用车申请 有 有（企微云） 适用于因公使用车辆的申请 行政–物品领用 有 有（企微云） 适用于物品领用申请 行政–用印申请 有 无（可以创建） 适用于公司印章使用 行政–通用审批 有 有 适用于通用审批 财务–报销 有 有 适用于公司报销审批 财务–备用金申请 有 无（可以创建） 用于企业员工出差或外出办事填写的备用金申请单 财务–付款申请 有 无（可以创建） 适用于付款审批 其它–立项申请 有 无（可以创建） 适用于项目立项时的申请 其它–采购 有 无（可以创建） 用于企业办公或所需材料的采购申请 合同和CRM 无（销帮帮） 企微云 均为第三方产品，都支持自定义合同表单和审批流程。钉钉中第三方产品比较多。企业微信比较少。 手机客户端界面对比 功能页 钉钉 企业微信 说明 首页 钉钉：显示多个公司的信息。企业微信：显示单个公司的信息。 工作台 审批 企业微信：第一个是微信的，第二张图是第三方的（指掌天下） CRM(合同) 钉钉：销帮帮（第三方）。 企业微信：企微云（第三方） PC客户端界面对比 功能页 钉钉 企业微信 说明 首页 工作台 企业微信：首页即为工作台 审批 企业微信：内置审批需要跳转到web申请 CRM(合同) 钉钉：跳转到web 销帮帮 网址 使用手册销帮帮CRM钉钉版管理员使用手册V3.4.pptx销帮帮CRM钉钉版用户使用手册V3.4.ppt 费用 企微云 网址 使用手册企微云平台-微信办公第一品牌8.0.pdf 免费版与收费版区别 费用:服务价格：100人（含）内2万元/年，超出部分，每50人增加2千元（不足50人按50人计算) ，超过2千人价格面议]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot学习笔记08--NoSql之MongoDB&Redis]]></title>
    <url>%2F2016%2F12%2F30%2Fspring-boot-study-nosql%2F</url>
    <content type="text"><![CDATA[摘要看完本文你将掌握如下知识点： Spring Boot对MongoDB的支持 Spring Boot对Redis的支持 SpringBoot系列：Spring Boot学习笔记 Spring Boot对MongoDB的支持pom中加入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;&lt;/dependency&gt; 自定义Repository需要继承于MongoRepository，与JPA类似，同样支持命名方法和@Query接口查询。 按方法名进行查询，规则与JPA一致，@Query接口查询就是mongo的原生查询语句的语法类似。 12345678910111213141516171819202122232425262728293031public interface PersonRepository extends MongoRepository&lt;Person, String&gt; &#123; //等于 List&lt;Person&gt; findByName(String name); //And --- 等价于 SQL 中的 and 关键字； List&lt;Person&gt; findByNameAndAge(String name, Integer age); // Or --- 等价于 SQL 中的 or 关键字； List&lt;Person&gt; findByNameOrAge(String name, Integer age); //分页 Page&lt;Person&gt; findByNameNot(String name, Pageable pageable); //mongo原生查询语句 //等于 @Query("&#123;'age':?0&#125;") List&lt;Person&gt; withQueryFindByAge(Integer age); //大于 @Query("&#123;'age': &#123;'$gt' : ?0&#125;&#125;") List&lt;Person&gt; findByAgeGreaterThan(int age); //正则匹配name，age范围 @Query("&#123; 'name':&#123;'$regex':?0,'$options':'i'&#125;, 'age': &#123;'$gte':?1,'$lte':?2&#125;&#125;") public Page&lt;Person&gt; findByNameAndAgeRange(String name,int ageFrom,int ageTo,Pageable page); //正则匹配name，age范围，查询结果只封装name和age，当然默认ID是必须封装的 @Query(value = "&#123; 'name':&#123;'$regex':?0,'$options':'i'&#125;, 'age': &#123;'$gte':?1,'$lte':?2&#125;&#125;",fields = "&#123; 'name' : 1, 'age' : 1&#125;") public Page&lt;Person&gt; findByNameAndAgeRangeShow(String name,int ageFrom,int ageTo,Pageable page);&#125; 关于Mongo原生语句的说明可以参考：http://www.cnblogs.com/egger/archive/2013/06/14/3135847.html 如果希望接管spring boot对mongo的自动配置，可以创建如下配置类，这样我们也可以像前文介绍的JPA绑定多数据源那样，绑定多个mongo数据源。 123456789101112131415161718192021222324252627282930313233343536373839package com.example.mongo;import com.mongodb.MongoClient;import com.mongodb.MongoClientURI;import com.mongodb.ServerAddress;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.mongodb.MongoDbFactory;import org.springframework.data.mongodb.core.MongoTemplate;import org.springframework.data.mongodb.core.SimpleMongoDbFactory;import org.springframework.data.mongodb.repository.config.EnableMongoRepositories;@Configuration@EnableMongoRepositories(basePackages = &#123;"com.example.mongo.dao"&#125;,mongoTemplateRef = "mongoTemplate")public class MongoConfig &#123; @Value("$&#123;spring.data.mongodb.host&#125;") String mongoHost; @Value("$&#123;spring.data.mongodb.uri&#125;") String mongoUrl; @Bean public MongoClient mongoClient() &#123; MongoClient mongoClient = new MongoClient(new ServerAddress(mongoHost)); return mongoClient; &#125; @Bean public MongoDbFactory mongoDbFactory()&#123; String database = new MongoClientURI(mongoUrl).getDatabase(); return new SimpleMongoDbFactory(mongoClient(),database); &#125; @Bean(name = "mongoTemplate") public MongoTemplate mongoTemplate()&#123; return new MongoTemplate(mongoDbFactory()); &#125;&#125; Spring Boot对Redis的支持pom中加入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 然后就可以通过@Autowired注解注入RedisTemplate，比如： 1234567891011121314151617181920212223242526272829303132333435363738394041package com.example.redis.dao;import com.example.redis.domain.Student;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.core.ValueOperations;import org.springframework.stereotype.Repository;import javax.annotation.Resource;@Repositorypublic class StudentDao &#123; @Autowired StringRedisTemplate stringRedisTemplate; @Autowired RedisTemplate&lt;Object,Object&gt; redisTemplate; @Resource(name = "stringRedisTemplate") ValueOperations&lt;String,String&gt; valueOperationsStr; @Resource(name = "redisTemplate") ValueOperations&lt;Object,Object&gt; valueOperations; public void setString(String key,String value)&#123; valueOperationsStr.set(key,value); &#125; public String getString(String key)&#123; return valueOperationsStr.get(key); &#125; public void saveStudent(Student student)&#123; valueOperations.set(student.getId(),student); &#125; public Student getStudent(String id)&#123; return (Student)valueOperations.get(id); &#125;&#125; 同样，如果希望接管spring boot对redis的自动配置，可以创建如下自动配置类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.example.redis;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.jedis.JedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer;@Configurationpublic class RedisConfig &#123; @Value("$&#123;spring.redis.database&#125;") String redisDatabase; @Value("$&#123;spring.redis.host&#125;") String redisHost; @Bean public JedisConnectionFactory connectionFactory()&#123; JedisConnectionFactory jedisConnectionFactory = new JedisConnectionFactory(); jedisConnectionFactory.setDatabase(Integer.valueOf(redisDatabase)); jedisConnectionFactory.setHostName(redisHost); return jedisConnectionFactory; &#125; @Bean public Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer() &#123; ObjectMapper objectMapper = new ObjectMapper(); Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;Object&gt;( Object.class); jackson2JsonRedisSerializer.setObjectMapper(objectMapper); return jackson2JsonRedisSerializer; &#125; //用于对存储内容转换为json格式 @Bean(name = "redisTemplate") public RedisTemplate&lt;Object, Object&gt; objRedisTemplate(JedisConnectionFactory connectionFactory, Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer) &#123; RedisTemplate&lt;Object, Object&gt; redisTemplate = new RedisTemplate&lt;Object, Object&gt;(); redisTemplate.setConnectionFactory(connectionFactory); redisTemplate.setDefaultSerializer(jackson2JsonRedisSerializer); StringRedisSerializer stringRedisSerializer = new StringRedisSerializer(); redisTemplate.setKeySerializer(stringRedisSerializer); redisTemplate.setHashKeySerializer(stringRedisSerializer); return redisTemplate; &#125; @Bean(name = "stringRedisTemplate") public StringRedisTemplate stringRedisTemplate(JedisConnectionFactory connectionFactory) &#123; StringRedisTemplate stringRedisTemplate = new StringRedisTemplate(connectionFactory); return stringRedisTemplate; &#125;&#125; 本文示例代码下载地址：https://github.com/hanqunfeng/SpringBootStudy]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot学习笔记07--DataSource的创建方法]]></title>
    <url>%2F2016%2F12%2F22%2Fspring-boot-study-datasource%2F</url>
    <content type="text"><![CDATA[摘要看完本文你将掌握如下知识点： Spring Boot项目中DataSource的创建方法 SpringBoot系列：Spring Boot学习笔记 DataSource的创建方法前面讲了很多Spring Boot数据访问方面的内容，在讲到自己扩展数据访问的时候，示例代码中给出的DataSource创建方式都是DriverManagerDataSource，比如： 12345#datasourcespring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/springboot1?useUnicode=true&amp;characterEncoding=utf-8spring.datasource.username=rootspring.datasource.password=newpwd 12345678910111213141516171819@Value("$&#123;spring.datasource.driver-class-name&#125;")String driverClass;@Value("$&#123;spring.datasource.url&#125;")String url;@Value("$&#123;spring.datasource.username&#125;")String userName;@Value("$&#123;spring.datasource.password&#125;")String passWord;@Bean(name = "dataSource")public DataSource dataSource() &#123; DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(driverClass); dataSource.setUrl(url); dataSource.setUsername(userName); dataSource.setPassword(passWord); return dataSource;&#125; 如果有多个数据源，就再创建多个DriverManagerDataSource。一般生产项目中我们不会这样使用，通常可以使用org.apache.commons.dbcp.BasicDataSource。 实际上Spring Boot为我们提供了简便的创建DataSource的方法： 12345678910111213#datasource#需要执行数据源的类型spring.datasource.ds1.type=org.apache.tomcat.jdbc.pool.DataSourcespring.datasource.ds1.driver-class-name=com.mysql.jdbc.Driverspring.datasource.ds1.url=jdbc:mysql://localhost:3306/springboot1?useUnicode=true&amp;characterEncoding=utf-8spring.datasource.ds1.username=rootspring.datasource.ds1.password=newpwdspring.datasource.ds2.type=org.apache.tomcat.jdbc.pool.DataSourcespring.datasource.ds2.driver-class-name=com.mysql.jdbc.Driverspring.datasource.ds2.url=jdbc:mysql://localhost:3306/springboot2?useUnicode=true&amp;characterEncoding=utf-8spring.datasource.ds2.username=rootspring.datasource.ds2.password=newpwd 123456789101112@Bean(name = "dataSource1")//application.properties中属性名称的前缀@ConfigurationProperties(prefix = "spring.datasource.ds1")public DataSource dataSource1() &#123; return DataSourceBuilder.create().build();&#125;@Bean(name = "dataSource2")@ConfigurationProperties(prefix = "spring.datasource.ds2")public DataSource dataSource2() &#123; return DataSourceBuilder.create().build();&#125; 目前，此种方式支持如下几种数据源类型： “org.apache.tomcat.jdbc.pool.DataSource”, “com.zaxxer.hikari.HikariDataSource”, “org.apache.commons.dbcp.BasicDataSource”, “org.apache.commons.dbcp2.BasicDataSource” 使用哪种数据源类型，就要在项目中加入相应的jar依赖，比如org.apache.tomcat.jdbc.pool.DataSource 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-jdbc&lt;/artifactId&gt; &lt;version&gt;8.5.6&lt;/version&gt;&lt;/dependency&gt;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot学习笔记06--JPA]]></title>
    <url>%2F2016%2F12%2F21%2Fspring-boot-study-jpa%2F</url>
    <content type="text"><![CDATA[摘要看完本文你将掌握如下知识点： Spring Boot项目中JPA的配置及使用方法 Spring Boot项目配置Spring Data JPA的方法 Spring Data JPA与Atomikos整合实现多数据源事务管理 扩展JPA的方法 SpringBoot系列：Spring Boot学习笔记 前言JPA即Java Persistence API，是一个基于O/R映射的标准规范，该规范只负责定义规则的标准（注解或接口），而不需要提供具体实现，具体的实现交由软件提供商来实现，目前主要的JPA提供商为Hibernate，EclipseLink和OperJPA。 Spring Data JPA是Spring Data的一个子项目，通过提供基于JPA的Repository来简化代码量。其提供了一个org.springframework.data.jpa.repository.JpaRepository，我们的Repository只要继承该JpaRepository，即可享受到JPA带来的好处。 Spring Boot通过spring-boot-starter-data-jpa来提供对JPA的支持，Spring Boot默认的JPA实现者是Hibernate。 说明在讲解下面的内容前，我们先在数据库中创建一张表 1234567891011121314# 创建库1CREATE SCHEMA `springboot1` DEFAULT CHARACTER SET utf8 ;CREATE TABLE `springboot1`.`person` ( `p_id` INT NOT NULL AUTO_INCREMENT COMMENT '主键', `p_name` VARCHAR(45) NULL COMMENT '姓名', `p_age` INT NULL COMMENT '年龄', PRIMARY KEY (`p_id`))ENGINE = InnoDBCOMMENT = '人员信息表';INSERT INTO `springboot1`.`person` (`p_id`, `p_name`, `p_age`) VALUES ('1', '张三', '20');INSERT INTO `springboot1`.`person` (`p_id`, `p_name`, `p_age`) VALUES ('2', '李四', '25');INSERT INTO `springboot1`.`person` (`p_id`, `p_name`, `p_age`) VALUES ('3', '王五', '18');INSERT INTO `springboot1`.`person` (`p_id`, `p_name`, `p_age`) VALUES ('4', '王五', '18'); Spring Boot项目中使用JPA创建项目时选择JPA依赖，或者手工将spring-boot-starter-data-jpa添加到pom中。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; 此时项目会自动开启如下两个自动配置类： JpaRepositoriesAutoConfigurationHibernateJpaAutoConfiguration application.properties中增加jpa相关配置 12345678910111213#datasourcespring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/springboot1?useUnicode=true&amp;characterEncoding=utf-8spring.datasource.username=rootspring.datasource.password=newpwd#spring_jpa#启动时会根据实体类生成数据表，或者更新表结构，不清空数据，开发阶段使用；validate：表结构稳定后使用，可用于正式环境；spring.jpa.hibernate.ddl-auto=update#控制台打印sqlspring.jpa.show-sql=true#让控制器输出的json格式更美观spring.jackson.serialization.indent-output=true 在项目中使用JPA时，只需要创建一个继承于JpaRepository的Repository接口，即可拥有JpaRepository及其父类中提供的全部数据访问方法。如果提供的方法不满足业务需要，可以按如下规则扩展数据方法。 JpaRepository 12345678910111213141516171819202122232425262728293031323334package org.springframework.data.jpa.repository;import java.io.Serializable;import java.util.List;import org.springframework.data.domain.Example;import org.springframework.data.domain.Sort;import org.springframework.data.repository.NoRepositoryBean;import org.springframework.data.repository.PagingAndSortingRepository;import org.springframework.data.repository.query.QueryByExampleExecutor;@NoRepositoryBeanpublic interface JpaRepository&lt;T, ID extends Serializable&gt; extends PagingAndSortingRepository&lt;T, ID&gt;, QueryByExampleExecutor&lt;T&gt; &#123; List&lt;T&gt; findAll(); List&lt;T&gt; findAll(Sort var1); List&lt;T&gt; findAll(Iterable&lt;ID&gt; var1); &lt;S extends T&gt; List&lt;S&gt; save(Iterable&lt;S&gt; var1); void flush(); &lt;S extends T&gt; S saveAndFlush(S var1); void deleteInBatch(Iterable&lt;T&gt; var1); void deleteAllInBatch(); T getOne(ID var1); &lt;S extends T&gt; List&lt;S&gt; findAll(Example&lt;S&gt; var1); &lt;S extends T&gt; List&lt;S&gt; findAll(Example&lt;S&gt; var1, Sort var2);&#125; 自定义Repository：PersonRepository，并扩展数据访问方法，具体扩展方法参看示例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package com.example.dao;import com.example.model.Person;import org.springframework.data.domain.Page;import org.springframework.data.domain.Pageable;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.Modifying;import org.springframework.data.jpa.repository.Query;import org.springframework.data.repository.query.Param;import java.util.List;public interface PersonRepository extends JpaRepository&lt;Person, Integer&gt; &#123; //1.以下方法基于属性名称和查询关键字，所以方法名称必须遵循命名规则，并且参数类型要与实体的参数类型一致。 // 只用于查询方法，以下给出常用的示例 //等于 List&lt;Person&gt; findByPName(String PName); //And --- 等价于 SQL 中的 and 关键字； List&lt;Person&gt; findByPNameAndPAge(String PName, Integer PAge); // Or --- 等价于 SQL 中的 or 关键字； List&lt;Person&gt; findByPNameOrPAge(String PName, Integer PAge); //Between --- 等价于 SQL 中的 between 关键字； List&lt;Person&gt; findByPAgeBetween(Integer min, Integer max); //LessThan --- 等价于 SQL 中的 "&lt;"； 日期类型也可以使用Before关键字 List&lt;Person&gt; findByPAgeLessThan(Integer max); //LessThanEqual --- 等价于 SQL 中的 "&lt;="； List&lt;Person&gt; findByPAgeLessThanEqual(Integer max); //GreaterThan --- 等价于 SQL 中的"&gt;"；日期类型也可以使用After关键字 List&lt;Person&gt; findByPAgeGreaterThan(Integer min); //GreaterThanEqual --- 等价于 SQL 中的"&gt;="； List&lt;Person&gt; findByPAgeGreaterThanEqual(Integer min); //IsNull --- 等价于 SQL 中的 "is null"； List&lt;Person&gt; findByPNameIsNull(); //IsNotNull --- 等价于 SQL 中的 "is not null"； List&lt;Person&gt; findByPNameIsNotNull(); //NotNull --- 与 IsNotNull 等价； List&lt;Person&gt; findByPNameNotNull(); //Like --- 等价于 SQL 中的 "like"; List&lt;Person&gt; findByPNameLike(String PName); //NotLike --- 等价于 SQL 中的 "not like"； List&lt;Person&gt; findByPNameNotLike(String PName); //OrderBy --- 等价于 SQL 中的 "order by"； List&lt;Person&gt; findByPNameNotNullOrderByPAgeAsc(); //Not --- 等价于 SQL 中的 "！ ="； List&lt;Person&gt; findByPNameNot(String PName); //In --- 等价于 SQL 中的 "in"; List&lt;Person&gt; findByPNameIn(String PName); //NotIn --- 等价于 SQL 中的 "not in"; List&lt;Person&gt; findByPNameNotIn(String PName); //Top --- 查询符合条件的前两条记录，等价与First关键字 List&lt;Person&gt; findTop2ByPName(String PName); //2.以下方法基于@Query注解，方法名称可以随意，可用于查询和更新方法，更新方法要设置@Modifying注解 //使用命名参数 @Query("select p from Person p where p.pName = :name and p.pAge = :age") List&lt;Person&gt; withNameAndAgeQuery(@Param("name") String name, @Param("age") Integer age); //使用参数索引 @Query("select p from Person p where p.pName = ?1 and p.pAge = ?2") List&lt;Person&gt; withNameAndAgeQuery2(String name, Integer age); //删除操作，使用hql，如果要使用sql，需要增加nativeQuery = true @Query(value = "delete from Person where pId=?1") @Modifying int deletePersonById(Integer id); //修改操作 @Query(value = "update Person set pName=?1 where pId=?2 ") @Modifying int updatePersonName(String name, Integer id); //插入操作，使用sql操作 @Query(value = "insert into person(p_name,p_age) value(?1,?2)",nativeQuery = true) @Modifying int insertPersonByParam(String name, Integer age); //3.以下方法实现分页查询功能，只需要在方法中增加Pageable pageable参数即可，返回结果为Page集合 Page&lt;Person&gt; findByPNameNot(String name, Pageable pageable); //使用命名参数 @Query("select p from Person p where p.pName = :name ") Page&lt;Person&gt; withNameQueryPage(@Param("name") String name, Pageable pageable);&#125; POJO实体对象：Person 123456789101112131415161718192021222324252627282930313233package com.example.model;import javax.persistence.*;import static javax.persistence.GenerationType.IDENTITY;@Entity@Table(name = "person" , catalog = "springboot1")public class Person implements java.io.Serializable &#123; @Id @GeneratedValue(strategy = IDENTITY) @Column(name = "p_id", unique = true, nullable = false) private Integer pId; @Column(name = "p_name", length = 45) private String pName; @Column(name = "p_age") private Integer pAge; //setter and getter @Override public String toString() &#123; return "Person&#123;" + "pId=" + pId + ", pName='" + pName + '\'' + ", pAge=" + pAge + '&#125;'; &#125;&#125; 测试演示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148package com.example;import com.example.dao.PersonRepository;import com.example.model.Person;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.data.domain.Sort;import org.springframework.test.context.junit4.SpringRunner;import org.springframework.transaction.annotation.Transactional;import java.util.Iterator;import java.util.List;@RunWith(SpringRunner.class)@SpringBootTest@Transactionalpublic class JpaSingleDatasourceApplicationTests &#123; @Autowired private PersonRepository personRepository; @Test public void findByPName() &#123; String name = "王五"; List&lt;Person&gt; list = personRepository.findByPName(name); System.out.println(list.size()); for(Person person : list)&#123; System.out.println(person); &#125; &#125; @Test public void findByPNameAndPAge() &#123; String name = "王五"; int age = 18; List&lt;Person&gt; list = personRepository.findByPNameAndPAge(name,age); System.out.println(list.size()); for(Person person : list)&#123; System.out.println(person); &#125; &#125; @Test public void findByPNameOrPAge() &#123; String name = "王五"; int age = 25; List&lt;Person&gt; list = personRepository.findByPNameOrPAge(name,age); System.out.println(list.size()); for(Person person : list)&#123; System.out.println(person); &#125; &#125; @Test public void findTop2ByPName() &#123; String name = "王五"; List&lt;Person&gt; list = personRepository.findTop2ByPName(name); System.out.println(list.size()); for(Person person : list)&#123; System.out.println(person); &#125; &#125; @Test public void withNameAndAgeQuery() &#123; String name = "王五"; int age = 18; List&lt;Person&gt; list = personRepository.withNameAndAgeQuery(name,age); System.out.println(list.size()); for(Person person : list)&#123; System.out.println(person); &#125; &#125; @Test public void withNameAndAgeQuery2() &#123; String name = "王五"; int age = 18; List&lt;Person&gt; list = personRepository.withNameAndAgeQuery2(name,age); System.out.println(list.size()); for(Person person : list)&#123; System.out.println(person); &#125; &#125; @Test public void deletePersonById()&#123; int id = 1; int result = personRepository.deletePersonById(id); System.out.println("result = " + result); &#125; @Test public void updatePersonName()&#123; int id = 1; String name = "哈哈"; int result = personRepository.updatePersonName(name,id); System.out.println("result = " + result); &#125; @Test public void insertPersonByParam()&#123; int age = 10; String name = "哈哈"; int result = personRepository.insertPersonByParam(name,age); System.out.println("result = " + result); &#125; @Test public void findByPNameNot()&#123; String name = "哈哈"; //排序 Sort sort = new Sort(Sort.Direction.DESC, "pId"); //查询第一页，按一页三行分页 Pageable pageable = new PageRequest(0, 3, sort); Page&lt;Person&gt; pages = personRepository.findByPNameNot(name,pageable); System.out.println("pages.getTotalElements()" + pages.getTotalElements()); System.out.println("pages.getTotalPages()" + pages.getTotalPages()); Iterator&lt;Person&gt; it=pages.iterator(); while(it.hasNext())&#123; System.out.println("value:"+((Person)it.next())); &#125; &#125; @Test public void withNameQueryPage()&#123; String name = "王五"; //排序 Sort sort = new Sort(Sort.Direction.DESC, "pId"); //查询第二页，按一页三行分页 Pageable pageable = new PageRequest(1, 3, sort); Page&lt;Person&gt; pages = personRepository.withNameQueryPage(name,pageable); System.out.println("pages.getTotalElements()" + pages.getTotalElements()); System.out.println("pages.getTotalPages()" + pages.getTotalPages()); Iterator&lt;Person&gt; it=pages.iterator(); while(it.hasNext())&#123; System.out.println("value:"+((Person)it.next())); &#125; &#125;&#125; Spring Boot项目配置Spring Data JPA的方法如果不想依赖于spring-boot-starter-data-jpa，我们依然可以通过配置类来实现Spring Boot对Spring Data JPA的支持。 pom替换依赖这里说明一下，实际上我们可以不用替换掉spring-boot-starter-data-jpa的依赖，替换掉的好处仅仅是减少对不需要的jar的依赖。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.37&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.transaction&lt;/groupId&gt; &lt;artifactId&gt;jta&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.9&lt;/version&gt;&lt;/dependency&gt;&lt;!-- hibernate --&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;4.3.5.Final&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt; &lt;version&gt;4.3.5.Final&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;4.3.3.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-jpa&lt;/artifactId&gt; &lt;version&gt;1.10.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;--&gt; 自定义配置类：DataSourceConfig 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.example;import org.hibernate.jpa.HibernatePersistenceProvider;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.jpa.repository.config.EnableJpaRepositories;import org.springframework.jdbc.datasource.DriverManagerDataSource;import org.springframework.orm.jpa.JpaTransactionManager;import org.springframework.orm.jpa.JpaVendorAdapter;import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;import org.springframework.orm.jpa.vendor.Database;import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;import org.springframework.transaction.PlatformTransactionManager;import org.springframework.transaction.annotation.EnableTransactionManagement;import javax.sql.DataSource;@Configuration@EnableTransactionManagement(proxyTargetClass = true)//开启Spring Data JPA的支持@EnableJpaRepositories(basePackages = "com.example.dao", entityManagerFactoryRef = "entityManagerFactory", transactionManagerRef = "transactionManager")public class DataSourceConfig &#123; @Value("$&#123;spring.datasource.driver-class-name&#125;") String driverClass; @Value("$&#123;spring.datasource.url&#125;") String url; @Value("$&#123;spring.datasource.username&#125;") String userName; @Value("$&#123;spring.datasource.password&#125;") String passWord; @Bean(name = "dataSource") public DataSource dataSource() &#123; DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(driverClass); dataSource.setUrl(url); dataSource.setUsername(userName); dataSource.setPassword(passWord); return dataSource; &#125; // jpa事务管理器 @Bean(name = "transactionManager") public PlatformTransactionManager transactionManager() &#123; JpaTransactionManager jpaTransactionManager = new JpaTransactionManager(); jpaTransactionManager.setDataSource(dataSource()); jpaTransactionManager.setEntityManagerFactory(entityManagerFactory().getObject()); return jpaTransactionManager; &#125; @Bean public JpaVendorAdapter jpaVendorAdapter() &#123; HibernateJpaVendorAdapter adapter = new HibernateJpaVendorAdapter(); adapter.setShowSql(true); adapter.setDatabase(Database.MYSQL); adapter.setGenerateDdl(true); return adapter; &#125; @Bean(name = "entityManagerFactory") public LocalContainerEntityManagerFactoryBean entityManagerFactory() &#123; LocalContainerEntityManagerFactoryBean entityManager = new LocalContainerEntityManagerFactoryBean(); entityManager.setDataSource(dataSource()); entityManager.setJpaVendorAdapter(jpaVendorAdapter()); entityManager.setPackagesToScan("com.example.model");// entity package entityManager.setPersistenceProviderClass(HibernatePersistenceProvider.class); return entityManager; &#125;&#125; 项目启动类中要关闭jpa的自动配置： 1234567@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class,JpaRepositoriesAutoConfiguration.class, HibernateJpaAutoConfiguration.class&#125;)public class JpaSingleDatasourceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(JpaSingleDatasourceApplication.class, args); &#125;&#125; Spring Data JPA与Atomikos整合实现多数据源事务管理spring-data-jpa虽说默认使用的是Hibernate，但是其与Atomikos整合方式与Hibernate略有不同。 pom 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;dependency&gt; &lt;groupId&gt;com.atomikos&lt;/groupId&gt; &lt;artifactId&gt;transactions-jdbc&lt;/artifactId&gt; &lt;version&gt;4.0.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.atomikos&lt;/groupId&gt; &lt;artifactId&gt;transactions-jta&lt;/artifactId&gt; &lt;version&gt;4.0.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.atomikos&lt;/groupId&gt; &lt;artifactId&gt;transactions&lt;/artifactId&gt; &lt;version&gt;4.0.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.atomikos&lt;/groupId&gt; &lt;artifactId&gt;atomikos-util&lt;/artifactId&gt; &lt;version&gt;4.0.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.transaction&lt;/groupId&gt; &lt;artifactId&gt;jta&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- hibernate --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;4.3.5.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;4.3.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-jpa&lt;/artifactId&gt; &lt;version&gt;1.10.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt; &lt;version&gt;4.3.5.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.37&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; application.properties 1234567891011#datasourcespring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/springboot1?useUnicode=true&amp;characterEncoding=utf-8spring.datasource.username=rootspring.datasource.password=newpwd#datasource2spring.datasource.driver-class-name2=com.mysql.jdbc.Driverspring.datasource.url2=jdbc:mysql://localhost:3306/springboot2?useUnicode=true&amp;characterEncoding=utf-8spring.datasource.username2=rootspring.datasource.password2=newpwd MainConfig：用于注册Atomikos事务管理器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.example;import com.atomikos.icatch.jta.UserTransactionImp;import com.atomikos.icatch.jta.UserTransactionManager;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.DependsOn;import org.springframework.transaction.PlatformTransactionManager;import org.springframework.transaction.jta.JtaTransactionManager;import javax.transaction.TransactionManager;import javax.transaction.UserTransaction;@Configurationpublic class MainConfig &#123; @Bean(name = "userTransaction") public UserTransaction userTransaction() throws Throwable &#123; UserTransactionImp userTransactionImp = new UserTransactionImp(); userTransactionImp.setTransactionTimeout(10000); return userTransactionImp; &#125; @Bean(name = "atomikosTransactionManager", initMethod = "init", destroyMethod = "close") public TransactionManager atomikosTransactionManager() throws Throwable &#123; UserTransactionManager userTransactionManager = new UserTransactionManager(); userTransactionManager.setForceShutdown(true); return userTransactionManager; &#125; @Bean(name = "transactionManager") @DependsOn(&#123; "userTransaction", "atomikosTransactionManager" &#125;) public PlatformTransactionManager transactionManager() throws Throwable &#123; UserTransaction userTransaction = userTransaction(); TransactionManager atomikosTransactionManager = atomikosTransactionManager(); JtaTransactionManager jtaTransactionManager = new JtaTransactionManager(userTransaction, atomikosTransactionManager); jtaTransactionManager.setAllowCustomIsolationLevels(true); return jtaTransactionManager; &#125; //上面三个都认识，下面说一下这个bean @Bean(name = "atomikosJtaPlatfom") public AtomikosJtaPlatfom atomikosJtaPlatfom()&#123; AtomikosJtaPlatfom atomikosJtaPlatfom = new AtomikosJtaPlatfom(); try &#123; atomikosJtaPlatfom.setTm(atomikosTransactionManager()); atomikosJtaPlatfom.setUt(userTransaction()); &#125; catch (Throwable throwable) &#123; throwable.printStackTrace(); &#125; return atomikosJtaPlatfom; &#125;&#125; 配置JPA的LocalContainerEntityManagerFactoryBean时候，如果要使其能够支持JTA事务，则在配置其JpaProperties时需要为其指定如下参数： hibernate.transaction.jta.platformhibernate.current_session_context_classhibernate.transaction.factory_class 后面我们配置LocalContainerEntityManagerFactoryBean的时候会看到相应的配置，这里要说的是，hibernate.transaction.jta.platform需要指定org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform的实现类，其主要功能就是要绑定javax.transaction.TransactionManager和javax.transaction.UserTransaction。 spring-data-jpa没有提供该实现类，但是hibernate提供了许多实现类，spring boot也提供了一个实现类–SpringJtaPlatform，但是这些实现类都是通过构造函数绑定javax.transaction.TransactionManager和javax.transaction.UserTransaction，而没有提供缺省的构造方法，这就导致通过属性指定hibernate.transaction.jta.platform时，spring不能初始化该实现类（可能是我还没有搞明白吧）。 所以，可以自己创建一个实现类，并通过set方法来绑定javax.transaction.TransactionManager和javax.transaction.UserTransaction。这就是AtomikosJtaPlatfom 12345678910111213141516171819202122232425262728293031323334353637package com.example;import org.hibernate.engine.transaction.jta.platform.internal.AbstractJtaPlatform;import javax.transaction.TransactionManager;import javax.transaction.UserTransaction;public class AtomikosJtaPlatfom extends AbstractJtaPlatform &#123; private static UserTransaction ut; private static TransactionManager tm; @Override protected TransactionManager locateTransactionManager() &#123; return tm; &#125; @Override protected UserTransaction locateUserTransaction() &#123; return ut; &#125; public UserTransaction getUt() &#123; return ut; &#125; public void setUt(UserTransaction ut) &#123; AtomikosJtaPlatfom.ut = ut; &#125; public TransactionManager getTm() &#123; return tm; &#125; public void setTm(TransactionManager tm) &#123; AtomikosJtaPlatfom.tm = tm; &#125;&#125; 接下来需要在配置类中注册LocalContainerEntityManagerFactoryBean，由于@EnableJpaRepositories注解不能在同一个配置类上声明两次，所以就按数据源进行分别设置： JpaConfigDs1：数据源1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package com.example;import com.atomikos.jdbc.AtomikosDataSourceBean;import com.mysql.jdbc.jdbc2.optional.MysqlXADataSource;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.DependsOn;import org.springframework.data.jpa.repository.config.EnableJpaRepositories;import org.springframework.orm.jpa.JpaVendorAdapter;import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;import org.springframework.orm.jpa.vendor.Database;import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;import org.springframework.transaction.annotation.EnableTransactionManagement;import javax.sql.DataSource;import java.util.Properties;@Configuration@EnableTransactionManagement(proxyTargetClass = true)//指定数据源1的Repository路径，数据源1的entityManagerFactory，事务是公共事务@EnableJpaRepositoryies(basePackages = "com.example.dao.ds1", entityManagerFactoryRef = "entityManagerFactory", transactionManagerRef = "transactionManager")public class JpaConfigDs1 &#123; @Value("$&#123;spring.datasource.driver-class-name&#125;") String driverClass; @Value("$&#123;spring.datasource.url&#125;") String url; @Value("$&#123;spring.datasource.username&#125;") String userName; @Value("$&#123;spring.datasource.password&#125;") String passWord; @Bean(name = "dataSource", initMethod = "init", destroyMethod = "close") public DataSource dataSource() &#123; System.out.println("dataSource init"); MysqlXADataSource mysqlXaDataSource = new MysqlXADataSource(); mysqlXaDataSource.setUrl(url); mysqlXaDataSource.setPassword(passWord); mysqlXaDataSource.setUser(userName); mysqlXaDataSource.setPinGlobalTxToPhysicalConnection(true); AtomikosDataSourceBean xaDataSource = new AtomikosDataSourceBean(); xaDataSource.setXaDataSource(mysqlXaDataSource); xaDataSource.setUniqueResourceName("dataSource"); xaDataSource.setMinPoolSize(10); xaDataSource.setPoolSize(10); xaDataSource.setMaxPoolSize(30); xaDataSource.setBorrowConnectionTimeout(60); xaDataSource.setReapTimeout(20); xaDataSource.setMaxIdleTime(60); xaDataSource.setMaintenanceInterval(60); return xaDataSource; &#125; @Bean(name = "jpaVendorAdapter") public JpaVendorAdapter jpaVendorAdapter() &#123; System.out.println("jpaVendorAdapter init"); HibernateJpaVendorAdapter adapter = new HibernateJpaVendorAdapter(); adapter.setShowSql(true); adapter.setDatabase(Database.MYSQL); adapter.setDatabasePlatform("org.hibernate.dialect.MySQLDialect"); adapter.setGenerateDdl(true); return adapter; &#125; @Bean(name = "entityManagerFactory") @DependsOn(&#123;"atomikosJtaPlatfom"&#125;) //需要先注册atomikosJtaPlatfom public LocalContainerEntityManagerFactoryBean entityManagerFactory() &#123; System.out.println("entityManagerFactory init"); LocalContainerEntityManagerFactoryBean entityManager = new LocalContainerEntityManagerFactoryBean(); entityManager.setJpaVendorAdapter(jpaVendorAdapter()); // entity package entityManager.setPackagesToScan("com.example.model.ds1"); entityManager.setJtaDataSource(dataSource()); Properties properties = new Properties(); properties.put("hibernate.dialect", "org.hibernate.dialect.MySQLDialect"); properties.put("hibernate.show_sql", "true"); properties.put("hibernate.format_sql", "true"); //jta设置 properties.put("hibernate.current_session_context_class", "jta"); properties.put("hibernate.transaction.factory_class", "org.hibernate.engine.transaction.internal.jta.CMTTransactionFactory"); //这里指定我们自己创建的AtomikosJtaPlatfom properties.put("hibernate.transaction.jta.platform","com.example.AtomikosJtaPlatfom"); entityManager.setJpaProperties(properties); return entityManager; &#125;&#125; JpaConfigDs2：数据源2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package com.example;import com.atomikos.jdbc.AtomikosDataSourceBean;import com.mysql.jdbc.jdbc2.optional.MysqlXADataSource;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.DependsOn;import org.springframework.data.jpa.repository.config.EnableJpaRepositories;import org.springframework.orm.jpa.JpaVendorAdapter;import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;import org.springframework.orm.jpa.vendor.Database;import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;import org.springframework.transaction.annotation.EnableTransactionManagement;import javax.sql.DataSource;import java.util.Properties;@Configuration@EnableTransactionManagement(proxyTargetClass = true)@EnableJpaRepositories(basePackages = "com.example.dao.ds2", entityManagerFactoryRef = "entityManagerFactory2", transactionManagerRef = "transactionManager")public class JpaConfigDs2 &#123; @Value("$&#123;spring.datasource.driver-class-name2&#125;") String driverClass; @Value("$&#123;spring.datasource.url2&#125;") String url; @Value("$&#123;spring.datasource.username2&#125;") String userName; @Value("$&#123;spring.datasource.password2&#125;") String passWord; @Bean(name = "dataSource2", initMethod = "init", destroyMethod = "close") public DataSource dataSource() &#123; System.out.println("dataSource2 init"); MysqlXADataSource mysqlXaDataSource = new MysqlXADataSource(); mysqlXaDataSource.setUrl(url); mysqlXaDataSource.setPassword(passWord); mysqlXaDataSource.setUser(userName); mysqlXaDataSource.setPinGlobalTxToPhysicalConnection(true); AtomikosDataSourceBean xaDataSource = new AtomikosDataSourceBean(); xaDataSource.setXaDataSource(mysqlXaDataSource); xaDataSource.setUniqueResourceName("dataSource2"); xaDataSource.setMinPoolSize(10); xaDataSource.setPoolSize(10); xaDataSource.setMaxPoolSize(30); xaDataSource.setBorrowConnectionTimeout(60); xaDataSource.setReapTimeout(20); xaDataSource.setMaxIdleTime(60); xaDataSource.setMaintenanceInterval(60); return xaDataSource; &#125; @Bean(name = "jpaVendorAdapter2") public JpaVendorAdapter jpaVendorAdapter() &#123; System.out.println("jpaVendorAdapter2 init"); HibernateJpaVendorAdapter adapter = new HibernateJpaVendorAdapter(); adapter.setShowSql(true); adapter.setDatabase(Database.MYSQL); adapter.setDatabasePlatform("org.hibernate.dialect.MySQLDialect"); adapter.setGenerateDdl(true); return adapter; &#125; @Bean(name = "entityManagerFactory2") @DependsOn(&#123;"atomikosJtaPlatfom"&#125;) public LocalContainerEntityManagerFactoryBean entityManagerFactory() &#123; System.out.println("entityManagerFactory2 init"); LocalContainerEntityManagerFactoryBean entityManager = new LocalContainerEntityManagerFactoryBean(); entityManager.setJpaVendorAdapter(jpaVendorAdapter()); entityManager.setPackagesToScan("com.example.model.ds2");// entity package entityManager.setJtaDataSource(dataSource()); Properties properties = new Properties(); properties.put("hibernate.transaction.jta.platform","com.example.AtomikosJtaPlatfom"); properties.put("hibernate.dialect", "org.hibernate.dialect.MySQLDialect"); properties.put("hibernate.show_sql", "true"); properties.put("hibernate.format_sql", "true"); properties.put("hibernate.current_session_context_class", "jta"); properties.put("hibernate.transaction.factory_class", "org.hibernate.engine.transaction.internal.jta.CMTTransactionFactory"); entityManager.setJpaProperties(properties); return entityManager; &#125;&#125; 其它方面与单数据源使用JPA没有区别，这里就不罗列代码了。 扩展JPA的方法上面我们介绍过，一般情况下我们的Repository接口继承JpaRepository，所以可以默认使用JpaRepository提供的所有方法，如果提供的方法不满足需求时，可以在自己的Repository中通过命名规则或者@Query注解等实现方法的扩展。那么，我们如果希望将一些自己扩展公共的方法放在父类中，以便我们所有的Repository都能拥有该扩展功能，该如何实现呢？ 本例只举例说明，实现的功能为接收查询条件的分页查询，查询时按传递实体对象的属性进行处理，如果是字符串就按模糊匹配，否则就按精确匹配。 定义父类接口–BaseJpaRepository12345@NoRepositoryBean //说明这不是一个需要被扫描到的Repositorypublic interface BaseJpaRepository&lt;T, ID extends Serializable&gt; extends JpaRepository&lt;T, ID&gt;,JpaSpecificationExecutor&lt;T&gt; &#123; Page&lt;T&gt; findByAuto(T example, Pageable pageable);&#125; 创建实现类–BaseJpaRepositoryImpl123456789101112131415public class BaseJpaRepositoryImpl&lt;T, ID extends Serializable&gt; extends SimpleJpaRepository&lt;T, ID&gt; implements BaseJpaRepository&lt;T, ID&gt; &#123; //通过构造方法初始化EntityManager private final EntityManager entityManager; public BaseJpaRepositoryImpl(Class&lt;T&gt; domainClass, EntityManager entityManager) &#123; super(domainClass, entityManager); this.entityManager = entityManager; &#125; //具体方法实现，这里使用了一个自定义工具类BaseSpecs @Override public Page&lt;T&gt; findByAuto(T example, Pageable pageable) &#123; return findAll(BaseSpecs.byAuto(entityManager,example),pageable); &#125;&#125; BaseSpecs的byAuto方法负责封装查询对象Specification，按传递实体对象的属性进行处理，如果是字符串就按模糊匹配，否则就按精确匹配。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class BaseSpecs &#123; public static &lt;T&gt; Specification&lt;T&gt; byAuto(final EntityManager entityManager, final T example)&#123; final Class&lt;T&gt; type = (Class&lt;T&gt;) example.getClass(); return new Specification&lt;T&gt;() &#123; @Override public Predicate toPredicate(Root&lt;T&gt; root, CriteriaQuery&lt;?&gt; criteriaQuery, CriteriaBuilder criteriaBuilder) &#123; List&lt;Predicate&gt; predicateList = new ArrayList&lt;&gt;(); EntityType&lt;T&gt; entityType = entityManager.getMetamodel().entity(type); for(Attribute&lt;T,?&gt; attribute : entityType.getDeclaredAttributes())&#123; Object attrValue = getValue(example,attribute); if(attrValue != null)&#123; if(attribute.getJavaType() == String.class)&#123; if(!StringUtils.isEmpty(attrValue))&#123; predicateList.add(criteriaBuilder.like(root.get(attribute(entityType,attribute.getName(),String.class)),pattern((String)attrValue))); &#125; &#125;else&#123; predicateList.add(criteriaBuilder.equal(root.get(attribute(entityType,attribute.getName(),attrValue.getClass())),attrValue)); &#125; &#125; &#125; return predicateList.isEmpty()?criteriaBuilder.conjunction():criteriaBuilder.and(toArray(predicateList)); &#125; private &lt;T&gt; Object getValue(T example,Attribute&lt;T,?&gt; attr)&#123; return ReflectionUtils.getField((Field)attr.getJavaMember(),example); &#125; private &lt;E,T&gt; SingularAttribute&lt;T,E&gt; attribute(EntityType&lt;T&gt; entityType,String fieldName,Class&lt;E&gt; fieldClass)&#123; return entityType.getDeclaredSingularAttribute(fieldName,fieldClass); &#125; private Predicate[] toArray(List&lt;Predicate&gt; predicateList)&#123; Predicate[] array = predicateList.toArray(new Predicate[predicateList.size()]); return array; &#125; &#125;; &#125; static private String pattern(String str)&#123; return "%" + str + "%"; &#125;&#125; 说明当我们的Repository实现的是JpaRepository的时候，Spring-data-jpa会为我们动态使用JpaRepository的实现类SimpleJpaRepository，这也是为什么我们只需要创建接口而不需要提供实现类。 这里，我们创建了新的父类接口BaseJpaRepository，并为其提供了实现类BaseJpaRepositoryImpl，所以我们要告诉Spring-data-jpa要使用我们自己的实现类，而不能去使用SimpleJpaRepository，所以我们要改写JpaRepositoryFactoryBean； 创建一个BaseRepositoryFactoryBean继承于JpaRepositoryFactoryBean： 12345678910111213141516171819202122232425262728public class BaseRepositoryFactoryBean&lt;T extends JpaRepository&lt;S, ID&gt;, S, ID extends Serializable&gt; extends JpaRepositoryFactoryBean&lt;T,S,ID&gt; &#123; @Override protected RepositoryFactorySupport createRepositoryFactory(EntityManager entityManager) &#123; return new BaseRepositoryFactory(entityManager); &#125;&#125;class BaseRepositoryFactory extends JpaRepositoryFactory &#123; public BaseRepositoryFactory(EntityManager entityManager)&#123; super(entityManager); &#125; //指定实现类 @Override protected &lt;T, ID extends Serializable&gt; SimpleJpaRepository&lt;?, ?&gt; getTargetRepository(RepositoryInformation information, EntityManager entityManager) &#123; BaseJpaRepositoryImpl customRepository = new BaseJpaRepositoryImpl&lt;T,ID&gt;((Class&lt;T&gt;)information.getDomainType(),entityManager); return customRepository; &#125; //指定实现类类型 @Override protected Class&lt;?&gt; getRepositoryBaseClass(RepositoryMetadata metadata) return BaseJpaRepositoryImpl.class; &#125;&#125; 并且在@EnableJpaRepositories注解中进行指定： 1234@EnableJpaRepositories(basePackages = "com.example.dao", entityManagerFactoryRef = "entityManagerFactory", transactionManagerRef = "transactionManager",repositoryFactoryBeanClass=BaseRepositoryFactoryBean.class)public class JpaConfig &#123; //………………&#125; 自定义Repository继承BaseJpaRepository1234public interface PersonRepository extends BaseJpaRepository&lt;Person, Integer&gt; &#123; //………依然可以在该接口中对功能进行扩展………&#125; 测试12345678910111213141516171819202122@RunWith(SpringRunner.class)@SpringBootTest@Transactionalpublic class JpaExtendApplicationTests &#123; @Autowired private PersonRepository personRepository; @Test public void findByAuto() &#123; Person person = new Person(); person.setpName("王五"); person.setpAge(18); Sort sort = new Sort(Sort.Direction.DESC, "pId"); //查询第一页，按一页三行分页 Pageable pageable = new PageRequest(0, 3, sort); Page&lt;Person&gt; list = personRepository.findByAuto(person,pageable); for(Person p:list)&#123; System.out.println(p); &#125; &#125;&#125; 本文示例代码下载地址：https://github.com/hanqunfeng/SpringBootStudy]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot学习笔记05--Mybatis+通用Mapper+分页插件]]></title>
    <url>%2F2016%2F12%2F20%2Fspring-boot-study-mybatis%2F</url>
    <content type="text"><![CDATA[摘要看完本文你将掌握如下知识点： Spring Boot项目中，Mybatis+通用Mapper+分页插件的配置方法 SpringBoot系列：Spring Boot学习笔记 前言前文已经对Spring Boot中各种类型的数据访问做了说明，本文是对Spring Boot中使用Mybatis的扩展，重点说明如何在mybatis中集成通用Mapper和分页插件。 本文代码是在上文中讲到的mybatis单数据源配置的基础上进行扩展。 配置说明pom中增加通用Mapper和分页插件的依赖： 123456789101112&lt;!--分页插件--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;4.2.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--通用Mapper--&gt;&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper&lt;/artifactId&gt; &lt;version&gt;3.3.9&lt;/version&gt;&lt;/dependency&gt; MyBatisConfig：在SqlSessionFactory中增加分页插件配置，因为通用Mapper是基于注解的，所以这里去掉xml的加载。 1234567891011121314151617181920212223242526272829@Bean(name = "sqlSessionFactory")public SqlSessionFactory sqlSessionFactoryBean() &#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dataSource()); bean.setTypeAliasesPackage("com.example.pojo"); //分页插件设置 PageHelper pageHelper = new PageHelper(); Properties properties = new Properties(); properties.setProperty("reasonable", "true"); properties.setProperty("supportMethodsArguments", "true"); properties.setProperty("returnPageInfo", "check"); properties.setProperty("params", "count=countSql"); pageHelper.setProperties(properties); //添加分页插件 bean.setPlugins(new Interceptor[]&#123;pageHelper&#125;); ResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(); try &#123; //基于注解扫描Mapper，不需配置xml路径 //bean.setMapperLocations(resolver.getResources("classpath:mapper/*.xml")); return bean.getObject(); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125;&#125; MyBatisMapperScannerConfig注意这里使用的是tk.mybatis.spring.mapper.MapperScannerConfigurer 1234567891011121314151617181920212223242526272829package com.example;import org.springframework.boot.autoconfigure.AutoConfigureAfter;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import tk.mybatis.spring.mapper.MapperScannerConfigurer;import java.util.Properties;@Configuration//必须在MyBatisConfig注册后再加载MapperScannerConfigurer，否则会报错@AutoConfigureAfter(MyBatisConfig.class)public class MyBatisMapperScannerConfig &#123; @Bean public MapperScannerConfigurer mapperScannerConfigurer() &#123; MapperScannerConfigurer mapperScannerConfigurer = new MapperScannerConfigurer(); mapperScannerConfigurer.setSqlSessionFactoryBeanName("sqlSessionFactory"); mapperScannerConfigurer.setBasePackage("com.example.mapper"); //初始化扫描器的相关配置，这里我们要创建一个Mapper的父类 Properties properties = new Properties(); properties.setProperty("mappers", "com.example.MyMapper"); properties.setProperty("notEmpty", "false"); properties.setProperty("IDENTITY", "MYSQL"); mapperScannerConfigurer.setProperties(properties); return mapperScannerConfigurer; &#125;&#125; MyMapper 123456789package com.example;import tk.mybatis.mapper.common.Mapper;import tk.mybatis.mapper.common.MySqlMapper;public interface MyMapper&lt;T&gt; extends Mapper&lt;T&gt;, MySqlMapper&lt;T&gt; &#123; //TODO //FIXME 特别注意，该接口不能被扫描到，否则会出错&#125; PersonMapper：实体mapper继承MyMapper即可，业务方法中我们就可以使用通用Mapper提供的各种方法 12345678910111213141516171819202122232425262728293031package com.example.mapper;import com.example.MyMapper;import com.example.pojo.Person;public interface PersonMapper extends MyMapper&lt;Person&gt; &#123; //以下方法用于演示，当通用Mapper不能买足需求时，可以自己扩展相应的方法 //不允许查询参数为空的情况 @Select(&#123; "select", "p_id, p_name, p_age", "from person", "where p_age between #&#123;startAge&#125; and #&#123;endAge&#125;" &#125;) @Results(&#123; @Result(column="p_id", property="pId", jdbcType= JdbcType.INTEGER, id=true), @Result(column="p_name", property="pName", jdbcType=JdbcType.VARCHAR), @Result(column="p_age", property="pAge", jdbcType=JdbcType.INTEGER) &#125;) List&lt;Person&gt; queryListByParam(Person person); //允许查询参数为空的情况 @SelectProvider(type = PersonSqlProvider.class,method = "selectSelective") @Results(&#123; @Result(column="p_id", property="pId", jdbcType= JdbcType.INTEGER, id=true), @Result(column="p_name", property="pName", jdbcType=JdbcType.VARCHAR), @Result(column="p_age", property="pAge", jdbcType=JdbcType.INTEGER) &#125;) List&lt;Person&gt; queryListByParamSelective(Person person);&#125; 123456789101112131415161718192021222324252627package com.example.mapper;import com.example.pojo.Person;import static org.apache.ibatis.jdbc.SqlBuilder.*;public class PersonSqlProvider &#123; public String selectSelective(Person record)&#123; BEGIN(); SELECT("p_id, p_name, p_age"); FROM("person"); WHERE("1=1"); if(record.getStartAge()!=null)&#123; AND(); WHERE("p_age &gt;= #&#123;startAge&#125;"); &#125; if(record.getEndAge()!=null)&#123; AND(); WHERE("p_age &lt;= #&#123;endAge&#125;"); &#125; return SQL(); &#125;&#125; 这里要注意，使用通用Mapper时，实体类必须有一个叫做id的整型主键，另外，为了方便使用分页插件，要在每个实体对象中定义两个属性–page和rows，我们可以把这些通用的属性放到父类中，比如我们创建一个父类：BaseEntity BaseEntity 123456789101112131415161718package com.example.pojo;import javax.persistence.Transient;public class BaseEntity &#123; @Id //注意，如果是老的项目，表中的主键可能不叫做id，这时可以在父类中去掉这个属性，改在子类中实现 @Column(name = "id") @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; @Transient private Integer page = 1; @Transient private Integer rows = 10;&#125; 1234567891011121314151617package com.example.pojo;import javax.persistence.*;@Table(name = "person")public class Person extends BaseEntity&#123; private String pName; private Integer pAge; //以下属性用于演示范围查询 @Transient private Integer startAge; @Transient private Integer endAge; //setter and getter&#125; 测试演示业务方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.example.service;import com.example.mapper.PersonMapper;import com.example.pojo.Person;import com.github.pagehelper.PageHelper;import org.apache.ibatis.session.RowBounds;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Propagation;import org.springframework.transaction.annotation.Transactional;import java.util.List;@Service@Transactional(propagation = Propagation.REQUIRED, readOnly = false, rollbackFor = &#123;Exception.class&#125;)public class PersonService &#123; @Autowired private PersonMapper personMapper; public int insert(Person person)&#123; return personMapper.insert(person); &#125; @Transactional(readOnly = true) public Person selectByPrimaryKey(Integer pId)&#123; return personMapper.selectByPrimaryKey(pId); &#125; @Transactional(readOnly = true) public List&lt;Person&gt; getAllPersonList()&#123; return personMapper.selectAll(); &#125; @Transactional(readOnly = true) public List&lt;Person&gt; getPagePersonList(Person person, RowBounds rowBounds)&#123; return personMapper.selectByRowBounds(person,rowBounds); &#125; public List&lt;Person&gt; getPagePersonList(Person person)&#123; if (person.getPage() != null &amp;&amp; person.getRows() != null) &#123; PageHelper.startPage(person.getPage(), person.getRows(), "p_id"); &#125; return personMapper.selectAll(); &#125; public List&lt;Person&gt; queryListByParam(Person person)&#123; if (person.getPage() != null &amp;&amp; person.getRows() != null) &#123; PageHelper.startPage(person.getPage(), person.getRows(), "p_id"); &#125; return personMapper.queryListByParam(person); &#125; public List&lt;Person&gt; queryListByParamSelective(Person person)&#123; if (person.getPage() != null &amp;&amp; person.getRows() != null) &#123; PageHelper.startPage(person.getPage(), person.getRows(), "p_id"); &#125; return personMapper.queryListByParamSelective(person); &#125;&#125; 单元测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package com.example;import com.example.pojo.Person;import com.example.service.PersonService;import org.apache.ibatis.session.RowBounds;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import org.springframework.transaction.annotation.Transactional;import java.util.List;@RunWith(SpringRunner.class)@SpringBootTest@Transactionalpublic class MybatisMapperPagehelperApplicationTests &#123; @Autowired PersonService personService; @Test public void selectByPrimaryKey()&#123; Person person = personService.selectByPrimaryKey(1); System.out.println(person); &#125; @Test public void insert()&#123; Person person = new Person(); person.setpName("王五"); person.setpAge(18); System.out.println(personService.insert(person)); &#125; @Test public void getAllPersonList()&#123; List&lt;Person&gt; list = personService.getAllPersonList(); System.out.println(list.size()); for(Person person : list)&#123; System.out.println(person); &#125; &#125; @Test public void getPagePersonList()&#123; Person person = new Person(); person.setpName("王五"); //指定limit和offset List&lt;Person&gt; list = personService.getPagePersonList(person,new RowBounds(2,3)); System.out.println(list.size()); for(Person p : list)&#123; System.out.println(p); &#125; &#125; @Test public void getPagePersonList2()&#123; Person person = new Person(); //每页2行，查询第二页 person.setPage(2); person.setRows(2); List&lt;Person&gt; list = personService.getPagePersonList(person); System.out.println(list.size()); for(Person p : list)&#123; System.out.println(p); &#125; &#125; @Test public void queryListByParam()&#123; Person person = new Person(); //每页2行，查询第二页 person.setPage(2); person.setRows(2); //查询年龄在15到22之间的数据 person.setStartAge(15); person.setEndAge(22); List&lt;Person&gt; list = personService.queryListByParam(person); System.out.println(list.size()); for(Person p : list)&#123; System.out.println(p); &#125; &#125; @Test public void queryListByParamSelective()&#123; Person person = new Person(); //每页2行，查询第一页 person.setPage(1); person.setRows(2); //查询年龄大于等于15的数据 person.setStartAge(15); //person.setEndAge(22); List&lt;Person&gt; list = personService.queryListByParamSelective(person); System.out.println(list.size()); for(Person p : list)&#123; System.out.println(p); &#125; &#125;&#125; 本文示例代码下载地址：https://github.com/hanqunfeng/SpringBootStudy 项目参考：https://github.com/abel533/MyBatis-Spring-Boot]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot学习笔记04--数据访问]]></title>
    <url>%2F2016%2F12%2F17%2Fspring-boot-study-data%2F</url>
    <content type="text"><![CDATA[摘要看完本文你将掌握如下知识点： Spring Boot对JDBC的支持 Spring Boot项目多数据源的配置 Spring Boot的事务管理 Spring Boot项目多数据源的事务管理 Spring Boot项目中使用Hibernate4的方法 Spring Boot项目中使用Mybatis的方法 SpringBoot系列：Spring Boot学习笔记 前言Spring Boot针对企业开发场景提供了各种『开箱即用』的spring-boot-starter-xxx自动配置依赖模块，这就使得我们开发Spring应用更加快速和高效。比如我们前面创建web项目时使用到的spring-boot-starter-web。 这些spring-boot-starter-xxx不但包含了对该功能的全部依赖包，同时也提供了该功能的自动配置类。我们本节要讨论的『数据访问』就是基于这些spring-boot-starter-xxx的自动配置依赖模块。 环境准备jdk版本：java version “1.8.0_31”数据库：10.1.16-MariaDB脚本1234567891011121314151617181920212223242526# 创建库1CREATE SCHEMA `springboot1` DEFAULT CHARACTER SET utf8 ;CREATE TABLE `springboot1`.`person` ( `p_id` INT NOT NULL AUTO_INCREMENT COMMENT '主键', `p_name` VARCHAR(45) NULL COMMENT '姓名', `p_age` INT NULL COMMENT '年龄', PRIMARY KEY (`p_id`))ENGINE = InnoDBCOMMENT = '人员信息表';INSERT INTO `springboot1`.`person` (`p_id`, `p_name`, `p_age`) VALUES ('1', '张三', '20');INSERT INTO `springboot1`.`person` (`p_id`, `p_name`, `p_age`) VALUES ('2', '李四', '25');# 创建库2CREATE SCHEMA `springboot2` DEFAULT CHARACTER SET utf8 ;CREATE TABLE `springboot2`.`person` ( `p_id` INT NOT NULL AUTO_INCREMENT COMMENT '主键', `p_name` VARCHAR(45) NULL COMMENT '姓名', `p_age` INT NULL COMMENT '年龄', PRIMARY KEY (`p_id`))ENGINE = InnoDBCOMMENT = '人员信息表';INSERT INTO `springboot2`.`person` (`p_id`, `p_name`, `p_age`) VALUES ('1', '张三', '20');INSERT INTO `springboot2`.`person` (`p_id`, `p_name`, `p_age`) VALUES ('2', '李四', '25'); Spring Boot对JDBC的支持创建项目新建一个springboot项目，依赖选择web和jdbc 项目创建成功后查看pom，会看到添加了spring-boot-starter-jdbc的依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 配置项目在pom中增加MySQL依赖12345&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.37&lt;/version&gt;&lt;/dependency&gt; 在application.properties中添加数据源配置信息12345#datasourcespring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/springboot1?useUnicode=true&amp;characterEncoding=utf-8spring.datasource.username=rootspring.datasource.password=newpwd 项目代码本例只做简单演示，所以只创建如下3个类，并用一个单元测试类进行测试Model:Person1234567891011121314151617public class Person implements Serializable &#123; private static final long serialVersionUID = -1L; private Long id; private String name; private Integer age; //getter and setter @Override public String toString() &#123; return "Person&#123;" + "id=" + id + ", name='" + name + '\'' + ", age=" + age + '&#125;'; &#125;&#125; Dao:PersonDao1234567891011121314151617181920212223242526272829@Repositorypublic class PersonDao &#123; @Autowired private JdbcTemplate jdbcTemplate; public int savePerson(Person person)&#123; String sql = "INSERT INTO `springboot1`.`person` (`p_name`, `p_age`) VALUES (?, ?)"; int result = jdbcTemplate.update(sql,new Object[]&#123;person.getName(),person.getAge()&#125;); return result; &#125; public List&lt;Person&gt; getAllPersonList()&#123; String sql = "select * from person s"; List&lt;Person&gt; list = jdbcTemplate.query(sql,new PersonMapper()); return list; &#125; class PersonMapper implements RowMapper&lt;Person&gt;&#123; @Override public Person mapRow(ResultSet resultSet, int i) throws SQLException &#123; Person person = new Person(); person.setId(resultSet.getLong("p_id")); person.setName(resultSet.getString("p_name")); person.setAge(resultSet.getInt("p_age")); return person; &#125; &#125;&#125; Service:PersonService1234567891011121314@Servicepublic class PersonService &#123; @Autowired private PersonDao personDao; public int savePserson(Person person)&#123; return personDao.savePerson(person); &#125; public List&lt;Person&gt; getAllPersonList()&#123; return personDao.getAllPersonList(); &#125;&#125; 单元测试:SpringbootjdbcdemoApplicationTests12345678910111213141516171819202122232425@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringbootjdbcdemoApplicationTests &#123; @Autowired private PersonService personService; @Test public void savePerson()&#123; Person person = new Person(); person.setName("王五"); person.setAge(18); int result = personService.savePserson(person); Assert.assertEquals(1,result); &#125; @Test public void getAllPersonList()&#123; List&lt;Person&gt; list = personService.getAllPersonList(); System.out.println(list.size()); for(Person person : list)&#123; System.out.println(person); &#125; &#125;&#125; 说明实际上，项目加入spring-boot-starter-jdbc的依赖后，即可在项目代码中通过@Autowired自动注入JdbcTemplate。而数据源的配置则在application.properties中进行配置。 如果不想使用spring-boot-starter-jdbc带来的默认依赖和自动配置，那么采用如下的方式，效果是一样的。 使用自定义的DataSourceConfig修改pom中的依赖，去掉对spring-boot-starter-jdbc的依赖，并加入对spring-jdbc的依赖，这样我们就失去了对JDBC的自动配置功能了。123456789101112&lt;!--&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.3.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; 启动类中去掉对DataSourceAutoConfiguration的自动配置支持1234567@SpringBootApplication(exclude=&#123;DataSourceAutoConfiguration.class&#125;)public class SpringbootjdbcdemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootjdbcdemoApplication.class, args); &#125;&#125; 创建DataSourceConfig配置类12345678910111213141516171819202122232425262728@Configurationpublic class DataSourceConfig &#123; @Value("$&#123;spring.datasource.driver-class-name&#125;") String driverClass; @Value("$&#123;spring.datasource.url&#125;") String url; @Value("$&#123;spring.datasource.username&#125;") String userName; @Value("$&#123;spring.datasource.password&#125;") String passWord; @Bean(name = "dataSource") public DataSource dataSource() &#123; DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(driverClass); dataSource.setUrl(url); dataSource.setUsername(userName); dataSource.setPassword(passWord); return dataSource; &#125; @Bean(name = "jdbcTemplate") public JdbcTemplate jdbcTemplate()&#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource()); return jdbcTemplate; &#125;&#125; 其它代码不需要任何修改，运行效果一致。 说明为什么SpringBoot为我们提供了spring-boot-starter-jdbc的自动配置解决方案，我们还要自己配置呢，这是因为自动配置并不是那么的强大，spring-boot-starter-jdbc只能支持单一的数据源配置，如果项目中需要关联多个数据源，就需要我们自己处理了。 比如我们在环境准备中创建了两个数据库，接下来我们在项目中增加多数据源的配置。 在application.properties中添加数据源配置信息12345#datasource2spring.datasource.driver-class-name2=com.mysql.jdbc.Driverspring.datasource.url2=jdbc:mysql://localhost:3306/springboot2?useUnicode=true&amp;characterEncoding=utf-8spring.datasource.username2=rootspring.datasource.password2=newpwd 然后在DataSourceConfig配置类中增加如下内容：123456789101112131415161718192021222324@Value("$&#123;spring.datasource.driver-class-name2&#125;")String driverClass2;@Value("$&#123;spring.datasource.url2&#125;")String url2;@Value("$&#123;spring.datasource.username2&#125;")String userName2;@Value("$&#123;spring.datasource.password2&#125;")String passWord2;@Bean(name = "dataSource2")public DataSource dataSource2() &#123; DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(driverClass2); dataSource.setUrl(url2); dataSource.setUsername(userName2); dataSource.setPassword(passWord2); return dataSource;&#125;@Bean(name = "jdbcTemplate2")public JdbcTemplate jdbcTemplate2()&#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource2()); return jdbcTemplate;&#125; 此时需要在Dao中将@Autowired注解替换成@Resource(name = &quot;jdbcTemplate&quot;)，来明确指定要使用哪一个jdbcTemplate对象。 说明关于如何在项目中使用Hibernate4框架，可以参考:SpringMVC4零配置 Spring Boot的事务管理JDBC事务管理如果我们项目中使用的是JDBC的数据访问方案，并且容器中只注册了一个DataSource，那么SpringBoot就会为我们开启DataSourceTransactionManagerAutoConfiguration的自动配置类，其会在容器中注册一个DataSourceTransactionManager事务管理器，同时会开启对注解式事务@Transactional的支持。感兴趣的可以看一下DataSourceTransactionManagerAutoConfiguration的源码。 @Transactional是Spring框架提供的，配置方法参考下面的代码12345678910111213141516//一般我们会在业务实现类上声明事务注解//当前表示需要在事务中运行，可以执行更新和删除操作，遇到异常则回滚@Transactional(propagation = Propagation.REQUIRED, readOnly = false, rollbackFor = &#123; Exception.class &#125;)public class PersonService&#123; //方法上也可以标注事务注解，方法上注解声明会覆盖类上的 //一般查询操作readOnly设置为true，增删该操作设置为false @Transactional(readOnly = true) public List&lt;Person&gt; getAllPersonList()&#123; //do something &#125; //不加@Transactiona注解，则使用类上的设置 public int savePserson(Person person)&#123; //do something &#125;&#125; 如果在测试类上声明@Transactional，则会开启自动回滚，不会产生脏数据1234@RunWith(SpringRunner.class)@SpringBootTest@Transactionalpublic class SpringbootjdbcdemoApplicationTests &#123;…………&#125; 如果希望自己配置事务，可以在配置类中增加事务管理器的配置，比如，我们在DataSourceConfig中增加如下配置：1234567891011121314151617181920212223242526272829303132333435@Configuration//启用注解事务管理，使用CGLib代理@EnableTransactionManagement(proxyTargetClass = true)public class DataSourceConfig &#123; @Value("$&#123;spring.datasource.driver-class-name&#125;") String driverClass; @Value("$&#123;spring.datasource.url&#125;") String url; @Value("$&#123;spring.datasource.username&#125;") String userName; @Value("$&#123;spring.datasource.password&#125;") String passWord; @Bean(name = "dataSource") public DataSource dataSource() &#123; DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(driverClass); dataSource.setUrl(url); dataSource.setUsername(userName); dataSource.setPassword(passWord); return dataSource; &#125; @Bean(name = "jdbcTemplate") public JdbcTemplate jdbcTemplate()&#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource()); return jdbcTemplate; &#125; @Bean public DataSourceTransactionManager transactionManager() &#123; return new DataSourceTransactionManager(dataSource()); &#125;&#125; 说明上面的方法只是针对单一数据源进行事务管理的，但是项目中经常会用到多数据源的情况，那么要如何进行事务管理呢？ 我们上文讲到了可以在项目中通过配置类，自己配置多个数据源，并通过DataSourceConfig进行了演示，接下来我们添加多个事务管理器。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@Configuration//启用注解事务管理，使用CGLib代理@EnableTransactionManagement(proxyTargetClass = true)public class DataSourceConfig &#123; @Value("$&#123;spring.datasource.driver-class-name&#125;") String driverClass; @Value("$&#123;spring.datasource.url&#125;") String url; @Value("$&#123;spring.datasource.username&#125;") String userName; @Value("$&#123;spring.datasource.password&#125;") String passWord; @Value("$&#123;spring.datasource.driver-class-name2&#125;") String driverClass2; @Value("$&#123;spring.datasource.url2&#125;") String url2; @Value("$&#123;spring.datasource.username2&#125;") String userName2; @Value("$&#123;spring.datasource.password2&#125;") String passWord2; @Bean(name = "dataSource") public DataSource dataSource() &#123; DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(driverClass); dataSource.setUrl(url); dataSource.setUsername(userName); dataSource.setPassword(passWord); return dataSource; &#125; @Bean(name = "jdbcTemplate") public JdbcTemplate jdbcTemplate()&#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource()); return jdbcTemplate; &#125; @Bean(name = "transactionManager") public DataSourceTransactionManager transactionManager() &#123; return new DataSourceTransactionManager(dataSource()); &#125; @Bean(name = "dataSource2") public DataSource dataSource2() &#123; DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(driverClass2); dataSource.setUrl(url2); dataSource.setUsername(userName2); dataSource.setPassword(passWord2); System.out.println(url2); return dataSource; &#125; @Bean(name = "jdbcTemplate2") public JdbcTemplate jdbcTemplate2()&#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource2()); return jdbcTemplate; &#125; @Bean(name = "transactionManager2") public DataSourceTransactionManager transactionManager2() &#123; return new DataSourceTransactionManager(dataSource2()); &#125;&#125; 这时，我们必须在@Transactional注解中指定要使用哪一个事务管理器123456789101112131415161718192021222324@Service@Transactional(transactionManager = "transactionManager",propagation = Propagation.REQUIRED, readOnly = false, rollbackFor = &#123; Exception.class &#125;)public class PersonService &#123; @Autowired private PersonDao personDao; public int savePserson(Person person)&#123; return personDao.savePerson(person); &#125; @Transactional(transactionManager = "transactionManager",readOnly = true) public List&lt;Person&gt; getAllPersonList()&#123; return personDao.getAllPersonList(); &#125; @Transactional(transactionManager = "transactionManager2",propagation = Propagation.REQUIRED, readOnly = false, rollbackFor = &#123; Exception.class &#125;) public int savePserson2(Person person)&#123; return personDao.savePerson2(person); &#125; @Transactional(transactionManager = "transactionManager2",readOnly = true) public List&lt;Person&gt; getAllPersonList2()&#123; return personDao.getAllPersonList2(); &#125;&#125; 说明这样做并不美好，不能对多个数据源同时进行事务管理，比如，我们在一个业务方法里同时对两个数据源进行操作，我们希望只要有一个发生异常，则两个数据源的数据都进行回滚。 那要怎么做呢，我们接着往下看。 多数据源事务管理这里推荐使用Atomikos，Atomikos支持Mysql、Oracle等多种数据库，可与多种ORM框架集成，如MyBatis、JPA、Hibernate等等，同时支持各种容器下JNDI的多数据源管理。Atomikos官网提供了各种情况下使用Atomikos的Example，本文只对使用JDBC时的情况进行说明。 目前maven中央仓库的最新版本是4.0.4，使用Atomikos，需要在项目中加入如下依赖：12345678910111213141516171819202122232425&lt;dependency&gt; &lt;groupId&gt;com.atomikos&lt;/groupId&gt; &lt;artifactId&gt;transactions-jdbc&lt;/artifactId&gt; &lt;version&gt;4.0.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.atomikos&lt;/groupId&gt; &lt;artifactId&gt;transactions-jta&lt;/artifactId&gt; &lt;version&gt;4.0.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.atomikos&lt;/groupId&gt; &lt;artifactId&gt;transactions&lt;/artifactId&gt; &lt;version&gt;4.0.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.atomikos&lt;/groupId&gt; &lt;artifactId&gt;atomikos-util&lt;/artifactId&gt; &lt;version&gt;4.0.4&lt;/version&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.transaction&lt;/groupId&gt; &lt;artifactId&gt;jta&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt;&lt;/dependency&gt; 对DataSourceConfig进行改造：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127package com.example;import com.atomikos.icatch.jta.UserTransactionImp;import com.atomikos.icatch.jta.UserTransactionManager;import com.atomikos.jdbc.AtomikosDataSourceBean;import com.mysql.jdbc.jdbc2.optional.MysqlXADataSource;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.DependsOn;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.transaction.PlatformTransactionManager;import org.springframework.transaction.annotation.EnableTransactionManagement;import org.springframework.transaction.jta.JtaTransactionManager;import javax.sql.DataSource;import javax.transaction.TransactionManager;import javax.transaction.UserTransaction;@Configuration//启用注解事务管理，使用CGLib代理@EnableTransactionManagement(proxyTargetClass = true)public class DataSourceConfig &#123; @Value("$&#123;spring.datasource.driver-class-name&#125;") String driverClass; @Value("$&#123;spring.datasource.url&#125;") String url; @Value("$&#123;spring.datasource.username&#125;") String userName; @Value("$&#123;spring.datasource.password&#125;") String passWord; @Value("$&#123;spring.datasource.driver-class-name2&#125;") String driverClass2; @Value("$&#123;spring.datasource.url2&#125;") String url2; @Value("$&#123;spring.datasource.username2&#125;") String userName2; @Value("$&#123;spring.datasource.password2&#125;") String passWord2; @Bean(name = "userTransaction") public UserTransaction userTransaction() throws Throwable &#123; UserTransactionImp userTransactionImp = new UserTransactionImp(); userTransactionImp.setTransactionTimeout(300); return userTransactionImp; &#125; @Bean(name = "atomikosTransactionManager", initMethod = "init", destroyMethod = "close") public TransactionManager atomikosTransactionManager() throws Throwable &#123; UserTransactionManager userTransactionManager = new UserTransactionManager(); userTransactionManager.setForceShutdown(true); return userTransactionManager; &#125; @Bean(name = "transactionManager") @DependsOn(&#123; "userTransaction", "atomikosTransactionManager" &#125;) public PlatformTransactionManager transactionManager() throws Throwable &#123; UserTransaction userTransaction = userTransaction(); TransactionManager atomikosTransactionManager = atomikosTransactionManager(); JtaTransactionManager jtaTransactionManager = new JtaTransactionManager(userTransaction, atomikosTransactionManager); jtaTransactionManager.setAllowCustomIsolationLevels(true); return jtaTransactionManager; &#125; @Bean(name = "dataSource", initMethod = "init", destroyMethod = "close") public DataSource dataSource() &#123; System.out.println("dataSource init"); //Oracle:oracle.jdbc.xa.client.OracleXADataSource //Druid:com.alibaba.druid.pool.xa.DruidXADataSource //Postgresql:org.postgresql.xa.PGXADataSource MysqlXADataSource mysqlXaDataSource = new MysqlXADataSource(); mysqlXaDataSource.setUrl(url); mysqlXaDataSource.setPassword(passWord); mysqlXaDataSource.setUser(userName); mysqlXaDataSource.setPinGlobalTxToPhysicalConnection(true); AtomikosDataSourceBean xaDataSource = new AtomikosDataSourceBean(); xaDataSource.setXaDataSource(mysqlXaDataSource); xaDataSource.setUniqueResourceName("dataSource"); xaDataSource.setMinPoolSize(10); xaDataSource.setPoolSize(10); xaDataSource.setMaxPoolSize(30); xaDataSource.setBorrowConnectionTimeout(60); xaDataSource.setReapTimeout(20); xaDataSource.setMaxIdleTime(60); xaDataSource.setMaintenanceInterval(60); return xaDataSource; &#125; @Bean(name = "dataSource2", initMethod = "init", destroyMethod = "close") public DataSource dataSource2() &#123; System.out.println("dataSource2 init"); MysqlXADataSource mysqlXaDataSource = new MysqlXADataSource(); mysqlXaDataSource.setUrl(url2); mysqlXaDataSource.setPassword(passWord2); mysqlXaDataSource.setUser(userName2); mysqlXaDataSource.setPinGlobalTxToPhysicalConnection(true); AtomikosDataSourceBean xaDataSource = new AtomikosDataSourceBean(); xaDataSource.setXaDataSource(mysqlXaDataSource); xaDataSource.setUniqueResourceName("dataSource2"); xaDataSource.setMinPoolSize(10); xaDataSource.setPoolSize(10); xaDataSource.setMaxPoolSize(30); xaDataSource.setBorrowConnectionTimeout(60); xaDataSource.setReapTimeout(20); xaDataSource.setMaxIdleTime(60); xaDataSource.setMaintenanceInterval(60); return xaDataSource; &#125; @Bean(name = "jdbcTemplate") public JdbcTemplate jdbcTemplate()&#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource()); return jdbcTemplate; &#125; @Bean(name = "jdbcTemplate2") public JdbcTemplate jdbcTemplate2()&#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource2()); return jdbcTemplate; &#125;&#125; 项目编译路径下可以创建一个jta.properties文件，用于对Atomikos的相关属性进行配置，不过也可以不加这个文件，因为所有的属性都有默认值。123456789101112131415161718192021com.atomikos.icatch.enable_logging=truecom.atomikos.icatch.force_shutdown_on_vm_exit=falsecom.atomikos.icatch.automatic_resource_registration=truecom.atomikos.icatch.checkpoint_interval=500com.atomikos.icatch.serial_jta_transactions=truecom.atomikos.icatch.default_jta_timeout=10000com.atomikos.icatch.max_timeout=300000com.atomikos.icatch.log_base_dir=./com.atomikos.icatch.threaded_2pc=falsecom.atomikos.icatch.max_actives=50com.atomikos.icatch.log_base_name=tmlogjava.naming.factory.initial=com.sun.jndi.rmi.registry.RegistryContextFactorycom.atomikos.icatch.client_demarcation=falsejava.naming.provider.url=rmi://localhost:1099com.atomikos.icatch.rmi_export_class=nonecom.atomikos.icatch.trust_client_tm=falsecom.atomikos.icatch.forget_orphaned_log_entries_delay=86400000com.atomikos.icatch.recovery_delay=$&#123;com.atomikos.icatch.default_jta_timeout&#125;com.atomikos.icatch.oltp_max_retries=5com.atomikos.icatch.oltp_retry_interval=10000com.atomikos.icatch.allow_subtransactions=true Spring Boot中Atomikos与Hibernate4多数据源集成方法Atomikos与Hibernate4集成方法与JDBC类似，我们在pom中加入hibernate的依赖，并对DataSourceConfig进行改造pom12345&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;4.3.5.Final&lt;/version&gt;&lt;/dependency&gt; DataSourceConfig123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183package com.example;import com.atomikos.icatch.jta.UserTransactionImp;import com.atomikos.icatch.jta.UserTransactionManager;import com.atomikos.jdbc.AtomikosDataSourceBean;import com.example.hibernate.CP_HibernateDAO;import com.example.hibernate.impl.CP_Hibernate4DAOImpl;import com.mysql.jdbc.jdbc2.optional.MysqlXADataSource;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.DependsOn;import org.springframework.orm.hibernate4.LocalSessionFactoryBean;import org.springframework.transaction.PlatformTransactionManager;import org.springframework.transaction.annotation.EnableTransactionManagement;import org.springframework.transaction.jta.JtaTransactionManager;import javax.sql.DataSource;import javax.transaction.TransactionManager;import javax.transaction.UserTransaction;import java.util.Properties;@Configuration@EnableTransactionManagement(proxyTargetClass = true)public class DataSourceConfig &#123; @Value("$&#123;spring.datasource.driver-class-name&#125;") String driverClass; @Value("$&#123;spring.datasource.url&#125;") String url; @Value("$&#123;spring.datasource.username&#125;") String userName; @Value("$&#123;spring.datasource.password&#125;") String passWord; @Value("$&#123;spring.datasource.driver-class-name2&#125;") String driverClass2; @Value("$&#123;spring.datasource.url2&#125;") String url2; @Value("$&#123;spring.datasource.username2&#125;") String userName2; @Value("$&#123;spring.datasource.password2&#125;") String passWord2; @Bean(name = "userTransaction") public UserTransaction userTransaction() throws Throwable &#123; UserTransactionImp userTransactionImp = new UserTransactionImp(); userTransactionImp.setTransactionTimeout(10000); return userTransactionImp; &#125; @Bean(name = "atomikosTransactionManager", initMethod = "init", destroyMethod = "close") public TransactionManager atomikosTransactionManager() throws Throwable &#123; UserTransactionManager userTransactionManager = new UserTransactionManager(); userTransactionManager.setForceShutdown(true); return userTransactionManager; &#125; @Bean(name = "transactionManager") @DependsOn(&#123; "userTransaction", "atomikosTransactionManager" &#125;) public PlatformTransactionManager transactionManager() throws Throwable &#123; System.out.println(); UserTransaction userTransaction = userTransaction(); TransactionManager atomikosTransactionManager = atomikosTransactionManager(); JtaTransactionManager jtaTransactionManager = new JtaTransactionManager(userTransaction, atomikosTransactionManager); jtaTransactionManager.setAllowCustomIsolationLevels(true); return jtaTransactionManager; &#125; @Bean(name = "dataSource", initMethod = "init", destroyMethod = "close") public DataSource dataSource() &#123; System.out.println(); MysqlXADataSource mysqlXaDataSource = new MysqlXADataSource(); mysqlXaDataSource.setUrl(url); mysqlXaDataSource.setPassword(passWord); mysqlXaDataSource.setUser(userName); mysqlXaDataSource.setPinGlobalTxToPhysicalConnection(true); AtomikosDataSourceBean xaDataSource = new AtomikosDataSourceBean(); xaDataSource.setXaDataSource(mysqlXaDataSource); xaDataSource.setUniqueResourceName("dataSource"); xaDataSource.setMinPoolSize(10); xaDataSource.setPoolSize(10); xaDataSource.setMaxPoolSize(30); xaDataSource.setBorrowConnectionTimeout(60); xaDataSource.setReapTimeout(20); xaDataSource.setMaxIdleTime(60); xaDataSource.setMaintenanceInterval(60); return xaDataSource; &#125; @Bean(name = "dataSource2", initMethod = "init", destroyMethod = "close") public DataSource dataSource2() &#123; System.out.println(); MysqlXADataSource mysqlXaDataSource = new MysqlXADataSource(); mysqlXaDataSource.setUrl(url2); mysqlXaDataSource.setPassword(passWord2); mysqlXaDataSource.setUser(userName2); mysqlXaDataSource.setPinGlobalTxToPhysicalConnection(true); AtomikosDataSourceBean xaDataSource = new AtomikosDataSourceBean(); xaDataSource.setXaDataSource(mysqlXaDataSource); xaDataSource.setUniqueResourceName("dataSource2"); xaDataSource.setMinPoolSize(10); xaDataSource.setPoolSize(10); xaDataSource.setMaxPoolSize(30); xaDataSource.setBorrowConnectionTimeout(60); xaDataSource.setReapTimeout(20); xaDataSource.setMaxIdleTime(60); xaDataSource.setMaintenanceInterval(60); return xaDataSource; &#125; @Bean(name = "sessionFactory") public LocalSessionFactoryBean localSessionFactoryBean() &#123; System.out.println("sessionFactory"); LocalSessionFactoryBean sessionFactory = new LocalSessionFactoryBean(); sessionFactory.setDataSource(dataSource()); //扫描实体对象的目录，不同的数据源，实体要存放不同的目录 String[] packagesToScan = new String[] &#123; "com.example.model.ds1" &#125;; sessionFactory.setPackagesToScan(packagesToScan); Properties hibernateProperties = new Properties(); hibernateProperties.setProperty("hibernate.dialect", "org.hibernate.dialect.MySQLDialect"); hibernateProperties.setProperty("hibernate.show_sql", "true"); //开启Hibernate对JTA的支持 hibernateProperties.setProperty("hibernate.current_session_context_class", "jta"); hibernateProperties.setProperty("hibernate.transaction.factory_class", "org.hibernate.transaction.JTATransactionFactory"); sessionFactory.setHibernateProperties(hibernateProperties); return sessionFactory; &#125; @Bean(name = "sessionFactory2") public LocalSessionFactoryBean localSessionFactoryBean2() &#123; System.out.println("sessionFactory2"); LocalSessionFactoryBean sessionFactory = new LocalSessionFactoryBean(); sessionFactory.setDataSource(dataSource2()); //扫描实体对象的目录，不同的数据源，实体要存放不同的目录 String[] packagesToScan = new String[] &#123; "com.example.model.ds2" &#125;; sessionFactory.setPackagesToScan(packagesToScan); Properties hibernateProperties = new Properties(); hibernateProperties.setProperty("hibernate.dialect", "org.hibernate.dialect.MySQLDialect"); hibernateProperties.setProperty("hibernate.show_sql", "true"); //开启Hibernate对JTA的支持 hibernateProperties.setProperty("hibernate.current_session_context_class", "jta"); hibernateProperties.setProperty("hibernate.transaction.factory_class", "org.hibernate.transaction.JTATransactionFactory"); sessionFactory.setHibernateProperties(hibernateProperties); return sessionFactory; &#125; @Bean(name = "hibernateDAO") public CP_HibernateDAO hibernate4Dao() &#123; System.out.println("hibernateDAO"); CP_Hibernate4DAOImpl dao = new CP_Hibernate4DAOImpl(); //绑定SessionFactory dao.setSessionFactory(localSessionFactoryBean().getObject()); return dao; &#125; @Bean(name = "hibernateDAO2") public CP_HibernateDAO hibernate4Dao2() &#123; System.out.println("hibernateDAO2"); CP_Hibernate4DAOImpl dao = new CP_Hibernate4DAOImpl(); //绑定SessionFactory2 dao.setSessionFactory(localSessionFactoryBean2().getObject()); return dao; &#125;&#125; 123456789101112131415@Entity@Table(name = "person")public class Person implements Serializable &#123; private static final long serialVersionUID = -1L; @Id @GeneratedValue(strategy = GenerationType.AUTO) @Column(name = "p_id") private Long id; @Column(name = "p_name") private String name; @Column(name = "p_age") private Integer age; //setter and getter&#125; CP_HibernateDAO是我们自定义的Hibernate的通用Dao接口，其定义的方法和和实现类CP_Hibernate4DAOImpl代码如下：1234567891011package com.example.hibernate;import java.util.List;public interface CP_HibernateDAO &#123; public List&lt;?&gt; findAll(Class&lt;?&gt; entityClazz, String... str); public void save(Object entity);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.example.hibernate.impl;import com.example.hibernate.CP_HibernateDAO;import org.hibernate.Criteria;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.criterion.DetachedCriteria;import java.util.List;public class CP_Hibernate4DAOImpl implements CP_HibernateDAO &#123; private SessionFactory sessionFactory; public SessionFactory getSessionFactory() &#123; return sessionFactory; &#125; //绑定SessionFactory public void setSessionFactory(SessionFactory sessionFactory) &#123; this.sessionFactory = sessionFactory; &#125; private Session getHibernateSession() &#123; Session session = sessionFactory.openSession(); return session; &#125; /* * @see com.example.hibernate.CP_HibernateDAO#findAll() */ @Override public List&lt;?&gt; findAll(Class&lt;?&gt; entityClazz, String... str) &#123; DetachedCriteria dc = DetachedCriteria.forClass(entityClazz); List&lt;?&gt; list = findAllByCriteria(dc); return list; &#125; /* * @see com.example.hibernate.CP_HibernateDAO#save(java.lang.Object) */ @Override public void save(Object entity) &#123; getHibernateSession().save(entity); //注意这里一定要执行flush方法 getHibernateSession().flush(); &#125; public List&lt;?&gt; findAllByCriteria(DetachedCriteria detachedCriteria) &#123; // TODO Auto-generated method stub Criteria criteria = detachedCriteria .getExecutableCriteria(getHibernateSession()); return criteria.list(); &#125;&#125; 说明需要注意两点： session必须使用sessionFactory.openSession()的方式获得，不能使用sessionFactory.getCurrentSession()。 更新操作必须调用session.flush()方法。 Spring配置文件的方式，可以参考：Spring4+Hibernate4+Atomikos3.3多数据源事务管理 Spring Boot中Mybitas的使用创建项目时，我们可以选择mybatis-spring-boot-starter依赖，这样可以激活SpringBoot对Mybatis的自动配置类。 pom中添加依赖12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt; application.properties中添加mybaits的自动配置属性，可以查看MybatisProperties了解可以配置哪些属性12#mapper配置文件路径，如果是基于注解的形式可以不需要配置该属性mybatis.mapper-locations=classpath:mapper/*.xml Mapper接口上要配置@Mapper注解，因为mybatis-spring-boot-starter的自动配置会扫描@Mapper注解来注册Mapper接口。1234@Mapperpublic interface PersonMapper &#123; //………………&#125; 此时同样可以使用@Transactional注解 说明可以使用maven的mybatis-generator插件自动生成代码，参考maven插件–MyBatis自动生成代码 mybatis-spring-boot-starter不利于扩展，所以还是我们自己实现个mybitas的配置类吧。 pom中去掉mybatis-spring-boot-starter的依赖，增加mybatis的依赖1234567891011121314151617181920212223&lt;!--&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt;--&gt;&lt;!--Mybatis--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.3.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; 创建MyBatisConfig12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Configuration@EnableTransactionManagement(proxyTargetClass = true)public class MyBatisConfig &#123; @Value("$&#123;spring.datasource.driver-class-name&#125;") String driverClass; @Value("$&#123;spring.datasource.url&#125;") String url; @Value("$&#123;spring.datasource.username&#125;") String userName; @Value("$&#123;spring.datasource.password&#125;") String passWord; @Bean(name = "dataSource") public DataSource dataSource() &#123; DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(driverClass); dataSource.setUrl(url); dataSource.setUsername(userName); dataSource.setPassword(passWord); return dataSource; &#125; @Bean(name = "sqlSessionFactory") public SqlSessionFactory sqlSessionFactoryBean() &#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dataSource()); //添加XML目录 ResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(); try &#123; bean.setMapperLocations(resolver.getResources("classpath:mapper/*.xml")); return bean.getObject(); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; &#125; @Bean public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) &#123; return new SqlSessionTemplate(sqlSessionFactory); &#125; @Bean public PlatformTransactionManager annotationDrivenTransactionManager() &#123; return new DataSourceTransactionManager(dataSource()); &#125;&#125; MyBatisMapperScannerConfig，基于包扫描Mapper，此时不需要配置@Mapper注解123456789101112@Configuration//必须在MyBatisConfig注册后再加载MapperScannerConfigurer，否则会报错@AutoConfigureAfter(MyBatisConfig.class)public class MyBatisMapperScannerConfig &#123; @Bean public MapperScannerConfigurer mapperScannerConfigurer() &#123; MapperScannerConfigurer mapperScannerConfigurer = new MapperScannerConfigurer(); mapperScannerConfigurer.setSqlSessionFactoryBeanName("sqlSessionFactory"); mapperScannerConfigurer.setBasePackage("com.example.mapper"); return mapperScannerConfigurer; &#125;&#125; 关闭DataSourceAutoConfiguration，因为这里我们配置了数据源，所以需要关闭该自动配置，另外，MybatisAutoConfiguration也是基于DataSourceAutoConfiguration的，所以关闭了DataSourceAutoConfiguration也就同时关闭了MybatisAutoConfiguration。 Spring Boot中Atomikos与Mybatis多数据源集成方法pom1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.3.4.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--Mybatis--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.atomikos&lt;/groupId&gt; &lt;artifactId&gt;transactions-jdbc&lt;/artifactId&gt; &lt;version&gt;4.0.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.atomikos&lt;/groupId&gt; &lt;artifactId&gt;transactions-jta&lt;/artifactId&gt; &lt;version&gt;4.0.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.atomikos&lt;/groupId&gt; &lt;artifactId&gt;transactions&lt;/artifactId&gt; &lt;version&gt;4.0.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.atomikos&lt;/groupId&gt; &lt;artifactId&gt;atomikos-util&lt;/artifactId&gt; &lt;version&gt;4.0.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.transaction&lt;/groupId&gt; &lt;artifactId&gt;jta&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.37&lt;/version&gt;&lt;/dependency&gt; MyBatisConfig123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134@Configuration@EnableTransactionManagement(proxyTargetClass = true)public class MyBatisConfig &#123; @Value("$&#123;spring.datasource.driver-class-name&#125;") String driverClass; @Value("$&#123;spring.datasource.url&#125;") String url; @Value("$&#123;spring.datasource.username&#125;") String userName; @Value("$&#123;spring.datasource.password&#125;") String passWord; @Value("$&#123;spring.datasource.driver-class-name2&#125;") String driverClass2; @Value("$&#123;spring.datasource.url2&#125;") String url2; @Value("$&#123;spring.datasource.username2&#125;") String userName2; @Value("$&#123;spring.datasource.password2&#125;") String passWord2; @Bean(name = "userTransaction") public UserTransaction userTransaction() throws Throwable &#123; UserTransactionImp userTransactionImp = new UserTransactionImp(); userTransactionImp.setTransactionTimeout(10000); return userTransactionImp; &#125; @Bean(name = "atomikosTransactionManager", initMethod = "init", destroyMethod = "close") public TransactionManager atomikosTransactionManager() throws Throwable &#123; UserTransactionManager userTransactionManager = new UserTransactionManager(); userTransactionManager.setForceShutdown(true); return userTransactionManager; &#125; @Bean(name = "transactionManager") @DependsOn(&#123; "userTransaction", "atomikosTransactionManager" &#125;) public PlatformTransactionManager transactionManager() throws Throwable &#123; UserTransaction userTransaction = userTransaction(); TransactionManager atomikosTransactionManager = atomikosTransactionManager(); JtaTransactionManager jtaTransactionManager = new JtaTransactionManager(userTransaction, atomikosTransactionManager); jtaTransactionManager.setAllowCustomIsolationLevels(true); return jtaTransactionManager; &#125; @Bean(name = "dataSource", initMethod = "init", destroyMethod = "close") public DataSource dataSource() &#123; System.out.println("dataSource init"); MysqlXADataSource mysqlXaDataSource = new MysqlXADataSource(); mysqlXaDataSource.setUrl(url); mysqlXaDataSource.setPassword(passWord); mysqlXaDataSource.setUser(userName); mysqlXaDataSource.setPinGlobalTxToPhysicalConnection(true); AtomikosDataSourceBean xaDataSource = new AtomikosDataSourceBean(); xaDataSource.setXaDataSource(mysqlXaDataSource); xaDataSource.setUniqueResourceName("dataSource"); xaDataSource.setMinPoolSize(10); xaDataSource.setPoolSize(10); xaDataSource.setMaxPoolSize(30); xaDataSource.setBorrowConnectionTimeout(60); xaDataSource.setReapTimeout(20); xaDataSource.setMaxIdleTime(60); xaDataSource.setMaintenanceInterval(60); return xaDataSource; &#125; @Bean(name = "dataSource2", initMethod = "init", destroyMethod = "close") public DataSource dataSource2() &#123; System.out.println("dataSource2 init"); MysqlXADataSource mysqlXaDataSource = new MysqlXADataSource(); mysqlXaDataSource.setUrl(url2); mysqlXaDataSource.setPassword(passWord2); mysqlXaDataSource.setUser(userName2); mysqlXaDataSource.setPinGlobalTxToPhysicalConnection(true); AtomikosDataSourceBean xaDataSource = new AtomikosDataSourceBean(); xaDataSource.setXaDataSource(mysqlXaDataSource); xaDataSource.setUniqueResourceName("dataSource2"); xaDataSource.setMinPoolSize(10); xaDataSource.setPoolSize(10); xaDataSource.setMaxPoolSize(30); xaDataSource.setBorrowConnectionTimeout(60); xaDataSource.setReapTimeout(20); xaDataSource.setMaxIdleTime(60); xaDataSource.setMaintenanceInterval(60); return xaDataSource; &#125; //基于xml式Mapper @Bean(name = "sqlSessionFactory") public SqlSessionFactory sqlSessionFactoryBean() &#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dataSource()); //添加Mapper配置文件的目录 ResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(); try &#123; bean.setMapperLocations(resolver.getResources("classpath:mapper/ds1/*.xml")); return bean.getObject(); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; &#125; @Bean(name = "sqlSessionTemplate") public SqlSessionTemplate sqlSessionTemplate() &#123; return new SqlSessionTemplate(sqlSessionFactoryBean()); &#125; //基于注解式Mapper @Bean(name = "sqlSessionFactory2") public SqlSessionFactory sqlSessionFactoryBean2() &#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dataSource2()); try &#123; return bean.getObject(); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; &#125; @Bean(name = "sqlSessionTemplate2") public SqlSessionTemplate sqlSessionTemplate2() &#123; return new SqlSessionTemplate(sqlSessionFactoryBean2()); &#125;&#125; MyBatisMapperScannerConfig123456789101112131415161718192021222324@Configuration//必须在MyBatisConfig注册后再加载MapperScannerConfigurer，否则会报错@AutoConfigureAfter(MyBatisConfig.class)public class MyBatisMapperScannerConfig &#123; @Bean public MapperScannerConfigurer mapperScannerConfigurer() &#123; MapperScannerConfigurer mapperScannerConfigurer = new MapperScannerConfigurer(); //绑定datasorce的sqlSessionFactory mapperScannerConfigurer.setSqlSessionFactoryBeanName("sqlSessionFactory"); //扫描ds1目录来注册Mapper接口 mapperScannerConfigurer.setBasePackage("com.example.mapper.ds1"); return mapperScannerConfigurer; &#125; @Bean public MapperScannerConfigurer mapperScannerConfigurer2() &#123; MapperScannerConfigurer mapperScannerConfigurer = new MapperScannerConfigurer(); //绑定datasorce2的sqlSessionFactory mapperScannerConfigurer.setSqlSessionFactoryBeanName("sqlSessionFactory2"); //扫描ds2目录来注册Mapper接口 mapperScannerConfigurer.setBasePackage("com.example.mapper.ds2"); return mapperScannerConfigurer; &#125;&#125; 这里要说明的是，如果两个数据源下的Mapper起了相同的类名，虽然他们在不同的包路径下，启动也会报错了，因为默认注册Mapper时使用的是类名称（不含包名），此时可以在Mapper上加上@Component(“personMapper”)注解 写在后面的话Spring Boot为我们提供了大量的spring-boot-starter-xxx来加快我们的开发流程，创建项目时就可以看到可供选择的各种spring-boot-starter-xxx，那么这么多的spring-boot-starter-xxx，我们是否都需要了解呢，如果项目中需要用到某一个功能，是否就应该加入这个spring-boot-starter-xxx呢？ 笔者人为，spring-boot-starter-xxx提供的完整jar包依赖和自动配置固然很好，但是当我们要在项目中加入某一个功能时，作为开发人员，是应该清楚的知道该功能的依赖关系和配置逻辑的，所以并不一定需要引入SpringBoot的spring-boot-starter-xxx，而且SpringBoot对这些spring-boot-starter-xxx做的自动配置，如果我们并不熟悉和十分清楚，往往会给我们开发人员造成不明所以的困扰，所以，笔者建议，在对SpringBoot提供的某一个spring-boot-starter-xxx所提供的功能并不十分清楚时，还是使用配置类的方式吧。 还有，由于某些自动配置类的激活是根据项目中是否包含某个class或容器中是否注册了某个bean，所以笔者建议，如果项目中引入了新的jar包，或者手工注册了某个bean，都要通过debug的方式查看是否开启了某个自动配置。 另外，本文代码只是为了辅助说明，比如DriverManagerDataSource正式环境不建议使用，请更换为其它数据源，比如BasicDataSource。 本文示例代码下载地址：https://github.com/hanqunfeng/SpringBootStudy]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot学习笔记03--深入了解SpringBoot的启动过程]]></title>
    <url>%2F2016%2F12%2F13%2Fspring-boot-study-springapplication%2F</url>
    <content type="text"><![CDATA[摘要看完本文你将掌握如下知识点： SpringApplication的作用及运行过程 SpringBootServletInitializer的作用及运行过程 PS:本节内容略显枯燥，如果对SpringBoot的启动过程不感兴趣，可以略过。 SpringBoot系列：Spring Boot学习笔记 深入了解SpringApplication123456@SpringBootApplicationpublic class SpringBootWebDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootWebDemoApplication.class, args); &#125;&#125; 这就是SpringBoot的启动入口，通过前面的学习我们大体上了解了@SpringBootApplication的作用，接下来我们来认识一下SpringApplication。SpringApplication (Spring Boot Docs 1.4.2.RELEASE API)。 SpringApplication.run(SpringBootWebDemoApplication.class, args);通过源码我们来看一下SpringApplication.run()方法的执行过程1.调用static方法1234//1public static ConfigurableApplicationContext run(Object source, String... args) &#123;return run(new Object[]&#123;source&#125;, args);&#125;public static ConfigurableApplicationContext run(Object[] sources, String[] args) &#123;return (new SpringApplication(sources)).run(args);&#125; 2.创建SpringApplication对象12345678910//2public SpringApplication(Object... sources) &#123; this.bannerMode = Mode.CONSOLE; //banner的打印模式，此时是控制台模式 this.logStartupInfo = true; //开启日志 this.addCommandLineProperties = true;//启用CommandLineProperties this.headless = true;//开启headless模式支持 this.registerShutdownHook = true;//启用注册ShutdownHook，用于在非Web应用中关闭IoC容器和资源 this.additionalProfiles = new HashSet(); this.initialize(sources);//初始化 &#125; PS：Headless参考资料：在 Java SE 平台上使用 Headless 模式 3.初始化相关对象和属性1234567891011121314//3private void initialize(Object[] sources) &#123; if(sources != null &amp;&amp; sources.length &gt; 0) &#123; this.sources.addAll(Arrays.asList(sources)); &#125; //3.1判断是否是web运行环境，如果classpath中是否含有**WEB_ENVIRONMENT_CLASSES**指定的全部类，则返回true this.webEnvironment = this.deduceWebEnvironment(); //3.2找到*META-INF/spring.factories*中声明的所有ApplicationContextInitializer的实现类并将其实例化 this.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class)); //3.3找到*META-INF/spring.factories*中声明的所有ApplicationListener的实现类并将其实例化 this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class)); //3.4获得当前执行main方法的类对象，这里就是SpringBootWebDemoApplication的实例 this.mainApplicationClass = this.deduceMainApplicationClass(); &#125; 3.1 判断是否是web运行环境如果classpath中是否含有WEB_ENVIRONMENT_CLASSES指定的全部类，则返回true，用于创建指定类型的ApplicationContext对象。12//3.1private static final String[] WEB_ENVIRONMENT_CLASSES = new String[]&#123;"javax.servlet.Servlet", "org.springframework.web.context.ConfigurableWebApplicationContext"&#125;; 3.2 大体的过程就是通过SpringFactoriesLoader检索META-INF/spring.factories，找到声明的所有ApplicationContextInitializer的实现类并将其实例化。ApplicationContextInitializer是Spring框架中的接口，其作用可以理解为在ApplicationContext执行refresh之前，调用ApplicationContextInitializer的initialize()方法，对ApplicationContext做进一步的设置和处理。123public interface ApplicationContextInitializer&lt;C extends ConfigurableApplicationContext&gt; &#123; void initialize(C var1);&#125; spring-boot-1.4.2.RELEASE.jar中的META-INF/spring.factories包含的ApplicationContextInitializer123456# Application Context Initializersorg.springframework.context.ApplicationContextInitializer=\org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\org.springframework.boot.context.ContextIdApplicationContextInitializer,\org.springframework.boot.context.config.DelegatingApplicationContextInitializer,\org.springframework.boot.context.web.ServerPortInfoApplicationContextInitializer spring-boot-autoconfigure-1.4.2.RELEASE.jar中的META-INF/spring.factories包含的ApplicationContextInitializer1234# Initializersorg.springframework.context.ApplicationContextInitializer=\org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\org.springframework.boot.autoconfigure.logging.AutoConfigurationReportLoggingInitializer 3.3 大体的过程就是通过SpringFactoriesLoader检索META-INF/spring.factories，找到声明的所有ApplicationListener的实现类并将其实例化。ApplicationListener是Spring框架中的接口，就是事件监听器，其作用可以理解为在SpringApplicationRunListener发布通知事件时，由ApplicationListener负责接收。123public interface ApplicationListener&lt;E extends ApplicationEvent&gt; extends EventListener &#123; void onApplicationEvent(E var1);&#125; SpringBoot只提供了一个SpringApplicationRunListener的实现类，就是EventPublishingRunListener，起作用就是在SpringBoot启动过程中，负责注册ApplicationListener监听器，在不同的时点发布不同的事件类型，如果有哪些ApplicationListener的实现类监听了这些事件，则可以接收并处理。123456789101112public interface SpringApplicationRunListener &#123; //通知监听器，SpringBoot开始执行 void started(); //通知监听器，Environment准备完成 void environmentPrepared(ConfigurableEnvironment var1); //通知监听器，ApplicationContext已经创建并初始化完成 void contextPrepared(ConfigurableApplicationContext var1); //通知监听器，ApplicationContext已经完成IoC配置加载 void contextLoaded(ConfigurableApplicationContext var1); //通知监听器，SpringBoot启动完成 void finished(ConfigurableApplicationContext var1, Throwable var2);&#125; spring-boot-1.4.2.RELEASE.jar中的META-INF/spring.factories包含的ApplicationListener1234567891011# Application Listenersorg.springframework.context.ApplicationListener=\org.springframework.boot.ClearCachesApplicationListener,\org.springframework.boot.builder.ParentContextCloserApplicationListener,\org.springframework.boot.context.FileEncodingApplicationListener,\org.springframework.boot.context.config.AnsiOutputApplicationListener,\org.springframework.boot.context.config.ConfigFileApplicationListener,\org.springframework.boot.context.config.DelegatingApplicationListener,\org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener,\org.springframework.boot.logging.ClasspathLoggingApplicationListener,\org.springframework.boot.logging.LoggingApplicationListener spring-boot-autoconfigure-1.4.2.RELEASE.jar中的META-INF/spring.factories包含的ApplicationListener123# Application Listenersorg.springframework.context.ApplicationListener=\org.springframework.boot.autoconfigure.BackgroundPreinitializer spring-boot-1.4.2.RELEASE.jar中的META-INF/spring.factories包含的SpringApplicationRunListener123# Run Listenersorg.springframework.boot.SpringApplicationRunListener=\org.springframework.boot.context.event.EventPublishingRunListener 3.4 获得当前执行main方法的类对象，这里就是SpringBootWebDemoApplication的实例。 4.核心方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//4public ConfigurableApplicationContext run(String... args) &#123; //开启任务执行时间监听器 StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; Object analyzers = null; //设置系统属性『java.awt.headless』，为true则启用headless模式支持 this.configureHeadlessProperty(); //通过*SpringFactoriesLoader*检索*META-INF/spring.factories*， //找到声明的所有SpringApplicationRunListener的实现类并将其实例化， //之后逐个调用其started()方法，广播SpringBoot要开始执行了。 SpringApplicationRunListeners listeners = this.getRunListeners(args); listeners.started(); try &#123; DefaultApplicationArguments ex = new DefaultApplicationArguments(args); //创建并配置当前SpringBoot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）, //并遍历调用所有的SpringApplicationRunListener的environmentPrepared()方法，广播Environment准备完毕。 ConfigurableEnvironment environment = this.prepareEnvironment(listeners, ex); //决定是否打印Banner Banner printedBanner = this.printBanner(environment); //根据webEnvironment的值来决定创建何种类型的ApplicationContext对象 //如果是web环境，则创建org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext //否则创建org.springframework.context.annotation.AnnotationConfigApplicationContext context = this.createApplicationContext(); //注册异常分析器 new FailureAnalyzers(context); //为ApplicationContext加载environment，之后逐个执行ApplicationContextInitializer的initialize()方法来进一步封装ApplicationContext， //并调用所有的SpringApplicationRunListener的contextPrepared()方法，【EventPublishingRunListener只提供了一个空的contextPrepared()方法】， //之后初始化IoC容器，并调用SpringApplicationRunListener的contextLoaded()方法，广播ApplicationContext的IoC加载完成， //这里就包括通过**@EnableAutoConfiguration**导入的各种自动配置类。 this.prepareContext(context, environment, listeners, ex, printedBanner); //初始化所有自动配置类，调用ApplicationContext的refresh()方法 this.refreshContext(context); //遍历所有注册的ApplicationRunner和CommandLineRunner，并执行其run()方法。 //该过程可以理解为是SpringBoot完成ApplicationContext初始化前的最后一步工作， //我们可以实现自己的ApplicationRunner或者CommandLineRunner，来对SpringBoot的启动过程进行扩展。 this.afterRefresh(context, ex); //调用所有的SpringApplicationRunListener的finished()方法，广播SpringBoot已经完成了ApplicationContext初始化的全部过程。 listeners.finished(context, (Throwable)null); //关闭任务执行时间监听器 stopWatch.stop(); //如果开启日志，则答应执行是时间 if(this.logStartupInfo) &#123; (new StartupInfoLogger(this.mainApplicationClass)).logStarted(this.getApplicationLog(), stopWatch); &#125; return context; &#125; catch (Throwable var9) &#123; //调用异常分析器打印报告，调用所有的SpringApplicationRunListener的finished()方法将异常信息发布出去 this.handleRunFailure(context, listeners, (FailureAnalyzers)analyzers, var9); throw new IllegalStateException(var9); &#125; &#125; spring-boot-1.4.2.RELEASE.jar中的META-INF/spring.factories包含的FailureAnalyzer和FailureAnalysisReporters12345678910111213# Failure Analyzersorg.springframework.boot.diagnostics.FailureAnalyzer=\org.springframework.boot.diagnostics.analyzer.BeanCurrentlyInCreationFailureAnalyzer,\org.springframework.boot.diagnostics.analyzer.BeanNotOfRequiredTypeFailureAnalyzer,\org.springframework.boot.diagnostics.analyzer.BindFailureAnalyzer,\org.springframework.boot.diagnostics.analyzer.ConnectorStartFailureAnalyzer,\org.springframework.boot.diagnostics.analyzer.NoUniqueBeanDefinitionFailureAnalyzer,\org.springframework.boot.diagnostics.analyzer.PortInUseFailureAnalyzer,\org.springframework.boot.diagnostics.analyzer.ValidationExceptionFailureAnalyzer# FailureAnalysisReportersorg.springframework.boot.diagnostics.FailureAnalysisReporter=\org.springframework.boot.diagnostics.LoggingFailureAnalysisReporter 说明 SpringBoot的启动过程，实际上就是对ApplicationContext的初始化过程。 ApplicationContext创建后立刻为其设置Environmen，并由ApplicationContextInitializer对其进一步封装。 通过SpringApplicationRunListener在ApplicationContext初始化过程中各个时点发布各种广播事件，并由ApplicationListener负责接收广播事件。 初始化过程中完成IoC的注入，包括通过@EnableAutoConfiguration导入的各种自动配置类。 初始化完成前调用ApplicationRunner和CommandLineRunner的实现类。 扩展SpringApplication通过上面的学习，我们基本上了解了，如果要对SpringApplication进行扩展，我们可以选择如下三种方案： 创建ApplicationContextInitializer的实现类 创建ApplicationListener的实现类 创建ApplicationRunner和CommandLineRunner的实现类 1.可以通过如下方式加载自定义的ApplicationContextInitializer和ApplicationListener12345678910111213@SpringBootApplicationpublic class SpringBootWebDemoApplication &#123; public static void main(String[] args) &#123; //SpringApplication.run(SpringBootWebDemoApplication.class, args); SpringApplication springApplication = new SpringApplication(SpringBootWebDemoApplication.class); springApplication.addInitializers(MyApplicationContextInitializer1,MyApplicationContextInitializer2); springApplication.addListeners(MyApplicationListener1,MyApplicationListener2); springApplication.run(args); &#125;&#125; 2.也可以在当前项目的类路径下创建META-INF/spring.factories文件，并声明相应的ApplicationContextInitializer和ApplicationListener12345678org.springframework.context.ApplicationContextInitializer=\xxx.xxx.MyApplicationContextInitializer1,\xxx.xxx.MyApplicationContextInitializer2# Application Listenersorg.springframework.context.ApplicationListener=\xxx.xxx.MyApplicationListener1,\xxx.xxx.MyApplicationListener2 3.至于ApplicationRunner和CommandLineRunner，只需要在其实现类上加上@Component注解或者在@Configuration配置类中通过@Bean注解注入。 深入了解SpringBootServletInitializer熟悉了SpringApplication的原理之后，我们再来了解SpringBootServletInitializer的原理就比较容易了。1234567public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; return application.sources(DemoWarApplication.class); &#125;&#125; SpringBootServletInitializer就是一个org.springframework.web.context.WebApplicationContext，容器启动时会调用其onStartup(ServletContext servletContext)方法，接下来我么就来看一下这个方法:12345678910111213public void onStartup(ServletContext servletContext) throws ServletException &#123; this.logger = LogFactory.getLog(this.getClass()); final WebApplicationContext rootAppContext = this.createRootApplicationContext(servletContext); if(rootAppContext != null) &#123; servletContext.addListener(new ContextLoaderListener(rootAppContext) &#123; public void contextInitialized(ServletContextEvent event) &#123; &#125; &#125;); &#125; else &#123; this.logger.debug("No ContextLoaderListener registered, as createRootApplicationContext() did not return an application context"); &#125; &#125; 这里的核心方法就是createRootApplicationContext(servletContext)：123456789101112131415161718192021222324252627282930313233343536protected WebApplicationContext createRootApplicationContext(ServletContext servletContext) &#123; //创建SpringApplicationBuilder，并用其生产出SpringApplication对象 SpringApplicationBuilder builder = this.createSpringApplicationBuilder(); builder.main(this.getClass()); ApplicationContext parent = this.getExistingRootWebApplicationContext(servletContext); if(parent != null) &#123; this.logger.info("Root context already created (using as parent)."); servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, (Object)null); builder.initializers(new ApplicationContextInitializer[]&#123;new ParentContextApplicationContextInitializer(parent)&#125;); &#125; //初始化并封装SpringApplicationBuilder对象，为SpringApplication对象增加ApplicationContextInitializer和ApplicationListener做准备 builder.initializers(new ApplicationContextInitializer[]&#123;new ServletContextApplicationContextInitializer(servletContext)&#125;); builder.listeners(new ApplicationListener[]&#123;new ServletContextApplicationListener(servletContext)&#125;); //指定创建的ApplicationContext类型 builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class); //传递入口类，并构建SpringApplication对象 //可以通过configure()方法对SpringBootServletInitializer进行扩展 builder = this.configure(builder); SpringApplication application = builder.build(); if(application.getSources().isEmpty() &amp;&amp; AnnotationUtils.findAnnotation(this.getClass(), Configuration.class) != null) &#123; application.getSources().add(this.getClass()); &#125; Assert.state(!application.getSources().isEmpty(), "No SpringApplication sources have been defined. Either override the configure method or add an @Configuration annotation"); if(this.registerErrorPageFilter) &#123; application.getSources().add(ErrorPageFilter.class); &#125; //最后调用SpringApplication的run方法 return this.run(application); &#125; 说明SpringBootServletInitializer的执行过程，简单来说就是通过SpringApplicationBuilder构建并封装SpringApplication对象，并最终调用SpringApplication的run方法的过程。 扩展SpringBootServletInitializer与扩展SpringApplication类似，ApplicationContextInitializer和ApplicationListener可以基于SpringApplicationBuilder提供的public方法进行扩展12345678910public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; application.initializers(MyApplicationContextInitializer1,MyApplicationContextInitializer2); application.listeners(MyApplicationListener1,MyApplicationListener2) return application.sources(DemoWarApplication.class); &#125;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot学习笔记02--深入了解自动配置]]></title>
    <url>%2F2016%2F12%2F10%2Fspring-boot-study-web%2F</url>
    <content type="text"><![CDATA[摘要看完本文你将掌握如下知识点： SpringBoot都帮我们做了哪些自动配置 我们如何接管SpringBoot的自动配置 注册Servlet、Filter、Listener的方法 SpringBoot系列：Spring Boot学习笔记 SpringBoot的自动配置1.自动配置类都存放在spring-boot-autoconfigure-1.4.2.RELEASE.jar下的org.springframework.boot.autoconfigure路径下；2.application.properties中配置debug=true后启动容器，可以看到服务器初始化的自动配置如下: DispatcherServletAutoConfiguration注册org.springframework.web.servlet.DispatcherServlet EmbeddedServletContainerAutoConfiguration注册容器类型，如类路径下存在org.apache.catalina.startup.Tomcat，就会注册Tomcat容器 ErrorMvcAutoConfiguration注册异常处理器 HttpEncodingAutoConfiguration注册http编码过滤器 HttpMessageConvertersAutoConfiguration注册json或者xml处理器 JacksonAutoConfiguration注册json对象解析器 JmxAutoConfiguration注册JMX管理器 JMX与Spring集成spring通过annotation注解注册MBean到JMX实现监控java运行状态 MultipartAutoConfiguration注册文件传输处理器 ServerPropertiesAutoConfiguration用于初始化容器相关的配置属性，如服务地址、端口、contextPath，并根据当前容器类型初始化各个容器的特有属性，如tomcat的maxThreads、uriEncoding等等，其对应的属性类为ServerProperties； WebClientAutoConfiguration注册RestTemplate WebMvcAutoConfiguration注册SpringMvc相关处理器，如ResourceResolver、RequestMappingHandlerAdapter、ExceptionHandlerExceptionResolver、ViewResolver、LocaleResolver，等等 WebSocketAutoConfiguration注册webSocket相关处理器，根据容器类型注册不同的处理器 3.如果依赖中加入了其它功能的依赖，SpringBoot还会实现这些功能的自动适配，比如我们增加数据库的JPA的功能，就会启用对JpaRepositoriesAutoConfiguration的自动配置功能。关于数据库方面的内容将在后文介绍。1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; 说明从各个AutoConfiguration配置类中可以看到如下注解，基于这些注解可以确定这些AutoConfiguration的初始化顺序： @AutoConfigureOrder(-2147483648)：数越小越先初始化 @AutoConfigureAfter({EmbeddedServletContainerAutoConfiguration.class})：在指定的配置类初始化后再加载 @AutoConfigureBefore({WebMvcAutoConfiguration.class})：在指定的配置类初始化前加载 接管SpringBoot的自动配置我们介绍过@SpringBootApplication这个注解，因其包含@EnableAutoConfiguration和@ComponentScan注解，可以自动扫描相关的自动配置类，从而实现自动配置功能的。上面介绍默认情况下SpringBoot默认会初始化很多的自动配置，这些配置有些我们在项目中可能用不到，那要如何去掉呢？ 去掉不需要的自动配置类比如我们不需要开启webSocket和JMX的自动配置，我们需要在@SpringBootApplication这个注解中指定exclude属性123456@SpringBootApplication(exclude = &#123;WebSocketAutoConfiguration.class,JmxAutoConfiguration.class&#125;)public class SpringBootWebDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootWebDemoApplication.class, args); &#125;&#125; 明确指定需要启用哪些自动配置我们可以去掉@SpringBootApplication注解，改用@Configuration、@Import、@ComponentScan注解，在@Import注解中明确指定需要启用哪些自动配置1234567891011121314151617181920//@SpringBootApplication(exclude = &#123;WebSocketAutoConfiguration.class,JmxAutoConfiguration.class&#125;)@Configuration@Import(&#123; DispatcherServletAutoConfiguration.class, EmbeddedServletContainerAutoConfiguration.class, ErrorMvcAutoConfiguration.class, HttpEncodingAutoConfiguration.class, HttpMessageConvertersAutoConfiguration.class, JacksonAutoConfiguration.class, MultipartAutoConfiguration.class, ServerPropertiesAutoConfiguration.class, WebMvcAutoConfiguration.class&#125;)@ComponentScanpublic class SpringBootWebDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootWebDemoApplication.class, args); &#125;&#125; 说明： 这里推荐使用第一种方式：@SpringBootApplication(exclude={})； 实际上，开启默认的自动配置功能，只是会影响项目启动时间，所以没有特殊需要，可以不需要关闭某个自动配置功能； 在某些情况，比如项目需要多数据源时，在项目中就会包含多个DataSource的Bean，因为DataSourceAutoConfiguration自动配置只能绑定一个数据源，此时发现多个DataSource的Bean被Spring注册就会抛出异常。 1.这时就可以采用去掉DataSourceAutoConfiguration的方式;2.或者也可以在某一个DataSource的Bean上声明@Primary注解，指定其为主数据源，这时DataSourceAutoConfiguration只会加载被指定@Primary注解的主数据源，这样就可以享受到SpringBoot自动配置带来的好处。 接管WebMvc自动配置对于一个web项目，最重要的就是Mvc相关的控制，SpringBoot通过WebMvcAutoConfiguration来完成与Mvc有关的自动配置。如果希望完全接管WebMvc自动配置，可以在项目中创建一个注解了@EnableWebMvc的配置类，比如：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169package com.example;import org.apache.log4j.Logger;import org.springframework.context.MessageSource;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.FilterType;import org.springframework.context.support.ResourceBundleMessageSource;import org.springframework.stereotype.Controller;import org.springframework.web.multipart.commons.CommonsMultipartResolver;import org.springframework.web.servlet.HandlerAdapter;import org.springframework.web.servlet.HandlerMapping;import org.springframework.web.servlet.ViewResolver;import org.springframework.web.servlet.config.annotation.EnableWebMvc;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;import org.springframework.web.servlet.handler.SimpleMappingExceptionResolver;import org.springframework.web.servlet.handler.SimpleServletHandlerAdapter;import org.springframework.web.servlet.i18n.CookieLocaleResolver;import org.springframework.web.servlet.i18n.LocaleChangeInterceptor;import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter;import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;import org.springframework.web.servlet.view.InternalResourceViewResolver;import java.util.Properties;@Configuration@EnableWebMvc@ComponentScan(basePackages = "com.example", useDefaultFilters = false, includeFilters = &#123; @ComponentScan.Filter(type = FilterType.ANNOTATION, value = &#123;Controller.class&#125;)&#125;)public class MvcConfig extends WebMvcConfigurationSupport &#123; private static final Logger logger = Logger .getLogger(MvcConfig.class); /** * 描述 : &lt;注册视图处理器&gt;. &lt;br&gt; *&lt;p&gt; &lt;使用方法说明&gt; &lt;/p&gt; * @return */ @Bean public ViewResolver viewResolver() &#123; logger.info("ViewResolver"); InternalResourceViewResolver viewResolver = new InternalResourceViewResolver(); viewResolver.setPrefix("/WEB-INF/views/jsp/function/"); viewResolver.setSuffix(".jsp"); return viewResolver; &#125; /** * 描述 : &lt;注册消息资源处理器&gt;. &lt;br&gt; *&lt;p&gt; &lt;使用方法说明&gt; &lt;/p&gt; * @return */ @Bean public MessageSource messageSource() &#123; logger.info("MessageSource"); ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); messageSource.setBasename("config.messages.messages"); return messageSource; &#125; /** * 描述 : &lt;注册servlet适配器&gt;. &lt;br&gt; *&lt;p&gt; &lt;只需要在自定义的servlet上用@Controller("映射路径")标注即可&gt; &lt;/p&gt; * @return */ @Bean public HandlerAdapter servletHandlerAdapter()&#123; logger.info("HandlerAdapter"); return new SimpleServletHandlerAdapter(); &#125; /** * 描述 : &lt;本地化拦截器&gt;. &lt;br&gt; *&lt;p&gt; &lt;使用方法说明&gt; &lt;/p&gt; * @return */ @Bean public LocaleChangeInterceptor localeChangeInterceptor()&#123; logger.info("LocaleChangeInterceptor"); return new LocaleChangeInterceptor(); &#125; /** * 描述 : &lt;基于cookie的本地化资源处理器&gt;. &lt;br&gt; *&lt;p&gt; &lt;使用方法说明&gt; &lt;/p&gt; * @return */ @Bean(name="localeResolver") public CookieLocaleResolver cookieLocaleResolver()&#123; logger.info("CookieLocaleResolver"); return new CookieLocaleResolver(); &#125; /** * 描述 : &lt;添加拦截器&gt;. &lt;br&gt; *&lt;p&gt; &lt;使用方法说明&gt; &lt;/p&gt; * @param registry */ @Override protected void addInterceptors(InterceptorRegistry registry) &#123; // TODO Auto-generated method stub logger.info("addInterceptors start"); registry.addInterceptor(localeChangeInterceptor()); logger.info("addInterceptors end"); &#125; /** * 描述 : &lt;资源访问处理器&gt;. &lt;br&gt; *&lt;p&gt; &lt;可以在jsp中使用/static/**的方式访问/WEB-INF/static/下的内容&gt; &lt;/p&gt; * @param registry */ @Override protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123; logger.info("addResourceHandlers"); registry.addResourceHandler("/static/**").addResourceLocations("/WEB-INF/static/"); &#125; /** * 描述 : &lt;文件上传处理器&gt;. &lt;br&gt; *&lt;p&gt; &lt;使用方法说明&gt; &lt;/p&gt; * @return */ @Bean(name="multipartResolver") public CommonsMultipartResolver commonsMultipartResolver()&#123; logger.info("CommonsMultipartResolver"); return new CommonsMultipartResolver(); &#125; /** * 描述 : &lt;异常处理器&gt;. &lt;br&gt; *&lt;p&gt; &lt;系统运行时遇到指定的异常将会跳转到指定的页面&gt; &lt;/p&gt; * @return */ @Bean(name="exceptionResolver") public SimpleMappingExceptionResolver simpleMappingExceptionResolver()&#123; logger.info("CP_SimpleMappingExceptionResolver"); SimpleMappingExceptionResolver simpleMappingExceptionResolver= new SimpleMappingExceptionResolver(); simpleMappingExceptionResolver.setDefaultErrorView("common_error"); simpleMappingExceptionResolver.setExceptionAttribute("exception"); Properties properties = new Properties(); properties.setProperty("java.lang.RuntimeException", "common_error"); simpleMappingExceptionResolver.setExceptionMappings(properties); return simpleMappingExceptionResolver; &#125;&#125; 此时debug模式运行项目，会看到WebMvcAutoConfiguration没有被自动配置，说明我们自己定义的MvcConfig已经完全接管了默认的自动配置，这是因为WebMvcAutoConfiguration有一个条件注解:1@ConditionalOnMissingBean(&#123;WebMvcConfigurationSupport.class&#125;) 而我们本例中MvcConfig就是WebMvcConfigurationSupport的实现类，同时加入@EnableWebMvc注解也会导入一个WebMvcConfigurationSupport的实现类：DelegatingWebMvcConfiguration，所以MvcConfig继承WebMvcConfigurationSupport不是必须的，但是可以方便我们编码。 参考：SpringMVC4零配置–Web上下文配置【MvcConfig】 如果希望可以继续使用WebMvcAutoConfiguration的自动配置，而只是需要修改或者增加MVC中的某些配置时，我们可以创建一个配置类，并继承于抽象类WebMvcConfigurerAdapter，我们可以通过实现抽象类的方法来注册自己的控制器。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public abstract class WebMvcConfigurerAdapter implements WebMvcConfigurer &#123; public WebMvcConfigurerAdapter() &#123; &#125; public void configurePathMatch(PathMatchConfigurer configurer) &#123; &#125; public void configureContentNegotiation(ContentNegotiationConfigurer configurer) &#123; &#125; public void configureAsyncSupport(AsyncSupportConfigurer configurer) &#123; &#125; public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; &#125; public void addFormatters(FormatterRegistry registry) &#123; &#125; public void addInterceptors(InterceptorRegistry registry) &#123; &#125; public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; &#125; public void addCorsMappings(CorsRegistry registry) &#123; &#125; public void addViewControllers(ViewControllerRegistry registry) &#123; &#125; public void configureViewResolvers(ViewResolverRegistry registry) &#123; &#125; public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) &#123; &#125; public void addReturnValueHandlers(List&lt;HandlerMethodReturnValueHandler&gt; returnValueHandlers) &#123; &#125; public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; &#125; public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; &#125; public void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; exceptionResolvers) &#123; &#125; public void extendHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; exceptionResolvers) &#123; &#125; public Validator getValidator() &#123; return null; &#125; public MessageCodesResolver getMessageCodesResolver() &#123; return null; &#125;&#125; 比如我们可以增加一个视图跳转控制器，如下：1234567@Configurationpublic class WebMvcConfig extends WebMvcConfigurerAdapter&#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController("/demo/123").setViewName("/demo"); &#125;&#125; 注册Servlet、Filter、Listener的方法1.如果是war包项目，我们可以将Servlet、Filter、Listener注册到WebApplicationInitializer的实现类中123456789101112131415161718192021222324252627282930@Order(1)public class CommonInitializer implements WebApplicationInitializer &#123; @Override public void onStartup(ServletContext servletContext) throws ServletException &#123; //Log4jConfigListener servletContext.setInitParameter("log4jConfigLocation", "classpath:log4j.properties"); servletContext.addListener(Log4jConfigListener.class); //OpenSessionInViewFilter OpenSessionInViewFilter hibernateSessionInViewFilter = new OpenSessionInViewFilter(); FilterRegistration.Dynamic filterRegistration = servletContext.addFilter( "hibernateFilter", hibernateSessionInViewFilter); filterRegistration.addMappingForUrlPatterns( EnumSet.of(DispatcherType.REQUEST, DispatcherType.FORWARD, DispatcherType.INCLUDE), false, "/"); //DemoServlet DemoServlet demoServlet = new DemoServlet(); ServletRegistration.Dynamic dynamic = servletContext.addServlet( "demoServlet", demoServlet); dynamic.setLoadOnStartup(2); dynamic.addMapping("/demo_servlet"); &#125;&#125; 2.如果是jar包部署方式，则可以将其注册到任意一个@Configuration配置类中1234567891011121314151617181920212223242526272829303132333435@Configurationpublic class WebConfig &#123; @Bean public ServletRegistrationBean servletRegistrationBean_demo1()&#123; return new ServletRegistrationBean(new DemoServlet(),"/demo-servlet1"); &#125; @Bean public ServletRegistrationBean servletRegistrationBean_demo2()&#123; ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean(); servletRegistrationBean.addUrlMappings("/demo-servlet2"); servletRegistrationBean.setServlet(new DemoServlet2()); return servletRegistrationBean; &#125; @Bean public FilterRegistrationBean filterRegistrationBean()&#123; FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(); filterRegistrationBean.setFilter(new OpenSessionInViewFilter()); Set&lt;String&gt; set = new HashSet&lt;String&gt;(); set.add("/"); filterRegistrationBean.setUrlPatterns(set); return filterRegistrationBean; &#125; @Bean public ServletListenerRegistrationBean servletListenerRegistrationBean()&#123; ServletListenerRegistrationBean servletListenerRegistrationBean = new ServletListenerRegistrationBean(); servletListenerRegistrationBean.setListener(new Log4jConfigListener()); servletListenerRegistrationBean.addInitParameter("log4jConfigLocation","classpath:log4j.properties"); return servletListenerRegistrationBean; &#125;&#125; 总结一句话概括SpringBoot的自动配置–就是一组基于条件注解实现Bean注册的Spring配置类。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot学习笔记01--基本介绍]]></title>
    <url>%2F2016%2F12%2F09%2Fspring-boot-study%2F</url>
    <content type="text"><![CDATA[摘要看完本文你将掌握如下知识点： 如何搭建一个SpringBoot项目 SpringBoot自动配置原理 SpringBoot属性配置方法 修改默认的Logback日志为log4j和log4j2的方法 修改默认的内置tomcat容器为Jetty容器和Undertow容器的方法 SpringBoot单元测试方法 使用war包运行项目 SpringBoot系列：Spring Boot学习笔记 Spring Boot简介 要我给Spring Boot做个定义，简单来说就是一个基于强大的Spring框架的、推崇JavaConfig的极简配置的web开发框架； Spring Boot通过内嵌Servlet容器（Tomcat、Jetty，等等）的方式，可以以jar包的形式独立运行一个web项目； Spring Boot提倡JavaConfig和注解的零配置方式，并且默认配置满足绝大多数场景的需要，意味着少量修改默认配置即可快速搭建一个web项目，极大的提高开发效率； 项目中加入某一个spring-boot-starter-*依赖，就可以引入该功能的完整jar包，降低pom的复杂度 本文基于Spring Boot的版本为1.4.2.RELEASE Spring Boot项目创建方法 http://start.spring.io：可以通过网页创建项目结构并下载； Spring Boot CLI：通过命令行的方式创建Spring Boot项目； Spring Tool Suite：习惯Eclipse的用户可以使用STS创建『Spring Starter Project』项目; IntelliJ IDEA：强大的生产力工具，推荐使用，创建『Spring Initializr』项目; 使用IntelliJ IDEA创建一个web项目 新建Spring Initializr项目 说明：Spring Boot要求JDK1.6+ 填写项目信息，构建工具使用maven 选择项目使用的依赖，这里我们只需要勾选web Spring Boot当前最新的稳定版是1.4.2； 所有依赖可以在创建时勾选，也可以在创建后手工将依赖添加到pom中，如果对依赖比较熟悉，推荐手工添加，这样可以加快创建项目的时间； 填写项目名称，点击Finish 新建的项目结构如下 SpringBoot项目只会在项目根目录下生成一个类–SpringBootWebDemoApplication(artifactId+Application)，它就是一个带有main函数的启动类； 123456789101112package com.example;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class SpringBootWebDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootWebDemoApplication.class, args); &#125;&#125; pom.xml说明12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;springbootwebdemo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;SpringBootWebDemo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;!-- 创建的Springboot项目需要继承于spring-boot-starter-parent --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- 创建项目是勾选的web依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 每个项目都会自动添加一个test依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- Springboot的编译插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 这就是一个web项目的pom文件，可以看到只关联了很少的依赖，这是因为我们继承的spring-boot-starter-parent和关联的spring-boot-starter-web本身已经为我们关联了全部的依赖，如下是该项目所有的依赖包 运行Spring Boot项目 maven运行：mvn spring-boot:run； main函数运行：右键单击SpringBootWebDemoApplication，选择『Run 或者 Debug』； 推荐安装JRebel插件，支持热部署； 当然，也可以maven先打成jar，然后通过命令行执行java -jar xx.jar； 运行成功会看到控制台打印了如下信息 可以看到打印信息中有tomcat的启动信息，说明springboot默认使用tomcat作为web运行容器，这点从上面的依赖包中也可以看到。因为当前项目并没有开放任何服务，所以此时访问8080端口会提示无服务 添加服务 我们可以在项目中创建一个Controller控制器，比如DemoController 12345678910111213package com.example.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class DemoController &#123; @RequestMapping("/") String index()&#123; return "Hello Spring Boot!"; &#125;&#125; 运行SpringBootWebDemoApplication，再次访问http://localhost:8080 一切似乎就是那么美好，我们什么都没配置，一个web项目就这样运行起来了，SpringBoot自动帮我们默认了一些常用的配置 自动配置原理说明SpringBootWebDemoApplication类上的注解：@SpringBootApplication123456789101112131415161718192021222324252627282930313233343536373839404142434445package org.springframework.boot.autoconfigure;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import org.springframework.boot.SpringBootConfiguration;import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.boot.context.TypeExcludeFilter;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.FilterType;import org.springframework.context.annotation.ComponentScan.Filter;import org.springframework.core.annotation.AliasFor;@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;)&#125;)public @interface SpringBootApplication &#123; Class&lt;?&gt;[] exclude() default &#123;&#125;; String[] excludeName() default &#123;&#125;; @AliasFor( annotation = ComponentScan.class, attribute = "basePackages" ) String[] scanBasePackages() default &#123;&#125;; @AliasFor( annotation = ComponentScan.class, attribute = "basePackageClasses" ) Class&lt;?&gt;[] scanBasePackageClasses() default &#123;&#125;;&#125; @SpringBootConfiguration实际上就是@Configuration，说明这是一个JavaConfig @ComponentScan，启用注解自动扫描 @EnableAutoConfiguration的作用是根据类路径中jar包是否存在来决定是否开启某一个功能的自动配置，比如，我们项目中添加了spring-boot-starter-web依赖，因其关联Tomcat和Srping MVC，所以类路径下就会存在Tomcat和Spring MVC的jar包，SpringBoot项目扫描到这些jar包后会自动开启两者的配置，当然，这个配置是默认配置，我们可以根据需要进行修改（下文介绍）。 exclude和excludeName用于关闭指定的自动配置，比如关闭数据源相关的自动配置 1@SpringBootApplication(exclude=&#123;DataSourceAutoConfiguration.class&#125;) scanBasePackages和scanBasePackageClasses用于指定扫描的路径，默认情况下会自动扫描被@SpringBootApplication注解的类（这里是SpringBootWebDemoApplication）的同级包以及子包中的Bean。比如我们创建的DemoController，因为开启了SpringMVC自动配置，同时又在对应的路径下，所以该Controller会被自动加载。比如我们这里指定扫描的包路径如下： 1@SpringBootApplication(scanBasePackages = &#123;"com.temp.Controller"&#125;) 再次运行程序，发现原来的DemoController不能被访问了，而『com.temp.Controller』下的controller却可以被访问。 那么问题来了，SpringBoot到底为我们自动配置了哪些功能呢？ 开启Debug模式，方式有多种: java -jar xx.jar –debug 在IDE中执行Run时添加VM arguments:-Ddebug 在项目resources下的application.properties文件中增加debug=true Debug模式运行程序，打印信息中会显示如下内容 启动的自动配置未启用的自动配置 从打印结果中看到，每一个*AutoConfiguration*都对应着一类功能的自动配置类，比如HttpEncodingAutoConfiguration: 1234HttpEncodingAutoConfiguration matched: - @ConditionalOnClass found required class &apos;org.springframework.web.filter.CharacterEncodingFilter&apos; (OnClassCondition) - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition) - @ConditionalOnProperty (spring.http.encoding.enabled) matched (OnPropertyCondition) 开启的自动配置中都会有@ConditionalOnClass、@ConditionalOnWebApplication等标识，这是什么意思呢？为了弄清楚这个，我们需要先来认识一下@EnableAutoConfiguration； @EnableAutoConfiguration12345678910111213141516171819202122232425package org.springframework.boot.autoconfigure;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import org.springframework.boot.autoconfigure.AutoConfigurationPackage;import org.springframework.boot.autoconfigure.EnableAutoConfigurationImportSelector;import org.springframework.context.annotation.Import;@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(&#123;EnableAutoConfigurationImportSelector.class&#125;)public @interface EnableAutoConfiguration &#123; String ENABLED_OVERRIDE_PROPERTY = "spring.boot.enableautoconfiguration"; Class&lt;?&gt;[] exclude() default &#123;&#125;; String[] excludeName() default &#123;&#125;;&#125; 这里我们需要了解一下@Import注解中的EnableAutoConfigurationImportSelector 感兴趣的可以看一下源码，大体的功能就是扫描jar包里是否含有META-INF/spring.factories文件;并在spring.factories中找到@EnableAutoConfiguration的全路径名称org.springframework.boot.autoconfigure.EnableAutoConfiguration这个key，该key对应的value就是用于声明都需要启用哪些自动配置类;比如spring-boot-autoconfigure-1.4.2.RELEASE.jar中就有一个spring.factories，可以看到org.springframework.boot.autoconfigure.EnableAutoConfiguration参数中列出了自动配置类列表，而HttpEncodingAutoConfiguration这个自动配置类就是其声明的; HttpEncodingAutoConfiguration 先看下源码 12345678910111213141516171819202122232425262728@Configuration@EnableConfigurationProperties(&#123;HttpEncodingProperties.class&#125;)@ConditionalOnWebApplication@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;)@ConditionalOnProperty( prefix = "spring.http.encoding", value = &#123;"enabled"&#125;, matchIfMissing = true)public class HttpEncodingAutoConfiguration &#123; private final HttpEncodingProperties properties; public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) &#123; this.properties = properties; &#125; @Bean @ConditionalOnMissingBean(&#123;CharacterEncodingFilter.class&#125;) public CharacterEncodingFilter characterEncodingFilter() &#123; OrderedCharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE)); return filter; &#125; //.......省略以下........&#125; 熟悉JavaConfig的都会明白，这就是一个配置类@Configuration，并且通过@Bean注册了一个CharacterEncodingFilter; 但是还有一些注解，是什么意思呢，我们分别说明： @EnableConfigurationProperties：开启属性注入 本例中表示HttpEncodingProperties是属性类，并使用@Autowired自动注入；属性类实际上是一个是注解了@ConfigurationProperties的JavaBean，SpringBoot将属性文件（application.properties）中的键值对与JavaBean的属性建立起一一对应关系: 1234567891011121314@ConfigurationProperties( prefix = "spring.http.encoding" //属性值的前缀)/*举例：application.properties中设置如下属性spring.http.encoding.charset=UTF-8spring.http.encoding.force=true*/public class HttpEncodingProperties &#123; private Charset charset; private Boolean force; //....属性声明及set、get方法........ &#125; 所有@ConditionalOn开头的注解都是用于进行条件判断的 @ConditionalOnWebApplication：当前项目是web项目的条件下才加载当前配置类 @ConditionalOnClass：当类路径下有指定的类的条件下才加载当前配置类 12//本例表示，当前类路径（含jar）下必须存在CharacterEncodingFilter@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;) @ConditionalOnProperty：当指定的属性等于指定的值的情况下加载当前配置类 1234567// spring.http.encoding=enabled// matchIfMissing = true表示如果没有在application.properties设置该属性，则默认为条件符合@ConditionalOnProperty( prefix = "spring.http.encoding", value = &#123;"enabled"&#125;, matchIfMissing = true) @ConditionalOnMissingBean：当前容器里没有指定的Bean的情况下 12// 如果当前容器中找不到CharacterEncodingFilter实例，则创建当前的Bean@ConditionalOnMissingBean(&#123;CharacterEncodingFilter.class&#125;) 通过上面的分析，应该可以明白SpringBoot是如何做到自动配置的，简单总结如下： @SpringBootConfiguration实际上就是@Configuration，说明这是一个JavaConfig @EnableAutoConfiguration负责扫描jar包中的META-INF/spring.factories来找到要初始化的各种AutoConfiguration类 各种@Conditional注解决定哪些Bean可以被容器初始化 如果希望进一步了解SpringBoot的自动配置，建议查看每一个AutoConfiguration类的源码 除了上面介绍的，@Conditional注解还有如下形式 @ConditionalOnExpression：基于SpEL表达式作为条件判断 @ConditionalOnJava：基于JAVA版本作为判断条件 @ConditionalOnJndi：在JNDI存在的条件下查找指定的位置 @ConditionalOnMissingClass：当前类路径下没有指定的类的条件下 @ConditionalOnNotWebApplication：当前项目不是web项目的条件下 @ConditionalOnResource：类路径下是否有指定的值 @ConditionalOnSingleCandidate：当指定的Bean在容器中只有一个的情况下 如果我们希望自己创建一个自动配置类(AutoConfiguration)，则只需要在我们自己创建的JavaConfig中加上@ConditionalOn注解，并且在类路径下创建META-INF/spring.factories，加入参数org.springframework.boot.autoconfigure.EnableAutoConfiguration=xxxxAutoConfiguration SpringBoot的配置文件 SpringBoot支持常规的properties配置文件(application.properties)，还支持yaml语言的配置文件(application.yml) SpringBoot会从classpath下的/config目录或者classpath的根目录查找application.properties或application.yml 如果要修改SpringBoot自动配置中默认配置，可以通过在配置文件中配置相应的参数即可 比如，项目启动时，tomcat默认的端口号是『8080』，访问路径是『/』，修改如下： application.properties 12server.port=8081server.context-path=/demo application.yml 123server: port: 8081 context-path: /demo IntelliJ IDEA支持对properties和yml的代码提示功能，编辑起来还是很方便的，不需要特别记住这些属性名称 SpringBoot默认使用priperites进行配置 SpringBoot的属性可以通过多种方式指定，配置文件只是其中一种方式，常用的方式还有如下几种，按加载的优先级列出： 命令行参数：java -jar xx.jar --server.port=8081 --server.context-path=/demo操作系统环境变量：有些OS不支持使用.这种名字，如server.port，可以使用SERVER_PORT来配置。项目中的配置文件：application.properties或者application.yml项目依赖jar包中的配置文件：application.properties或者application.yml 关于SpringBoot支持的配置属性可以查看官网地址1.4.2.RELEASE Profile配置 不同的环境可以使用不同的配置文件，application-{profile}.properties，比如 开发：application-rnd.properties测试：application-release.properties验证：application-verify.properties生产：application-prod.properties 通过在application.properties(项目中必须包含该文件)中设置spring.profiles.active=prod来指定启用哪一个Profile。 关于属性配置还想多说的一些内容 application.properties也可以配置自定义属性：my.name=hanqf 通过@Value将属性注入Bean属性 12@Value("$&#123;my.name&#125;")private String myName; 通过@ConfigurationProperties将属性注入Bean对象 使用prefix123my.name=hanqfmy.servers[0]=rnd.hanqf.commy.servers[1]=release.hanqf.com 1234567@ConfigurationProperties(prefix="my")public class Config &#123; private String name; private List&lt;String&gt; servers = new ArrayList&lt;String&gt;();//list需要初始化 //....set and get method&#125; 不使用prefix123name=hanqfjdbc.username=rootjdbc.password=root 123456789101112@ConfigurationPropertiespublic class Config &#123; private String name; private Jdbc jdbc; class Jdbc &#123; private String username; private String password; //....set and get method &#125; //....set and get method&#125; 属性占位符 1234app.name=MyAppapp.description=$&#123;app.name&#125; is a Spring Boot application server.port=$&#123;port:8080&#125; # 如果没有设置port，则使用默认值8080 属性名匹配规则 123456@ConfigurationProperties(prefix="person")public class Config &#123; private String firstName; //....set and get method&#125; firstName可以使用的属性名如下：123person.firstName，标准的驼峰式命名person.first-name，虚线（-）分割方式，推荐在.properties和.yml配置文件中使用PERSON_FIRST_NAME，大写下划线形式，建议在系统环境变量中使用 日志配置 Spring Boot默认使用Logback作为日志框架，这是推荐的方式，如果希望修改为熟悉的log4j可以看下文 创建项目时我们引入了spring-boot-starter-web，其依赖spring-boot-starter，spring-boot-starter又依赖于spring-boot-starter-logging，该依赖内容就是Spring Boot默认的日志框架LogbackLogback相关设置，可以在application.properties中进行如下配置： 12345# 日志文件路径logging.file=D:/my_log.log # 配置日志打印级别logging.level.org.springframework=INFO 当然，也可以直接将自己的logback.xml放到项目根路径下 修改为log4j框架pom中排除对spring-boot-starter-logging的依赖，并加入对spring-boot-starter-log4j的依赖目前maven中央仓库的最新版本是1.3.8.RELEASE12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j&lt;/artifactId&gt; &lt;version&gt;1.3.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; 项目根路径下添加log4j.properties 修改为log4j2框架与log4j类似，修改pom，增加spring-boot-starter-log4j2依赖目前maven中央仓库的最新版本是1.4.2.RELEASE12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt; &lt;version&gt;1.4.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; 项目根路径下添加log4j2.xml 说明这里需要说明一个问题，如果切换为其它log框架，debug=true将会失效，需要在各自的log配置文件中声明，比如log4j需要添加log4j.logger.org.springframework.boot=debug 修改内置Tomcat为Jetty 修改pom，去除spring-boot-starter-tomcat的依赖，增加spring-boot-starter-jetty依赖目前maven中央仓库的最新版本是1.4.2.RELEASE 12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;version&gt;1.4.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; application.properties中的属性配置与tomcat一致 修改内置Tomcat为Undertow容器 修改pom，去除spring-boot-starter-tomcat的依赖，增加spring-boot-starter-undertow依赖目前maven中央仓库的最新版本是1.4.2.RELEASE 12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt; &lt;version&gt;1.4.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; application.properties中的属性配置与tomcat一致 单元测试 创建一个单元测试的抽象父类，用于初始化必要的对象 123456789101112131415161718192021222324252627package com.common;import org.junit.Before;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.setup.MockMvcBuilders;import org.springframework.web.context.WebApplicationContext;@RunWith(SpringRunner.class)//1.4.2.RELEASE中不再需要@SpringApplicationConfiguration和@WebAppConfiguration@SpringBootTest public abstract class SpringBootTestParent &#123; public MockMvc mockMvc; @Autowired WebApplicationContext webApplicationContext; @Before public void setUp() throws Exception &#123; mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build(); &#125;&#125; 继承抽象父类，并实现测试逻辑 123456789101112131415161718192021222324public class SpringBootWebDemoApplicationTests extends SpringBootTestParent&#123; @Autowired DemoService demoService; @Test public void content()&#123; String content = "456"; System.out.println(demoService.printContent(content)); Assert.assertEquals(content,demoService.printContent(content)); &#125; @Test public void DemoControllerContent()&#123; String uri = "/content/123"; MvcResult mvcResult; try &#123; mvcResult = mockMvc.perform(MockMvcRequestBuilders.get(uri)).andReturn(); System.out.println(mvcResult.getResponse().getStatus() + "##" + mvcResult.getResponse().getContentAsString()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 使用war包的形式运行项目上面我们介绍了SpringBoot通过jar的形式运行项目的方法，这也是SpringBoot推荐的方式，因其内置Servlet容器，所以发布和部署都非常方便，但是某些情况下（比如使用JSP作为VIEW层，内置容器的形式并不能支持），我们希望将web项目部署到自己的容器中，这时候就需要将SpringBoot项目打成war包部署，有两种方式：1.创建项目时打包方式选择：war war项目目录结构 2.将原打包方式为jar的项目修改为war形式与war项目对比发现，通过修改如下内容，可以将jar项目修改为war项目2.1 pom中将&lt;packaging&gt;jar&lt;/packaging&gt;==&gt;&lt;packaging&gt;war&lt;/packaging&gt;2.2 pom中添加tomcat依赖，显示声明scope为provided，这样打包时就不会将tomcat的jar包打到war中12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 2.3 创建ServletInitializer类123456public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; return application.sources(DemoWarApplication.class); &#125;&#125; 说明 Servlet3.0规范，支持将web.xml相关配置也硬编码到代码中，并由javax.servlet.ServletContainerInitializer的实现类负责在容器启动时进行加载 spring提供了一个实现类org.springframework.web.SpringServletContainerInitializer,该类会调用所有org.springframework.web.WebApplicationInitializer的实现类的onStartup(ServletContext servletContext)方法，从而将相关的容器组件注册到容器； SpringBootServletInitializer就是WebApplicationInitializer的实现类； 我之前写过一篇SpringMVC4零配置的文章，对零配置感兴趣的同学可以参考。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown编辑器--Sublime Text和Atom]]></title>
    <url>%2F2016%2F12%2F06%2Fmd-subl-atom%2F</url>
    <content type="text"><![CDATA[摘要 Markdown 是一种轻量级的「标记语言」，相对于更为复杂的 HTML 标记语言来说Markdown的语法十分简单。Markdown百度百科； Markdown语法说明『中文』，『英文』，Hexo就是基于Markdown语法； 支持Markdown的编辑器很多，这里推荐使用Sublime Text和Atom，因为这两种编辑器对于喜欢编程的人来说都非常熟悉，支持多种语法并且跨平台，所以如果你已经在使用其中之一，就没必要为了使用markdown再安装其它的编辑器了； Sublime Text 官方网站 Sublime默认不支持Markdown语法，需要安装插件，而要为Sublime Text安装插件，需要先安装package control； Package Control安装方法，简单说就是按『ctrl+`』调出控制台，并根据Sublime Text的版本粘贴相应的脚本并回车执行； 安装完成后按ctrl+shift+p (Win, Linux) or cmd+shift+p (OS X)，调出『Command Palette』，输入package control install回车，等待左下角的缓冲结束会弹出一个输入框，我们在里面输入插件的名称，即可快速筛选出可用的插件； 安装markdown编辑插件：MarkdownEditing 在弹出的输入框中输入MarkdownEditing，回车安装，安装后需要重新启动Sublime Text； 新建文件后缀为md，则会自动开启markdown语法支持； 非md后缀文件，可以按ctrl+shift+p (Win, Linux) or cmd+shift+p (OS X)，调出『Command Palette』，输入markdown回车来开启markdown语法支持； 安装markdown查看插件：OmniMarkupPreviwer 在弹出的输入框中输入OmniMarkupPreviwer，回车安装，安装后需要重新启动Sublime Text； 打开markdown的文档，按ctrl+alt+o (Win, Linux) or cmd+alt+o (OS X)，会打开浏览器对当前文档查看效果； 可以通过下面的方式查看所有安装的插件，并对其进行个性化配置； Atom 官方网站 Atom是github开发的开源跨平台的编辑器，Atom的强大可以与大名鼎鼎的Sublime Text相媲美。其使用方式与Sublime Text类似，所以如果会使用Sublime Text，上手Atom会很快。而且与Sublime Text相比，Atom是免费的，但是由于其安装包大小接近百兆，所以对于轻量级编辑器来说略显笨重； Atom内置了对markdown的支持，编辑markdown文档时，按ctrl+shift+M即可打开实时预览窗口，这点比Sublime Text方便很多； 对于非md结尾的文档，可以通过点击右下角的语法格式条，在弹出筛选框输入markdown进行语法切换； 可以按ctrl+, (Win, Linux) or cmd+,(OS X)，调出Atom的Settings，对其进行设置以及插件的管理; 总结 Atom相比Sublime Text来说一个新的产物，目前还不是很普及，不过Atom从一开始就整合了Sublime Text优点，同时提供了更友好的配置和管理方式，安装与卸载插件更加的方便； 编程时我们经常喜欢使用snippets+tab补全的方式来快速生成代码块，Atom和Sublime Text都支持snippets Atom 按ctrl+shift+p (Win, Linux) or cmd+shift+p (OS X)，调出『Command Palette』，输入Snippet: Available，可以调出snippets筛选框； Sublime Text 按ctrl+shift+p (Win, Linux) or cmd+shift+p (OS X)，调出『Command Palette』，输入Snippet:，可以调出snippets筛选框； 在Atom的Settings中，我们可以搜索相应的插件，并点击『settings』，可以在其中查看到其所支持的snippets，语法与Sublime Text一致；]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo--解决百度不能索引git page的问题]]></title>
    <url>%2F2016%2F12%2F05%2Fhexo-baidu-coding%2F</url>
    <content type="text"><![CDATA[摘要 由于git page网站对百度spider进行了屏蔽，所以导致了百度是无法对我们发布在git page上的网站进行索引； 解决方式是将我们的代码发布到国内的coding站点，其同样可以提供代码托管和Pages服务； Coding配置 Coding站点地址，注册个帐号 新建一个项目，比如： 设置SSH公钥，实现免密提交代码，如下图，将我们设置github page时生成的公钥填入其中，这里注意，要去掉最后面的邮箱地址。参考 新建coding-pages分支，并设置为默认 开启Pages服务 注意，此时提交代码后，可以通过http://hanqunfeng.coding.me访问 Hexo配置 hexo支持多仓库发布 1234567deploy:- type: git repo: https://github.com/hanqunfeng/hanqunfeng.github.io.git branch: master- type: git repo: https://git.coding.net/hanqunfeng/hanqunfeng.git branch: coding-pages 执行hexo d，会将代码同时发布到github和coding 域名解析–Dnspod 因为代码同时发布到github和coding，所以我希望国内用户访问coding，国外用户访问github，这样可以提高访问效率； 使用Dnspod实现域名解析，其支持让来源为指定线路的用户访问特定的地址； 注册一个Dnspod帐号，注册成功后在【域名解析】中添加一个域名，我这里添加的就是hanqunfeng.com； 添加成功后会自动解析出两个记录类型为A的记录，选择导入； 之后手工添加两条记录，一个CNAME到hanqunfeng.github.io.【国外】，一个CNAME到hanqunfeng.coding.me.【国内】，如下： 注意记录值最后都要加个点 修改万网的域名DNS 因为我的域名是在万网购买的，所以要想Dnspod起作用，需要修改万网中的DNS为Dnspod提供的地址； 万网域名修改 DNS 方法12f1g1ns1.dnspod.netf1g1ns2.dnspod.net Coding Pages服务中配置映射域名]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo--百度和谷歌搜索引擎索引方法]]></title>
    <url>%2F2016%2F12%2F05%2Fhexo-baidu-google%2F</url>
    <content type="text"><![CDATA[摘要 让百度和谷歌搜索引擎对当前站点进行索引的方法。 由于国内对谷歌的访问限制，所以可以使用chrome浏览器安装『谷歌访问助手』插件，安装方法 百度搜索 需要拥有百度帐号，并进行网站验证，因为我已经验证过blog.hanqunfneg.com，所以这里为了演示，使用www.hanqunfeng.com进行验证。 推荐『HTML 文件上传』的方式进行验证 将百度的验证文件，如我的是baidu_verify_5T5OVCioxp.html下载到本地，并拷贝到source目录下，并在文件上方增加如下内容,这样可以保证该文件不会被编译： 123layout: false---5T5OVCioxp 编译并发布，之后在刚才的下载页面进行验证 谷歌搜索 需要拥有谷歌帐号，并进行网站验证 推荐『HTML 文件上传』的方式进行验证 将谷歌的验证文件，如我的是googleea53a22ff4210278.html下载到本地，并拷贝到source目录下，并在文件上方增加如下内容,这样可以保证该文件不会被编译： 123layout: false---google-site-verification: googleea53a22ff4210278.html 编译并发布，之后在刚才的下载页面进行验证 插件站点地图安装 分别使用以下命令来安装针对百度和Google的地图插件，在站点的根目录下执行以下命令： 12$ npm install hexo-generator-sitemap --save$ npm install hexo-generator-baidu-sitemap --save 配置hexo的站点配置文件_config.yml 1234567891011#启用相应插件Plugins:- hexo-generator-sitemap- hexo-generator-baidu-sitemap#配置站点地图文件#sitemapsitemap: path: sitemap.xml baidusitemap:path: baidusitemap.xml 执行hexo g，当你成功编译并在Public目录下生成对应的baidusitemap.xml(针对百度)，sitemap.xml(针对Google)表明你已经成功建立的站点地图。 收录站点地图 百度推送 入口：百度站长–网页抓取–链接提交 谷歌推送 入口：Google Search Console–抓取–站点地图 百度推送方式–自动推送 索引效率：主动推送&gt;自动推送&gt;sitemap 百度的网站上有说明，地址 将自动推送的js脚本拷贝到themes\next\layout\_partials\footer.swig文件的最下方即可]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记]]></title>
    <url>%2F2016%2F12%2F02%2Fbook%2F</url>
    <content type="text"><![CDATA[资料列表 CentOS7下zabbix3.2的安装及使用 Rancher–Docker的管理控制台 git学习笔记]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo初体验]]></title>
    <url>%2F2016%2F12%2F01%2Fdubbo_dubbox%2F</url>
    <content type="text"><![CDATA[摘要 官网地址，官网有完整的资料以帮助使用者快速熟悉dubbo，不过目前相关下载地址已经失效，代码已经迁移到github，请参看下面的代码地址，自行编译打包 dubbo代码地址 2.5.4(官方版本)，基于spring3.2.16.RELEASE 2.8.4(第三方基于2.5.3修改)，基于spring3.2.9.RELEASE,项目名称为dubbox，但生成的包名依然是dubbo git、maven、jdk、tomcat、nexus请自行安装，我安装的版本如下 git version 2.9.3Apache Maven 3.3.9java version “1.8.0_31”tomcat version 8.5.4nexus version 2.5.0-04 编译打包以dubbo2.8.4为例 git clone https://github.com/dangdangdotcom/dubbox.git cd dubbox mvn clean package install -Dmaven.test.skip=true 发布dubbo2.8.4到nexus的3rd party仓库 登录nexus，设置3rd party的Deployment Policy=Allow Redeploy(在Configuration中配置) vi ~/.m2/settings.xml，在servers中增加如下配置12345&lt;server&gt; &lt;id&gt;thirdparty&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt; 修改dubbox的pom.xml，增加如下配置123456&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;thirdparty&lt;/id&gt; &lt;url&gt;http://192.168.36.49:8080/nexus/content/repositories/thirdparty/&lt;/url&gt; &lt;/repository&gt;&lt;/distributionManagement&gt; mvn clean package deploy -Dmaven.test.skip=true 发布dubbo2.5.4到nexus的3rd party仓库 因为目前2.5.4是Snapshots版本，所以不能直接发布到3rd party中，如果要发布到3rd party，需要修改pom.xml，去掉版本号中的Snapshots，比如在intellij IDEA中，使用快捷键Command+Shift+R； dubbo包含四个组件 Provider: 暴露服务的服务提供方。这里我们自己提供(基于2.8.4)； Consumer: 调用远程服务的服务消费方。这里我们自己提供(基于2.8.4)； Registry: 服务注册与发现的注册中心。这里使用zookeeper； Monitor: 统计服务的调用次调和调用时间的监控中心。这里介绍两个，一个是dubbo提供的dubbo-monitor-simple，另一个是第三方对dubbo-monitor-simple的改进版本：改版的monitor(基于2.8.4) 下面分别介绍：顺序为Registry，Provider，Consumer，Monitor。 ZooKeeper Registry注册中心官网地址 下载安装1234$ wget http://apache.fayea.com/zookeeper/zookeeper-3.4.9/zookeeper-3.4.9.tar.gz$ tar zxvf zookeeper-3.4.9.tar.gz$ cd zookeeper-3.4.9$ cp conf/zoo_sample.cfg conf/zoo.cfg 配置$ vi conf/zoo.cfg123456tickTime=2000initLimit=10syncLimit=5#实际上只需要配置dataDir，这里修改为自己的存储目录dataDir=/usr/local/zookeeper-3.4.9/dataclientPort=2181 集群配置 分别在两台主机上按上述方法安装zookeeper，比如两台主机的IP分别为192.168.37.144、192.168.37.143； 分别在两台主机的zoo.cfg中增加如下配置 12server.1=192.168.37.144:2555:3555server.2=192.168.37.143:2555:3555 在144主机的dataDir指定的目录(/usr/local/zookeeper-3.4.9/data)下创建文件myid vi myid设置内容为1 #就是zoo.cfg中server.后面对应的数字 同理将143的myid文件中内容设置为2 开放端口 两台主机分别开放2181，2555，3555端口vi /etc/sysconfig/iptablse，加入如下内容 1234#zookeeper-A INPUT -p tcp -m state --state NEW -m tcp --dport 2181 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 2555 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 3555 -j ACCEPT 重启iptables 启动与关闭zookeeper./bin/zkServer.sh start./bin/zkServer.sh stop 查看在zookeeper中注册的信息echo dump | nc 192.168.37.144 2181ORtelnet 192.168.37.144 2188dump 关于Provider&amp;Consumer，阿里官方的实例很详细了，网上也有很多资料，这里只做简单的说明，示例项目依赖于dubbo2.8.4,spring替换为4.3.3，使用中并未见异常，示例源码地址:https://github.com/hanqunfeng/DubboStudy Provider 服务提供者123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt; &lt;!-- 一个项目中只能有一个dubbo:application配置项 --&gt; &lt;dubbo:application name="demo-provider" owner="hanqf" organization="dubbox"/&gt; &lt;!-- 使用zookeeper注册中心暴露服务地址--&gt; &lt;dubbo:registry address="zookeeper://192.168.37.144:2181?backup=192.168.37.143:2181" timeout="50000"/&gt; &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt; &lt;dubbo:protocol name="dubbo" port="20880"/&gt; &lt;!-- 声明需要暴露的服务接口 服务实现类是通过注解注册的，所以此处不需要声明实现类 --&gt; &lt;dubbo:service interface="web.function.demo.service.DemoService" ref="demoService"/&gt; &lt;dubbo:service interface="web.function.demo.service.Demo2Service" ref="demo2Service"/&gt; &lt;!-- 启用monitor服务，只有配置这个，才会主动向monitor推送信息 --&gt; &lt;dubbo:monitor protocol="registry" /&gt;&lt;/beans&gt; 不同的Provider之间可以使用相同的应用名称（比如这里是name=”demo-provider”），因为注册的服务只基于服务所在服务器的ip地址和dubbo协议开放的端口号，两者有一个不相同即可，但是不建议这样做。 对于提供相同服务的Provider，也就是副本（同一个war包，部署到不同主机），则可以不去修改name，但是对于提供不同服务的Provider，不要使用相同的name，这样不便于在monitor中查看。 对于同一个Provider，要在同一台主机中部署（同一个war包，部署到同一台主机），则需要修改duboo协议端口，比如示例代码中的dubbo-provider和dubbo-provider02，因为两者提供相同的服务，所以应用名称相同，但是因为都在本机部署，所以一个用20880，一个使用20881 Consumer 服务消费者12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt; &lt;dubbo:application name="demo-consumer" owner="hanqf" organization="dubbox"/&gt; &lt;!-- 设置check的缺省值，如果配置中有显式的声明，如：&lt;dubbo:reference check="true"/&gt;，不会受影响 --&gt; &lt;!-- 关闭所有服务的启动时检查,注意：如果关闭某个服务的启动时检查，需要在指定的服务单独配置check="false" --&gt; &lt;dubbo:consumer check="false" /&gt; &lt;dubbo:registry protocol="zookeeper" address="192.168.37.144:2181,192.168.37.143:2181" timeout="50000"/&gt; &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt; &lt;dubbo:protocol name="dubbo" port="20880"/&gt; &lt;!-- 声明需要暴露的服务接口 --&gt; &lt;dubbo:reference interface="web.function.demo.service.DemoService" id="demoService" timeout="50000"/&gt; &lt;dubbo:reference interface="web.function.demo.service.Demo2Service" id="demo2Service" timeout="50000"/&gt; &lt;dubbo:monitor protocol="registry" /&gt;&lt;/beans&gt; Consumer和Provider如果部署在同一台主机，可以使用相同的dubbo协议端口，两者不受影响 关于相关配置属性的说明，还是参考官方资料吧，在dubbo源码中已经包含了Consumer和Provider的示例，可以作为参考。 Monitordubbo-monitor-simple 简易监控中心 dubbo项目源码中已经自带了一个Monitor，就是dubbo-monitor-simple，使用maven编译后，会在dubbox/dubbo-simple/dubbo-monitor-simple/target下生成dubbo-monitor-simple-2.8.4-assembly.tar.gz 将dubbo-monitor-simple-2.8.4-assembly.tar.gz拷贝的合适的地方并解压 123$ tar -zxvf dubbo-monitor-simple-2.8.4-assembly.tar.gz$ cd dubbo-monitor-simple-2.8.4$ vi conf/dubbo.properties 主要修改zookeeper地址、端口、绘图目录（该目录必须手工创建，比如这里是/Users/hanqunfeng/monitor）： 1234567891011121314dubbo.container=log4j,spring,registry,jettydubbo.application.name=simple-monitordubbo.application.owner=#dubbo.registry.address=multicast://224.5.6.7:1234dubbo.registry.address=zookeeper://192.168.37.144:2181?backup=192.168.37.143:2181#dubbo.registry.address=redis://127.0.0.1:6379#dubbo.registry.address=dubbo://127.0.0.1:9090dubbo.protocol.port=7070dubbo.jetty.port=8085dubbo.jetty.directory=/Users/hanqunfeng/monitordubbo.charts.directory=$&#123;dubbo.jetty.directory&#125;/chartsdubbo.statistics.directory=/Users/hanqunfeng/monitor/statisticsdubbo.log4j.file=logs/dubbo-monitor-simple.logdubbo.log4j.level=WARN 启动与关闭 ./bin/start.sh./bin/stop.sh 浏览器访问http://localhost:8085，图表中的效果是注册了Provider，Consumer的效果 改版的monitor(基于2.8.4) 特点：使用mysql作为数据存储，界面使用bootstrap进行优化 下载 12$ git clone http://git.oschina.net/handu/dubbo-monitor$ cd dubbo-monitor 配置vi src/main/resources/application.properties，修改zookeeper地址，端口，数据库信息 1234567891011121314dubbo.application.name=dubbo-monitordubbo.application.owner=hanqunfengdubbo.registry.address=zookeeper://192.168.37.144:2181?backup=192.168.37.143:2181dubbo.protocol.port=6060# Database Settingsdb.url=jdbc:mysql://127.0.0.1:3306/monitor?prepStmtCacheSize=517&amp;cachePrepStmts=true&amp;autoReconnect=true&amp;characterEncoding=utf-8db.username=rootdb.password=passworddb.maxActive=500# System Managermanager.username=adminmanager.password=admin 数据库初始化 创建monitor数据库 执行sql目录下的create.sql 打包mvn clean package -Dmaven.test.skip=true 基于本地nexus编译打包时，提示找不到jetbrick-template-2.0.10.jar，去maven中央仓库下载再上传到nexus中吧。 部署将生成的dubbo-monitor.war包部署到tomcat中，启动tomcat（端口8084）访问地址http://localhost:8084/dubbo-monitor 最后说一下dubbo-admin，这个是dubbo官方提供的dubbo管理控制台官方说明：管理控制台为内部裁剪版本，开源部分主要包含：路由规则，动态配置，服务降级，访问控制，权重调整，负载均衡，等管理功能。 dubbo-admin 管理控制台dubbo项目源码中有一个模块叫做dubbo-admin cd dubbox/dubbo-admin/src/main/webapp/WEB-INFvi dubbo.properties配置dubbo.registry.address=zookeeper://192.168.37.144:2181?backup=192.168.37.143:2181编译打包，将生成的dubbo-admin-2.8.4.war部署到tomcat]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo--NexT主题]]></title>
    <url>%2F2016%2F11%2F17%2Fhexo-theme-next%2F</url>
    <content type="text"><![CDATA[NexT主题简介 NexT有着完善的使用文档，NexT官方资料； NexT整合了常用的插件，如评论、分享、统计； 下载安装 12cd ~/bloggit clone https://github.com/iissnan/hexo-theme-next themes/next 第三方参考资料 我的配置多说评论和百度统计 NexT主题的_config.yml，配置方式参考Hexo–添加多说评论插件和百度统计插件 12345678910111213141516171819# 多说配置：# Duoshuo ShortNameduoshuo_shortname: 注册前缀# 开启热评文章duoshuo_hotartical: true# 可以看到评论用户的UA信息# Make duoshuo show UA# user_id must NOT be null when admin_enable is true!# you can visit http://dev.duoshuo.com get duoshuo user id.duoshuo_info: ua_enable: true admin_enable: false user_id: 0# 百度统计配置：# Baidu Analytics ID# 这里只需要填写js代码中hm.js链接的参数(如下：xxxxxxx)部分，而不再需要将整个js配置到模板中baidu_analytics: xxxxxxx 百度统计代码 1234567var _hmt = _hmt || [];(function() &#123; var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?xxxxxxx"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);&#125;)(); 百度分享 NexT主题的_config.yml，其它主题配置方式参考地址123456# Baidu Share# Available value:# button | slide# Warning: Baidu Share does not support https.baidushare: type: button 阅读次数 注册LeanCloud帐号，在LeanCloud中创建应用，具体配置方式查看参考资料。 复制AppID以及AppKey并在NexT主题的_config.yml文件中我们相应的位置填入即可，正确配置之后文件内容像这个样子: 1234leancloud_visitors: enable: true app_id: joaeuuc4hsqudUUwx4gIvGF6-gzGzoHsz app_key: E9UJsJpw1omCHuS22PdSpKoh 这里要注意，一定要在LeanCloud中的安全中心配置Web安全域名，否则不能正常统计 字数统计和阅读时常 参考资料 安装hexo-wordcount插件，在站点的根目录下执行以下命令：npm install hexo-wordcount --save 修改模板位置：themes\next\layout\_macro\post.swig，插入代码如下：1234567891011121314151617181920212223242526272829303132333435# 查找如下代码段： &#123;# LeanCould PageView #&#125; &#123;% if theme.leancloud_visitors.enable %&#125; &lt;span id="&#123;&#123; url_for(post.path) &#125;&#125;" class="leancloud_visitors" data-flag-title="&#123;&#123; post.title &#125;&#125;"&gt; &amp;nbsp; | &amp;nbsp; &lt;span class="post-meta-item-icon"&gt; &lt;i class="fa fa-eye"&gt;&lt;/i&gt; &lt;/span&gt; &lt;span class="post-meta-item-text"&gt;&#123;&#123;__('post.visitors')&#125;&#125; &lt;/span&gt; &lt;span class="leancloud-visitors-count"&gt;&lt;/span&gt; &lt;/span&gt; &#123;% endif %&#125;# 添加如下代码段： # 以下部分为：字数统计、阅读时长插入代码 &lt;span class="post-time"&gt; &amp;nbsp; | &amp;nbsp; &lt;span class="post-meta-item-icon"&gt; &lt;i class="fa fa-calendar-o"&gt;&lt;/i&gt; &lt;/span&gt; &lt;span class="post-meta-item-text"&gt;字数统计:&lt;/span&gt; &lt;span class="post-count"&gt;&#123;&#123; wordcount(post.content) &#125;&#125;(字)&lt;/span&gt; &lt;/span&gt; &lt;span class="post-time"&gt; &amp;nbsp; | &amp;nbsp; &lt;span class="post-meta-item-icon"&gt; &lt;i class="fa fa-calendar-o"&gt;&lt;/i&gt; &lt;/span&gt; &lt;span class="post-meta-item-text"&gt;阅读时长:&lt;/span&gt; &lt;span class="post-count"&gt;&#123;&#123; min2read(post.content) &#125;&#125;(分)&lt;/span&gt; &lt;/span&gt;# 以上部分为：字数统计、阅读时长插入代码 Local Search 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令：$ npm install hexo-generator-searchdb --save NexT主题的_config.yml 12345search: path: search.xml field: post format: html limit: 10000 重新编译之后会发现左侧导航栏最下方多出一个搜索菜单 标签页和分类页 默认情况下，NexT没有开启标签页和分类页功能 新增标签页 使用命令hexp new page “tags” 并将页面类型设置为tags12345---title: 标签date: 2016-11-17 23:03:47type: &quot;tags&quot;--- 通常情况下你的标签页并不需要评论框，取消评论代码123456---title: 标签date: 2016-11-17 23:03:47type: &quot;tags&quot;comments: false--- 在主题配置文件下的菜单设置项memu下设置，设置完成在主页导航可以看到标签导航栏12menu: tags: /tags 新增分类页 使用命令hexp new page categories 并将页面类型设置为categories12345---title: 分类date: 2016-11-17 23:08:35type: &quot;categories&quot;--- 通常情况下你的标签页并不需要评论框，取消评论代码123456---title: 分类date: 2016-11-17 23:08:35type: &quot;categories&quot;comments: false--- 在主题配置文件下的菜单设置项memu下设置，设置完成在主页导航可以看到分类导航栏12menu: categories: /categories 设定首页/归档/标签页面文章的篇数 安装如下插件，在站点的根目录下执行以下命令： 123$ npm install hexo-generator-index --save$ npm install hexo-generator-archive --save$ npm install hexo-generator-tag --save NexT主题的_config.yml 12345678910index_generator: per_page: 5archive_generator: per_page: 20 yearly: true monthly: truetag_generator: per_page: 10 RSS设置 安装 hexo-generator-feed，在站点的根目录下执行以下命令：$ npm install hexo-generator-feed --save NexT主题的_config.yml 1234# Set rss to false to disable feed link.# Leave rss as empty to use site's feed link.# Set rss to specific value if you have burned your feed already.rss: /atom.xml 编译后，会看到左侧头像下方会显示RSS入口 跳过指定文件的渲染 如果某些资源希望放到source下，但是又不希望被编译，可以在hexo的_config.yml中增加如下配置： 1234skip_render: - zabbix/** #跳过zabbix文件夹下的全部子目录和文件 - abc.html #跳过某一个具体的文件 - *.html #跳过以html结尾的文件 比如我的导航菜单中的『资料』，其下面配置的资源就是我从为知笔记中导出的html。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo--绑定域名到githubpage]]></title>
    <url>%2F2016%2F11%2F17%2Fhexo-domain-name%2F</url>
    <content type="text"><![CDATA[申请域名 可以通过万网购买域名; 比如博主的域名为hanqunfeng.com; 添加解析规则 登录阿里云的控制台，进入【域名】，找到自己的域名，点击【解析】 点击【添加解析】 『记录类型』：CNAME 『主机记录』：blog #说明：设置为二级域名，也可以设置为www的一级域名 『记录值』：hanqunfeng.github.io. #注意最后面有个点 上面的配置表示将blog.hanqunfeng.com的请求定向到hanqunfeng.github.io blog目录下创建CNAME文件 在自己的blog目录下的/source目录下新建一个文件，命名为CNAME，内容为：blog.hanqunfeng.com hexo cl，hexo g，hexo d，发布到github page 说明 购买域名需要进行实名认证； 官方说域名解析最长等待48小时就可以全球生效； 博主配置时，只是提交了实名认证申请，域名解析不到5分钟就可以访问了；]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo--添加多说评论插件和百度统计插件]]></title>
    <url>%2F2016%2F11%2F16%2Fhexo_duoshuo_baidutongji%2F</url>
    <content type="text"><![CDATA[添加多说评论插件 登录多说官网，多说不支持注册，仅支持绑定社交帐号登录，比如QQ，新浪微博，等等。 登录后会要求进行站点设置，这里需要设置域名、站点名称、首页网址等信息，域名的后缀已经默认为.duoshuo.com,所以我们只需要设置前缀，记住这个前缀。站点名称随便起个名字，首页网站填写https://hanqunfeng.github.io； 编辑yilia主题的_config.yml文件，设置如下： duoshuo: 域名前缀 重新发布即可，效果见页面下方的评论区； 在多说管理后台中可以对评论进行管理。 添加百度统计插件 注册百度统计帐号; 新注册用户会要求创建一个网站，设置如下： 登录后在代码管理--》代码获取中复制代码，将其粘贴到yilia主题下的layout/_partial/after-footer.gjs的最下面； 重新发布到github page； 在百度统计管理平台中的代码管理--》代码安装检查查看是否配置正确； 配置无误后，可以通过百度统计平台查看统计数据。 参考资料 http://m.blog.csdn.net/article/details?id=51049695]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+GitHub Page搭建自己的Blog]]></title>
    <url>%2F2016%2F11%2F14%2Fhexo_gitpage%2F</url>
    <content type="text"><![CDATA[什么是Hexo Hexo 是一个简单地、轻量地、基于Node的一个静态博客框架，可以方便的生成静态网页托管在github和Heroku上，引用Hexo作者 @tommy351 的话： 快速、简单且功能强大的 Node.js 博客框架。A fast, simple &amp; powerful blog framework, powered by Node.js. GitHub Pages是什么？ GitHub Pages 可以被认为是用户编写的、托管在github上的静态网页。由于它的空间免费稳定， 可以用于介绍托管在github上的Project或者搭建网站。 以下环境为mac下安装。 Hexo安装需要安装git和Node.js运行环境 git安装 mac自带git，如果需要重新安装，可去官网下载12$ git --versiongit version 2.9.3 (Apple Git-75) 安装npm 基于brew方式安装npm1$ brew install npm 安装Hexo1$ npm install hexo-cli -g npm安装Hexo：参考资料 查看Hexo版本12345678910111213$ hexo versionhexo: 3.2.2hexo-cli: 1.0.2os: Darwin 16.1.0 darwin x64http_parser: 2.7.0node: 6.6.0v8: 5.1.281.83uv: 1.9.1zlib: 1.2.8ares: 1.10.1-DEVicu: 57.1modules: 48openssl: 1.0.2h Quick StartSetup your blog123$ cd ~$ hexo init blog$ cd blog 此命令会在当前用户的家目录下创建一个blog目录，并初始化相关文件，如下为初始化的目录结构： blog目录结构说明 scaffolds ：模板文件夹，新建文章时，Hexo 会根据 scaffold 来建立文件。Hexo 有三种默认布局： post 、 page 和 draft ，它们分别对应不同的路径。新建文件的默认布局是 post ，可以在配置文件中更改布局。用 draft 布局生成的文件会被保存到 source/_drafts 文件夹。 source ：资源文件夹是存放用户资源的地方。 source/_post ：文件箱。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件或者文件夹和隐藏的文件将会被忽略。Markdown文件会被解析并放到 public 文件夹。 themes ：主题 文件夹。Hexo 会根据主题来生成静态页面。我们可以将自己的主题放到该目录下，然后在_config.yml中修改默认的主题即可。 themes/landscape ：默认的皮肤文件夹 _config.yml ：全局的配置文件，每次更改要重启服务。 _config.yml简介1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site 站点配置title: Study Zone #网站标题subtitle: Spring--java程序员的春天 #网站副标题description: 分享成长与快乐的地方 #网站描述author: hanqunfeng #作者，网站所有者language: zh-CN #网站使用的语言timezone: Asia/Shanghai #网站时区# URL 可以不配置## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://hanqunfeng.github.io #网址，搜索时会在搜索引擎中显示root: / #网站根目录 permalink: :year/:month/:day/:title/ #永久链接格式permalink_defaults: #永久链接中各部分的默认值# Directory 目录配置source_dir: source #资源文件夹，这个文件夹用来存放内容public_dir: public #公共文件夹，这个文件夹用于存放生成的站点文件tag_dir: tags #标签文件夹archive_dir: archives #归档文件夹category_dir: categories #分类文件夹code_dir: downloads/code #Include code 文件夹i18n_dir: :lang #国际化文件夹skip_render: #跳过指定文件的渲染，您可使用 glob 来配置路径# Writing 写作配置new_post_name: :title.md # File name of new posts # 新文章的文件名称default_layout: post #默认布局titlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0 #把文件名称转换为 (1) 小写或 (2) 大写render_drafts: false #显示草稿post_asset_folder: false #是否启动资源文件夹relative_link: false #把链接改为与根目录的相对位址future: truehighlight: #代码块的设置 enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tag 分类 &amp; 标签default_category: uncategorized #默认分类category_map: #分类别名tag_map: #标签别名# Date / Time format 时间和日期## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination 分页## Set per_page to 0 to disable paginationper_page: 10 #每页显示的文章量 (0 = 关闭分页功能)pagination_dir: page #分页目录# Extensions 扩展## Plugins: https://hexo.io/plugins/ 插件## Themes: https://hexo.io/themes/ 主题# theme: landscape #当前主题名称theme: yilia #当前主题名称# Deployment #部署到github## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/hanqunfeng/hanqunfeng.github.io.git branch: master 注意：以下所有命令，都必须在blog目录下执行。 Start the server123$ hexo serverINFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 我们可以通过浏览器访问http://localhost:4000/，就可以看到blog的页面了。 创建文件、生成静态文件以及发布到github，都不需要启动服务，启动服务的目的仅是为了能在本地看到效果。 hexo server == hexo s Create a new post12$ hexo new "Hello Hexo"INFO Created: ~/blog/source/_posts/Hello-Hexo.md 创建好的文件基于makedown语法，可以使用sublime或者atom编辑器，进行编辑与管理。 编辑完成后不需要执行hexo generate命令即可在浏览器中查看效果，但是修改了主题内容，有时会不生效，需要先生成静态文件才能看到最终效果。 hexo new == hexo n Generate static files1$ hexo generate 该命令用于将makedown文件转换为静态html文件，并放到public文件夹下。 可以使用hexo clean命令来删除public文件夹，之后再使用hexo generate来重新生成静态文件。 hexo generate == hexo g Clean static files123$ hexo cleanINFO Deleted database.INFO Deleted public folder. hexo clean == hexo cl 主题更换主题 github上有许多技术达人为Hexo制作的主题，可以clone到本地，并拷贝到themes文件夹下，然后修改_config.yml中的theme属性，修改主题需要重启Hexo才能生效。 比如博主使用主题为yilia下载地址: 12$ cd ~/blog$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 更新主题时，在themes/yilia目录下执行git pull。 添加资源 可以在当前主题的source目录下放入自己的资源，执行hexo generate命令时，会将主题中的source目录下的内容拷贝到public目录下。 但是这样做如果更换主题，则资源就失效了，所以一般是在source目录下创建资源文件，执行hexo generate命令时，会将source目录下的内容拷贝到public目录下。 发布到Github安装hexo的git发布包1$ npm install hexo-deployer-git -S 创建SSH密钥 创建密钥可以在执行发布时不需要每次都输入用户名和密码，具体创建方法查看如下资料: github官网 图文教程 Deploy to remote sites 因为使用GitPage，所以需要申请一个Github帐号，并创建一个仓库，仓库名称为”your_name.github.io”。 创建好仓库后，在_config.yml中按上文中的内容配置好deploy属性。 执行如下命令，会将public下的文件发布到该仓库中，一般执行deploy前先执行clean和generate保证文件最新。 访问https://hanqunfeng.github.io，查看blog页面。 123$ hexo clean$ hexo generate$ hexo deploy hexo deploy == hexo d 参考资料 http://www.tuicool.com/articles/ueI7naV http://www.jianshu.com/p/465830080ea9]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
