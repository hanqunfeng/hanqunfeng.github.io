<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Spring Boot学习笔记02--自动配置]]></title>
      <url>%2F2016%2F12%2F10%2Fspring-boot-study-web%2F</url>
      <content type="text"><![CDATA[摘要看完本文你将掌握如下知识点： SpringBoot都帮我们做了哪些自动配置 我们如何接管SpringBoot的自动配置 SpringBoot的自动配置1.自动配置类都存放在spring-boot-autoconfigure-1.4.2.RELEASE.jar下的org.springframework.boot.autoconfigure路径下；2.application.properties中配置debug=true后启动容器，可以看到服务器初始化的自动配置如下: DispatcherServletAutoConfiguration注册org.springframework.web.servlet.DispatcherServlet EmbeddedServletContainerAutoConfiguration注册容器类型，如类路径下存在org.apache.catalina.startup.Tomcat，就会注册Tomcat容器 ErrorMvcAutoConfiguration注册异常处理器 HttpEncodingAutoConfiguration注册http编码过滤器 HttpMessageConvertersAutoConfiguration注册json或者xml处理器 JacksonAutoConfiguration注册json对象解析器 JmxAutoConfiguration注册JMX管理器 JMX与Spring集成spring通过annotation注解注册MBean到JMX实现监控java运行状态 MultipartAutoConfiguration注册文件传输处理器 ServerPropertiesAutoConfiguration用于初始化容器相关的配置属性，如服务地址、端口、contextPath，并根据当前容器类型初始化各个容器的特有属性，如tomcat的maxThreads、uriEncoding等等，其对应的属性类为ServerProperties； WebClientAutoConfiguration注册RestTemplate WebMvcAutoConfiguration注册SpringMvc相关处理器，如ResourceResolver、RequestMappingHandlerAdapter、ExceptionHandlerExceptionResolver、ViewResolver、LocaleResolver，等等 WebSocketAutoConfiguration注册webSocket相关处理器，根据容器类型注册不同的处理器 3.如果依赖中加入了其它功能的依赖，SpringBoot还会实现这些功能的自动适配，比如我们增加数据库的JPA的功能，就会启用对JpaRepositoriesAutoConfiguration的自动配置功能。关于数据库方面的内容将在后文介绍。1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; 说明从各个AutoConfiguration配置类中可以看到如下注解，基于这些注解可以确定这些AutoConfiguration的初始化顺序： @AutoConfigureOrder(-2147483648)：数越小越先初始化 @AutoConfigureAfter({EmbeddedServletContainerAutoConfiguration.class})：在指定的配置类初始化后再加载 @AutoConfigureBefore({WebMvcAutoConfiguration.class})：在指定的配置类初始化前加载]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring Boot学习笔记01--基本介绍]]></title>
      <url>%2F2016%2F12%2F09%2Fspring-boot-study%2F</url>
      <content type="text"><![CDATA[摘要看完本文你将掌握如下知识点： 如何搭建一个SpringBoot项目 SpringBoot自动配置原理 SpringBoot属性配置方法 修改默认的Logback日志为log4j和log4j2的方法 修改默认的内置tomcat容器为Jetty容器和Undertow容器的方法 SpringBoot单元测试方法 使用war包运行项目 Spring Boot简介 要我给Spring Boot做个定义，简单来说就是一个基于强大的Spring框架的、推崇JavaConfig的极简配置的web开发框架； Spring Boot通过内嵌Servlet容器（Tomcat、Jetty，等等）的方式，可以以jar包的形式独立运行一个web项目； Spring Boot提倡JavaConfig和注解的零配置方式，并且默认配置满足绝大多数场景的需要，意味着少量修改默认配置即可快速搭建一个web项目，极大的提高开发效率； 项目中加入某一个spring-boot-starter-*依赖，就可以引入该功能的完整jar包，降低pom的复杂度 本文基于Spring Boot的版本为1.4.2.RELEASE Spring Boot项目创建方法 http://start.spring.io：可以通过网页创建项目结构并下载； Spring Boot CLI：通过命令行的方式创建Spring Boot项目； Spring Tool Suite：习惯Eclipse的用户可以使用STS创建『Spring Starter Project』项目; IntelliJ IDEA：强大的生产力工具，推荐使用，创建『Spring Initializr』项目; 使用IntelliJ IDEA创建一个web项目 新建Spring Initializr项目 说明：Spring Boot要求JDK1.6+ 填写项目信息，构建工具使用maven 选择项目使用的依赖，这里我们只需要勾选web Spring Boot当前最新的稳定版是1.4.2； 所有依赖可以在创建时勾选，也可以在创建后手工将依赖添加到pom中，如果对依赖比较熟悉，推荐手工添加，这样可以加快创建项目的时间； 填写项目名称，点击Finish 新建的项目结构如下 SpringBoot项目只会在项目根目录下生成一个类–SpringBootWebDemoApplication(artifactId+Application)，它就是一个带有main函数的启动类； 123456789101112package com.example;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class SpringBootWebDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootWebDemoApplication.class, args); &#125;&#125; pom.xml说明12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;springbootwebdemo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;SpringBootWebDemo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;!-- 创建的Springboot项目需要继承于spring-boot-starter-parent --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- 创建项目是勾选的web依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 每个项目都会自动添加一个test依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- Springboot的编译插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 这就是一个web项目的pom文件，可以看到只关联了很少的依赖，这是因为我们继承的spring-boot-starter-parent和关联的spring-boot-starter-web本身已经为我们关联了全部的依赖，如下是该项目所有的依赖包 运行Spring Boot项目 maven运行：mvn spring-boot:run； main函数运行：右键单击SpringBootWebDemoApplication，选择『Run 或者 Debug』； 推荐安装JRebel插件，支持热部署； 当然，也可以maven先打成jar，然后通过命令行执行java -jar xx.jar； 运行成功会看到控制台打印了如下信息 可以看到打印信息中有tomcat的启动信息，说明springboot默认使用tomcat作为web运行容器，这点从上面的依赖包中也可以看到。因为当前项目并没有开放任何服务，所以此时访问8080端口会提示无服务 添加服务 我们可以在项目中创建一个Controller控制器，比如DemoController 12345678910111213package com.example.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class DemoController &#123; @RequestMapping("/") String index()&#123; return "Hello Spring Boot!"; &#125;&#125; 运行SpringBootWebDemoApplication，再次访问http://localhost:8080 一切似乎就是那么美好，我们什么都没配置，一个web项目就这样运行起来了，SpringBoot自动帮我们默认了一些常用的配置 自动配置原理说明SpringBootWebDemoApplication类上的注解：@SpringBootApplication123456789101112131415161718192021222324252627282930313233343536373839404142434445package org.springframework.boot.autoconfigure;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import org.springframework.boot.SpringBootConfiguration;import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.boot.context.TypeExcludeFilter;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.FilterType;import org.springframework.context.annotation.ComponentScan.Filter;import org.springframework.core.annotation.AliasFor;@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;)&#125;)public @interface SpringBootApplication &#123; Class&lt;?&gt;[] exclude() default &#123;&#125;; String[] excludeName() default &#123;&#125;; @AliasFor( annotation = ComponentScan.class, attribute = "basePackages" ) String[] scanBasePackages() default &#123;&#125;; @AliasFor( annotation = ComponentScan.class, attribute = "basePackageClasses" ) Class&lt;?&gt;[] scanBasePackageClasses() default &#123;&#125;;&#125; @SpringBootConfiguration实际上就是@Configuration，说明这是一个JavaConfig @EnableAutoConfiguration的作用是根据类路径中jar包是否存在来决定是否开启某一个功能的自动配置，比如，我们项目中添加了spring-boot-starter-web依赖，因其关联Tomcat和Srping MVC，所以类路径下就会存在Tomcat和Spring MVC的jar包，SpringBoot项目扫描到这些jar包后会自动开启两者的配置，当然，这个配置是默认配置，我们可以根据需要进行修改（下文介绍）。 exclude和excludeName用于关闭指定的自动配置，比如关闭数据源相关的自动配置 1@SpringBootApplication(exclude=&#123;DataSourceAutoConfiguration.class&#125;) scanBasePackages和scanBasePackageClasses用于指定扫描的路径，默认情况下会自动扫描被@SpringBootApplication注解的类（这里是SpringBootWebDemoApplication）的同级包以及子包中的Bean。比如我们创建的DemoController，因为开启了SpringMVC自动配置，同时又在对应的路径下，所以该Controller会被自动加载。比如我们这里指定扫描的包路径如下： 1@SpringBootApplication(scanBasePackages = &#123;"com.temp.Controller"&#125;) 再次运行程序，发现原来的DemoController不能被访问了，而『com.temp.Controller』下的controller却可以被访问。 那么问题来了，SpringBoot到底为我们自动配置了哪些功能呢？ 开启Debug模式，方式有多种: java -jar xx.jar –debug 在IDE中执行Run时添加VM arguments:-Ddebug 在项目resources下的application.properties文件中增加debug=true Debug模式运行程序，打印信息中会显示如下内容 启动的自动配置未启用的自动配置 从打印结果中看到，每一个*AutoConfiguration*都对应着一类功能的自动配置类，比如HttpEncodingAutoConfiguration: 1234HttpEncodingAutoConfiguration matched: - @ConditionalOnClass found required class &apos;org.springframework.web.filter.CharacterEncodingFilter&apos; (OnClassCondition) - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition) - @ConditionalOnProperty (spring.http.encoding.enabled) matched (OnPropertyCondition) 开启的自动配置中都会有@ConditionalOnClass、@ConditionalOnWebApplication等标识，这是什么意思呢？为了弄清楚这个，我们需要先来认识一下@EnableAutoConfiguration； @EnableAutoConfiguration12345678910111213141516171819202122232425package org.springframework.boot.autoconfigure;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import org.springframework.boot.autoconfigure.AutoConfigurationPackage;import org.springframework.boot.autoconfigure.EnableAutoConfigurationImportSelector;import org.springframework.context.annotation.Import;@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(&#123;EnableAutoConfigurationImportSelector.class&#125;)public @interface EnableAutoConfiguration &#123; String ENABLED_OVERRIDE_PROPERTY = "spring.boot.enableautoconfiguration"; Class&lt;?&gt;[] exclude() default &#123;&#125;; String[] excludeName() default &#123;&#125;;&#125; 这里我们需要了解一下@Import注解中的EnableAutoConfigurationImportSelector 感兴趣的可以看一下源码，大体的功能就是扫描jar包里是否含有META-INF/spring.factories文件;spring.factories中的org.springframework.boot.autoconfigure.EnableAutoConfiguration属性用于声明都需要启用哪些自动配置类;比如spring-boot-autoconfigure-1.4.2.RELEASE.jar中就有一个spring.factories，可以看到org.springframework.boot.autoconfigure.EnableAutoConfiguration参数中列出了自动配置类列表，而HttpEncodingAutoConfiguration这个自动配置类就是其声明的; HttpEncodingAutoConfiguration 先看下源码 12345678910111213141516171819202122232425262728@Configuration@EnableConfigurationProperties(&#123;HttpEncodingProperties.class&#125;)@ConditionalOnWebApplication@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;)@ConditionalOnProperty( prefix = "spring.http.encoding", value = &#123;"enabled"&#125;, matchIfMissing = true)public class HttpEncodingAutoConfiguration &#123; private final HttpEncodingProperties properties; public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) &#123; this.properties = properties; &#125; @Bean @ConditionalOnMissingBean(&#123;CharacterEncodingFilter.class&#125;) public CharacterEncodingFilter characterEncodingFilter() &#123; OrderedCharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE)); return filter; &#125; //.......省略以下........&#125; 熟悉JavaConfig的都会明白，这就是一个配置类@Configuration，并且通过@Bean注册了一个CharacterEncodingFilter; 但是还有一些注解，是什么意思呢，我们分别说明： @EnableConfigurationProperties：开启属性注入 本例中表示HttpEncodingProperties是属性类，并使用@Autowired自动注入；属性类实际上是一个是注解了@ConfigurationProperties的JavaBean，SpringBoot将属性文件（application.properties）中的键值对与JavaBean的属性建立起一一对应关系: 1234567891011121314@ConfigurationProperties( prefix = "spring.http.encoding" //属性值的前缀)/*举例：application.properties中设置如下属性spring.http.encoding.charset=UTF-8spring.http.encoding.force=true*/public class HttpEncodingProperties &#123; private Charset charset; private Boolean force; //....属性声明及set、get方法........ &#125; 所有@ConditionalOn开头的注解都是用于进行条件判断的 @ConditionalOnWebApplication：当前项目是web项目的条件下才加载当前配置类 @ConditionalOnClass：当类路径下有指定的类的条件下才加载当前配置类 12//本例表示，当前类路径（含jar）下必须存在CharacterEncodingFilter@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;) @ConditionalOnProperty：当指定的属性等于指定的值的情况下加载当前配置类 1234567// spring.http.encoding=enabled// matchIfMissing = true表示如果没有在application.properties设置该属性，则默认为条件符合@ConditionalOnProperty( prefix = "spring.http.encoding", value = &#123;"enabled"&#125;, matchIfMissing = true) @ConditionalOnMissingBean：当前容器里没有指定的Bean的情况下 12// 如果当前容器中找不到CharacterEncodingFilter实例，则创建当前的Bean@ConditionalOnMissingBean(&#123;CharacterEncodingFilter.class&#125;) 通过上面的分析，应该可以明白SpringBoot是如何做到自动配置的，简单总结如下： @SpringBootConfiguration实际上就是@Configuration，说明这是一个JavaConfig @EnableAutoConfiguration负责扫描jar包中的META-INF/spring.factories来找到要初始化的各种AutoConfiguration类 各种@Conditional注解决定哪些Bean可以被容器初始化 如果希望进一步了解SpringBoot的自动配置，建议查看每一个AutoConfiguration类的源码 除了上面介绍的，@Conditional注解还有如下形式 @ConditionalOnExpression：基于SpEL表达式作为条件判断 @ConditionalOnJava：基于JAVA版本作为判断条件 @ConditionalOnJndi：在JNDI存在的条件下查找指定的位置 @ConditionalOnMissingClass：当前类路径下没有指定的类的条件下 @ConditionalOnNotWebApplication：当前项目不是web项目的条件下 @ConditionalOnResource：类路径下是否有指定的值 @ConditionalOnSingleCandidate：当指定的Bean在容器中只有一个的情况下 如果我们希望自己创建一个自动配置类(AutoConfiguration)，则只需要在我们自己创建的JavaConfig中加上@ConditionalOn注解，并且在类路径下创建META-INF/spring.factories，加入参数org.springframework.boot.autoconfigure.EnableAutoConfiguration=xxxxAutoConfiguration SpringBoot的配置文件 SpringBoot支持常规的properties配置文件(application.properties)，还支持yaml语言的配置文件(application.yml) SpringBoot会从classpath下的/config目录或者classpath的根目录查找application.properties或application.yml 如果要修改SpringBoot自动配置中默认配置，可以通过在配置文件中配置相应的参数即可 比如，项目启动时，tomcat默认的端口号是『8080』，访问路径是『/』，修改如下： application.properties 12server.port=8081server.context-path=/demo application.yml 123server: port: 8081 context-path: /demo IntelliJ IDEA支持对properties和yml的代码提示功能，编辑起来还是很方便的，不需要特别记住这些属性名称 SpringBoot默认使用priperites进行配置 SpringBoot的属性可以通过多种方式指定，配置文件只是其中一种方式，常用的方式还有如下几种，按加载的优先级列出： 命令行参数：java -jar xx.jar --server.port=8081 --server.context-path=/demo操作系统环境变量：有些OS不支持使用.这种名字，如server.port，可以使用SERVER_PORT来配置。项目中的配置文件：application.properties或者application.yml项目依赖jar包中的配置文件：application.properties或者application.yml 关于SpringBoot支持的配置属性可以查看官网地址1.4.2.RELEASE Profile配置 不同的环境可以使用不同的配置文件，application-{profile}.properties，比如 开发：application-rnd.properties测试：application-release.properties验证：application-verify.properties生产：application-prod.properties 通过在application.properties(项目中必须包含该文件)中设置spring.profiles.active=prod来指定启用哪一个Profile。 关于属性配置还想多说的一些内容 application.properties也可以配置自定义属性：my.name=hanqf 通过@Value将属性注入Bean属性 12@Value("$&#123;my.name&#125;")private String myName; 通过@ConfigurationProperties将属性注入Bean对象 使用prefix123my.name=hanqfmy.servers[0]=rnd.hanqf.commy.servers[1]=release.hanqf.com 1234567@ConfigurationProperties(prefix="my")public class Config &#123; private String name; private List&lt;String&gt; servers = new ArrayList&lt;String&gt;();//list需要初始化 //....set and get method&#125; 不使用prefix123name=hanqfjdbc.username=rootjdbc.password=root 123456789101112@ConfigurationPropertiespublic class Config &#123; private String name; private Jdbc jdbc; class Jdbc &#123; private String username; private String password; //....set and get method &#125; //....set and get method&#125; 属性占位符 1234app.name=MyAppapp.description=$&#123;app.name&#125; is a Spring Boot application server.port=$&#123;port:8080&#125; # 如果没有设置port，则使用默认值8080 属性名匹配规则 123456@ConfigurationProperties(prefix="person")public class Config &#123; private String firstName; //....set and get method&#125; firstName可以使用的属性名如下：123person.firstName，标准的驼峰式命名person.first-name，虚线（-）分割方式，推荐在.properties和.yml配置文件中使用PERSON_FIRST_NAME，大写下划线形式，建议在系统环境变量中使用 日志配置 Spring Boot默认使用Logback作为日志框架，这是推荐的方式，如果希望修改为熟悉的log4j可以看下文 创建项目时我们引入了spring-boot-starter-web，其依赖spring-boot-starter，spring-boot-starter又依赖于spring-boot-starter-logging，该依赖内容就是Spring Boot默认的日志框架LogbackLogback相关设置，可以在application.properties中进行如下配置： 12345# 日志文件路径logging.file=D:/my_log.log # 配置日志打印级别logging.level.org.springframework=INFO 当然，也可以直接将自己的logback.xml放到项目根路径下 修改为log4j框架pom中排除对spring-boot-starter-logging的依赖，并加入对spring-boot-starter-log4j的依赖目前maven中央仓库的最新版本是1.3.8.RELEASE12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j&lt;/artifactId&gt; &lt;version&gt;1.3.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; 项目根路径下添加log4j.properties 修改为log4j2框架与log4j类似，修改pom，增加spring-boot-starter-log4j2依赖目前maven中央仓库的最新版本是1.4.2.RELEASE12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt; &lt;version&gt;1.4.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; 项目根路径下添加log4j2.xml 修改内置Tomcat为Jetty 修改pom，去除spring-boot-starter-tomcat的依赖，增加spring-boot-starter-jetty依赖目前maven中央仓库的最新版本是1.4.2.RELEASE 12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;version&gt;1.4.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; application.properties中的属性配置与tomcat一致 修改内置Tomcat为Undertow容器 修改pom，去除spring-boot-starter-tomcat的依赖，增加spring-boot-starter-undertow依赖目前maven中央仓库的最新版本是1.4.2.RELEASE 12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt; &lt;version&gt;1.4.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; application.properties中的属性配置与tomcat一致 单元测试 创建一个单元测试的抽象父类，用于初始化必要的对象 123456789101112131415161718192021222324252627package com.common;import org.junit.Before;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.setup.MockMvcBuilders;import org.springframework.web.context.WebApplicationContext;@RunWith(SpringRunner.class)//1.4.2.RELEASE中不再需要@SpringApplicationConfiguration和@WebAppConfiguration@SpringBootTest public abstract class SpringBootTestParent &#123; public MockMvc mockMvc; @Autowired WebApplicationContext webApplicationContext; @Before public void setUp() throws Exception &#123; mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build(); &#125;&#125; 继承抽象父类，并实现测试逻辑 123456789101112131415161718192021222324public class SpringBootWebDemoApplicationTests extends SpringBootTestParent&#123; @Autowired DemoService demoService; @Test public void content()&#123; String content = "456"; System.out.println(demoService.printContent(content)); Assert.assertEquals(content,demoService.printContent(content)); &#125; @Test public void DemoControllerContent()&#123; String uri = "/content/123"; MvcResult mvcResult; try &#123; mvcResult = mockMvc.perform(MockMvcRequestBuilders.get(uri)).andReturn(); System.out.println(mvcResult.getResponse().getStatus() + "##" + mvcResult.getResponse().getContentAsString()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 使用war包的形式运行项目上面我们介绍了SpringBoot通过jar的形式运行项目的方法，这也是SpringBoot推荐的方式，因其内置Servlet容器，所以发布和部署都非常方便，但是某些情况下（比如使用JSP作为VIEW层，内置容器的形式并不能支持），我们希望将web项目部署到自己的容器中，这时候就需要将SpringBoot项目打成war包部署，有两种方式：1.创建项目时打包方式选择：war war项目目录结构 2.将原打包方式为jar的项目修改为war形式与war项目对比发现，通过修改如下内容，可以将jar项目修改为war项目2.1 pom中将&lt;packaging&gt;jar&lt;/packaging&gt;==&gt;&lt;packaging&gt;war&lt;/packaging&gt;2.2 pom中添加tomcat依赖，显示声明scope为provided，这样打包时就不会将tomcat的jar包打到war中12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 2.3 创建ServletInitializer类123456public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; return application.sources(DemoWarApplication.class); &#125;&#125; 说明 Servlet3.0规范，支持将web.xml相关配置也硬编码到代码中，并由javax.servlet.ServletContainerInitializer的实现类负责在容器启动时进行加载 spring提供了一个实现类org.springframework.web.SpringServletContainerInitializer,该类会调用所有org.springframework.web.WebApplicationInitializer的实现类的onStartup(ServletContext servletContext)方法，从而将相关的容器组件注册到容器； SpringBootServletInitializer就是WebApplicationInitializer的实现类； 我之前写过一篇SpringMVC4零配置的文章，对零配置感兴趣的同学可以参考。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown编辑器--Sublime Text和Atom]]></title>
      <url>%2F2016%2F12%2F06%2Fmd-subl-atom%2F</url>
      <content type="text"><![CDATA[摘要 Markdown 是一种轻量级的「标记语言」，相对于更为复杂的 HTML 标记语言来说Markdown的语法十分简单。Markdown百度百科； Markdown语法说明『中文』，『英文』，Hexo就是基于Markdown语法； 支持Markdown的编辑器很多，这里推荐使用Sublime Text和Atom，因为这两种编辑器对于喜欢编程的人来说都非常熟悉，支持多种语法并且跨平台，所以如果你已经在使用其中之一，就没必要为了使用markdown再安装其它的编辑器了； Sublime Text 官方网站 Sublime默认不支持Markdown语法，需要安装插件，而要为Sublime Text安装插件，需要先安装package control； Package Control安装方法，简单说就是按『ctrl+`』调出控制台，并根据Sublime Text的版本粘贴相应的脚本并回车执行； 安装完成后按ctrl+shift+p (Win, Linux) or cmd+shift+p (OS X)，调出『Command Palette』，输入package control install回车，等待左下角的缓冲结束会弹出一个输入框，我们在里面输入插件的名称，即可快速筛选出可用的插件； 安装markdown编辑插件：MarkdownEditing 在弹出的输入框中输入MarkdownEditing，回车安装，安装后需要重新启动Sublime Text； 新建文件后缀为md，则会自动开启markdown语法支持； 非md后缀文件，可以按ctrl+shift+p (Win, Linux) or cmd+shift+p (OS X)，调出『Command Palette』，输入markdown回车来开启markdown语法支持； 安装markdown查看插件：OmniMarkupPreviwer 在弹出的输入框中输入OmniMarkupPreviwer，回车安装，安装后需要重新启动Sublime Text； 打开markdown的文档，按ctrl+alt+o (Win, Linux) or cmd+alt+o (OS X)，会打开浏览器对当前文档查看效果； 可以通过下面的方式查看所有安装的插件，并对其进行个性化配置； Atom 官方网站 Atom是github开发的开源跨平台的编辑器，Atom的强大可以与大名鼎鼎的Sublime Text相媲美。其使用方式与Sublime Text类似，所以如果会使用Sublime Text，上手Atom会很快。而且与Sublime Text相比，Atom是免费的，但是由于其安装包大小接近百兆，所以对于轻量级编辑器来说略显笨重； Atom内置了对markdown的支持，编辑markdown文档时，按ctrl+shift+M即可打开实时预览窗口，这点比Sublime Text方便很多； 对于非md结尾的文档，可以通过点击右下角的语法格式条，在弹出筛选框输入markdown进行语法切换； 可以按ctrl+, (Win, Linux) or cmd+,(OS X)，调出Atom的Settings，对其进行设置以及插件的管理; 总结 Atom相比Sublime Text来说一个新的产物，目前还不是很普及，不过Atom从一开始就整合了Sublime Text优点，同时提供了更友好的配置和管理方式，安装与卸载插件更加的方便； 编程时我们经常喜欢使用snippets+tab补全的方式来快速生成代码块，Atom和Sublime Text都支持snippets Atom 按ctrl+shift+p (Win, Linux) or cmd+shift+p (OS X)，调出『Command Palette』，输入Snippet: Available，可以调出snippets筛选框； Sublime Text 按ctrl+shift+p (Win, Linux) or cmd+shift+p (OS X)，调出『Command Palette』，输入Snippet:，可以调出snippets筛选框； 在Atom的Settings中，我们可以搜索相应的插件，并点击『settings』，可以在其中查看到其所支持的snippets，语法与Sublime Text一致；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo--解决百度不能索引git page的问题]]></title>
      <url>%2F2016%2F12%2F05%2Fhexo-baidu-coding%2F</url>
      <content type="text"><![CDATA[摘要 由于git page网站对百度spider进行了屏蔽，所以导致了百度是无法对我们发布在git page上的网站进行索引； 解决方式是将我们的代码发布到国内的coding站点，其同样可以提供代码托管和Pages服务； Coding配置 Coding站点地址，注册个帐号 新建一个项目，比如： 设置SSH公钥，实现免密提交代码，如下图，将我们设置github page时生成的公钥填入其中，这里注意，要去掉最后面的邮箱地址。参考 新建coding-pages分支，并设置为默认 开启Pages服务 注意，此时提交代码后，可以通过http://hanqunfeng.coding.me访问 Hexo配置 hexo支持多仓库发布 1234567deploy:- type: git repo: https://github.com/hanqunfeng/hanqunfeng.github.io.git branch: master- type: git repo: https://git.coding.net/hanqunfeng/hanqunfeng.git branch: coding-pages 执行hexo d，会将代码同时发布到github和coding 域名解析–Dnspod 因为代码同时发布到github和coding，所以我希望国内用户访问coding，国外用户访问github，这样可以提高访问效率； 使用Dnspod实现域名解析，其支持让来源为指定线路的用户访问特定的地址； 注册一个Dnspod帐号，注册成功后在【域名解析】中添加一个域名，我这里添加的就是hanqunfeng.com； 添加成功后会自动解析出两个记录类型为A的记录，选择导入； 之后手工添加两条记录，一个CNAME到hanqunfeng.github.io.【国外】，一个CNAME到hanqunfeng.coding.me.【国内】，如下： 注意记录值最后都要加个点 修改万网的域名DNS 因为我的域名是在万网购买的，所以要想Dnspod起作用，需要修改万网中的DNS为Dnspod提供的地址； 万网域名修改 DNS 方法12f1g1ns1.dnspod.netf1g1ns2.dnspod.net Coding Pages服务中配置映射域名]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo--百度和谷歌搜索引擎索引方法]]></title>
      <url>%2F2016%2F12%2F05%2Fhexo-baidu-google%2F</url>
      <content type="text"><![CDATA[摘要 让百度和谷歌搜索引擎对当前站点进行索引的方法。 由于国内对谷歌的访问限制，所以可以使用chrome浏览器安装『谷歌访问助手』插件，安装方法 百度搜索 需要拥有百度帐号，并进行网站验证，因为我已经验证过blog.hanqunfneg.com，所以这里为了演示，使用www.hanqunfeng.com进行验证。 推荐『HTML 文件上传』的方式进行验证 将百度的验证文件，如我的是baidu_verify_5T5OVCioxp.html下载到本地，并拷贝到source目录下，并在文件上方增加如下内容,这样可以保证该文件不会被编译： 123layout: false---5T5OVCioxp 编译并发布，之后在刚才的下载页面进行验证 谷歌搜索 需要拥有谷歌帐号，并进行网站验证 推荐『HTML 文件上传』的方式进行验证 将谷歌的验证文件，如我的是googleea53a22ff4210278.html下载到本地，并拷贝到source目录下，并在文件上方增加如下内容,这样可以保证该文件不会被编译： 123layout: false---google-site-verification: googleea53a22ff4210278.html 编译并发布，之后在刚才的下载页面进行验证 插件站点地图安装 分别使用以下命令来安装针对百度和Google的地图插件，在站点的根目录下执行以下命令： 12$ npm install hexo-generator-sitemap --save$ npm install hexo-generator-baidu-sitemap --save 配置hexo的站点配置文件_config.yml 1234567891011#启用相应插件Plugins:- hexo-generator-sitemap- hexo-generator-baidu-sitemap#配置站点地图文件#sitemapsitemap: path: sitemap.xml baidusitemap:path: baidusitemap.xml 执行hexo g，当你成功编译并在Public目录下生成对应的baidusitemap.xml(针对百度)，sitemap.xml(针对Google)表明你已经成功建立的站点地图。 收录站点地图 百度推送 入口：百度站长–网页抓取–链接提交 谷歌推送 入口：Google Search Console–抓取–站点地图 百度推送方式–自动推送 索引效率：主动推送&gt;自动推送&gt;sitemap 百度的网站上有说明，地址 将自动推送的js脚本拷贝到themes\next\layout\_partials\footer.swig文件的最下方即可]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[学习笔记]]></title>
      <url>%2F2016%2F12%2F02%2Fbook%2F</url>
      <content type="text"><![CDATA[资料列表 CentOS7下zabbix3.2的安装及使用 Rancher–Docker的管理控制台 git学习笔记]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Dubbo初体验]]></title>
      <url>%2F2016%2F12%2F01%2Fdubbo_dubbox%2F</url>
      <content type="text"><![CDATA[摘要 官网地址，官网有完整的资料以帮助使用者快速熟悉dubbo，不过目前相关下载地址已经失效，代码已经迁移到github，请参看下面的代码地址，自行编译打包 dubbo代码地址 2.5.4(官方版本)，基于spring3.2.16.RELEASE 2.8.4(第三方基于2.5.3修改)，基于spring3.2.9.RELEASE,项目名称为dubbox，但生成的包名依然是dubbo git、maven、jdk、tomcat、nexus请自行安装，我安装的版本如下 git version 2.9.3Apache Maven 3.3.9java version “1.8.0_31”tomcat version 8.5.4nexus version 2.5.0-04 编译打包以dubbo2.8.4为例 git clone https://github.com/dangdangdotcom/dubbox.git cd dubbox mvn clean package install -Dmaven.test.skip=true 发布dubbo2.8.4到nexus的3rd party仓库 登录nexus，设置3rd party的Deployment Policy=Allow Redeploy(在Configuration中配置) vi ~/.m2/settings.xml，在servers中增加如下配置 12345&lt;server&gt; &lt;id&gt;thirdparty&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt; 修改dubbox的pom.xml，增加如下配置 123456&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;thirdparty&lt;/id&gt; &lt;url&gt;http://192.168.36.49:8080/nexus/content/repositories/thirdparty/&lt;/url&gt; &lt;/repository&gt;&lt;/distributionManagement&gt; mvn clean package deploy -Dmaven.test.skip=true 发布dubbo2.5.4到nexus的3rd party仓库 因为目前2.5.4是Snapshots版本，所以不能直接发布到3rd party中，如果要发布到3rd party，需要修改pom.xml，去掉版本号中的Snapshots，比如在intellij IDEA中，使用快捷键Command+Shift+R； dubbo包含四个组件 Provider: 暴露服务的服务提供方。这里我们自己提供(基于2.8.4)； Consumer: 调用远程服务的服务消费方。这里我们自己提供(基于2.8.4)； Registry: 服务注册与发现的注册中心。这里使用zookeeper； Monitor: 统计服务的调用次调和调用时间的监控中心。这里介绍两个，一个是dubbo提供的dubbo-monitor-simple，另一个是第三方对dubbo-monitor-simple的改进版本：改版的monitor(基于2.8.4) 下面分别介绍：顺序为Registry，Provider，Consumer，Monitor。 ZooKeeper Registry注册中心官网地址 下载安装1234$ wget http://apache.fayea.com/zookeeper/zookeeper-3.4.9/zookeeper-3.4.9.tar.gz$ tar zxvf zookeeper-3.4.9.tar.gz$ cd zookeeper-3.4.9$ cp conf/zoo_sample.cfg conf/zoo.cfg 配置$ vi conf/zoo.cfg123456tickTime=2000initLimit=10syncLimit=5#实际上只需要配置dataDir，这里修改为自己的存储目录dataDir=/usr/local/zookeeper-3.4.9/dataclientPort=2181 集群配置 分别在两台主机上按上述方法安装zookeeper，比如两台主机的IP分别为192.168.37.144、192.168.37.143； 分别在两台主机的zoo.cfg中增加如下配置 12server.1=192.168.37.144:2555:3555server.2=192.168.37.143:2555:3555 在144主机的dataDir指定的目录(/usr/local/zookeeper-3.4.9/data)下创建文件myid vi myid设置内容为1 #就是zoo.cfg中server.后面对应的数字 同理将143的myid文件中内容设置为2 开放端口 两台主机分别开放2181，2555，3555端口vi /etc/sysconfig/iptablse，加入如下内容 1234#zookeeper-A INPUT -p tcp -m state --state NEW -m tcp --dport 2181 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 2555 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 3555 -j ACCEPT 重启iptables 启动与关闭zookeeper./bin/zkServer.sh start./bin/zkServer.sh stop 查看在zookeeper中注册的信息echo dump | nc 192.168.37.144 2181ORtelnet 192.168.37.144 2188dump 关于Provider&amp;Consumer，阿里官方的实例很详细了，网上也有很多资料，这里只做简单的说明，示例项目依赖于dubbo2.8.4,spring替换为4.3.3，使用中并未见异常，示例源码地址:https://github.com/hanqunfeng/DubboStudy Provider 服务提供者123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt; &lt;!-- 一个项目中只能有一个dubbo:application配置项 --&gt; &lt;dubbo:application name="demo-provider" owner="hanqf" organization="dubbox"/&gt; &lt;!-- 使用zookeeper注册中心暴露服务地址--&gt; &lt;dubbo:registry address="zookeeper://192.168.37.144:2181?backup=192.168.37.143:2181" timeout="50000"/&gt; &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt; &lt;dubbo:protocol name="dubbo" port="20880"/&gt; &lt;!-- 声明需要暴露的服务接口 服务实现类是通过注解注册的，所以此处不需要声明实现类 --&gt; &lt;dubbo:service interface="web.function.demo.service.DemoService" ref="demoService"/&gt; &lt;dubbo:service interface="web.function.demo.service.Demo2Service" ref="demo2Service"/&gt; &lt;!-- 启用monitor服务，只有配置这个，才会主动向monitor推送信息 --&gt; &lt;dubbo:monitor protocol="registry" /&gt;&lt;/beans&gt; 不同的Provider之间可以使用相同的应用名称（比如这里是name=”demo-provider”），因为注册的服务只基于服务所在服务器的ip地址和dubbo协议开放的端口号，两者有一个不相同即可，但是不建议这样做。 对于提供相同服务的Provider，也就是副本（同一个war包，部署到不同主机），则可以不去修改name，但是对于提供不同服务的Provider，不要使用相同的name，这样不便于在monitor中查看。 对于同一个Provider，要在同一台主机中部署（同一个war包，部署到同一台主机），则需要修改duboo协议端口，比如示例代码中的dubbo-provider和dubbo-provider02，因为两者提供相同的服务，所以应用名称相同，但是因为都在本机部署，所以一个用20880，一个使用20881 Consumer 服务消费者12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt; &lt;dubbo:application name="demo-consumer" owner="hanqf" organization="dubbox"/&gt; &lt;!-- 设置check的缺省值，如果配置中有显式的声明，如：&lt;dubbo:reference check="true"/&gt;，不会受影响 --&gt; &lt;!-- 关闭所有服务的启动时检查,注意：如果关闭某个服务的启动时检查，需要在指定的服务单独配置check="false" --&gt; &lt;dubbo:consumer check="false" /&gt; &lt;dubbo:registry protocol="zookeeper" address="192.168.37.144:2181,192.168.37.143:2181" timeout="50000"/&gt; &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt; &lt;dubbo:protocol name="dubbo" port="20880"/&gt; &lt;!-- 声明需要暴露的服务接口 --&gt; &lt;dubbo:reference interface="web.function.demo.service.DemoService" id="demoService" timeout="50000"/&gt; &lt;dubbo:reference interface="web.function.demo.service.Demo2Service" id="demo2Service" timeout="50000"/&gt; &lt;dubbo:monitor protocol="registry" /&gt;&lt;/beans&gt; Consumer和Provider如果部署在同一台主机，可以使用相同的dubbo协议端口，两者不受影响 关于相关配置属性的说明，还是参考官方资料吧，在dubbo源码中已经包含了Consumer和Provider的示例，可以作为参考。 Monitordubbo-monitor-simple 简易监控中心 dubbo项目源码中已经自带了一个Monitor，就是dubbo-monitor-simple，使用maven编译后，会在dubbox/dubbo-simple/dubbo-monitor-simple/target下生成dubbo-monitor-simple-2.8.4-assembly.tar.gz 将dubbo-monitor-simple-2.8.4-assembly.tar.gz拷贝的合适的地方并解压 123$ tar -zxvf dubbo-monitor-simple-2.8.4-assembly.tar.gz$ cd dubbo-monitor-simple-2.8.4$ vi conf/dubbo.properties 主要修改zookeeper地址、端口、绘图目录（该目录必须手工创建，比如这里是/Users/hanqunfeng/monitor）： 1234567891011121314dubbo.container=log4j,spring,registry,jettydubbo.application.name=simple-monitordubbo.application.owner=#dubbo.registry.address=multicast://224.5.6.7:1234dubbo.registry.address=zookeeper://192.168.37.144:2181?backup=192.168.37.143:2181#dubbo.registry.address=redis://127.0.0.1:6379#dubbo.registry.address=dubbo://127.0.0.1:9090dubbo.protocol.port=7070dubbo.jetty.port=8085dubbo.jetty.directory=/Users/hanqunfeng/monitordubbo.charts.directory=$&#123;dubbo.jetty.directory&#125;/chartsdubbo.statistics.directory=/Users/hanqunfeng/monitor/statisticsdubbo.log4j.file=logs/dubbo-monitor-simple.logdubbo.log4j.level=WARN 启动与关闭 ./bin/start.sh./bin/stop.sh 浏览器访问http://localhost:8085，图表中的效果是注册了Provider，Consumer的效果 改版的monitor(基于2.8.4) 特点：使用mysql作为数据存储，界面使用bootstrap进行优化 下载 12$ git clone http://git.oschina.net/handu/dubbo-monitor$ cd dubbo-monitor 配置vi src/main/resources/application.properties，修改zookeeper地址，端口，数据库信息 1234567891011121314dubbo.application.name=dubbo-monitordubbo.application.owner=hanqunfengdubbo.registry.address=zookeeper://192.168.37.144:2181?backup=192.168.37.143:2181dubbo.protocol.port=6060# Database Settingsdb.url=jdbc:mysql://127.0.0.1:3306/monitor?prepStmtCacheSize=517&amp;cachePrepStmts=true&amp;autoReconnect=true&amp;characterEncoding=utf-8db.username=rootdb.password=passworddb.maxActive=500# System Managermanager.username=adminmanager.password=admin 数据库初始化 创建monitor数据库 执行sql目录下的create.sql 打包mvn clean package -Dmaven.test.skip=true 基于本地nexus编译打包时，提示找不到jetbrick-template-2.0.10.jar，去maven中央仓库下载再上传到nexus中吧。 部署将生成的dubbo-monitor.war包部署到tomcat中，启动tomcat（端口8084）访问地址http://localhost:8084/dubbo-monitor 最后说一下dubbo-admin，这个是dubbo官方提供的dubbo管理控制台官方说明：管理控制台为内部裁剪版本，开源部分主要包含：路由规则，动态配置，服务降级，访问控制，权重调整，负载均衡，等管理功能。 dubbo-admin 管理控制台dubbo项目源码中有一个模块叫做dubbo-admin cd dubbox/dubbo-admin/src/main/webapp/WEB-INFvi dubbo.properties配置dubbo.registry.address=zookeeper://192.168.37.144:2181?backup=192.168.37.143:2181编译打包，将生成的dubbo-admin-2.8.4.war部署到tomcat]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo--NexT主题]]></title>
      <url>%2F2016%2F11%2F17%2Fhexo-theme-next%2F</url>
      <content type="text"><![CDATA[NexT主题简介 NexT有着完善的使用文档，NexT官方资料； NexT整合了常用的插件，如评论、分享、统计； 下载安装 12cd ~/bloggit clone https://github.com/iissnan/hexo-theme-next themes/next 第三方参考资料 我的配置多说评论和百度统计 NexT主题的_config.yml，配置方式参考Hexo–添加多说评论插件和百度统计插件 12345678910111213141516171819# 多说配置：# Duoshuo ShortNameduoshuo_shortname: 注册前缀# 开启热评文章duoshuo_hotartical: true# 可以看到评论用户的UA信息# Make duoshuo show UA# user_id must NOT be null when admin_enable is true!# you can visit http://dev.duoshuo.com get duoshuo user id.duoshuo_info: ua_enable: true admin_enable: false user_id: 0# 百度统计配置：# Baidu Analytics ID# 这里只需要填写js代码中hm.js链接的参数(如下：xxxxxxx)部分，而不再需要将整个js配置到模板中baidu_analytics: xxxxxxx 百度统计代码 1234567var _hmt = _hmt || [];(function() &#123; var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?xxxxxxx"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);&#125;)(); 百度分享 NexT主题的_config.yml，其它主题配置方式参考地址123456# Baidu Share# Available value:# button | slide# Warning: Baidu Share does not support https.baidushare: type: button 阅读次数 注册LeanCloud帐号，在LeanCloud中创建应用，具体配置方式查看参考资料。 复制AppID以及AppKey并在NexT主题的_config.yml文件中我们相应的位置填入即可，正确配置之后文件内容像这个样子: 1234leancloud_visitors: enable: true app_id: joaeuuc4hsqudUUwx4gIvGF6-gzGzoHsz app_key: E9UJsJpw1omCHuS22PdSpKoh 这里要注意，一定要在LeanCloud中的安全中心配置Web安全域名，否则不能正常统计 字数统计和阅读时常 参考资料 安装hexo-wordcount插件，在站点的根目录下执行以下命令：npm install hexo-wordcount --save 修改模板位置：themes\next\layout\_macro\post.swig，插入代码如下：1234567891011121314151617181920212223242526272829303132333435# 查找如下代码段： &#123;# LeanCould PageView #&#125; &#123;% if theme.leancloud_visitors.enable %&#125; &lt;span id="&#123;&#123; url_for(post.path) &#125;&#125;" class="leancloud_visitors" data-flag-title="&#123;&#123; post.title &#125;&#125;"&gt; &amp;nbsp; | &amp;nbsp; &lt;span class="post-meta-item-icon"&gt; &lt;i class="fa fa-eye"&gt;&lt;/i&gt; &lt;/span&gt; &lt;span class="post-meta-item-text"&gt;&#123;&#123;__('post.visitors')&#125;&#125; &lt;/span&gt; &lt;span class="leancloud-visitors-count"&gt;&lt;/span&gt; &lt;/span&gt; &#123;% endif %&#125;# 添加如下代码段： # 以下部分为：字数统计、阅读时长插入代码 &lt;span class="post-time"&gt; &amp;nbsp; | &amp;nbsp; &lt;span class="post-meta-item-icon"&gt; &lt;i class="fa fa-calendar-o"&gt;&lt;/i&gt; &lt;/span&gt; &lt;span class="post-meta-item-text"&gt;字数统计:&lt;/span&gt; &lt;span class="post-count"&gt;&#123;&#123; wordcount(post.content) &#125;&#125;(字)&lt;/span&gt; &lt;/span&gt; &lt;span class="post-time"&gt; &amp;nbsp; | &amp;nbsp; &lt;span class="post-meta-item-icon"&gt; &lt;i class="fa fa-calendar-o"&gt;&lt;/i&gt; &lt;/span&gt; &lt;span class="post-meta-item-text"&gt;阅读时长:&lt;/span&gt; &lt;span class="post-count"&gt;&#123;&#123; min2read(post.content) &#125;&#125;(分)&lt;/span&gt; &lt;/span&gt;# 以上部分为：字数统计、阅读时长插入代码 Local Search 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令：$ npm install hexo-generator-searchdb --save NexT主题的_config.yml 12345search: path: search.xml field: post format: html limit: 10000 重新编译之后会发现左侧导航栏最下方多出一个搜索菜单 标签页和分类页 默认情况下，NexT没有开启标签页和分类页功能 新增标签页 使用命令hexp new page “tags” 并将页面类型设置为tags12345---title: 标签date: 2016-11-17 23:03:47type: &quot;tags&quot;--- 通常情况下你的标签页并不需要评论框，取消评论代码123456---title: 标签date: 2016-11-17 23:03:47type: &quot;tags&quot;comments: false--- 在主题配置文件下的菜单设置项memu下设置，设置完成在主页导航可以看到标签导航栏12menu: tags: /tags 新增分类页 使用命令hexp new page categories 并将页面类型设置为categories12345---title: 分类date: 2016-11-17 23:08:35type: &quot;categories&quot;--- 通常情况下你的标签页并不需要评论框，取消评论代码123456---title: 分类date: 2016-11-17 23:08:35type: &quot;categories&quot;comments: false--- 在主题配置文件下的菜单设置项memu下设置，设置完成在主页导航可以看到分类导航栏12menu: categories: /categories 设定首页/归档/标签页面文章的篇数 安装如下插件，在站点的根目录下执行以下命令： 123$ npm install hexo-generator-index --save$ npm install hexo-generator-archive --save$ npm install hexo-generator-tag --save NexT主题的_config.yml 12345678910index_generator: per_page: 5archive_generator: per_page: 20 yearly: true monthly: truetag_generator: per_page: 10 RSS设置 安装 hexo-generator-feed，在站点的根目录下执行以下命令：$ npm install hexo-generator-feed --save NexT主题的_config.yml 1234# Set rss to false to disable feed link.# Leave rss as empty to use site's feed link.# Set rss to specific value if you have burned your feed already.rss: /atom.xml 编译后，会看到左侧头像下方会显示RSS入口 跳过指定文件的渲染 如果某些资源希望放到source下，但是又不希望被编译，可以在hexo的_config.yml中增加如下配置： 1234skip_render: - zabbix/** #跳过zabbix文件夹下的全部子目录和文件 - abc.html #跳过某一个具体的文件 - *.html #跳过以html结尾的文件 比如我的导航菜单中的『资料』，其下面配置的资源就是我从为知笔记中导出的html。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo--绑定域名到githubpage]]></title>
      <url>%2F2016%2F11%2F17%2Fhexo-domain-name%2F</url>
      <content type="text"><![CDATA[申请域名 可以通过万网购买域名; 比如博主的域名为hanqunfeng.com; 添加解析规则 登录阿里云的控制台，进入【域名】，找到自己的域名，点击【解析】 点击【添加解析】 『记录类型』：CNAME 『主机记录』：blog #说明：设置为二级域名，也可以设置为www的一级域名 『记录值』：hanqunfeng.github.io. #注意最后面有个点 上面的配置表示将blog.hanqunfeng.com的请求定向到hanqunfeng.github.io blog目录下创建CNAME文件 在自己的blog目录下的/source目录下新建一个文件，命名为CNAME，内容为：blog.hanqunfeng.com hexo cl，hexo g，hexo d，发布到github page 说明 购买域名需要进行实名认证； 官方说域名解析最长等待48小时就可以全球生效； 博主配置时，只是提交了实名认证申请，域名解析不到5分钟就可以访问了；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo--添加多说评论插件和百度统计插件]]></title>
      <url>%2F2016%2F11%2F16%2Fhexo_duoshuo_baidutongji%2F</url>
      <content type="text"><![CDATA[添加多说评论插件 登录多说官网，多说不支持注册，仅支持绑定社交帐号登录，比如QQ，新浪微博，等等。 登录后会要求进行站点设置，这里需要设置域名、站点名称、首页网址等信息，域名的后缀已经默认为.duoshuo.com,所以我们只需要设置前缀，记住这个前缀。站点名称随便起个名字，首页网站填写https://hanqunfeng.github.io； 编辑yilia主题的_config.yml文件，设置如下： duoshuo: 域名前缀 重新发布即可，效果见页面下方的评论区； 在多说管理后台中可以对评论进行管理。 添加百度统计插件 注册百度统计帐号; 新注册用户会要求创建一个网站，设置如下： 登录后在代码管理--》代码获取中复制代码，将其粘贴到yilia主题下的layout/_partial/after-footer.gjs的最下面； 重新发布到github page； 在百度统计管理平台中的代码管理--》代码安装检查查看是否配置正确； 配置无误后，可以通过百度统计平台查看统计数据。 参考资料 http://m.blog.csdn.net/article/details?id=51049695]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo+GitHub Page搭建自己的Blog]]></title>
      <url>%2F2016%2F11%2F14%2Fhexo_gitpage%2F</url>
      <content type="text"><![CDATA[什么是Hexo Hexo 是一个简单地、轻量地、基于Node的一个静态博客框架，可以方便的生成静态网页托管在github和Heroku上，引用Hexo作者 @tommy351 的话： 快速、简单且功能强大的 Node.js 博客框架。A fast, simple &amp; powerful blog framework, powered by Node.js. GitHub Pages是什么？ GitHub Pages 可以被认为是用户编写的、托管在github上的静态网页。由于它的空间免费稳定， 可以用于介绍托管在github上的Project或者搭建网站。 以下环境为mac下安装。 Hexo安装需要安装git和Node.js运行环境 git安装 mac自带git，如果需要重新安装，可去官网下载12$ git --versiongit version 2.9.3 (Apple Git-75) 安装npm 基于brew方式安装npm1$ brew install npm 安装Hexo1$ npm install hexo-cli -g npm安装Hexo：参考资料 查看Hexo版本12345678910111213$ hexo versionhexo: 3.2.2hexo-cli: 1.0.2os: Darwin 16.1.0 darwin x64http_parser: 2.7.0node: 6.6.0v8: 5.1.281.83uv: 1.9.1zlib: 1.2.8ares: 1.10.1-DEVicu: 57.1modules: 48openssl: 1.0.2h Quick StartSetup your blog123$ cd ~$ hexo init blog$ cd blog 此命令会在当前用户的家目录下创建一个blog目录，并初始化相关文件，如下为初始化的目录结构： blog目录结构说明 scaffolds ：模板文件夹，新建文章时，Hexo 会根据 scaffold 来建立文件。Hexo 有三种默认布局： post 、 page 和 draft ，它们分别对应不同的路径。新建文件的默认布局是 post ，可以在配置文件中更改布局。用 draft 布局生成的文件会被保存到 source/_drafts 文件夹。 source ：资源文件夹是存放用户资源的地方。 source/_post ：文件箱。除 posts 文件夹之外，开头命名为 (下划线)的文件或者文件夹和隐藏的文件将会被忽略。Markdown文件会被解析并放到 public 文件夹。 themes ：主题 文件夹。Hexo 会根据主题来生成静态页面。我们可以将自己的主题放到该目录下，然后在_config.yml中修改默认的主题即可。 themes/landscape ：默认的皮肤文件夹 _config.yml ：全局的配置文件，每次更改要重启服务。 _config.yml简介1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site 站点配置title: Study Zone #网站标题subtitle: Spring--java程序员的春天 #网站副标题description: 分享成长与快乐的地方 #网站描述author: hanqunfeng #作者，网站所有者language: zh-CN #网站使用的语言timezone: Asia/Shanghai #网站时区# URL 可以不配置## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://hanqunfeng.github.io #网址，搜索时会在搜索引擎中显示root: / #网站根目录 permalink: :year/:month/:day/:title/ #永久链接格式permalink_defaults: #永久链接中各部分的默认值# Directory 目录配置source_dir: source #资源文件夹，这个文件夹用来存放内容public_dir: public #公共文件夹，这个文件夹用于存放生成的站点文件tag_dir: tags #标签文件夹archive_dir: archives #归档文件夹category_dir: categories #分类文件夹code_dir: downloads/code #Include code 文件夹i18n_dir: :lang #国际化文件夹skip_render: #跳过指定文件的渲染，您可使用 glob 来配置路径# Writing 写作配置new_post_name: :title.md # File name of new posts # 新文章的文件名称default_layout: post #默认布局titlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0 #把文件名称转换为 (1) 小写或 (2) 大写render_drafts: false #显示草稿post_asset_folder: false #是否启动资源文件夹relative_link: false #把链接改为与根目录的相对位址future: truehighlight: #代码块的设置 enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tag 分类 &amp; 标签default_category: uncategorized #默认分类category_map: #分类别名tag_map: #标签别名# Date / Time format 时间和日期## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination 分页## Set per_page to 0 to disable paginationper_page: 10 #每页显示的文章量 (0 = 关闭分页功能)pagination_dir: page #分页目录# Extensions 扩展## Plugins: https://hexo.io/plugins/ 插件## Themes: https://hexo.io/themes/ 主题# theme: landscape #当前主题名称theme: yilia #当前主题名称# Deployment #部署到github## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/hanqunfeng/hanqunfeng.github.io.git branch: master 注意：以下所有命令，都必须在blog目录下执行。 Start the server123$ hexo serverINFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 我们可以通过浏览器访问http://localhost:4000/，就可以看到blog的页面了。 创建文件、生成静态文件以及发布到github，都不需要启动服务，启动服务的目的仅是为了能在本地看到效果。 hexo server == hexo s Create a new post12$ hexo new "Hello Hexo"INFO Created: ~/blog/source/_posts/Hello-Hexo.md 创建好的文件基于makedown语法，可以使用sublime或者atom编辑器，进行编辑与管理。 编辑完成后不需要执行hexo generate命令即可在浏览器中查看效果，但是修改了主题内容，有时会不生效，需要先生成静态文件才能看到最终效果。 hexo new == hexo n Generate static files1$ hexo generate 该命令用于将makedown文件转换为静态html文件，并放到public文件夹下。 可以使用hexo clean命令来删除public文件夹，之后再使用hexo generate来重新生成静态文件。 hexo generate == hexo g Clean static files123$ hexo cleanINFO Deleted database.INFO Deleted public folder. hexo clean == hexo cl 主题更换主题 github上有许多技术达人为Hexo制作的主题，可以clone到本地，并拷贝到themes文件夹下，然后修改_config.yml中的theme属性，修改主题需要重启Hexo才能生效。 比如博主使用主题为yilia下载地址: 12$ cd ~/blog$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 更新主题时，在themes/yilia目录下执行git pull。 添加资源 可以在当前主题的source目录下放入自己的资源，执行hexo generate命令时，会将主题中的source目录下的内容拷贝到public目录下。 但是这样做如果更换主题，则资源就失效了，所以一般是在source目录下创建资源文件，执行hexo generate命令时，会将source目录下的内容拷贝到public目录下。 发布到Github安装hexo的git发布包1$ npm install hexo-deployer-git -S 创建SSH密钥 创建密钥可以在执行发布时不需要每次都输入用户名和密码，具体创建方法查看如下资料: github官网 图文教程 Deploy to remote sites 因为使用GitPage，所以需要申请一个Github帐号，并创建一个仓库，仓库名称为”your_name.github.io”。 创建好仓库后，在_config.yml中按上文中的内容配置好deploy属性。 执行如下命令，会将public下的文件发布到该仓库中，一般执行deploy前先执行clean和generate保证文件最新。 访问https://hanqunfeng.github.io，查看blog页面。 123$ hexo clean$ hexo generate$ hexo deploy hexo deploy == hexo d 参考资料 http://www.tuicool.com/articles/ueI7naV http://www.jianshu.com/p/465830080ea9]]></content>
    </entry>

    
  
  
</search>
